<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[Android][Framework] AndroidTV小窥及keyEvent事件传递流程</title>
      <link href="/2019/12/19/%5BAndroid%5D%5BFramework%5Dglance-of-androidTV/"/>
      <url>/2019/12/19/%5BAndroid%5D%5BFramework%5Dglance-of-androidTV/</url>
      
        <content type="html"><![CDATA[<p>首先我不做AndroidTV，只是因为一些汽车的屏幕无法触摸，所以无法获得Touch事件，但是车机上有一些旋钮，可以拿到一些键盘事件，因此需要用这些键盘事件对系统（不是应用）进行交互。所以，为了解决这个问题，就需要先了解一下Android TV应用的原理，以及键盘事件是如何传递的。</p><h2 id="模拟Android-TV"><a href="#模拟Android-TV" class="headerlink" title="模拟Android TV"></a>模拟Android TV</h2><p>下面是最终Demo效果。</p><p><img src="https://raw.githubusercontent.com/wossoneri/wossoneri.github.io/master/articleImage/tv.gif" alt></p><p>界面上有9个CardView，分布为：</p><p>1—2—3</p><p>4—5—6</p><p>7—8—9</p><h3 id="焦点"><a href="#焦点" class="headerlink" title="焦点"></a>焦点</h3><p>为了使每个CardView接收焦点，所以需要设定焦点相关的属性：</p><pre class=" language-lang-xml"><code class="language-lang-xml">android:clickable="true"    <!--可点击-->android:focusable="true"    <!--可获得焦点-->android:focusableInTouchMode="true"    <!--在触屏下可获得焦点-->android:nextFocusLeft="@id/card3"      <!--切换到左边焦点目标-->android:nextFocusRight="@id/card2"     <!--切换到右边焦点目标-->android:nextFocusUp="@id/card7"        <!--切换到上边焦点目标-->android:nextFocusDown="@id/card4"      <!--切换到下边焦点目标--><!--如果按下某个方向键时，想让焦点停留在自身，可以使用android:nextFocusRight:"@null"或者android:nextFocusRight:"@id/自身id"--></code></pre><blockquote><p>也可以使用setNextFocusLeftId()方法修改焦点切换目标</p></blockquote><p>设置好属性，下一步就需要实现<code>OnFocusChangeListener</code>接口，通过回调设置目标获得焦点之后的样式：</p><pre class=" language-lang-java"><code class="language-lang-java">private void selectCard(CardView cardView, boolean selected) {  if (selected) {    cardView.setScaleX(1.5f);    cardView.setScaleY(1.5f);    cardView.setElevation(10);  } else {    cardView.setScaleX(1f);    cardView.setScaleY(1f);    cardView.setElevation(1);  }}</code></pre><p>整个过程并不需要处理<code>onKeyDown</code>回调，系统会根据xml文件里设置的前后目标去找对应的<code>View</code>。</p><p>所以，系统已经实现的相关的逻辑，所以就需要看看系统的实现代码。</p><h2 id="KeyEvent事件的传递"><a href="#KeyEvent事件的传递" class="headerlink" title="KeyEvent事件的传递"></a>KeyEvent事件的传递</h2><h3 id="下发KeyEvent"><a href="#下发KeyEvent" class="headerlink" title="下发KeyEvent"></a>下发KeyEvent</h3><h4 id="ViewRootImpl-ViewPostImeInputStage-processKeyEvent"><a href="#ViewRootImpl-ViewPostImeInputStage-processKeyEvent" class="headerlink" title="ViewRootImpl.ViewPostImeInputStage.processKeyEvent"></a>ViewRootImpl.ViewPostImeInputStage.processKeyEvent</h4><pre class=" language-lang-java"><code class="language-lang-java">private int processKeyEvent(QueuedInputEvent q) {  final KeyEvent event = (KeyEvent)q.mEvent;  // Deliver the key to the view hierarchy.  //由dispatchKeyEvent进行焦点的分发，如果dispatchKeyEvent方法返回true，那么下面的焦点查找步骤就不会继续了。  //这里mView是Activity的顶层容器DecorView，是一FrameLayout。  //所以这里的dispatchKeyEvent方法执行的是ViewGroup的dispatchKeyEvent()方法  if (mView.dispatchKeyEvent(event)) {    return FINISH_HANDLED;  }  // 是否终止事件  // 当根视图不存在就会停止下面的步骤  // 属于保护措施  if (shouldDropInputEvent(q)) {    return FINISH_NOT_HANDLED;  }  // If the Control modifier is held, try to interpret the key as a shortcut.  if (event.getAction() == KeyEvent.ACTION_DOWN      && event.isCtrlPressed()      && event.getRepeatCount() == 0      && !KeyEvent.isModifierKey(event.getKeyCode())) {    if (mView.dispatchKeyShortcutEvent(event)) {      return FINISH_HANDLED;    }    if (shouldDropInputEvent(q)) {      return FINISH_NOT_HANDLED;    }  }  // Apply the fallback event policy.  // 具体实现见PhoneFallbackEventHandler中dispatchKeyEvent()方法  // 主要是对媒体键，音量键，通话键等做处理，如果是这些按键则会停止下面的步骤  if (mFallbackEventHandler.dispatchKeyEvent(event)) {    return FINISH_HANDLED;  }  if (shouldDropInputEvent(q)) {    return FINISH_NOT_HANDLED;  }  // Handle automatic focus changes.  if (event.getAction() == KeyEvent.ACTION_DOWN) {    //direction用来记录方向的值，用来进行后面的焦点查找    int direction = 0;    switch (event.getKeyCode()) {      case KeyEvent.KEYCODE_DPAD_LEFT:        //根据指定的元状态没有按下修饰符键,则返回true        if (event.hasNoModifiers()) {          direction = View.FOCUS_LEFT;        }        break;      case KeyEvent.KEYCODE_DPAD_RIGHT:        if (event.hasNoModifiers()) {          direction = View.FOCUS_RIGHT;        }        break;      case KeyEvent.KEYCODE_DPAD_UP:        if (event.hasNoModifiers()) {          direction = View.FOCUS_UP;        }        break;      case KeyEvent.KEYCODE_DPAD_DOWN:        if (event.hasNoModifiers()) {          direction = View.FOCUS_DOWN;        }        break;      case KeyEvent.KEYCODE_TAB:        if (event.hasNoModifiers()) {          direction = View.FOCUS_FORWARD;        } else if (event.hasModifiers(KeyEvent.META_SHIFT_ON)) {          direction = View.FOCUS_BACKWARD;        }        break;    }    //给定了direction（遥控器按键按下的方向），接下来就是焦点寻找    if (direction != 0) {      //找到当前聚焦的View 下面会详细讲解      View focused = mView.findFocus();      if (focused != null) {        //如果focused不为空，说明找到了焦点，接着focusSearch会把direction（遥控器按键按下的方向）作为参数，找到特定方向下一个将要获取焦点的view，最后如果该view不为空，那么就让该view获取焦点。        //后面详细介绍focusSearch()具体方法        View v = focused.focusSearch(direction);        if (v != null && v != focused) {          // do the math the get the interesting rect          // of previous focused into the coord system of          // newly focused view          focused.getFocusedRect(mTempRect);          if (mView instanceof ViewGroup) {            ((ViewGroup) mView).offsetDescendantRectToMyCoords(              focused, mTempRect);            ((ViewGroup) mView).offsetRectIntoDescendantCoords(              v, mTempRect);          }          if (v.requestFocus(direction, mTempRect)) {            playSoundEffect(SoundEffectConstants                            .getContantForFocusDirection(direction));            return FINISH_HANDLED;          }        }        // Give the focused view a last chance to handle the dpad key.        if (mView.dispatchUnhandledMove(focused, direction)) {          return FINISH_HANDLED;        }      } else {        // find the best view to give focus to in this non-touch-mode with no-focus        View v = focusSearch(null, direction);        if (v != null && v.requestFocus(direction)) {          return FINISH_HANDLED;        }      }    }  }  return FORWARD;}</code></pre><h3 id="当前焦点查找"><a href="#当前焦点查找" class="headerlink" title="当前焦点查找"></a>当前焦点查找</h3><h4 id="View-findFocus"><a href="#View-findFocus" class="headerlink" title="View.findFocus"></a>View.findFocus</h4><pre class=" language-lang-java"><code class="language-lang-java">/**  * Find the view in the hierarchy rooted at this view that currently has  * focus.  *  * @return The view that currently has focus, or null if no focused view can  *         be found.  */public View findFocus() {  return (mPrivateFlags & PFLAG_FOCUSED) != 0 ? this : null;}</code></pre><h4 id="ViewGroup-findFocus"><a href="#ViewGroup-findFocus" class="headerlink" title="ViewGroup.findFocus"></a>ViewGroup.findFocus</h4><p>在ViewGroup也有对findFocus的复写：</p><pre class=" language-lang-java"><code class="language-lang-java">/* * (non-Javadoc) * * @see android.view.View#findFocus() */@Overridepublic View findFocus() {    if (DBG) {        System.out.println("Find focus in " + this + ": flags="                + isFocused() + ", child=" + mFocused);    }    if (isFocused()) {        return this;    }    if (mFocused != null) {        return mFocused.findFocus();    }    return null;}</code></pre><p>这里isFocused()是父类View的方法，判断代码和findFocus方法一致</p><pre class=" language-lang-java"><code class="language-lang-java">/**  * Returns true if this view has focus  *  * @return True if this view has focus, false otherwise.  */ @ViewDebug.ExportedProperty(category = "focus") public boolean isFocused() {     return (mPrivateFlags & PFLAG_FOCUSED) != 0; }</code></pre><p>isFocused()方法的作用是判断当前<code>view</code>是否已经获取焦点，如果<code>viewGroup</code>已经获取到了焦点，那么返回本身即可，否则通过mFocused这个子<code>view</code>的findFocus()方法来找焦点。如果mView不是<code>ViewGroup</code>的话，findFocus其实就是判断本身是否已经获取焦点，如果已经获取焦点了，返回本身。</p><p>此时我们已经找到了当前获得焦点的<code>View</code>，接下来就是说按照给定的方向去寻找下一个即将获得焦点的<code>view</code>。</p><h3 id="下一个焦点查找"><a href="#下一个焦点查找" class="headerlink" title="下一个焦点查找"></a>下一个焦点查找</h3><h4 id="View-focusSearch"><a href="#View-focusSearch" class="headerlink" title="View.focusSearch"></a>View.focusSearch</h4><p>前面分析到，如果某个View获取焦点，也拿到方向，就调用该方法进行查找</p><pre class=" language-lang-java"><code class="language-lang-java">/**  * Find the nearest view in the specified direction that can take focus.  * This does not actually give focus to that view.  *  * @param direction One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and FOCUS_RIGHT  *  * @return The nearest focusable in the specified direction, or null if none  *         can be found.  */ public View focusSearch(@FocusRealDirection int direction) {     if (mParent != null) {         return mParent.focusSearch(this, direction);     } else {         return null;     } }</code></pre><p>代码逻辑上看，该<code>View</code>并不会查找，而是通过父<code>View</code>进行查找</p><h4 id="ViewGroup-focusSearch"><a href="#ViewGroup-focusSearch" class="headerlink" title="ViewGroup.focusSearch"></a>ViewGroup.focusSearch</h4><pre class=" language-lang-java"><code class="language-lang-java">/** * Find the nearest view in the specified direction that wants to take * focus. * * @param focused The view that currently has focus * @param direction One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and *        FOCUS_RIGHT, or 0 for not applicable. */@Overridepublic View focusSearch(View focused, int direction) {    if (isRootNamespace()) {        // root namespace means we should consider ourselves the top of the        // tree for focus searching; otherwise we could be focus searching        // into other tabs.  see LocalActivityManager and TabHost for more info        return FocusFinder.getInstance().findNextFocus(this, focused, direction);    } else if (mParent != null) {        return mParent.focusSearch(focused, direction);    }    return null;}</code></pre><p>判断是否为顶层布局（isRootNamespace()方法），若是则执行对应方法，若不是则继续向上寻找，说明会从内到外的一层层进行判断，直到最外层的布局为止。</p><p>最终会调用viewGroup的FocusFinder来找计算下一个获得焦点的view。</p><h4 id="FocusFinder-findNextFocus"><a href="#FocusFinder-findNextFocus" class="headerlink" title="FocusFinder.findNextFocus"></a>FocusFinder.findNextFocus</h4><pre class=" language-lang-java"><code class="language-lang-java">// FocusFinder.javapublic final View findNextFocus(ViewGroup root, View focused, int direction) {    return findNextFocus(root, focused, null, direction);}//root是上面isRootNamespace()为true的ViewGroup//focused是当前焦点视图private View findNextFocus(ViewGroup root, View focused, Rect focusedRect, int direction) {    View next = null;    ViewGroup effectiveRoot = getEffectiveRoot(root, focused);    if (focused != null) {        // 优先从xml或者代码中指定focusid的View中找        next = findNextUserSpecifiedFocus(effectiveRoot, focused, direction);    }    if (next != null) {        return next;    }    ArrayList<View> focusables = mTempList;    try {        focusables.clear();        effectiveRoot.addFocusables(focusables, direction);        if (!focusables.isEmpty()) {            //其次，根据算法去找，原理就是找在方向上最近的View            next = findNextFocus(effectiveRoot, focused, focusedRect, direction, focusables);        }    } finally {        focusables.clear();    }    return next;}</code></pre><p>从上面可以看出</p><ul><li>优先找开发者指定的下一个focus的视图 ，就是在xml或者代码中指定NextFocusDirection Id的视图</li><li>其次，根据算法去找，原理就是找在方向上最近的视图</li></ul><h3 id="根据用户指定xml去找焦点"><a href="#根据用户指定xml去找焦点" class="headerlink" title="根据用户指定xml去找焦点"></a>根据用户指定xml去找焦点</h3><h4 id="FocusFinder-findNextUserSpecifiedFocus"><a href="#FocusFinder-findNextUserSpecifiedFocus" class="headerlink" title="FocusFinder.findNextUserSpecifiedFocus"></a>FocusFinder.findNextUserSpecifiedFocus</h4><p>先看查找用户在xml指定的目标</p><pre class=" language-lang-java"><code class="language-lang-java">private View findNextUserSpecifiedFocus(ViewGroup root, View focused, int direction) {  // check for user specified next focus  View userSetNextFocus = focused.findUserSetNextFocus(root, direction);  if (userSetNextFocus != null && userSetNextFocus.isFocusable()      && (!userSetNextFocus.isInTouchMode()          || userSetNextFocus.isFocusableInTouchMode())) {    return userSetNextFocus;  }  return null;}</code></pre><p>所以看到这里是会根据<code>View</code>的<code>focusable</code>相关属性决定是否返回该<code>View</code>，如果不设置<code>focusable</code>属性，系统是不会赋予其焦点的。</p><h4 id="View-findUserSetNextFocus"><a href="#View-findUserSetNextFocus" class="headerlink" title="View.findUserSetNextFocus"></a>View.findUserSetNextFocus</h4><pre class=" language-lang-java"><code class="language-lang-java">/**  * If a user manually specified the next view id for a particular direction,  * use the root to look up the view.  * @param root The root view of the hierarchy containing this view.  * @param direction One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT, FOCUS_FORWARD,  * or FOCUS_BACKWARD.  * @return The user specified next view, or null if there is none.  */ View findUserSetNextFocus(View root, @FocusDirection int direction) {     switch (direction) {         case FOCUS_LEFT:             if (mNextFocusLeftId == View.NO_ID) return null;             return findViewInsideOutShouldExist(root, mNextFocusLeftId);         case FOCUS_RIGHT:             if (mNextFocusRightId == View.NO_ID) return null;             return findViewInsideOutShouldExist(root, mNextFocusRightId);         case FOCUS_UP:             if (mNextFocusUpId == View.NO_ID) return null;             return findViewInsideOutShouldExist(root, mNextFocusUpId);         case FOCUS_DOWN:             if (mNextFocusDownId == View.NO_ID) return null;             return findViewInsideOutShouldExist(root, mNextFocusDownId);         case FOCUS_FORWARD:             if (mNextFocusForwardId == View.NO_ID) return null;             return findViewInsideOutShouldExist(root, mNextFocusForwardId);         case FOCUS_BACKWARD: {             if (mID == View.NO_ID) return null;             final int id = mID;             return root.findViewByPredicateInsideOut(this, new Predicate<View>() {                 @Override                 public boolean apply(View t) {                     return t.mNextFocusForwardId == id;                 }             });         }     }     return null; }</code></pre><p>就是通过设置的id去找view，比如：按了“左”方向键，如果设置了mNextFocusLeftId，则会通过findViewInsideOutShouldExist去找这个View。具体怎么找的就不看了，大概是findViewInsideOutShouldExist这个方法从当前指定视图去寻找指定id的视图。首先从自己开始向下遍历，如果没找到则从自己的parent开始向下遍历，直到找到id匹配的视图为止。</p><h3 id="根据算法自动找目标"><a href="#根据算法自动找目标" class="headerlink" title="根据算法自动找目标"></a>根据算法自动找目标</h3><h4 id="FocusFinder-findNextFocus-1"><a href="#FocusFinder-findNextFocus-1" class="headerlink" title="FocusFinder.findNextFocus"></a>FocusFinder.findNextFocus</h4><pre class=" language-lang-java"><code class="language-lang-java">private View findNextFocus(ViewGroup root, View focused, Rect focusedRect,                           int direction, ArrayList<View> focusables) {  if (focused != null) {    if (focusedRect == null) {      focusedRect = mFocusedRect;    }    // fill in interesting rect from focused    focused.getFocusedRect(focusedRect);    root.offsetDescendantRectToMyCoords(focused, focusedRect);  } else {    if (focusedRect == null) {      focusedRect = mFocusedRect;      // make up a rect at top left or bottom right of root      switch (direction) {        case View.FOCUS_RIGHT:        case View.FOCUS_DOWN:          setFocusTopLeft(root, focusedRect);          break;        case View.FOCUS_FORWARD:          if (root.isLayoutRtl()) {            setFocusBottomRight(root, focusedRect);          } else {            setFocusTopLeft(root, focusedRect);          }          break;        case View.FOCUS_LEFT:        case View.FOCUS_UP:          setFocusBottomRight(root, focusedRect);          break;        case View.FOCUS_BACKWARD:          if (root.isLayoutRtl()) {            setFocusTopLeft(root, focusedRect);          } else {            setFocusBottomRight(root, focusedRect);            break;          }      }    }  }  switch (direction) {    case View.FOCUS_FORWARD:    case View.FOCUS_BACKWARD:      return findNextFocusInRelativeDirection(focusables, root, focused, focusedRect,                                              direction);    case View.FOCUS_UP:    case View.FOCUS_DOWN:    case View.FOCUS_LEFT:    case View.FOCUS_RIGHT:      return findNextFocusInAbsoluteDirection(focusables, root, focused,                                              focusedRect, direction);    default:      throw new IllegalArgumentException("Unknown direction: " + direction);  }}</code></pre><ul><li>遍历找出所有isFocusable的视图</li><li>将focused视图的坐标系，转换到root的坐标系中，统一坐标，以便进行下一步的计算</li><li>进行一次遍历比较，得到最“近”的视图作为下一个焦点视图</li></ul><h3 id="KeyEvent小结"><a href="#KeyEvent小结" class="headerlink" title="KeyEvent小结"></a>KeyEvent小结</h3><ul><li>ViewRootImpl的processKeyEvent方法获取按键事件<ul><li>判断ViewGroup的dispatchKeyEvent()方法是否消费了事件，是则不往下分发，终止</li><li>判断是否是一些特殊按键如：接听，挂断，音量等，是则不处理</li><li>如果没有消费事件，那么焦点就会交给系统来处理</li><li>开始计算记录按键的方向 direction 触发查找焦点</li></ul></li><li>先查找当前当前持有焦点的View，DecorView会从顶部一层一层往下调用findFocus方法找到当前获取焦点的View<ul><li>如果是View，则直接判断是否持有焦点<ul><li>是则返回自己</li><li>不是返回null</li></ul></li><li>如果是ViewGroup，先判断自己是否持有焦点<ul><li>是则返回自己</li><li>不是则直接返回当前持有焦点的子View（mFocused 具体看代码分析）</li></ul></li></ul></li><li>通过focusSearch从内到外层层寻找下一个焦点view<ul><li>持有焦点的View不会查找，而是通过parent查找，直到顶层为止，具体算法在FocusFinder</li><li>查找分为两种<ul><li>优先找用户在xml指定的view</li><li>系统根据算法找view</li></ul></li></ul></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>FocusFinder.findNextUserSpecifiedFocus会根据<code>focusable</code>属性决定是否使用该view，所以如果想在系统层修改使所有view都能接收焦点，这里是个修改的参考点。</p><p>另外，就是从系统层面给所有的view添加<code>focusable</code>属性，也就是解析的时候给view都加上这个属性。</p><p>最后就是焦点的显示，可能也需要给所有的view添加获取焦点后的放大或加边框显示。</p><p>有的我做了。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Framework </tag>
            
            <tag> TV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Java] 使用EnumSet代替位运算简化代码逻辑</title>
      <link href="/2019/12/09/%5BJava%5DUse-Bit-mask-code-By-EnumSet/"/>
      <url>/2019/12/09/%5BJava%5DUse-Bit-mask-code-By-EnumSet/</url>
      
        <content type="html"><![CDATA[<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>在Review代码时候，看到一段涉及到USB的逻辑代码，他是这样写的</p><pre class=" language-lang-java"><code class="language-lang-java">private boolean isUsbConnected;private boolean isUsbModeNCM;private boolean isUsbModeAccessory;private boolean isUsbModeAdb;private boolean isUsbModeMTP;...</code></pre><p>然后代码逻辑里是大量的成员变量的判断，显得非常臃肿而且难读懂，大量的if-else判断让代码逻辑很脆弱，稍微一个情况没考虑好就会出现难以排查的bug。</p><p>所以这种情况使用位掩码进行处理会更简单：</p><pre class=" language-lang-java"><code class="language-lang-java">// 博客地址：wossoneri.github.ioprivate static final int FLAG_USB_CONNECTED = 0x1;private static final int FLAG_USB_MODE_NCM = 0x1 << 1;private static final int FLAG_USB_MODE_ACY = 0x1 << 2;private static final int FLAG_USB_MODE_ADB = 0x1 << 3;private static final int FLAG_USB_MODE_MTP = 0x1 << 4;...private int mUsbState;public void addUsbState(int flag) {     mUsbState |= flag; }public void removeUsbState(int flag) {  mUsbState &= ~flag;}public boolean isUsbStateEnable(int flag) {  return (mUsbState & flag) == flag;}</code></pre><p>简单分析一下这样写的好处：</p><blockquote><p>FLAG_USB_CONNECTED =     0001</p><p>FLAG_USB_MODE_NCM =      0010</p><p>FLAG_USB_MODE_ACY    =     0100</p><p>FLAG_USB_MODE_ADB =       1000</p></blockquote><p>通过移位，使得每一位都有独立的代表的意义，1代表enable，0代表disable。</p><p>如果要<strong>添加状态</strong>（Java里int值默认赋值为0）：</p><pre class=" language-lang-java"><code class="language-lang-java">public void addUsbState(int flag) {     mUsbState |= flag; }</code></pre><p>假设添加accessory状态FLAG_USB_MODE_ACY</p><pre class=" language-lang-txt"><code class="language-lang-txt">0000 |= 0100 -> 0100</code></pre><p>所以mUsbState就是0100的状态了。</p><p>继续添加FLAG_USB_MODE_ADB状态</p><pre class=" language-lang-txt"><code class="language-lang-txt">0100 |= 1000 -> 1100</code></pre><p>也可以一次添加多个状态，比如上面的两个状态在一次设置同时添加：</p><pre class=" language-lang-java"><code class="language-lang-java">addUsbState(FLAG_USB_MODE_ACY | FLAG_USB_MODE_ADB);</code></pre><p>结果就是：</p><pre class=" language-lang-txt"><code class="language-lang-txt">0000 |= (0100 | 1000)-> 0000 |= 1100-> 1100</code></pre><p>如果是原来的boolean变量，就需要单独为每一个变量设置，就会很麻烦。</p><hr><p>然后是<strong>移除状态</strong>：</p><pre class=" language-lang-java"><code class="language-lang-java">public void removeUsbState(int flag) {  mUsbState &= ~flag;}</code></pre><p>比如接着上面移除FLAG_USB_MODE_ADB状态</p><pre class=" language-lang-txt"><code class="language-lang-txt">1100 &= ~1000-> 1100 &= 0111-> 0100</code></pre><p>如果移除一个不存在的状态比如FLAG_USB_MODE_NCM</p><pre class=" language-lang-txt"><code class="language-lang-txt">0100 &= ~0010-> 0100 &= 1101-> 0100</code></pre><p>可以看到并不会对当前状态造成任何影响。</p><hr><p>最后看一下<strong>检查状态</strong>：</p><pre class=" language-lang-java"><code class="language-lang-java">public boolean isUsbStateEnable(int flag) {  return (mUsbState & flag) == flag;}</code></pre><p>首先检查一下当前拥有的状态：</p><pre class=" language-lang-txt"><code class="language-lang-txt">(0100 & 0100) == 0100-> 0100 == 0100-> true</code></pre><p>可以检测到该状态。然后换一个状态：</p><pre class=" language-lang-txt"><code class="language-lang-txt">(0100 & 1000) == 1000-> 0000 == 1000-> false</code></pre><p>没有检测到该状态。</p><p>所以，通过三个简单的方法，就可以检查一个变量里保存的所有状态，避免了使用大量bool变量进行挨个检查。简化了代码，增加代码可读性，并且使代码更加稳定。</p><h2 id="进阶！使用EnumSet替代位运算"><a href="#进阶！使用EnumSet替代位运算" class="headerlink" title="进阶！使用EnumSet替代位运算"></a>进阶！使用EnumSet替代位运算</h2><p>到这里你可能觉得问题解决了就完了，但是还没有！</p><p>实际上，《Effective Java》这本书有对位域的一项讨论：</p><blockquote><p>位域表示法也允许利用位操作，有效的执行像union和intersection这样的集合操作。但位域有着int枚举常量所有的缺点，甚至更多。当位域以数字形式打印时，翻译位域比翻译简单的int枚举常量要困难很多。甚至要遍历位域表示的所有元素也没有很容易的方法。</p></blockquote><p>Java.util包提供了EnumSet类来有效地表示从单个枚举类型中提取的多个值的多个集合。这个类实现Set<strong>接口</strong>，提供丰富的功能、类型安全性以及可从其他Set实现中得到的互用性。</p><p>内部实现上，每个EnumSet内容都表示为位矢量，一般（低于64个元素）整个EnumSet就是用一个long的位运算来表示的。也就是说它替你使用位算法实现了这一切，避免你自己写位运算导致代码难读懂的情况。</p><p>下面是用EnumSet修改后的示例代码，它更加简短，清楚也更安全。</p><pre class=" language-lang-java"><code class="language-lang-java">// 博客地址：wossoneri.github.iopublic class UsbManager {    private EnumSet<UsbFlags> mUsbState = EnumSet.noneOf(UsbFlags.class);    public enum UsbFlags {        CONNECTED, NCM, ACCESSORY, ADB, MTP    }    public void addFlag(UsbFlags flag) {        mUsbState.add(flag);        System.out.println("After add flag " + flag + ", Now state is " + this.mUsbState);    }    public void addFlag(Set<UsbFlags> flags) {        mUsbState.addAll(flags);        System.out.println("After add flags " + flags + ", Now state is " + this.mUsbState);    }    public void removeFlag(UsbFlags flag) {        mUsbState.remove(flag);        System.out.println("After remove flag " + flag + ", Now state is " + this.mUsbState);    }    public void removeFlag(Set<UsbFlags> flags) {        mUsbState.removeAll(flags);        System.out.println("After remove flags " + flags + ", Now state is " + this.mUsbState);    }    public boolean checkFlagEnabled(UsbFlags flag) {        return mUsbState.contains(flag);    }    public boolean checkFlagEnabled(Set<UsbFlags> flag) {        return mUsbState.containsAll(flag);    }    public void printUsbState() {        System.out.println("Current usb state is " + mUsbState);    }}</code></pre><p>测试用例以及输出</p><pre class=" language-lang-java"><code class="language-lang-java">public static void main(String[] args) {  // 博客地址：wossoneri.github.io  UsbManager usbManager = new UsbManager();  usbManager.printUsbState();  // 添加一项flag  usbManager.addFlag(UsbFlags.CONNECTED);  // 添加一组 flag  usbManager.addFlag(EnumSet.of(UsbFlags.ACCESSORY, UsbFlags.ADB));  // 检查存在的一个flag  System.out.println("mUsbState contains flag " + UsbFlags.ACCESSORY + ": " +                     usbManager.checkFlagEnabled(UsbFlags.ACCESSORY));  // 检查不存在的一个flag  System.out.println("mUsbState contains flag " + UsbFlags.MTP + ": " +                     usbManager.checkFlagEnabled(UsbFlags.MTP));  // 检查一组存在的flag  System.out.println("mUsbState contains flag " + EnumSet.of(UsbFlags.ACCESSORY, UsbFlags.ADB) + ": " +                     usbManager.checkFlagEnabled(EnumSet.of(UsbFlags.ACCESSORY, UsbFlags.ADB)));  // 检查一组包含不存在的flag  System.out.println("mUsbState contains flag " + EnumSet.of(UsbFlags.ACCESSORY, UsbFlags.MTP) + ": " +                     usbManager.checkFlagEnabled(EnumSet.of(UsbFlags.ACCESSORY, UsbFlags.MTP)));  // 检查一组都不存在的flag  System.out.println("mUsbState contains flag " + EnumSet.of(UsbFlags.NCM, UsbFlags.MTP) + ": " +                     usbManager.checkFlagEnabled(EnumSet.of(UsbFlags.NCM, UsbFlags.MTP)));  usbManager.printUsbState();  // 删除一个不存在的flag  usbManager.removeFlag(UsbFlags.MTP);  // 删除一个存在的flag  usbManager.removeFlag(UsbFlags.ACCESSORY);  // 删除一组都不存在的flag  usbManager.removeFlag(EnumSet.of(UsbFlags.NCM, UsbFlags.MTP));  // 删除一组包含不存在的flag  usbManager.removeFlag(EnumSet.of(UsbFlags.NCM, UsbFlags.ADB));  usbManager.addFlag(EnumSet.of(UsbFlags.ACCESSORY, UsbFlags.ADB));  // 删除一组存在的flag  usbManager.removeFlag(EnumSet.of(UsbFlags.ADB, UsbFlags.ACCESSORY));}</code></pre><p>输出为</p><pre class=" language-lang-txt"><code class="language-lang-txt">Current usb state is []After add flag CONNECTED, Now state is [CONNECTED]After add flags [ACCESSORY, ADB], Now state is [CONNECTED, ACCESSORY, ADB]mUsbState contains flag ACCESSORY: truemUsbState contains flag MTP: falsemUsbState contains flag [ACCESSORY, ADB]: truemUsbState contains flag [ACCESSORY, MTP]: falsemUsbState contains flag [NCM, MTP]: falseCurrent usb state is [CONNECTED, ACCESSORY, ADB]After remove flag MTP, Now state is [CONNECTED, ACCESSORY, ADB]After remove flag ACCESSORY, Now state is [CONNECTED, ADB]After remove flags [NCM, MTP], Now state is [CONNECTED, ADB]After remove flags [NCM, ADB], Now state is [CONNECTED]After add flags [ACCESSORY, ADB], Now state is [CONNECTED, ACCESSORY, ADB]After remove flags [ACCESSORY, ADB], Now state is [CONNECTED]</code></pre><p>综上，代码唯一要注意的是</p><pre class=" language-lang-java"><code class="language-lang-java">public boolean checkFlagEnabled(Set<UsbFlags> flag)</code></pre><p>传入参数使用了Set接口，这是考虑到可能会传入其他Set的实现类型，所以传入接口参数要好于实现类型参数。</p><p>最后，EnumSet类集成了位域自身的简洁性和性能优势，又拥有枚举的所有优点，所以使用它代替位域是非常好的选择。</p>]]></content>
      
      
      <categories>
          
          <category> Syntax </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> EnumSet </tag>
            
            <tag> Effective Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Android][Framework]关于Activity回收你要知道的事情</title>
      <link href="/2019/11/18/%5BAndroid%5D%5BFramework%5DSomething-about-activity-recycle/"/>
      <url>/2019/11/18/%5BAndroid%5D%5BFramework%5DSomething-about-activity-recycle/</url>
      
        <content type="html"><![CDATA[<p>之前分析过一篇:<a href="http://wossoneri.github.io/2018/05/17/[Android][Framework]ActivityThread/">ActivityThread流程wossoneri.github.io</a>，简单了解了从ActivityThread创建到Application的启动流程。</p><p>但毕竟Android源码是个大工程，分析流程的时候很多地方不会特别去关注，后来在解决问题的时候又发现一些很有意思的东西，所以拎出来整理一下。</p><p>ActivityThread创建之后首先创建Handler和获取Looper，之后就调用了非常重要的attach方法。</p><h3 id="ActivityThread-attach"><a href="#ActivityThread-attach" class="headerlink" title="ActivityThread.attach()"></a>ActivityThread.attach()</h3><pre class=" language-lang-java"><code class="language-lang-java">private void attach(boolean system) {  ...  final IActivityManager mgr = ActivityManagerNative.getDefault();  try {    mgr.attachApplication(mAppThread);  } catch (RemoteException ex) {    throw ex.rethrowFromSystemServer();  }  // Watch for getting close to heap limit.  // 这里有一个watcher，上次分析被我忽略了...  BinderInternal.addGcWatcher(new Runnable() {    @Override public void run() {      if (!mSomeActivitiesChanged) {        return;      }      Runtime runtime = Runtime.getRuntime();      long dalvikMax = runtime.maxMemory();      long dalvikUsed = runtime.totalMemory() - runtime.freeMemory();      if (dalvikUsed > ((3*dalvikMax)/4)) {        if (DEBUG_MEMORY_TRIM) Slog.d(TAG, "Dalvik max=" + (dalvikMax/1024)                                      + " total=" + (runtime.totalMemory()/1024)                                      + " used=" + (dalvikUsed/1024));        mSomeActivitiesChanged = false;        try {          mgr.releaseSomeActivities(mAppThread);        } catch (RemoteException e) {          throw e.rethrowFromSystemServer();        }      }    }  });}</code></pre><p>方法里有一段曾经被我忽略的代码，从字面知道，这里添加了一个GC的watcher，里面的线程运行条件是当虚拟机内存占用超过虚拟机分配的最大内存的3/4时，对一些Activity进行释放。</p><h3 id="BinderInternal-addGcWatcher"><a href="#BinderInternal-addGcWatcher" class="headerlink" title="BinderInternal.addGcWatcher()"></a>BinderInternal.addGcWatcher()</h3><pre class=" language-lang-java"><code class="language-lang-java">static ArrayList<Runnable> sGcWatchers = new ArrayList<>();public static void addGcWatcher(Runnable watcher) {  synchronized (sGcWatchers) {    sGcWatchers.add(watcher);  }}</code></pre><p>BinderInternel维护了一个Runnable列表。</p><h3 id="BinderInternal-GcWatcher"><a href="#BinderInternal-GcWatcher" class="headerlink" title="BinderInternal.GcWatcher"></a>BinderInternal.GcWatcher</h3><pre class=" language-lang-java"><code class="language-lang-java">static WeakReference<GcWatcher> sGcWatcher            = new WeakReference<GcWatcher>(new GcWatcher());static Runnable[] sTmpWatchers = new Runnable[1];static long sLastGcTime;static final class GcWatcher {  @Override  protected void finalize() throws Throwable {    handleGc();    sLastGcTime = SystemClock.uptimeMillis();    synchronized (sGcWatchers) {      sTmpWatchers = sGcWatchers.toArray(sTmpWatchers);    }    for (int i=0; i<sTmpWatchers.length; i++) {      if (sTmpWatchers[i] != null) {        sTmpWatchers[i].run();      }    }    sGcWatcher = new WeakReference<GcWatcher>(new GcWatcher());  }}</code></pre><p>这里重写了finalize()方法，根据JVM的原理，JVM垃圾回收器准备释放内存前，会先调用该对象finalize</p><p>重写的内容是拿到Runnable列表，依次执行每个Runnable。也就是说当执行到GC的时候，会调用到这里，然后执行Runnable的时候调用到虚拟机3/4内存的计算。</p><p>finallize方法最后重新创建了一个GcWatcher的弱引用。sGcWatcher是一个静态对象，如果它是一个强引用，那么他就会存在静态引用方法区，就会导致这个强引用的GC线程无法回收。所以作为弱引用，引用对象在被回收时就会触发sGcWatcher的finalize方法，执行结束时仔new一个弱引用出来，以保证下次的调用。</p><p>那么这里如何保证GC回收呢？</p><h3 id="BinderInternal-forceGc"><a href="#BinderInternal-forceGc" class="headerlink" title="BinderInternal.forceGc()"></a>BinderInternal.forceGc()</h3><pre class=" language-lang-java"><code class="language-lang-java">public static void forceGc(String reason) {  EventLog.writeEvent(2741, reason);  VMRuntime.getRuntime().requestConcurrentGC();}</code></pre><p>通过查询代码，发现一共有两处调用这个方法。我们分两条调用线去看</p><h3 id="第一种GC条件"><a href="#第一种GC条件" class="headerlink" title="第一种GC条件"></a>第一种GC条件</h3><h4 id="ActivityThread-doGcIfNeeded"><a href="#ActivityThread-doGcIfNeeded" class="headerlink" title="ActivityThread.doGcIfNeeded()"></a>ActivityThread.doGcIfNeeded()</h4><pre class=" language-lang-java"><code class="language-lang-java">private static final long MIN_TIME_BETWEEN_GCS = 5*1000;void doGcIfNeeded() {  mGcIdlerScheduled = false;  final long now = SystemClock.uptimeMillis();  //Slog.i(TAG, "**** WE MIGHT WANT TO GC: then=" + Binder.getLastGcTime()  //        + "m now=" + now);  if ((BinderInternal.getLastGcTime()+MIN_TIME_BETWEEN_GCS) < now) {    //Slog.i(TAG, "**** WE DO, WE DO WANT TO GC!");    BinderInternal.forceGc("bg");  }}</code></pre><p>这段代码就是根据上次GC的时间加上两次GC间隔的最小时间5s，判断当前是否要GC。再查找其调用。</p><h4 id="ActivityThread-GcIdler"><a href="#ActivityThread-GcIdler" class="headerlink" title="ActivityThread.GcIdler"></a>ActivityThread.GcIdler</h4><pre class=" language-lang-java"><code class="language-lang-java">final class GcIdler implements MessageQueue.IdleHandler {  @Override  public final boolean queueIdle() {    doGcIfNeeded();    return false;  }}</code></pre><p>是GcIdler类，在实现MessageQueue.IdleHandler的queueIdle方法时做的处理。</p><h4 id="MessageQueue-IdleHandler"><a href="#MessageQueue-IdleHandler" class="headerlink" title="MessageQueue.IdleHandler"></a>MessageQueue.IdleHandler</h4><pre class=" language-lang-java"><code class="language-lang-java">// 检测当一个线程将要阻塞以等待更多的message时的状态的接口public static interface IdleHandler {  // 当消息队列处理完消息后，等待新消息时调用。  // 如果返回true  则保持idle handler活跃  // 如果返回false 则代表handler被移除  // 如果队列里仍然有消息等待，但是这些消息不会立即发送，而是计划在之后一段时间发送，也会触发该回调。  boolean queueIdle();}</code></pre><h4 id="MessageQueue-next"><a href="#MessageQueue-next" class="headerlink" title="MessageQueue.next()"></a>MessageQueue.next()</h4><pre class=" language-lang-java"><code class="language-lang-java">Message next() {    ...    // Run the idle handlers.    // We only ever reach this code block during the first iteration.    for (int i = 0; i < pendingIdleHandlerCount; i++) {      final IdleHandler idler = mPendingIdleHandlers[i];      mPendingIdleHandlers[i] = null; // release the reference to the handler      boolean keep = false;      try {        keep = idler.queueIdle();      } catch (Throwable t) {        Log.wtf(TAG, "IdleHandler threw exception", t);      }      if (!keep) {        synchronized (this) {          mIdleHandlers.remove(idler);        }      }    }  ...}</code></pre><p>回调在这里触发的。知道回调后再回去看回调的实现是怎么调用的。</p><h4 id="ActivityThread"><a href="#ActivityThread" class="headerlink" title="ActivityThread"></a>ActivityThread</h4><pre class=" language-lang-java"><code class="language-lang-java">final GcIdler mGcIdler = new GcIdler();boolean mGcIdlerScheduled = false;public void handleMessage(Message msg) {  case GC_WHEN_IDLE:    scheduleGcIdler();    break; }</code></pre><h4 id="ActivityThread-unscheduleGcIdler"><a href="#ActivityThread-unscheduleGcIdler" class="headerlink" title="ActivityThread.unscheduleGcIdler()"></a>ActivityThread.unscheduleGcIdler()</h4><pre class=" language-lang-java"><code class="language-lang-java">void unscheduleGcIdler() {  if (mGcIdlerScheduled) {    mGcIdlerScheduled = false;    Looper.myQueue().removeIdleHandler(mGcIdler);  }  mH.removeMessages(H.GC_WHEN_IDLE);}</code></pre><p>这里主要是提一下：在所有的unscheduleGcIdler调用前都有一段注释：</p><pre class=" language-lang-java"><code class="language-lang-java">private void handleLaunchActivity(ActivityClientRecord r,                                   Intent customIntent, String  reason) {  // If we are getting ready to gc after going to the background, well  // we are back active so skip it.  unscheduleGcIdler();  ...</code></pre><p>调用unscheduleGcIdler的方法如下：</p><pre class=" language-lang-java"><code class="language-lang-java">private void handleLaunchActivity(ActivityClientRecord r,                                   Intent customIntent, String reason)private void handleReceiver(ReceiverData data)private void handleCreateBackupAgent(CreateBackupAgentData data)private void handleCreateService(CreateServiceData data)final void handleResumeActivity(IBinder token, boolean clearHide,              boolean isForward, boolean reallyResume, int seq, String reason)private void handleWindowVisibility(IBinder token, boolean show)private void handleRelaunchActivity(ActivityClientRecord tmp)</code></pre><h4 id="ActivityThread-scheduleGcIdler"><a href="#ActivityThread-scheduleGcIdler" class="headerlink" title="ActivityThread.scheduleGcIdler()"></a>ActivityThread.scheduleGcIdler()</h4><pre class=" language-lang-java"><code class="language-lang-java">void scheduleGcIdler() {  if (!mGcIdlerScheduled) {    mGcIdlerScheduled = true;    Looper.myQueue().addIdleHandler(mGcIdler);  }  mH.removeMessages(H.GC_WHEN_IDLE);}</code></pre><p>Looper.myQueue() ，也就是主线程里的handler线程队列内容全部处理 结束，这个GcIdler 的 queueIdle() 就会被触发，那么GC就会被触发。已经到这，大概我们就明白GC<strong>调用的时机</strong></p><p>scheduleGcIdler是Handler收到<strong>GC_WHEN_IDLE</strong>消息后触发，查询这个消息的来源：</p><h4 id="ActivityThread-processInBackground"><a href="#ActivityThread-processInBackground" class="headerlink" title="ActivityThread.processInBackground()"></a>ActivityThread.processInBackground()</h4><pre class=" language-lang-java"><code class="language-lang-java">public void processInBackground() {  mH.removeMessages(H.GC_WHEN_IDLE);  mH.sendMessage(mH.obtainMessage(H.GC_WHEN_IDLE));}</code></pre><p>代码上溯到AMS</p><h4 id="ActivityManagerService-performAppGcLocked"><a href="#ActivityManagerService-performAppGcLocked" class="headerlink" title="ActivityManagerService.performAppGcLocked()"></a>ActivityManagerService.performAppGcLocked()</h4><pre class=" language-lang-java"><code class="language-lang-java">/** * Ask a given process to GC right now. */final void performAppGcLocked(ProcessRecord app) {  try {    app.lastRequestedGc = SystemClock.uptimeMillis();    if (app.thread != null) {      if (app.reportLowMemory) {        app.reportLowMemory = false;        app.thread.scheduleLowMemory();      } else {        app.thread.processInBackground();      }    }  } catch (Exception e) {    // whatever.  }}</code></pre><h4 id="ActivityManagerService-performAppGcsLocked"><a href="#ActivityManagerService-performAppGcsLocked" class="headerlink" title="ActivityManagerService.performAppGcsLocked()"></a>ActivityManagerService.performAppGcsLocked()</h4><pre class=" language-lang-java"><code class="language-lang-java">/** * Perform GCs on all processes that are waiting for it, but only * if things are idle. */final void performAppGcsLocked() {  final int N = mProcessesToGc.size();  if (N <= 0) {    return;  }  if (canGcNowLocked()) {    while (mProcessesToGc.size() > 0) {      ProcessRecord proc = mProcessesToGc.remove(0);      if (proc.curRawAdj > ProcessList.PERCEPTIBLE_APP_ADJ || proc.reportLowMemory) {        if ((proc.lastRequestedGc+GC_MIN_INTERVAL)            <= SystemClock.uptimeMillis()) {          // To avoid spamming the system, we will GC processes one          // at a time, waiting a few seconds between each.          performAppGcLocked(proc);          scheduleAppGcsLocked();          return;        } else {          // It hasn't been long enough since we last GCed this          // process...  put it in the list to wait for its time.          addProcessToGcListLocked(proc);          break;        }      }    }    scheduleAppGcsLocked();  }}</code></pre><p>scheduleAppGcsLocked() 这个方法是用来通知Activity, Service, Application onLowMemory() 回调的</p><p> if (proc.curRawAdj &gt; ProcessList.PERCEPTIBLE_APP_ADJ || proc.reportLowMemory),这个从字面理解就是，如果目前的oom_adj 比 ProcessList.PERCEPTIBLE_APP_ADJ 级别要高，或者进程在低内存环境下运行，就会触发这个方法，关于oom_adj，在后面内存优化会介绍。</p><p>以上可以得出结论，就是如果此时App正在前台显示运行，并且不是低内存状态，那么进程全局的GC就不会被触发。</p><h3 id="第二种GC条件"><a href="#第二种GC条件" class="headerlink" title="第二种GC条件"></a>第二种GC条件</h3><h4 id="ActivityThread-handleLowMemory"><a href="#ActivityThread-handleLowMemory" class="headerlink" title="ActivityThread.handleLowMemory()"></a>ActivityThread.handleLowMemory()</h4><pre class=" language-lang-java"><code class="language-lang-java">final void handleLowMemory() {  ArrayList<ComponentCallbacks2> callbacks = collectComponentCallbacks(true, null);  final int N = callbacks.size();  for (int i=0; i<N; i++) {    callbacks.get(i).onLowMemory();  }  // Ask SQLite to free up as much memory as it can, mostly from its page caches.  if (Process.myUid() != Process.SYSTEM_UID) {    int sqliteReleased = SQLiteDatabase.releaseMemory();    EventLog.writeEvent(SQLITE_MEM_RELEASED_EVENT_LOG_TAG, sqliteReleased);  }  // Ask graphics to free up as much as possible (font/image caches)  Canvas.freeCaches();  // Ask text layout engine to free also as much as possible  Canvas.freeTextLayoutCaches();  BinderInternal.forceGc("mem");}</code></pre><p>方法的触发是收到<strong>LOW_MEMORY</strong>消息后开始。</p><p>消息的来源为：</p><p>ActivityThread.scheduleLowMemory</p><pre class=" language-lang-java"><code class="language-lang-java">@Overridepublic void scheduleLowMemory() {  sendMessage(H.LOW_MEMORY, null);}</code></pre><p>然后发现代码又回到了AMS</p><h4 id="ActivityManagerService-performAppGcLocked-1"><a href="#ActivityManagerService-performAppGcLocked-1" class="headerlink" title="ActivityManagerService.performAppGcLocked()"></a>ActivityManagerService.performAppGcLocked()</h4><pre class=" language-lang-java"><code class="language-lang-java">/** * Ask a given process to GC right now. */final void performAppGcLocked(ProcessRecord app) {  try {    app.lastRequestedGc = SystemClock.uptimeMillis();    if (app.thread != null) {      if (app.reportLowMemory) {        app.reportLowMemory = false;        app.thread.scheduleLowMemory();      } else {        app.thread.processInBackground();      }    }  } catch (Exception e) {    // whatever.  }}</code></pre><p>从这个方法看出，如果是LowMemeory的情况会调用scheduleLowMemory方法，否则调用processInBackground。</p><p>我们就整明白了App回收是何时触发的，那么接下来我们来看看，Activity会被释放部分Activity这种情况。</p><p>回到addGcWatcher，里面的线程运行条件是当虚拟机内存占用超过虚拟机分配的最大内存的3/4时，就会触发GC，对一些Activity进行释放。释放Activity代码是：</p><pre class=" language-lang-java"><code class="language-lang-java">final IActivityManager mgr = ActivityManagerNative.getDefault();mgr.releaseSomeActivities(mAppThread);</code></pre><p>所以代码又回到了ActivityManagerService中：</p><h3 id="ActivityManagerService-releaseSomeActivities"><a href="#ActivityManagerService-releaseSomeActivities" class="headerlink" title="ActivityManagerService.releaseSomeActivities()"></a>ActivityManagerService.releaseSomeActivities()</h3><pre class=" language-lang-java"><code class="language-lang-java">@Overridepublic void releaseSomeActivities(IApplicationThread appInt) {  synchronized(this) {    final long origId = Binder.clearCallingIdentity();    try {      ProcessRecord app = getRecordForAppLocked(appInt);      mStackSupervisor.releaseSomeActivitiesLocked(app, "low-mem");    } finally {      Binder.restoreCallingIdentity(origId);    }  }}</code></pre><h3 id="ActivityStackSupervisor-releaseSomeActivitiesLocked"><a href="#ActivityStackSupervisor-releaseSomeActivitiesLocked" class="headerlink" title="ActivityStackSupervisor.releaseSomeActivitiesLocked()"></a>ActivityStackSupervisor.releaseSomeActivitiesLocked()</h3><pre class=" language-lang-java"><code class="language-lang-java">void releaseSomeActivitiesLocked(ProcessRecord app, String reason) {  // 检查当前在进程中正在运行的所有activity  TaskRecord firstTask = null;  // 只有在2个或多个task任务栈时，tasks才不为空。也就是单栈app不会销毁。  ArraySet<TaskRecord> tasks = null;  if (DEBUG_RELEASE) Slog.d(TAG_RELEASE, "Trying to release some activities in " + app);  for (int i = 0; i < app.activities.size(); i++) {    ActivityRecord r = app.activities.get(i);    // 如果发现进程中的一个activity正在被destory，那么我们这次就不做任何处理。直接return掉    // 因为在执行清理activity的操作之前最好保持一个稳定的状态。    if (r.finishing || r.state == DESTROYING || r.state == DESTROYED) {      if (DEBUG_RELEASE) Slog.d(TAG_RELEASE, "Abort release; already destroying: " + r);      return;    }    // 如果一个activity处于不可销毁的状态就不处理这个activity    if (r.visible || !r.stopped || !r.haveState || r.state == RESUMED || r.state == PAUSING        || r.state == PAUSED || r.state == STOPPING) {      if (DEBUG_RELEASE) Slog.d(TAG_RELEASE, "Not releasing in-use activity: " + r);      continue;    }    if (r.task != null) {      if (DEBUG_RELEASE) Slog.d(TAG_RELEASE, "Collecting release task " + r.task                                + " from " + r);      if (firstTask == null) {        firstTask = r.task;      } else if (firstTask != r.task) { // 需要多一个TaskRecord        if (tasks == null) {          tasks = new ArraySet<>();          tasks.add(firstTask);        }        tasks.add(r.task);      }    }  }  if (tasks == null) {    // APP当前进程中，至少两个TaskRecord才有必要走Activity的销毁逻辑    if (DEBUG_RELEASE) Slog.d(TAG_RELEASE, "Didn't find two or more tasks to release");    return;  }  // If we have activities in multiple tasks that are in a position to be destroyed,  // let's iterate through the tasks and release the oldest one.  final int numDisplays = mActivityDisplays.size();  for (int displayNdx = 0; displayNdx < numDisplays; ++displayNdx) {    final ArrayList<ActivityStack> stacks = mActivityDisplays.valueAt(displayNdx).mStacks;    // Step through all stacks starting from behind, to hit the oldest things first.    for (int stackNdx = 0; stackNdx < stacks.size(); stackNdx++) {      final ActivityStack stack = stacks.get(stackNdx);      // Try to release activities in this stack; if we manage to, we are done.      if (stack.releaseSomeActivitiesLocked(app, tasks, reason) > 0) {        return;      }    }  }}</code></pre><p>StackSupervisor 是什么？可以理解为activity任务栈的管理中心，系统所有应用的activity任务都在此管理.</p><h3 id="ActivityStack-releaseSomeActivitiesLocked"><a href="#ActivityStack-releaseSomeActivitiesLocked" class="headerlink" title="ActivityStack.releaseSomeActivitiesLocked"></a>ActivityStack.releaseSomeActivitiesLocked</h3><pre class=" language-lang-java"><code class="language-lang-java">final int releaseSomeActivitiesLocked(ProcessRecord app, ArraySet<TaskRecord> tasks,                                      String reason) {  // Iterate over tasks starting at the back (oldest) first.  if (DEBUG_RELEASE) Slog.d(TAG_RELEASE, "Trying to release some activities in " + app);  int maxTasks = tasks.size() / 4;  if (maxTasks < 1) {    maxTasks = 1;  }  int numReleased = 0;  for (int taskNdx = 0; taskNdx < mTaskHistory.size() && maxTasks > 0; taskNdx++) {    final TaskRecord task = mTaskHistory.get(taskNdx);    if (!tasks.contains(task)) {      continue;    }    if (DEBUG_RELEASE) Slog.d(TAG_RELEASE, "Looking for activities to release in " + task);    int curNum = 0;    final ArrayList<ActivityRecord> activities = task.mActivities;    for (int actNdx = 0; actNdx < activities.size(); actNdx++) {      final ActivityRecord activity = activities.get(actNdx);      if (activity.app == app && activity.isDestroyable()) {        if (DEBUG_RELEASE) Slog.v(TAG_RELEASE, "Destroying " + activity             + " in state " + activity.state + " resumed=" + mResumedActivity             + " pausing=" + mPausingActivity + " for reason " + reason);        destroyActivityLocked(activity, true, reason);        if (activities.get(actNdx) != activity) {          // Was removed from list, back up so we don't miss the next one.          actNdx--;        }        curNum++;      }    }    if (curNum > 0) {      numReleased += curNum;      maxTasks--;      if (mTaskHistory.get(taskNdx) != task) {        // The entire task got removed, back up so we don't miss the next one.        taskNdx--;      }    }  }  if (DEBUG_RELEASE) Slog.d(TAG_RELEASE,            "Done releasing: did " + numReleased + " activities");  return numReleased;}</code></pre><p>至此之后就会执行到Activity 的 performDestroy方法进行ondestroy，然后就等待GC回收的处理了。</p><p>总结</p><ol><li>对于非系统进程，通过BinderInternal.addGcWatcher添加了一个内存监测工具，后面会发现，这个工具的检测时机是每个GC节点。而对于我们上文说的回收不可见Task的时机是在关键点</li><li>Java使用内存超过3/4的时候，调用AMS的<strong>releaseSomeActivities</strong>，尝试释放不可见Activity，当然，并非所有不可见的Activity会被回收，比如单栈的APP就不会销毁，多栈的也要分场景，可能选择性销毁不可见Activity，比如至少两个TaskRecord才有必要走Activity的销毁逻辑</li><li>该回收机制利用了Java虚拟机的gc机finalize</li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Framework </tag>
            
            <tag> Activity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Android][Framework] 全方位理解Android权限之Android权限系统1</title>
      <link href="/2019/11/17/%5BAndroid%5D%5BFramework%5DAndroid-permission-2/"/>
      <url>/2019/11/17/%5BAndroid%5D%5BFramework%5DAndroid-permission-2/</url>
      
        <content type="html"><![CDATA[<p>系列目录请点击这里： <a href="http://wossoneri.github.io/2019/01/11/[Android][Framework]Android-permission-1/">全方位理解Android权限</a></p><p>因为东忙西忙没时间整理这一块的东西，拖了有点久，现在继续更新</p><h1 id="权限的性质"><a href="#权限的性质" class="headerlink" title="权限的性质"></a>权限的性质</h1><p>我们知道，Android应用都运行在沙盒中，默认情况下这些应用只能访问他们自己的域，即自己的文件和非常少量的系统服务。为了能够和系统或者其他应用交互，app就需要申请额外的一些权限。</p><p>permission（权限）实际上就是一个简单的字串，申明需要做哪些类型的操作。</p><p>比如文件读权限就是这么一个字串：</p><pre class=" language-lang-xml"><code class="language-lang-xml"><uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /></code></pre><pre class=" language-lang-java"><code class="language-lang-java">public static final String WRITE_EXTERNAL_STORAGE = "android.permission.WRITE_EXTERNAL_STORAGE";</code></pre><p>Android系统预置了很多这样的权限，可以在官网查看文档：<a href="https://developer.android.com/reference/android/Manifest.permission.html" target="_blank" rel="noopener">Manifest.permission</a>。</p><p>权限的定义是在<code>/frameworks/base/core/res/AndroidManifest.xml</code></p><p>在AOSP的生成目录内<code>./out/target/common/R/android/Manifest.java</code>有对应定义（已删掉部分代码）：</p><pre class=" language-lang-java"><code class="language-lang-java">package android;public final class Manifest {    public static final class permission {        @android.annotation.SystemApi        public static final String ACCESS_CACHE_FILESYSTEM="android.permission.ACCESS_CACHE_FILESYSTEM";        @android.annotation.SystemApi        public static final String ACCESS_CHECKIN_PROPERTIES="android.permission.ACCESS_CHECKIN_PROPERTIES";        public static final String ACCESS_COARSE_LOCATION="android.permission.ACCESS_COARSE_LOCATION";    }  public static final class permission_group {        public static final String CALENDAR="android.permission-group.CALENDAR";        public static final String CAMERA="android.permission-group.CAMERA";        public static final String CONTACTS="android.permission-group.CONTACTS";        public static final String STORAGE="android.permission-group.STORAGE";    }</code></pre><p>如果要看系统内已知的权限列表，可以使用<code>pm list permissions</code>命令：</p><pre class=" language-lang-shell"><code class="language-lang-shell">> adb shell pm list permissionsAll Permissions:permission:android.permission.REBOOTpermission:android.permission.BIND_VPN_SERVICEpermission:com.google.android.gallery3d.permission.GALLERY_PROVIDERpermission:com.android.launcher3.permission.RECEIVE_LAUNCH_BROADCASTS...</code></pre><p>如果加上<code>-f</code>选项，可以打印出定义权限的package、label、description和protection level。</p><pre class=" language-lang-shell"><code class="language-lang-shell">> adb shell pm list permissions -fAll Permissions:+ permission:android.permission.REBOOT  package:android  label:null  description:null  protectionLevel:signature|privileged+ permission:android.permission.BIND_VPN_SERVICE  package:android  label:null  description:null  protectionLevel:signature+ permission:android.permission.GET_PACKAGE_SIZE  package:android  label:计算应用存储空间  description:允许应用检索其代码、数据和缓存大小  protectionLevel:normal+ permission:android.permission.BROADCAST_STICKY  package:android  label:发送持久广播  description:允许该应用发送持久广播消息，此类消息在广播结束后仍会保留。过度使用可能会导致手机使用过多内存，从而降低其速度或稳定性。  protectionLevel:normal</code></pre><p>一般，权限名的前缀是定义它的包名+<code>.permission.</code>。因为内置的权限都定义在<code>android</code>包内，所以系统权限命名都是<code>android.permission.</code>开头。</p><p>比如上面的例子，<strong>REBOOT</strong>和<strong>BIND_VPN_SERVICE</strong>都是系统内部权限，<strong>GALLERY_PROVIDER</strong>是Gallery应用定义的，<strong>RECEIVE_LAUNCH_BROADCASTS</strong>是默认launcher定义的。</p><h1 id="申请权限"><a href="#申请权限" class="headerlink" title="申请权限"></a>申请权限</h1><p>一般权限是在AndroidManifest.xml文件中添加<code>&lt;uses-permission&gt;</code>标签完成，关于AndroidManifest可以参考我前面写的<a href="http://wossoneri.github.io/2019/11/05/[Android][Framework]HowDoesAndroidManifestWork/">AndroidManifest解析流程wossoneri.github.io</a>。当然也可以使用<code>&lt;permission&gt;</code>标签定义新的权限。</p><pre class=" language-lang-xml"><code class="language-lang-xml"><?xml version="1.0" encoding="utf-8"?><manifest xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" package="com.example.app" android:versionCode="1" android:versionName="1.0" >    <uses-permission android:name="android.permission.INTERNET" />   <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />    <application android:name="SampleApp" ...>    </application></manifest></code></pre><h1 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h1><p>在应用安装的时候，PackageManagerService就对每个应用授予了权限。package manager管理了一个数据库，用来维护预置或者用户安装的package。维护的内容包括：安装路径，版本号，签名证书，每个package拿到的权限列表和一个在本设备上定义的所有权限列表。</p><blockquote><p>其实pm list permissions命令就是通过package manager查询权限列表的</p></blockquote><p>这个package数据库保存在<em>/data/system/packages.xml</em>路径下，每当有应用安装，更新或者卸载的时候都会更新这个xml文件。</p><p>看一下这个文件是怎么记录爱奇艺HD的：</p><pre class=" language-lang-xml"><code class="language-lang-xml"><package name="com.qiyi.video.pad" codePath="/system/vendor/app/Aiqiyi" nativeLibraryPath="/system/vendor/app/Aiqiyi/lib" primaryCpuAbi="armeabi" publicFlags="945307205" privateFlags="0" ft="11e8dc5d800" it="11e8dc5d800" ut="11e8dc5d800" version="80740" userId="10031" isOrphaned="true">  <sigs count="1">    <cert index="2" key="e700f576394b490f8c2f1708c6040c10a9f337af87" />  </sigs>  <perms>    <item name="android.permission.WRITE_SETTINGS" granted="true" flags="0" />    <item name="android.permission.MANAGE_ACCOUNTS" granted="true" flags="0" />    <item name="android.permission.SYSTEM_ALERT_WINDOW" granted="true" flags="0" />    <item name="android.permission.CHANGE_NETWORK_STATE" granted="true" flags="0" />    <item name="android.permission.EXPAND_STATUS_BAR" granted="true" flags="0" />    <item name="com.android.launcher.permission.UNINSTALL_SHORTCUT" granted="true" flags="0" />    <item name="android.permission.BLUETOOTH" granted="true" flags="0" />    <item name="android.permission.CHANGE_WIFI_MULTICAST_STATE" granted="true" flags="0" />    <item name="android.permission.GET_TASKS" granted="true" flags="0" />    <item name="android.permission.AUTHENTICATE_ACCOUNTS" granted="true" flags="0" />    <item name="android.permission.INTERNET" granted="true" flags="0" />    <item name="android.permission.CHANGE_WIFI_STATE" granted="true" flags="0" />    <item name="android.permission.ACCESS_NETWORK_STATE" granted="true" flags="0" />    <item name="android.permission.DISABLE_KEYGUARD" granted="true" flags="0" />    <item name="baidu.push.permission.WRITE_PUSHINFOPROVIDER.com.qiyi.video.pad" granted="true" flags="0" />    <item name="com.qiyi.video.pad.permission.MIPUSH_RECEIVE" granted="true" flags="0" />    <item name="android.permission.VIBRATE" granted="true" flags="0" />    <item name="android.permission.ACCESS_WIFI_STATE" granted="true" flags="0" />    <item name="android.permission.REQUEST_INSTALL_PACKAGES" granted="true" flags="0" />    <item name="com.android.launcher.permission.INSTALL_SHORTCUT" granted="true" flags="0" />    <item name="android.permission.WAKE_LOCK" granted="true" flags="0" />  </perms>  <proper-signing-keyset identifier="9" /></package></code></pre><p>这个xml文件还有很多譬如<code>&lt;shared-user&gt;</code>这类标签，这些在后面分析userId的地方再看。现在看一下permission相关的内容。</p><p>每个package都是由一个<code>&lt;package&gt;</code>标签包裹，里面包含了</p><ul><li>分配的UID userId=”10031”</li><li>签名证书 <code>&lt;cert&gt;</code>标签</li><li>分配的权限 在<code>&lt;perm&gt;</code>标签下</li></ul><p>当用代码获取已安装的应用的信息时，得到的就是包含了<code>&lt;package&gt;</code>标签下面所有内容的<em>PackageInfo</em>实例对象。</p><blockquote><p>使用android.content.pm.PackageManager.getPackageInfo()通过代码获取</p></blockquote><h1 id="权限组"><a href="#权限组" class="headerlink" title="权限组"></a>权限组</h1><p>在权限定义文件里会定义权限组，然后在单独的权限中指定该权限属于哪个权限组。</p><pre class=" language-lang-java"><code class="language-lang-java"><!-- Used for runtime permissions related to the shared external storage. --><permission-group android:name="android.permission-group.STORAGE"    android:icon="@drawable/perm_group_storage"    android:label="@string/permgrouplab_storage"    android:description="@string/permgroupdesc_storage"    android:priority="900" /><permission android:name="android.permission.READ_EXTERNAL_STORAGE"    android:permissionGroup="android.permission-group.STORAGE"    android:label="@string/permlab_sdcardRead"    android:description="@string/permdesc_sdcardRead"    android:protectionLevel="dangerous" /><permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"    android:permissionGroup="android.permission-group.STORAGE"    android:label="@string/permlab_sdcardWrite"    android:description="@string/permdesc_sdcardWrite"    android:protectionLevel="dangerous" /></code></pre><ul><li>如果应用没有获得与当前申请的权限在同一权限组的其他权限的授权，那么系统将以这个权限组的描述信息去提示用户，而不是具体申请的权限的描述信息。比如，一个应用申请了READ_CONTACTS权限，系统会提示用户”应用需要访问设备的联系人（包含读写）”，如果用户同意授权，系统只会赋予应用之前申请的权限（在这里就只是READ_CONTACTS）。</li><li>如果应用已经获得了与正在申请的权限同一个权限组的其他权限的授权，那么系统会自动将正在申请的权限授予应用，不需要任何与用户的交互行为。比如，如果一个应用之前已经获得了READ_CONTACTS权限的授权，那么在之后应用请求WRITE_CONTACTS权限时，系统会自动将该权限授予应用。</li></ul><h1 id="权限保护等级ProtectionLevel"><a href="#权限保护等级ProtectionLevel" class="headerlink" title="权限保护等级ProtectionLevel"></a>权限保护等级ProtectionLevel</h1><p>在查看权限定义时<code>frameworks/base/core/res/AndroidManifest.xml</code>，可以看到有一个标签叫做<code>protectionLevel</code>，下面放一个典型例子<strong>SYSTEM_ALERT_WINDOW</strong>的权限定义：</p><pre class=" language-lang-xml"><code class="language-lang-xml">    <permission android:name="android.permission.SYSTEM_ALERT_WINDOW"        android:label="@string/permlab_systemAlertWindow"        android:description="@string/permdesc_systemAlertWindow"        android:protectionLevel="signature|preinstalled|appop|pre23|development" /></code></pre><p><code>protectionLevel</code>是定义权限时的一个重要属性，它表示一个权限的级别，在很大程度上它也决定了一个权限被授权的方式（由系统安装时自动授权或者由用户来决定是否授权）。<br><code>protectionLevel</code>可以分为两类：<strong>基础权限级别</strong>和<strong>附加权限级别</strong>。</p><h2 id="基础权限级别"><a href="#基础权限级别" class="headerlink" title="基础权限级别"></a>基础权限级别</h2><h3 id="normal"><a href="#normal" class="headerlink" title="normal"></a>normal</h3><p>这是个默认值，也就是没有指定<code>protectionLevel</code>的权限默认获得此level。它表示这是一个对系统和其他应用低风险的权限。有该标记的权限是不需要用户确认就可以直接赋予应用程序的。</p><h3 id="dangerous"><a href="#dangerous" class="headerlink" title="dangerous"></a>dangerous</h3><p>较高风险的权限。该标记的权限一般涉及到访问用户的隐私数据或者其他一些控制设备的行为，可能会给用户带来影响。比如<strong>READ_SMS</strong>，读取短消息；比如<strong>CAMERA</strong>，允许使用摄像头。所以系统不会自动授权这类权限，而是会弹出对话框告诉用户，由用户进行选择是否授予权限。</p><h3 id="signature"><a href="#signature" class="headerlink" title="signature"></a>signature</h3><p>如果请求权限的app与声明权限的app签名一致，系统会自动赋予权限，而不会通知用户或者征求用户的同意。 否则需要通过intent将用户引导到权限管理界面由用户决定是否授权。</p><p>这属于最高级的权限等级，因为它需要有加密密钥的拥有权，而这个密钥只有这个app或者系统平台才会拥有。这也就意味着其他人无法随意使用这个权限。系统内置的signature权限一般都是由管理设备的系统App使用，也就是需要系统签名。</p><h3 id="signatureOrSystem"><a href="#signatureOrSystem" class="headerlink" title="signatureOrSystem"></a>signatureOrSystem</h3><p>相当于<code>signature | privileged</code></p><p>这个权限等级有两种应用可以自动获取该类型权限的授权：</p><p>与定义这个权限的apk拥有相同的签名的应用（这一点和Signature类型的权限相同）。</p><p>在/system/priv-app目录下的应用（即拥有超级权限的系统应用）。</p><p>这可以让制造商的预置应用即使没有与该权限一致的签名也可以通过作为系统应用去使用该权限。</p><h2 id="附加权限级别"><a href="#附加权限级别" class="headerlink" title="附加权限级别"></a>附加权限级别</h2><p>除了基础权限级别的其他权限级别都属于附加权限级别。它们必须附加在基础权限级别上使用。从目前系统定义的权限来看，附加权限级别基本都是与signature基础权限级别搭配使用。</p><p>可以理解为附加权限级别是在为signature级别的权限开后门，使signature级别的权限在特定的条件下能够授权给特定类型的应用。</p><ul><li><strong>privileged</strong>：只能与signature同时使用。signature | privileged与<strong>signatureOrSystem</strong>意义相同。</li><li><strong>system</strong>：与privileged相同，是privileged的老版本。</li><li><strong>development</strong>：development applications可以被自动授予此权限。</li><li><strong>appop</strong>：此类权限会与AppOpsManager来配合完成对应用操作的限制（AppOpsManager在后面的小节介绍）。</li><li><strong>pre23</strong>：应用请求此类权限后，系统将在应用安装时自动授权给那些targetSdkVersion在23（Android 6.0）以下的应用。</li><li><strong>installer</strong>：此类权限自动被授权给那些负责安装apk的系统app。</li><li><strong>verifier</strong>：此类权限自动被授权给那些负责验证apk的系统app。</li><li><strong>preinstalled</strong>：此类权限可以自动被授权给任何预安装在system image中的app，不只是privileged app。</li><li><strong>setup</strong>：此类权限自动被授予安装向导app。</li></ul><p>可以通过dumpsys命令查看应用权限授予情况：</p><pre class=" language-lang-shell"><code class="language-lang-shell">> dumpsys package com.xxxx.testrequested permissions:      android.permission.SYSTEM_ALERT_WINDOWShared users:  SharedUser [android.uid.system] (c5f2604):    userId=1000    install permissions:      android.permission.SYSTEM_ALERT_WINDOW: granted=true, flags=[ GRANTED_BY_DEFAULT ]</code></pre><p>所以对于前面提到的<strong>SYSTEM_ALERT_WINDOW</strong>权限，因为其权限类别为：<code>&quot;signature|preinstalled|appop|pre23|development&quot;</code>，所以，如果不是系统应用，也不是预置应用，那么就可以通过把app的targetSdkVersion调至23以下，来默认获得此权限。这里面还有一个appop权限，稍后会介绍这个东西。</p><h1 id="默认授予权限"><a href="#默认授予权限" class="headerlink" title="默认授予权限"></a>默认授予权限</h1><p>前面介绍<code>protectionLevel</code>的时候知道，只要App满足对应权限的保护级别，就可以默认获取对应权限。但是有一个没有提到，就是<strong>dangerous</strong>的权限。</p><p>我们知道，<strong>dangerous</strong>权限是需要用户手动确认的，所以要怎样默认授予其对应权限呢？</p><p>这个涉及到Framework层的修改。Framework中pm目录下有一个专门负责应用权限授予的类：</p><p><em>frameworks/base/services/core/java/com/android/server/pm/DefaultPermissionGrantPolicy.java</em></p><p>里面一个核心方法是<code>grantRuntimePermissionsLPw</code>。这篇主要做介绍，源码分析下一篇再做。</p><pre class=" language-lang-java"><code class="language-lang-java">private void grantRuntimePermissionsLPw(PackageParser.Package pkg, Set<String> permissions, boolean systemFixed, boolean isDefaultPhoneOrSms, int userId) {  if (pkg.requestedPermissions.isEmpty()) {    return;  }  List<String> requestedPermissions = pkg.requestedPermissions;  Set<String> grantablePermissions = null;  // If this is the default Phone or SMS app we grant permissions regardless  // whether the version on the system image declares the permission as used since  // selecting the app as the default Phone or SMS the user makes a deliberate  // choice to grant this app the permissions needed to function. For all other  // apps, (default grants on first boot and user creation) we don't grant default  // permissions if the version on the system image does not declare them.  if (!isDefaultPhoneOrSms && pkg.isUpdatedSystemApp()) {    PackageSetting sysPs = mService.mSettings.getDisabledSystemPkgLPr(pkg.packageName);    if (sysPs != null) {      if (sysPs.pkg.requestedPermissions.isEmpty()) {        return;      }      if (!requestedPermissions.equals(sysPs.pkg.requestedPermissions)) {        grantablePermissions = new ArraySet<>(requestedPermissions);        requestedPermissions = sysPs.pkg.requestedPermissions;      }    }  }  final int grantablePermissionCount = requestedPermissions.size();  for (int i = 0; i < grantablePermissionCount; i++) {    String permission = requestedPermissions.get(i);    // If there is a disabled system app it may request a permission the updated    // version ot the data partition doesn't, In this case skip the permission.    if (grantablePermissions != null && !grantablePermissions.contains(permission)) {      continue;    }    if (permissions.contains(permission)) {      final int flags = mService.getPermissionFlags(permission, pkg.packageName, userId);      // If any flags are set to the permission, then it is either set in      // its current state by the system or device/profile owner or the user.      // In all these cases we do not want to clobber the current state.      // Unless the caller wants to override user choices. The override is      // to make sure we can grant the needed permission to the default      // sms and phone apps after the user chooses this in the UI.      if (flags == 0 || isDefaultPhoneOrSms) {        // Never clobber policy or system.        final int fixedFlags = PackageManager.FLAG_PERMISSION_SYSTEM_FIXED          | PackageManager.FLAG_PERMISSION_POLICY_FIXED;        if ((flags & fixedFlags) != 0) {          continue;        }        mService.grantRuntimePermission(pkg.packageName, permission, userId);        if (DEBUG) {          Log.i(TAG, "Granted " + (systemFixed ? "fixed " : "not fixed ")                + permission + " to default handler " + pkg.packageName);        }        int newFlags = PackageManager.FLAG_PERMISSION_GRANTED_BY_DEFAULT;        if (systemFixed) {          newFlags |= PackageManager.FLAG_PERMISSION_SYSTEM_FIXED;        }        mService.updatePermissionFlags(permission, pkg.packageName,                                       newFlags, newFlags, userId);      }      // If a component gets a permission for being the default handler A      // and also default handler B, we grant the weaker grant form.      if ((flags & PackageManager.FLAG_PERMISSION_GRANTED_BY_DEFAULT) != 0          && (flags & PackageManager.FLAG_PERMISSION_SYSTEM_FIXED) != 0          && !systemFixed) {        if (DEBUG) {          Log.i(TAG, "Granted not fixed " + permission + " to default handler "                + pkg.packageName);        }        mService.updatePermissionFlags(permission, pkg.packageName,                                       PackageManager.FLAG_PERMISSION_SYSTEM_FIXED, 0, userId);      }    }  }}</code></pre><h1 id="AppOps"><a href="#AppOps" class="headerlink" title="AppOps"></a>AppOps</h1><p>初次接触Appops是因为，现在国内很多App都要过多的权限，比如随便一个App都要访问手机号，不给它权限的话它就退出不让你使用。后来发现，可以通过Appops默默修改权限，比如第一次打开App的时候给它所有权限，然后再用Appops偷偷把权限禁用掉，这样App可以正常打开使用，但它也偷不到对应的信息了。</p><p>它的使用也很简单，一条命令的事情：</p><pre class=" language-lang-shell"><code class="language-lang-shell">adb shell appops set com.tencent.gamehelper.smoba READ_EXTERNAL_STORAGE ignore</code></pre><p>这样就禁掉了腾讯游戏对设备存储的访问。当然除了这种用法，对于一些特殊权限比如悬浮窗权限的授权也可以使用AppOps来解决。</p><h2 id="AppOps-是什么"><a href="#AppOps-是什么" class="headerlink" title="AppOps 是什么"></a>AppOps 是什么</h2><p>Appops是Application Operations的简称，是关于应用权限管理的一套方案，但这里的应用指的是系统应用，这些API不对第三方应用开放。Google从4.3开始推出Appops, 但一直到最新的Android N都没有在Settings里面开放Appops的入口，但这套方案却一直在后台默默的运行着。</p><p>上面的命令用到了<code>ignore</code>模式，具体在<em>AppOpsManager.java</em>有4种模式定义：</p><pre class=" language-lang-java"><code class="language-lang-java">// 允许执行相关权限public static final int MODE_ALLOWED = 0;// 表示当前应用没有此权限，如果尝试使用该权限，就会静态地进入失败状态，出现应用莫名其妙crash。public static final int MODE_IGNORED = 1;// 表示当前应用没有此权限，并且如果使用此权限会导致SecurityException  public static final int MODE_ERRORED = 2;// 表示默认值，应该使用其默认的安全检查。这个模式并不常用，它应该和appop权限一起使用，并且调用者必须显式地检查和使用它public static final int MODE_DEFAULT = 3;</code></pre><h2 id="AppOps工作流程"><a href="#AppOps工作流程" class="headerlink" title="AppOps工作流程"></a>AppOps工作流程</h2><p>Appops工作框架如下</p><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/appops.png?raw=true" alt="appops"></p><p>可以看到Appops的两个重要组成部分是<code>AppOpsManager</code>和<code>AppOpsService</code>,它们是典型的客户端和服务端设计，通过Binder跨进程调用。</p><p><code>AppOpsService</code>是做最终检查的系统服务，它的注册名字是appops，应用可以类似于</p><pre class=" language-lang-java"><code class="language-lang-java">mAppOps=(AppOpsManager)getContext().getSystemService(Context.APP_OPS_SERVICE);</code></pre><p>的方式来获取这个服务。</p><p><code>AppOpsManager</code>提供了接口，访问AppOpsService的核心方法。</p><p><code>AppOpsService</code>是在AMS构造函数中启动的：</p><pre class=" language-lang-java"><code class="language-lang-java">mAppOpsService = new AppOpsService(new File(systemDir, "appops.xml"), mHandler);mAppOpsService.startWatchingMode(AppOpsManager.OP_RUN_IN_BACKGROUND, null,                                 new IAppOpsCallback.Stub() {    @Override   public void opChanged(int op, int uid, String packageName) {      if (op == AppOpsManager.OP_RUN_IN_BACKGROUND && packageName != null) {            if (mAppOpsService.checkOperation(op, uid, packageName)           != AppOpsManager.MODE_ALLOWED) {                runInBackgroundDisabled(uid);            }        }    }});</code></pre><p>从启动来看，该服务创建了一个<code>appops.xml</code>，这个文件最终位于<code>/data/system/</code>目录下，用来存储各个app的权限设置和操作信息。</p><p>我们可以看一下这个文件，以高德导航为例：</p><pre class=" language-lang-txt"><code class="language-lang-txt"><pkg n="com.autonavi.amapauto"><uid n="10033" p="false"><op n="0" t="1544544021632" pu="0" /><op n="1" t="1544544021448" pu="0" /><op n="11" m="1" /><op n="23" r="1544544022096" /><op n="24" m="2" r="1544544006269" /><op n="51" t="1544547622239" pu="0" /><op n="59" t="1544544022123" pu="0" /><op n="60" t="1544544022123" pu="0" /><op n="63" t="1544549408243" pu="0" /></uid></pkg></code></pre><p>然后设置悬浮窗权限</p><pre class=" language-lang-shell"><code class="language-lang-shell">adb shell appops set com.autonavi.amapauto SYSTEM_ALERT_WINDOW allow</code></pre><p>再次查看高德导航的权限</p><pre class=" language-lang-txt"><code class="language-lang-txt"><pkg n="com.autonavi.amapauto"><uid n="10033" p="false"><op n="0" t="1544544021528" pu="0" /><op n="1" t="1544544021371" pu="0" /><op n="11" m="1" /><op n="23" r="1544544022000" /><op n="24" m="0" r="1544544006269" />  <----------发生了变化<op n="51" t="1544544022020" pu="0" /><op n="59" t="1544544022016" pu="0" /><op n="60" t="1544544022016" pu="0" /><op n="63" t="1544544362713" pu="0" /></uid></pkg></code></pre><p>从上面的定义来看，<code>m=&quot;0&quot;</code>指的是<code>mode=MODE_ALLOWED=0</code>。</p><p>n=”24”指的是</p><pre class=" language-lang-java"><code class="language-lang-java">public static final int OP_SYSTEM_ALERT_WINDOW = 24;</code></pre><p>就是定义的悬浮窗权限了。</p><h2 id="Api使用"><a href="#Api使用" class="headerlink" title="Api使用"></a>Api使用</h2><p>AppOpsManager提供标准的API供APP调用，但google有明确说明，大部分只针对系统应用。但是想使用的话，可以尝试把Android源码里AppOpsManager.java打包一下，把jar包导入自己的工程，就可以使用了。</p><p><strong>int checkOp(Stringop, int uid,StringpackageName)</strong></p><p>Op对应一个权限操作，该接口来检测应用是否具有该项操作权限。</p><p><strong>int noteOp(Stringop, int uid,StringpackageName)</strong></p><p>和checkOp基本相同，但是在检验后会做记录。</p><p><strong>int checkOpNoThrow(Stringop, int uid,StringpackageName)</strong></p><p>和checkOp类似，但是权限错误，不会抛出SecurityException，而是返回AppOpsManager.MODE_ERRORED。</p><p><strong>int noteOpNoThrow(Stringop, int uid,StringpackageName)</strong></p><p>类似noteOp，但不会抛出SecurityException。</p><p><strong>void setMode( int code, int uid, String packageName, int mode)</strong></p><p>code代表具体的操作权限，mode代表要更改成的类型（允许/禁止/提示）</p><p>比较关键的就是这个setMode方法，比如通过代码设置悬浮窗权限的话，就需要这样：</p><pre class=" language-lang-java"><code class="language-lang-java">mAppOps = (AppOpsManager) mContext.getSystemService(Context.APP_OPS_SERVICE);mAppOps.setMode(AppOpsManager.OP_SYSTEM_ALERT_WINDOW, getAppUid(packageGaode), packageGaode, AppOpsManager.MODE_ALLOWED);private int getAppUid(String packageName) {  int uid = 0;  try {    PackageManager pm = mContext.getPackageManager();    ApplicationInfo ai = pm.getApplicationInfo(packageName, 0);    uid = ai.uid;  } catch (NameNotFoundException e) {    e.printStackTrace();  }  return uid;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Framework </tag>
            
            <tag> permission </tag>
            
            <tag> AppOps </tag>
            
            <tag> PackageManagerService </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Android][Framework] PackageManagerService之AndroidManifest的解析</title>
      <link href="/2019/11/05/%5BAndroid%5D%5BFramework%5DHowDoesAndroidManifestWork/"/>
      <url>/2019/11/05/%5BAndroid%5D%5BFramework%5DHowDoesAndroidManifestWork/</url>
      
        <content type="html"><![CDATA[<h2 id="前因"><a href="#前因" class="headerlink" title="前因"></a>前因</h2><p>最近遇到一个问题，涉及到一个三方应用在系统中的方向显示。三方应用设置了强制竖屏，我需要将其变成横屏。</p><p>应用设置屏幕方向有两种方式，一种是在Manifest文件里配置：</p><pre class=" language-lang-xml"><code class="language-lang-xml">android:screenOrientation="portrait"</code></pre><p>另一种是通过接口设置。</p><pre class=" language-lang-java"><code class="language-lang-java">setRequestedOrientation(int orientation)</code></pre><p>通过命令查看三方应用的AndroidManifest.xml文件：</p><pre class=" language-lang-shell"><code class="language-lang-shell">aapt dump xmltree xxxx.apk AndroidManifest.xml</code></pre><p>看到应用是在其AndroidManifest.xml文件中指定了应用的方向。</p><p>所以，要解决这个问题，就涉及到一个知识点：<code>Andriod系统是如何解析AndroidManifest文件的?</code>或者说，<code>AndroidManifest是怎么起作用的?</code></p><h2 id="PMS启动后的部分工作"><a href="#PMS启动后的部分工作" class="headerlink" title="PMS启动后的部分工作"></a>PMS启动后的部分工作</h2><p>PMS启动之后，首先会设置各种要扫描的目录，然后通过<code>scanDirLI</code>方法对一些目录比如<strong>system/app,data/app,vendor/app</strong>进行apk的扫描。</p><pre class=" language-lang-java"><code class="language-lang-java">private void scanDirLI(File dir, final int parseFlags, int scanFlags, long currentTime) {        final File[] files = dir.listFiles();        for (File file : files) {            final boolean isPackage = (isApkFile(file) || file.isDirectory())                    && !PackageInstallerService.isStageName(file.getName());            if (!isPackage) {                // Ignore entries which are not packages                continue;            }            try {        //扫描安装                scanPackageTracedLI(file, parseFlags | PackageParser.PARSE_MUST_BE_APK,                        scanFlags, currentTime, null);            } catch (PackageManagerException e) {                Slog.w(TAG, "Failed to parse " + file + ": " + e.getMessage());                //删除无效应用的用户数据                if ((parseFlags & PackageParser.PARSE_IS_SYSTEM) == 0 &&                        e.error == PackageManager.INSTALL_FAILED_INVALID_APK) {                    logCriticalInfo(Log.WARN, "Deleting invalid package at " + file);                    removeCodePathLI(file);                }            }        }    }</code></pre><p>其中调用了scanPackageTracedLI方法，其实就是跟踪package扫描：</p><pre class=" language-lang-java"><code class="language-lang-java">/**     *  Traces a package scan.     *  @see #scanPackageLI(File, int, int, long, UserHandle)     */private PackageParser.Package scanPackageTracedLI(File scanFile, final int parseFlags,                                                  int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {  Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "scanPackage");  try {    return scanPackageLI(scanFile, parseFlags, scanFlags, currentTime, user);  } finally {    Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);  }}</code></pre><p>接着进入</p><pre class=" language-lang-java"><code class="language-lang-java"> /**      *  Traces a package scan.      *  @see #scanPackageLI(File, int, int, long, UserHandle)      */ private PackageParser.Package scanPackageTracedLI(File scanFile, final int parseFlags,                                                   int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {   Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "scanPackage");   try {     return scanPackageLI(scanFile, parseFlags, scanFlags, currentTime, user);   } finally {     Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);   } }</code></pre><p>接着进入scanPackageLI。这个方法有两个实现：</p><pre class=" language-lang-java"><code class="language-lang-java">private PackageParser.Package scanPackageLI(File scanFile, int parseFlags, int scanFlags,            long currentTime, UserHandle user);private PackageParser.Package scanPackageLI(PackageParser.Package pkg, int parseFlags,            int scanFlags, long currentTime, UserHandle user);</code></pre><p>两者唯一的区别是签名列表中第一个参数，第一种实现为File类型的对象，而第二种实现为PackageParser.Package类型的对象。在具体解析某个文件时会先调用第一种实现解析apk文件，再调用第二种实现将解析后的信息保存至PMS：</p><pre class=" language-lang-java"><code class="language-lang-java">private PackageParser.Package scanPackageLI(File scanFile, int parseFlags, int scanFlags,            long currentTime, UserHandle user) throws PackageManagerException {    //创建PackageParser    PackageParser pp = new PackageParser();    final PackageParser.Package pkg;    try {        //调用PackageParser的parsePackage方法解析APK文件        pkg = pp.parsePackage(scanFile, parseFlags);    } catch (PackageParserException e) {}    //调用该方法的第二种实现，将解析后的信息保存至PMS    PackageParser.Package scannedPkg = scanPackageLI(pkg, parseFlags, scanFlags            | SCAN_UPDATE_SIGNATURE, currentTime, user);    return scannedPkg;}</code></pre><p>这里就调用到了PackageParser类的parsePackage方法进行对APK的解析。</p><h2 id="PackageParser类"><a href="#PackageParser类" class="headerlink" title="PackageParser类"></a>PackageParser类</h2><p>PackageParser类主要负责对应用AndroidManifest.xml文件的解析工作，所以第一个常亮定义就是：</p><pre class=" language-lang-java"><code class="language-lang-java">private static final String ANDROID_MANIFEST_FILENAME = "AndroidManifest.xml";</code></pre><p>解析AndroidManifest文件需要对不同xml节点分别解析，所以PackageParser部分的结构是如下形式：</p><pre class=" language-lang-java"><code class="language-lang-java">public class PackageParser {  public static class Component<II extends IntentInfo> {}  public final static class Activity extends Component<ActivityIntentInfo> {}  public final static class Instrumentation extends Component<IntentInfo> {}  public final static class Permission extends Component<IntentInfo> {}  public final static class PermissionGroup extends Component<IntentInfo> {}  public final static class Provider extends Component<ProviderIntentInfo> {}  public final static class Service extends Component<ServiceIntentInfo> {}}</code></pre><p>可以看到，PackageParser为Activity、Service、Provider、Permission等组件在其内部以内部类的方式创建了对应的类，按照解释器模式的定义，这些类其实都对应AndroidManifest.xml文件中的一个标签，其在对该配置文件解析时充分运用了解释器模式分离实现、解释执行的特性。</p><p>好了，前面代码流程PMS走到了parsePackage的地方，这个方法是PackageParser最关键的方法，它的实现如下：</p><pre class=" language-lang-java"><code class="language-lang-java">/**     * Parse the package at the given location. Automatically detects if the     * package is a monolithic style (single APK file) or cluster style     * (directory of APKs).     * <p>     * This performs sanity checking on cluster style packages, such as     * requiring identical package name and version codes, a single base APK,     * and unique split names.     * <p>     * Note that this <em>does not</em> perform signature verification; that     * must be done separately in {@link #collectCertificates(Package, int)}.     *     * @see #parsePackageLite(File, int)     */public Package parsePackage(File packageFile, int flags) throws PackageParserException {  if (packageFile.isDirectory()) {    return parseClusterPackage(packageFile, flags);  } else {    return parseMonolithicPackage(packageFile, flags);//该方法已弃用  }}</code></pre><p>下面是parseClusterPackage方法：</p><pre class=" language-lang-java"><code class="language-lang-java">   /**     * Parse all APKs contained in the given directory, treating them as a     * single package. This also performs sanity checking, such as requiring     * identical package name and version codes, a single base APK, and unique     * split names.     * <p>     * Note that this <em>does not</em> perform signature verification; that     * must be done separately in {@link #collectCertificates(Package, int)}.     */    private Package parseClusterPackage(File packageDir, int flags) throws PackageParserException {        final PackageLite lite = parseClusterPackageLite(packageDir, 0);                //...        final AssetManager assets = new AssetManager();        try {            // Load the base and all splits into the AssetManager            // so that resources can be overriden when parsing the manifests.            loadApkIntoAssetManager(assets, lite.baseCodePath, flags);                        //...            final File baseApk = new File(lite.baseCodePath);            final Package pkg = parseBaseApk(baseApk, assets, flags);                        //...            if (!ArrayUtils.isEmpty(lite.splitNames)) {                final int num = lite.splitNames.length;                pkg.splitNames = lite.splitNames;                pkg.splitCodePaths = lite.splitCodePaths;                pkg.splitRevisionCodes = lite.splitRevisionCodes;                pkg.splitFlags = new int[num];                pkg.splitPrivateFlags = new int[num];                for (int i = 0; i < num; i++) {                    parseSplitApk(pkg, i, assets, flags);                }            }            pkg.setCodePath(packageDir.getAbsolutePath());            pkg.setUse32bitAbi(lite.use32bitAbi);            return pkg;        } finally {            IoUtils.closeQuietly(assets);        }    }</code></pre><p>后面是很长的调用路线：</p><p><code>parsePackage-&gt;parseClusterPackage-&gt;parseBaseApk-&gt;parseBaseApkCommon-&gt;parseBaseApkChild-&gt;parseBaseApplication-&gt;parseSplitApk</code></p><p>其中最关键的一个解析方法是<strong>parseBaseApkCommon</strong>方法，这里就对每一个Tag分别调用对应的parse方法。</p><pre class=" language-lang-java"><code class="language-lang-java">   /**     * This is the common parsing routing for handling parent and child     * packages in a base APK. The difference between parent and child     * parsing is that some tags are not supported by child packages as     * well as some manifest attributes are ignored. The implementation     * assumes the calling code has already handled the manifest tag if needed     * (this applies to the parent only).     *     * @param pkg The package which to populate     * @param acceptedTags Which tags to handle, null to handle all     * @param res Resources against which to resolve values     * @param parser Parser of the manifest     * @param flags Flags about how to parse     * @param outError Human readable error if parsing fails     * @return The package if parsing succeeded or null.     *     * @throws XmlPullParserException     * @throws IOException     */    private Package parseBaseApkCommon(Package pkg, Set<String> acceptedTags, Resources res,            XmlResourceParser parser, int flags, String[] outError) throws XmlPullParserException,            IOException {        mParseInstrumentationArgs = null;        mParseActivityArgs = null;        mParseServiceArgs = null;        mParseProviderArgs = null;        int type;        boolean foundApp = false;        TypedArray sa = res.obtainAttributes(parser,                com.android.internal.R.styleable.AndroidManifest);        String str = sa.getNonConfigurationString(                com.android.internal.R.styleable.AndroidManifest_sharedUserId, 0);        if (str != null && str.length() > 0) {            String nameError = validateName(str, true, false);              //...            pkg.mSharedUserId = str.intern();            pkg.mSharedUserLabel = sa.getResourceId(                    com.android.internal.R.styleable.AndroidManifest_sharedUserLabel, 0);        }        pkg.installLocation = sa.getInteger(                com.android.internal.R.styleable.AndroidManifest_installLocation,                PARSE_DEFAULT_INSTALL_LOCATION);        pkg.applicationInfo.installLocation = pkg.installLocation;                //...        // Resource boolean are -1, so 1 means we don't know the value.        int supportsSmallScreens = 1;        int supportsNormalScreens = 1;        int supportsLargeScreens = 1;        int supportsXLargeScreens = 1;        int resizeable = 1;        int anyDensity = 1;        int outerDepth = parser.getDepth();        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT                && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {                continue;            }            String tagName = parser.getName();            if (acceptedTags != null && !acceptedTags.contains(tagName)) {                Slog.w(TAG, "Skipping unsupported element under <manifest>: "                        + tagName + " at " + mArchiveSourcePath + " "                        + parser.getPositionDescription());                XmlUtils.skipCurrentTag(parser);                continue;            }            if (tagName.equals(TAG_APPLICATION)) {                //...                if (!parseBaseApplication(pkg, res, parser, flags, outError)) {                    return null;                }            } else if (tagName.equals(TAG_OVERLAY)) {                //...                XmlUtils.skipCurrentTag(parser);            } else if (tagName.equals(TAG_KEY_SETS)) {                if (!parseKeySets(pkg, res, parser, outError)) {                    return null;                }            } else if (tagName.equals(TAG_PERMISSION_GROUP)) {                if (parsePermissionGroup(pkg, flags, res, parser, outError) == null) {                    return null;                }            } else if (tagName.equals(TAG_PERMISSION)) {                if (parsePermission(pkg, res, parser, outError) == null) {                    return null;                }            } else if (tagName.equals(TAG_PERMISSION_TREE)) {                if (parsePermissionTree(pkg, res, parser, outError) == null) {                    return null;                }            } else if (tagName.equals(TAG_USES_PERMISSION)) {                if (!parseUsesPermission(pkg, res, parser)) {                    return null;                }            } else if (tagName.equals(TAG_USES_PERMISSION_SDK_M)                    || tagName.equals(TAG_USES_PERMISSION_SDK_23)) {                if (!parseUsesPermission(pkg, res, parser)) {                    return null;                }            } else if (tagName.equals(TAG_USES_CONFIGURATION)) {                //...                XmlUtils.skipCurrentTag(parser);            } else if (tagName.equals(TAG_USES_FEATURE)) {                FeatureInfo fi = parseUsesFeature(res, parser);                pkg.reqFeatures = ArrayUtils.add(pkg.reqFeatures, fi);                                //...                XmlUtils.skipCurrentTag(parser);            } else if (tagName.equals(TAG_FEATURE_GROUP)) {                FeatureGroupInfo group = new FeatureGroupInfo();                ArrayList<FeatureInfo> features = null;                final int innerDepth = parser.getDepth();                while ((type = parser.next()) != XmlPullParser.END_DOCUMENT                        && (type != XmlPullParser.END_TAG || parser.getDepth() > innerDepth)) {                    final String innerTagName = parser.getName();                    if (innerTagName.equals("uses-feature")) {                        FeatureInfo featureInfo = parseUsesFeature(res, parser);                                                //...                    } else {                        Slog.w(TAG, "Unknown element under <feature-group>: " + innerTagName +                                " at " + mArchiveSourcePath + " " +                                parser.getPositionDescription());                    }                    XmlUtils.skipCurrentTag(parser);                }                                //...            } else if (tagName.equals(TAG_USES_SDK)) {                    //...                XmlUtils.skipCurrentTag(parser);            } else if (tagName.equals(TAG_SUPPORT_SCREENS)) {                    //...                XmlUtils.skipCurrentTag(parser);            } else if (tagName.equals(TAG_PROTECTED_BROADCAST)) {                    //...                XmlUtils.skipCurrentTag(parser);            } else if (tagName.equals(TAG_INSTRUMENTATION)) {                if (parseInstrumentation(pkg, res, parser, outError) == null) {                    return null;                }            } else if (tagName.equals(TAG_ORIGINAL_PACKAGE)) {                    //...                XmlUtils.skipCurrentTag(parser);            } else if (tagName.equals(TAG_ADOPT_PERMISSIONS)) {                    //...                XmlUtils.skipCurrentTag(parser);            } else if (tagName.equals(TAG_USES_GL_TEXTURE)) {                // Just skip this tag                XmlUtils.skipCurrentTag(parser);                continue;            } else if (tagName.equals(TAG_COMPATIBLE_SCREENS)) {                // Just skip this tag                XmlUtils.skipCurrentTag(parser);                continue;            } else if (tagName.equals(TAG_SUPPORTS_INPUT)) {//                XmlUtils.skipCurrentTag(parser);                continue;            } else if (tagName.equals(TAG_EAT_COMMENT)) {                // Just skip this tag                XmlUtils.skipCurrentTag(parser);                continue;            } else if (tagName.equals(TAG_PACKAGE)) {                if (!MULTI_PACKAGE_APK_ENABLED) {                    XmlUtils.skipCurrentTag(parser);                    continue;                }                if (!parseBaseApkChild(pkg, res, parser, flags, outError)) {                    // If parsing a child failed the error is already set                    return null;                }            } else if (tagName.equals(TAG_RESTRICT_UPDATE)) {                    //...                XmlUtils.skipCurrentTag(parser);            } else if (RIGID_PARSER) {                outError[0] = "Bad element under <manifest>: "                    + parser.getName();                mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;                return null;            } else {                Slog.w(TAG, "Unknown element under <manifest>: " + parser.getName()                        + " at " + mArchiveSourcePath + " "                        + parser.getPositionDescription());                XmlUtils.skipCurrentTag(parser);                continue;            }        }        //...        return pkg;    }</code></pre><p>可以看到，parsePackage方法的主要作用其实就是对AndroidManifest.xml配置文件中manifest下的每个子节点进行解析，这里主要来看看parseActivity方法是如何对activity节点进行解析的：</p><pre class=" language-lang-java"><code class="language-lang-java">   private Activity parseActivity(Package owner, Resources res,            XmlResourceParser parser, int flags, String[] outError,            boolean receiver, boolean hardwareAccelerated)            throws XmlPullParserException, IOException {        TypedArray sa = res.obtainAttributes(parser, R.styleable.AndroidManifestActivity);        if (mParseActivityArgs == null) {            mParseActivityArgs = new ParseComponentArgs(owner, outError,                    R.styleable.AndroidManifestActivity_name,                    R.styleable.AndroidManifestActivity_label,                    R.styleable.AndroidManifestActivity_icon,                    R.styleable.AndroidManifestActivity_roundIcon,                    R.styleable.AndroidManifestActivity_logo,                    R.styleable.AndroidManifestActivity_banner,                    mSeparateProcesses,                    R.styleable.AndroidManifestActivity_process,                    R.styleable.AndroidManifestActivity_description,                    R.styleable.AndroidManifestActivity_enabled);        }        mParseActivityArgs.tag = receiver ? "<receiver>" : "<activity>";        mParseActivityArgs.sa = sa;        mParseActivityArgs.flags = flags;        Activity a = new Activity(mParseActivityArgs, new ActivityInfo());        if (outError[0] != null) {            sa.recycle();            return null;        }        boolean setExported = sa.hasValue(R.styleable.AndroidManifestActivity_exported);        if (setExported) {            a.info.exported = sa.getBoolean(R.styleable.AndroidManifestActivity_exported, false);        }        a.info.theme = sa.getResourceId(R.styleable.AndroidManifestActivity_theme, 0);        a.info.uiOptions = sa.getInt(R.styleable.AndroidManifestActivity_uiOptions,                a.info.applicationInfo.uiOptions);        String parentName = sa.getNonConfigurationString(                R.styleable.AndroidManifestActivity_parentActivityName,                Configuration.NATIVE_CONFIG_VERSION);        if (parentName != null) {            String parentClassName = buildClassName(a.info.packageName, parentName, outError);            if (outError[0] == null) {                a.info.parentActivityName = parentClassName;            } else {                Log.e(TAG, "Activity " + a.info.name + " specified invalid parentActivityName " +                        parentName);                outError[0] = null;            }        }        String str;        str = sa.getNonConfigurationString(R.styleable.AndroidManifestActivity_permission, 0);        if (str == null) {            a.info.permission = owner.applicationInfo.permission;        } else {            a.info.permission = str.length() > 0 ? str.toString().intern() : null;        }        str = sa.getNonConfigurationString(                R.styleable.AndroidManifestActivity_taskAffinity,                Configuration.NATIVE_CONFIG_VERSION);        a.info.taskAffinity = buildTaskAffinityName(owner.applicationInfo.packageName,                owner.applicationInfo.taskAffinity, str, outError);        a.info.flags = 0;        if (sa.getBoolean(                R.styleable.AndroidManifestActivity_multiprocess, false)) {            a.info.flags |= ActivityInfo.FLAG_MULTIPROCESS;        }        if (sa.getBoolean(R.styleable.AndroidManifestActivity_finishOnTaskLaunch, false)) {            a.info.flags |= ActivityInfo.FLAG_FINISH_ON_TASK_LAUNCH;        }        if (sa.getBoolean(R.styleable.AndroidManifestActivity_clearTaskOnLaunch, false)) {            a.info.flags |= ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH;        }        if (sa.getBoolean(R.styleable.AndroidManifestActivity_noHistory, false)) {            a.info.flags |= ActivityInfo.FLAG_NO_HISTORY;        }        if (sa.getBoolean(R.styleable.AndroidManifestActivity_alwaysRetainTaskState, false)) {            a.info.flags |= ActivityInfo.FLAG_ALWAYS_RETAIN_TASK_STATE;        }        if (sa.getBoolean(R.styleable.AndroidManifestActivity_stateNotNeeded, false)) {            a.info.flags |= ActivityInfo.FLAG_STATE_NOT_NEEDED;        }        if (sa.getBoolean(R.styleable.AndroidManifestActivity_excludeFromRecents, false)) {            a.info.flags |= ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;        }        if (sa.getBoolean(R.styleable.AndroidManifestActivity_allowTaskReparenting,                (owner.applicationInfo.flags&ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING) != 0)) {            a.info.flags |= ActivityInfo.FLAG_ALLOW_TASK_REPARENTING;        }        if (sa.getBoolean(R.styleable.AndroidManifestActivity_finishOnCloseSystemDialogs, false)) {            a.info.flags |= ActivityInfo.FLAG_FINISH_ON_CLOSE_SYSTEM_DIALOGS;        }        if (sa.getBoolean(R.styleable.AndroidManifestActivity_showOnLockScreen, false)                || sa.getBoolean(R.styleable.AndroidManifestActivity_showForAllUsers, false)) {            a.info.flags |= ActivityInfo.FLAG_SHOW_FOR_ALL_USERS;        }        if (sa.getBoolean(R.styleable.AndroidManifestActivity_immersive, false)) {            a.info.flags |= ActivityInfo.FLAG_IMMERSIVE;        }        if (sa.getBoolean(R.styleable.AndroidManifestActivity_systemUserOnly, false)) {            a.info.flags |= ActivityInfo.FLAG_SYSTEM_USER_ONLY;        }        if (!receiver) {            if (sa.getBoolean(R.styleable.AndroidManifestActivity_hardwareAccelerated,                    hardwareAccelerated)) {                a.info.flags |= ActivityInfo.FLAG_HARDWARE_ACCELERATED;            }            a.info.launchMode = sa.getInt(                    R.styleable.AndroidManifestActivity_launchMode, ActivityInfo.LAUNCH_MULTIPLE);            a.info.documentLaunchMode = sa.getInt(                    R.styleable.AndroidManifestActivity_documentLaunchMode,                    ActivityInfo.DOCUMENT_LAUNCH_NONE);            a.info.maxRecents = sa.getInt(                    R.styleable.AndroidManifestActivity_maxRecents,                    ActivityManager.getDefaultAppRecentsLimitStatic());            a.info.configChanges = sa.getInt(R.styleable.AndroidManifestActivity_configChanges, 0);            a.info.softInputMode = sa.getInt(                    R.styleable.AndroidManifestActivity_windowSoftInputMode, 0);            a.info.persistableMode = sa.getInteger(                    R.styleable.AndroidManifestActivity_persistableMode,                    ActivityInfo.PERSIST_ROOT_ONLY);            if (sa.getBoolean(R.styleable.AndroidManifestActivity_allowEmbedded, false)) {                a.info.flags |= ActivityInfo.FLAG_ALLOW_EMBEDDED;            }            if (sa.getBoolean(R.styleable.AndroidManifestActivity_autoRemoveFromRecents, false)) {                a.info.flags |= ActivityInfo.FLAG_AUTO_REMOVE_FROM_RECENTS;            }            if (sa.getBoolean(R.styleable.AndroidManifestActivity_relinquishTaskIdentity, false)) {                a.info.flags |= ActivityInfo.FLAG_RELINQUISH_TASK_IDENTITY;            }            if (sa.getBoolean(R.styleable.AndroidManifestActivity_resumeWhilePausing, false)) {                a.info.flags |= ActivityInfo.FLAG_RESUME_WHILE_PAUSING;            }            a.info.screenOrientation = sa.getInt(                    R.styleable.AndroidManifestActivity_screenOrientation,                    SCREEN_ORIENTATION_UNSPECIFIED);            a.info.resizeMode = RESIZE_MODE_UNRESIZEABLE;            final boolean appDefault = (owner.applicationInfo.privateFlags                    & PRIVATE_FLAG_RESIZEABLE_ACTIVITIES) != 0;            // This flag is used to workaround the issue with ignored resizeableActivity param when            // either targetSdkVersion is not set at all or <uses-sdk> tag is below <application>            // tag in AndroidManifest. If this param was explicitly set to 'false' we need to set            // corresponding resizeMode regardless of targetSdkVersion value at this point in time.            final boolean resizeableSetExplicitly                    = sa.hasValue(R.styleable.AndroidManifestActivity_resizeableActivity);            final boolean resizeable = sa.getBoolean(                    R.styleable.AndroidManifestActivity_resizeableActivity, appDefault);            if (resizeable) {                if (sa.getBoolean(R.styleable.AndroidManifestActivity_supportsPictureInPicture,                        false)) {                    a.info.resizeMode = RESIZE_MODE_RESIZEABLE_AND_PIPABLE;                } else {                    a.info.resizeMode = RESIZE_MODE_RESIZEABLE;                }            } else if (owner.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.N                    || resizeableSetExplicitly) {                a.info.resizeMode = RESIZE_MODE_UNRESIZEABLE;            } else if (!a.info.isFixedOrientation() && (a.info.flags & FLAG_IMMERSIVE) == 0) {                a.info.resizeMode = RESIZE_MODE_FORCE_RESIZEABLE;            }            if (sa.getBoolean(R.styleable.AndroidManifestActivity_alwaysFocusable, false)) {                a.info.flags |= FLAG_ALWAYS_FOCUSABLE;            }            a.info.lockTaskLaunchMode =                    sa.getInt(R.styleable.AndroidManifestActivity_lockTaskMode, 0);            a.info.encryptionAware = a.info.directBootAware = sa.getBoolean(                    R.styleable.AndroidManifestActivity_directBootAware,                    false);            a.info.requestedVrComponent =                sa.getString(R.styleable.AndroidManifestActivity_enableVrMode);        } else {            a.info.launchMode = ActivityInfo.LAUNCH_MULTIPLE;            a.info.configChanges = 0;            if (sa.getBoolean(R.styleable.AndroidManifestActivity_singleUser, false)) {                a.info.flags |= ActivityInfo.FLAG_SINGLE_USER;                if (a.info.exported && (flags & PARSE_IS_PRIVILEGED) == 0) {                    Slog.w(TAG, "Activity exported request ignored due to singleUser: "                            + a.className + " at " + mArchiveSourcePath + " "                            + parser.getPositionDescription());                    a.info.exported = false;                    setExported = true;                }            }            a.info.encryptionAware = a.info.directBootAware = sa.getBoolean(                    R.styleable.AndroidManifestActivity_directBootAware,                    false);        }        if (a.info.directBootAware) {            owner.applicationInfo.privateFlags |=                    ApplicationInfo.PRIVATE_FLAG_PARTIALLY_DIRECT_BOOT_AWARE;        }        sa.recycle();        if (receiver && (owner.applicationInfo.privateFlags                &ApplicationInfo.PRIVATE_FLAG_CANT_SAVE_STATE) != 0) {            // A heavy-weight application can not have receives in its main process            // We can do direct compare because we intern all strings.            if (a.info.processName == owner.packageName) {                outError[0] = "Heavy-weight applications can not have receivers in main process";            }        }        if (outError[0] != null) {            return null;        }        int outerDepth = parser.getDepth();        int type;        while ((type=parser.next()) != XmlPullParser.END_DOCUMENT               && (type != XmlPullParser.END_TAG                       || parser.getDepth() > outerDepth)) {            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {                continue;            }            if (parser.getName().equals("intent-filter")) {                ActivityIntentInfo intent = new ActivityIntentInfo(a);                if (!parseIntent(res, parser, true, true, intent, outError)) {                    return null;                }                if (intent.countActions() == 0) {                    Slog.w(TAG, "No actions in intent filter at "                            + mArchiveSourcePath + " "                            + parser.getPositionDescription());                } else {                    a.intents.add(intent);                }            } else if (!receiver && parser.getName().equals("preferred")) {                ActivityIntentInfo intent = new ActivityIntentInfo(a);                if (!parseIntent(res, parser, false, false, intent, outError)) {                    return null;                }                if (intent.countActions() == 0) {                    Slog.w(TAG, "No actions in preferred at "                            + mArchiveSourcePath + " "                            + parser.getPositionDescription());                } else {                    if (owner.preferredActivityFilters == null) {                        owner.preferredActivityFilters = new ArrayList<ActivityIntentInfo>();                    }                    owner.preferredActivityFilters.add(intent);                }            } else if (parser.getName().equals("meta-data")) {                if ((a.metaData = parseMetaData(res, parser, a.metaData,                        outError)) == null) {                    return null;                }            } else if (!receiver && parser.getName().equals("layout")) {                parseLayout(res, parser, a);            } else {                if (!RIGID_PARSER) {                    Slog.w(TAG, "Problem in package " + mArchiveSourcePath + ":");                    if (receiver) {                        Slog.w(TAG, "Unknown element under <receiver>: " + parser.getName()                                + " at " + mArchiveSourcePath + " "                                + parser.getPositionDescription());                    } else {                        Slog.w(TAG, "Unknown element under <activity>: " + parser.getName()                                + " at " + mArchiveSourcePath + " "                                + parser.getPositionDescription());                    }                    XmlUtils.skipCurrentTag(parser);                    continue;                } else {                    if (receiver) {                        outError[0] = "Bad element under <receiver>: " + parser.getName();                    } else {                        outError[0] = "Bad element under <activity>: " + parser.getName();                    }                    return null;                }            }        }        if (!setExported) {            a.info.exported = a.intents.size() > 0;        }        return a;    }</code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>综上可以了解到，Android应用的AndroidManifest.xml文件是在PMS启动时，扫描Apk的过程中通过PackageParser对Apk进行解析处理。</p><p>最后，回到开始的问题，我们需要处理的是对应应用的方向，所以在解析Activity的时候，解析到<code>a.info.screenOrientation</code>的时候，根据应用的packageName进行对screenOrientation赋值即可。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Framework </tag>
            
            <tag> PackageManagerService </tag>
            
            <tag> PackageParser </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Android][Security] Android 逆向之安全防护基本策略</title>
      <link href="/2019/10/15/%5BAndroid%5D%5BSecurity%5DDefence-policy/"/>
      <url>/2019/10/15/%5BAndroid%5D%5BSecurity%5DDefence-policy/</url>
      
        <content type="html"><![CDATA[<h2 id="对抗反编译"><a href="#对抗反编译" class="headerlink" title="对抗反编译"></a>对抗反编译</h2><h3 id="混淆"><a href="#混淆" class="headerlink" title="混淆"></a>混淆</h3><p>使用混淆主要可以减小包的大小。混淆对于安全保护来说，只是增加了阅读难度而已。混淆不会把关键代码混淆掉，比如MainActivity，Application等，可以通过分析smali和阅读jar包定位代码。</p><p>资源混淆也是换汤不换药，针对加载资源代码getString(2131230929)进行进制转换，变成16进制，从public.xml里面查找对应的资源，就能定位到资源内容。</p><h3 id="签名保护"><a href="#签名保护" class="headerlink" title="签名保护"></a>签名保护</h3><p>这个是防止二次打包验证，但是，对于java代码的签名保护，可以很容易地进行修改smali代码绕过验证。</p><h3 id="手动注册native方法"><a href="#手动注册native方法" class="headerlink" title="手动注册native方法"></a>手动注册native方法</h3><p>安全性也不是很高，只是一种会增加破解成本的方式。一般Native方法根据命名规则生成头文件然后写cpp代码，这种方式属于静态注册。手动动态注册是复写JNI_OnLoad方法，在该函数中手动注册方法名和对应的方法签名，方法名可以自定义，这样避免了静态注册的命名规则，让破解者难以根据规律找到要破解的方法。不过破解者可以分析JNI_OnLoad函数的汇编代码找到register函数找到注册的native方法。</p><h3 id="反调试检测"><a href="#反调试检测" class="headerlink" title="反调试检测"></a>反调试检测</h3><p>IDA进行so动态调试是基于进程的注入技术，然后使用linux中ptrace机制，进行调试目标进程的附加操作。</p><p>ptrace机制有一个特点：如果一个进程被调试了，在它进程status文件中有一个字段TracerPid会记录调试者的进程id值</p><p>cat /proc/pidxx/status 可以看到TracerPid字段</p><p>方法是检测该TracerPid值，大于0就退出。但破解者会通过IDA工具给JNI_OnLoad下断点，检测轮询代码，使用nop指令跳过检测指令。</p><h2 id="对抗Xposed"><a href="#对抗Xposed" class="headerlink" title="对抗Xposed"></a>对抗Xposed</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="Zygote"><a href="#Zygote" class="headerlink" title="Zygote"></a>Zygote</h4><p>在Android系统中App进程都是由Zygote进程“孵化”出来的。Zygote进程在启动时会创建一个虚拟机实例，每当它“孵化”一个新的应用程序进程时，都会将这个Dalvik虚拟机实例复制到新的App进程里面去，从而使每个App进程都有一个独立的Dalvik虚拟机实例。</p><p>Zygote进程在启动的过程中，除了会创建一个虚拟机实例之外还会将<code>Java Rumtime</code>加载到进程中并注册一些Android核心类的JNI（Java Native Interface，Java本地接口）方法。一个App进程被Zygote进程孵化出来的时候，不仅会获得Zygote进程中的虚拟机实例拷贝，还会与Zygote进程一起共享<code>Java Rumtime</code>，也就是可以将<code>XposedBridge.jar</code>这个Jar包加载到每一个Android App进程中去。安装<code>Xposed Installer</code>之后，系统<code>app_process</code>将被替换，然后利用Java的<code>Reflection</code>机制覆写内置方法，实现功能劫持。下面我们来看一下细节。</p><h4 id="Hook和Replace"><a href="#Hook和Replace" class="headerlink" title="Hook和Replace"></a>Hook和Replace</h4><p><code>Xposed Installer</code>框架中真正起作用的是对方法的Hook和Replace。在Android系统启动的时候，Zygote进程加载<code>XposedBridge.jar</code>，将所有需要替换的Method通过<code>JNI</code>方法<code>hookMethodNative</code>指向Native方法<code>xposedCallHandler</code>，这个方法再通过调用<code>handleHookedMethod</code>这个Java方法来调用被劫持的方法转入Hook逻辑。</p><p>上面提到的<code>hookMethodNative</code>是<code>XposedBridge.jar</code>中的私有的本地方法，它将一个方法对象作为传入参数并修改Dalvik虚拟机中对于该方法的定义，把该方法的类型改变为Native并将其实现指向另外一个B方法。</p><p>换言之，当调用那个被Hook的A方法时，其实调用的是B方法，调用者是不知道的。在hookMethodNative的实现中，会调用<code>XposedBridge.jar</code>中的<code>handleHookedMethod</code>这个方法来传递参数。<code>handleHookedMethod</code>这个方法类似于一个统一调度的Dispatch例程，其对应的底层的C++函数是<code>xposedCallHandler</code>。而<code>handleHookedMethod</code>实现里面会根据一个全局结构<code>hookedMethodCallbacks</code>来选择相应的Hook函数并调用他们的<code>before</code>和<code>after</code>函数，当多模块同时Hook一个方法的时候<code>Xposed</code>会自动根据<code>Module</code>的优先级来排序。</p><p>调用顺序如下：A.before -&gt; B.before -&gt; original method -&gt; B.after -&gt; A.after。</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/73b15237.png" alt="img"></p><h3 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h3><p>在做Android App的安全防御中检测点众多，<code>Xposed Installer</code>检测是必不可少的一环。对于Xposed框架的防御总体上分为两层：Java层和Native层。</p><h4 id="Java层检测"><a href="#Java层检测" class="headerlink" title="Java层检测"></a>Java层检测</h4><p>需要说明的是，Java层的检测基本只能检测出基础的<code>Xposed Installer</code>框架，而不能防护其对App内方法的Hook，如果框架中带有反检测则Java层检测大多不起作用。</p><p>下面列出Java层的检测点，仅供参考。</p><p><strong>① 通过PackageManager查看安装列表</strong></p><p>最简单的检测，我们调用Android提供的<code>PackageManager</code>的API来遍历系统中App的安装情况来辨别是否有安装<code>Xposed Installer</code>相关的软件包。</p><pre><code>PackageManager packageManager = context.getPackageManager();List applicationInfoList = packageManager.getInstalledApplications(PackageManager.GET_META_DATA);for (ApplicationInfo applicationInfo: applicationInfoList) {    if (applicationInfo.packageName.equals(&quot;de.robv.android.xposed.installer&quot;)) {        // is Xposed TODO... }    }</code></pre><p>通常情况下使用<code>Xposed Installer</code>框架都会屏蔽对其的检测，即Hook掉<code>PackageManager的getInstalledApplications</code>方法的返回值，以便过滤掉<code>de.robv.android.xposed.installer</code>来躲避这种检测。</p><p><strong>② 自造异常读取栈</strong></p><p><code>Xposed Installer</code>框架对每个由Zygote孵化的App进程都会介入，因此在程序方法异常栈中就会出现<code>Xposed</code>相关的“身影”，我们可以通过自造异常<code>Catch</code>来读取异常堆栈的形式，用以检查其中是否存在<code>Xposed</code>的调用方法。</p><pre><code>try {    throw new Exception(&quot;blah&quot;);} catch(Exception e) {    for (StackTraceElement stackTraceElement: e.getStackTrace()) {        // stackTraceElement.getClassName() stackTraceElement.getMethodName() 是否存 在Xposed    }}E/GEnvironment: no such table: preference (code 1): while compiling: SELECT keyguard_show_livewallpaper FROM preference...at com.meituan.test.extpackage.ExtPackageManager.checkUpdate(ExtPackageManager.java:127)at com.meituan.test.MiFGService$1.run(MiFGService.java:41)at android.os.Looper.loop(Looper.java:136)at android.app.ActivityThread.main(ActivityThread.java:5072)at java.lang.reflect.Method.invokeNative(Native Method)at java.lang.reflect.Method.invoke(Method.java:515)...at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:793)at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:609)at de.robv.android.xposed.XposedBridge.main(XposedBridge.java:132) //发现Xposed模块at dalvik.system.NativeStart.main(Native Method)</code></pre><p><strong>③ 检查关键Java方法被变为Native JNI方法</strong></p><p>当一个Android App中的<code>Java</code>方法被莫名其妙地变成了<code>Native JNI</code>方法，则非常有可能被<code>Xposed Hook</code>了。由此可得，检查关键方法是不是变成<code>Native JNI</code>方法，也可以检测是否被Hook。</p><p>通过反射调用<code>Modifier.isNative(method.getModifiers())</code>方法可以校验方法是不是<code>Native JNI</code>方法，Xposed同样可以篡改<code>isNative</code>这个方法的返回值。</p><p><strong>④ 反射读取XposedHelper类字段</strong></p><p>通过反射遍历<code>XposedHelper</code>类中的<code>fieldCache</code>、<code>methodCache</code>、<code>constructorCache</code>变量，读取HashMap缓存字段，如字段项的key中包含App中唯一或敏感方法等，即可认为有<code>Xposed</code>注入。</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/aad203b3.png" alt="img"></p><pre><code>boolean methodCache = CheckHook(clsXposedHelper, &quot;methodCache&quot;, keyWord);private static boolean CheckHook(Object cls, String filedName, String str) {    boolean result = false;    String interName;    Set keySet;    try {        Field filed = cls.getClass().getDeclaredField(filedName);        filed.setAccessible(true);        keySet = filed.get(cls)).keySet();        if (!keySet.isEmpty()) {            for (Object aKeySet: keySet) {                interName = aKeySet.toString().toLowerCase();                if (interName.contains(&quot;meituan&quot;) || interName.contains(&quot;dianping&quot;) ) {                    result = true;                    break;                    }                 }            }        ...    return result;}</code></pre><h4 id="Native层检测"><a href="#Native层检测" class="headerlink" title="Native层检测"></a>Native层检测</h4><p>由上文可知，无论在Java层做何种检测，Xposed都可以通过Hook相关的API并返回指定的结果来绕过检测，只要有方法就可以被Hook。如果仅在Java层检测就显得很徒劳，为了有效提搞检测准确率，就须做到Java和Native层同时检测。每个App在系统中都有对应的加载库列表，这些加载库列表在<code>/proc/</code>下对应的<code>pid/maps</code>文件中描述，在Native层读取<code>/proc/self/maps</code>文件不失为检测Xposed Installer的有效办法之一。由于<code>Xposed Installer</code>通常只能Hook Java层，因此在Native层使用C来解析<code>/proc/self/maps</code>文件，搜检App自身加载的库中是否存在<code>XposedBridge.jar</code>、相关的Dex、Jar和So库等文件。</p><pre><code>bool is_xposed(){   bool rel = false;   FILE *fp = NULL;   char* filepath = &quot;/proc/self/maps&quot;;   ...   string xp_name = &quot;XposedBridge.jar&quot;;   fp = fopen(filepath,&quot;r&quot;))    while (!feof(fp))                                    {       fgets(strLine,BUFFER_SIZE,fp);                           origin_str = strLine;       str = trim(origin_str);       if (contain(str,xp_name))       {           rel = true; //检测到Xposed模块           break;       }   }    ...}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 逆向 </tag>
            
            <tag> 安全 </tag>
            
            <tag> xposed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Android][Security] Android 逆向之 xposed</title>
      <link href="/2019/10/12/%5BAndroid%5D%5BSecurity%5DDecompile-xposed/"/>
      <url>/2019/10/12/%5BAndroid%5D%5BSecurity%5DDecompile-xposed/</url>
      
        <content type="html"><![CDATA[<h3 id="Xposed"><a href="#Xposed" class="headerlink" title="Xposed"></a>Xposed</h3><p>网上关于Xposed的介绍很多，但都是点到为止，比如：</p><blockquote><p> 在Android系统中，应用程序进程以及系统服务进程SystemServer都是由Zygote进程孵化出来的，而Zygote进程是由Init进程启动的，Zygote进程在启动时会创建一个Dalvik虚拟机实例，每当它孵化一个新的应用程序进程时，都会将这个Dalvik虚拟机实例复制到新的应用程序进程里面去，从而使得每一个应用程序进程都有一个独立的Dalvik虚拟机实例，这也是Xposed选择替换app_process的原因。</p><p>Zygote进程在启动的过程中，除了会创建一个Dalvik虚拟机实例之外，还会注册一些Android核心类的JNI方法到Dalvik虚拟机实例中去，以及将Java运行时库加载到进程中来。而一个应用程序进程被Zygote进程孵化出来的时候，不仅会获得Zygote进程中的Dalvik虚拟机实例拷贝，还会与Zygote一起共享Java运行时库，这也就是可以将XposedBridge这个jar包加载到每一个Android应用程序中的原因，</p></blockquote><p>我当然不会满足于这么一点浅薄的介绍，既然用这个框架了，那就得把这个框架搞清楚对不？</p><p>一句话原理：</p><p>Xposed框架的原理是通过替换/system/bin/app_process程序控制zygote进程，使得app_process在启动过程中会加载XposedBridge.jar这个jar包，从而完成对Zygote进程及其创建的Dalvik虚拟机的劫持。</p><p>为什么是app_process</p><p>Android系统是基于Linux内核的，而在Linux系统中，所有的进程都是init进程的子孙进程，也就是说，所有的进程都是直接或者间接地由init进程fork出来的。Zygote进程也不例外，它是在系统启动的过程，由init进程创建的。在系统启动脚本system/core/rootdir/init.rc文件中，我们可以看到启动Zygote进程的脚本命令：</p><pre class=" language-lang-shell"><code class="language-lang-shell">service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server    socket zygote stream 666    onrestart write /sys/android_power/request_state wake    onrestart write /sys/power/state on    onrestart restart media    onrestart restart netd</code></pre><p>系统启动之后就可以在/dev/socket目录下看到有一个名为zygote的文件，就是zygote占用的socket端口。</p><p>所以，zygote是由app_process启动的，替换app_process后，启动的就是Xposed之后的zygote了。</p><p>为什么XposedBridge可以生效</p><p>Xposed版zygote进程在启动时会创建一个Dalvik虚拟机实例，以及注册一些Android核心类的JNI方法到Dalvik虚拟机实例中去。同时Xposed版zygote把XposedBridge.jar添加到CLASSPATH环境变量，并将Java运行时库加载到进程中。一个应用程序进程被Zygote进程孵化出来的时候，不仅会获得Zygote进程中的Dalvik虚拟机实例拷贝，还会与Zygote一起共享Java运行时库，所以XposedBridge.jar可以被加载到每一个Android应用程序中。</p><p>zygote进程加载XposedBridge将所有需要替换的Method通过JNI方法hookMethodNative指向Native方法<br> xposedCallHandler，xposedCallHandler在转入handleHookedMethod这个Java方法执行用户规定的Hook Func。</p><p>Xposed版zygote在启动时还会获得一个JNIEnv实例，该实例描述的是zygote进程的主线程的JNI环境，Xposed版zygote进程通过JNIEnv实例的成员函数CallStaticVoidMethod()调用de.robv.android.xposed.XposedBridge的main函数作为java代码的入口点。</p><p>de.robv.android.xposed.XposedBridge.main函数做了以下几件事：</p><p>（1）    初始化xposed框架。</p><p>（2）    调用initForZygote()方法hook应用进程创建时调用的一些关键函数，比如通过挂钩LoadedApk的构造函数获得应用进程的相关信息并保存至XC_LoadPackage.LoadPackageParam的实例中，该实例在后续hook应用程序中的函数时可用于获取应用程序相关信息。通过挂钩handleBindApplication方法，可以在应用程序启动时调用所有IXposedHookLoadPackage类型的钩子（其实最终调用的是IXposedHookLoadPackage的handleLoadPackage方法）。该类型的钩子用于对应用程序进行挂钩，假如要hook应用程序中的函数，我们编写的xposed插件中的钩子类必须实现IXposedHookLoadPackag接口，重写它的handleLoadPackage方法并在方法体中调用xposed框架提供的挂钩函数（比如findAndHookMethod）hook想要挂钩的应用程序函数。</p><p>（3）    调用loadModules()加载所有的xposed插件，将这些插件中不同钩子类型的钩子分别保存起来。有三种类型的钩子，IXposedHookLoadPackage类型的钩子对应用程序挂钩，IXposedHookZygoteInit类型钩子对Zygote的初始化进行挂钩，IXposedHookInitPackageResources类型钩子对资源进行挂钩。</p><p>（4）    最后再调用原始的ZygoteInit.main函数，完成zygote的全部初始化工作。</p><p><a href="http://4hou.win/wordpress/?p=7516" target="_blank" rel="noopener">http://4hou.win/wordpress/?p=7516</a></p><p><a href="https://blog.csdn.net/u014385722/article/details/82013306" target="_blank" rel="noopener">https://blog.csdn.net/u014385722/article/details/82013306</a></p><h3 id="使用Java反射实现API-Hook"><a href="#使用Java反射实现API-Hook" class="headerlink" title="使用Java反射实现API Hook"></a>使用Java反射实现API Hook</h3><p>通过对 Android 平台的虚拟机注入与 Java 反射的方式，来改变 Android 虚拟机调用函数的方式（ClassLoader），从而达到 Java 函数重定向的目的，这里我们将此类操作称为 Java API Hook。</p><p>先从简单的开始，比如尝试Hook按钮的点击事件。</p><p>首先先看一下点击事件：</p><pre class=" language-lang-java"><code class="language-lang-java">    /**     * Interface definition for a callback to be invoked when a view is clicked.     */    public interface OnClickListener {        /**         * Called when a view has been clicked.         *         * @param v The view that was clicked.         */        void onClick(View v);    }</code></pre><p>我们对Button绑定点击事件：</p><pre class=" language-lang-java"><code class="language-lang-java">mBtnHijack = findViewById(R.id.btn_hijack);mBtnHijack.setOnClickListener(v -> {  Toast.makeText(MainActivity.this, "Click button", Toast.LENGTH_LONG).show();});</code></pre><p>所以下一步是看setOnClickListener方法是怎么保存OnClickListener接口的：</p><pre class=" language-lang-java"><code class="language-lang-java">public void setOnClickListener(@Nullable OnClickListener l) {  if (!isClickable()) {    setClickable(true);  }  getListenerInfo().mOnClickListener = l;}</code></pre><p>看到OnClickListener被保存到ListenerInfo的成员变量中：</p><pre class=" language-lang-java"><code class="language-lang-java">ListenerInfo getListenerInfo() {  if (mListenerInfo != null) {    return mListenerInfo;  }  mListenerInfo = new ListenerInfo();  return mListenerInfo;}static class ListenerInfo {    ...  public OnClickListener mOnClickListener;  protected OnLongClickListener mOnLongClickListener;  protected OnContextClickListener mOnContextClickListener;  ...}</code></pre><p>而ListenerInfo是View的一个内部类。</p><p>既然知道OnClickListener的保存位置，那么我们要Hook点击事件，就是创建一个自己的点击事件，然后替换掉原来的事件即可。</p><p>先创建一个实现自己功能的点击事件</p><pre class=" language-lang-java"><code class="language-lang-java">class HookedOnClickListener implements View.OnClickListener {  private View.OnClickListener origin; // 原始的点击事件  HookedOnClickListener(View.OnClickListener origin) {    this.origin = origin;  }  @Override  public void onClick(View v) {    Toast.makeText(MainActivity.this, "hook click", Toast.LENGTH_SHORT).show();    Log.i("WOW", "Before click, do what you want to to.");    if (origin != null) {      origin.onClick(v); // 执行原始的点击逻辑    }    Log.i("WOW", "After click, do what you want to to.");  }}</code></pre><p>然后就是使用反射，用我们的OnClickListener替换原来注册的点击回调：</p><pre class=" language-lang-java"><code class="language-lang-java">private void hookOnClickListener(View view) {  try {    // 得到 View 的 ListenerInfo 对象    Method getListenerInfo = View.class.getDeclaredMethod("getListenerInfo");    // 强制访问    getListenerInfo.setAccessible(true);    // 执行getListenerInfo拿到对象    Object listenerInfo = getListenerInfo.invoke(view);    // 得到 原始的 ListenerInfo 类    Class<?> listenerInfoClz = Class.forName("android.view.View$ListenerInfo");    // 从 ListenerInfo找到onClickListener属性    Field mOnClickListener = listenerInfoClz.getDeclaredField("mOnClickListener");    mOnClickListener.setAccessible(true);    // 用前面的listenerInfo对象获取原始的listener    View.OnClickListener originOnClickListener = (View.OnClickListener) mOnClickListener.get(listenerInfo);    // 用自定义的 OnClickListener 替换原始的 OnClickListener    View.OnClickListener hookedOnClickListener = new HookedOnClickListener(originOnClickListener);    mOnClickListener.set(listenerInfo, hookedOnClickListener);  } catch (Exception e) {    Log.w("hook clickListener failed!", e);  }}</code></pre><p>把这段代码放到按钮设置OnClickListener之后:</p><pre class=" language-lang-java"><code class="language-lang-java">mBtnHijack.setOnClickListener(v -> {    Toast.makeText(MainActivity.this, "Click button", Toast.LENGTH_LONG).show();});hookOnClickListener(mBtnHijack);</code></pre><p>这样就完成了对按钮点击事件的Hook。</p><p>但是这只能编码Hook自己的应用，这样做的意义是什么呢？</p><p>当应用内接入了众多的 SDK，SDK 内部会使用系统服务 NotificationManager 发送通知，这就导致通知难以管理和控制。现在我们就用 Hook 技术拦截部分通知，限制应用内的通知发送操作。</p><p>发送通知是由NotificationManager的notify方法实现，通过查看源码，定位到：</p><pre class=" language-lang-java"><code class="language-lang-java">public void notifyAsUser(String tag, int id, Notification notification, UserHandle user)    {        INotificationManager service = getService();        ...        try {            service.enqueueNotificationWithTag(pkg, mContext.getOpPackageName(), tag, id, copy, user.getIdentifier());        } catch (RemoteException e) {            throw e.rethrowFromSystemServer();        }    }private static INotificationManager sService;/** @hide */static public INotificationManager getService(){  if (sService != null) {    return sService;  }  IBinder b = ServiceManager.getService("notification");  sService = INotificationManager.Stub.asInterface(b);  return sService;}</code></pre><p>INotificationManager  是跨进程通信的 Binder 类，sService 是 NMS(NotificationManagerService) 在客户端的代理，发送通知要委托给 sService，由它传递给 NMS。我们发现 sService 是个静态成员变量，而且只会初始化一次。只要把 sService 替换成自定义的不就行了么，确实如此。</p><pre class=" language-lang-java"><code class="language-lang-java">private void hookNotificationManager(Context context) {  try {    NotificationManager notificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);    // 得到系统的 sService    Method getService = NotificationManager.class.getDeclaredMethod("getService");    getService.setAccessible(true);    final Object sService = getService.invoke(notificationManager);    Class iNotiMngClz = Class.forName("android.app.INotificationManager");    // 动态代理 INotificationManager    Object proxyNotiMng = Proxy.newProxyInstance(getClass().getClassLoader(), new Class[]{iNotiMngClz}, new InvocationHandler() {      @Override      public Object invoke(Object proxy, Method method, Object[] args) throws Throwable                     {        log.debug("invoke(). method:{}", method);        if (args != null && args.length > 0) {          for (Object arg : args) {            log.debug("type:{}, arg:{}", arg != null ? arg.getClass() : null, arg);          }        }        // 操作交由 sService 处理，不拦截通知        // return method.invoke(sService, args);        // 拦截通知，什么也不做        return null;        // 或者是根据通知的 Tag 和 ID 进行筛选      }    });    // 替换 sService    Field sServiceField = NotificationManager.class.getDeclaredField("sService");    sServiceField.setAccessible(true);    sServiceField.set(notificationManager, proxyNotiMng);  } catch (Exception e) {    log.warn("Hook NotificationManager failed!", e);  }}</code></pre><p>Hook 的时机还是尽量要早，我们在 attachBaseContext 里面操作。</p><pre class=" language-lang-java"><code class="language-lang-java">    @Override    protected void attachBaseContext(Context newBase) {        super.attachBaseContext(newBase);        hookNotificationManager(newBase);    }</code></pre><p>这样我们就完成了对通知的拦截，可见 Hook 技术真的是非常强大，好多插件化的原理都是建立在 Hook 之上的。</p><p><strong>总结一下：</strong></p><ol><li>Hook 的选择点：静态变量和单例，因为一旦创建对象，它们不容易变化，非常容易定位。</li><li>Hook 过程：<ul><li>寻找 Hook 点，原则是静态变量或者单例对象，尽量 Hook public 的对象和方法。</li><li>选择合适的代理方式，如果是接口可以用动态代理。</li><li>偷梁换柱——用代理对象替换原始对象。</li></ul></li><li>Android 的 API 版本比较多，方法和类可能不一样，所以要做好 API 的兼容工作。</li></ol><h3 id="Xposed-Hook微信运动"><a href="#Xposed-Hook微信运动" class="headerlink" title="Xposed Hook微信运动"></a>Xposed Hook微信运动</h3><p>首先在AndroidManifest.xml Application下添加xposed模块</p><pre class=" language-lang-xml"><code class="language-lang-xml"><!--xposed描述--><meta-data    android:name="xposeddescription"    android:value="这是一个Xposed例程" /><!--xposed最低版本53--><meta-data    android:name="xposedminversion"    android:value="53" /><!--这是一个xposed模块--><meta-data    android:name="xposedmodule"    android:value="true" /></code></pre><p>Gradle添加依赖</p><pre class=" language-lang-shell"><code class="language-lang-shell">compileOnly 'de.robv.android.xposed:api:82'compileOnly 'de.robv.android.xposed:api:82:sources'</code></pre><p>然后再assets目录添加一个<code>xposed_init</code>文件供Xposed框架访问，内容为包名：</p><pre class=" language-lang-text"><code class="language-lang-text">com.softard.xposedemo.HookTest</code></pre><p>然后创建我们的HookTest</p><pre class=" language-lang-java"><code class="language-lang-java">public class HookTest implements IXposedHookLoadPackage {// 实现Hook篡改程序    @SuppressLint("PrivateApi")    @Override    public void handleLoadPackage(final XC_LoadPackage.LoadPackageParam lpparam) throws Throwable {            if (lpparam.packageName.equals("com.tencent.mm")) { // 搞一搞微信            XposedBridge.log("hoooook wechat");            Class<?> clazz1 = Class.forName(                    "android.hardware.SystemSensorManager$SensorEventQueue", true, lpparam.classLoader);            XposedBridge.hookAllMethods(clazz1, "dispatchSensorEvent", new XC_MethodHook() {                @Override                protected void beforeHookedMethod(MethodHookParam param) throws Throwable {                    int times = XSharedPreferencesUtil.getPref().getInt("step", 500);                    XposedBridge.log("~~~~~~~Multi times: " + times);                    XposedBridge.log("Wechat2222 Sensor param " + ((float[]) param.args[1])[0]);                    ((float[]) param.args[1])[0] = ((float[]) param.args[1])[0] * times;                    XposedBridge.log("final Sensor param " + ((float[]) param.args[1])[0]);                    super.beforeHookedMethod(param);                }                @Override                protected void afterHookedMethod(MethodHookParam param) throws Throwable {                    super.afterHookedMethod(param);                }            });        }*/          }}</code></pre><p>To be continued</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 逆向 </tag>
            
            <tag> 安全 </tag>
            
            <tag> xposed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Android][Security] Android 逆向之 smali</title>
      <link href="/2019/09/12/%5BAndroid%5D%5BSecurity%5DDecompile-smali/"/>
      <url>/2019/09/12/%5BAndroid%5D%5BSecurity%5DDecompile-smali/</url>
      
        <content type="html"><![CDATA[<h2 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h2><h3 id="APK"><a href="#APK" class="headerlink" title="APK"></a>APK</h3><p>APK其实就是一个ZIP压缩包，将APK后缀改成ZIP后就可以解压出APK内部文件。</p><h3 id="Dalvik字节码"><a href="#Dalvik字节码" class="headerlink" title="Dalvik字节码"></a>Dalvik字节码</h3><p>Dalvik是google专门为Android操作系统设计的一个虚拟机，经过深度的优化。虽然Android上的程序是使用java来开发的，但是Dalvik和标准的java虚拟机JVM还是两回事。Dalvik VM是基于寄存器的，而JVM是基于栈的；Dalvik有专属的文件执行格式dex（dalvik executable），而JVM则执行的是java字节码。Dalvik VM比JVM速度更快，占用空间更少。</p><h2 id="如何逆向"><a href="#如何逆向" class="headerlink" title="如何逆向"></a>如何逆向</h2><h3 id="查看资源文件"><a href="#查看资源文件" class="headerlink" title="查看资源文件"></a>查看资源文件</h3><ol><li><p>把要解压的APK拷贝到APKs目录</p></li><li><p>使用</p><pre class=" language-lang-shell"><code class="language-lang-shell">apktool d APKs/xxx.apk -o dir</code></pre><p>将APK解压到当前目录，得到完整的资源文件。</p><blockquote><p>虽然通过解压的方式也可以得到资源文件目录，但是那样得到的xml文件并无法阅读。</p></blockquote></li><li><p>打包回APK</p><pre class=" language-lang-shell"><code class="language-lang-shell">apktool b APKs/xxx –o file.apk</code></pre><p>将文件恢复到apk</p></li><li><p>重新签名</p><pre class=" language-lang-shell"><code class="language-lang-shell">jarsigner -verbose -keystore demo.keystore -storepass demopass -signedjar signed.apk XimalayaNew.apk demoAlias</code></pre></li><li><p>解出来的文件结构</p><pre class=" language-lang-shell"><code class="language-lang-shell">AndroidManifest.xml kotlin              smali               unknownapktool.yml         lib                 smali_classes2assets              original            smali_classes3build               res                 smali_classes4</code></pre><p>这样解出来可以看到有4个smali文件夹，里面都是smali文件。关于smali是这次的主角，后面再详细说。</p></li></ol><h3 id="查看源码"><a href="#查看源码" class="headerlink" title="查看源码"></a>查看源码</h3><ol><li><p>若要查看源码，将xxx.apk命名为xxx.zip，使用unzip命令解压，得到dex文件，目录结构如下：</p><pre class=" language-lang-shell"><code class="language-lang-shell">AndroidManifest.xml classes2.dex        javax               publicsuffixes.gzMETA-INF            classes3.dex        kotlin              push_versionassets              classes4.dex        lib                 resclasses.dex         com                 miui_push_version   resources.arsc</code></pre><p>这里也有xml文件，可以试着打开看看，发现这些文件打开是乱码。</p></li><li><p>使用<code>dex2jar</code>工具逆向dex文件：</p><pre class=" language-lang-shell"><code class="language-lang-shell">% d2j-dex2jar.sh *.dexdex2jar classes.dex -> ./classes-dex2jar.jarDetail Error Information in File ./classes-error.zipPlease report this file to http://code.google.com/p/dex2jar/issues/entry if possible.dex2jar classes2.dex -> ./classes2-dex2jar.jardex2jar classes3.dex -> ./classes3-dex2jar.jardex2jar classes4.dex -> ./classes4-dex2jar.jar</code></pre><p>看到每个dex文件都生成了对应的jar文件。</p></li><li><p>用<code>JD-gui</code>工具打开这些<code>jar</code>文件，可以看到对应的源码。</p></li></ol><h3 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h3><p>代码可以通过<code>JD-GUI</code>查看，但是这个工具查代码并不方便，所以还是推荐把smali文件导入到编辑器中，在编辑器里查找要看的关键词，然后再回到<code>JD-GUI</code>查看源码。两者结合一起去看是效率最高的。</p><p><code>JD-GUI</code>看的代码有很多是混淆过的，但是一些系统回调方法是不能混淆的，比如<code>onCreate</code></p><ol><li>首先看这个类有没有静态方法和静态代码块，因为这类代码会在对象初始化前运行，可能在这里加载so文件，或者是加密校验等操作。</li><li>再看看这个类的构造方法。</li><li>最后看生命周期方法。</li></ol><h2 id="Smali"><a href="#Smali" class="headerlink" title="Smali"></a>Smali</h2><p>smali就是Dalvik VM内部执行的核心代码。它有自己的一套语法。</p><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><div class="table-container"><table><thead><tr><th>指令</th><th>功能</th></tr></thead><tbody><tr><td>.field private isFlag:z</td><td>定义变量</td></tr><tr><td>.method</td><td>方法</td></tr><tr><td>.parameter</td><td>方法参数</td></tr><tr><td>.prologue</td><td>方法开始</td></tr><tr><td>.line 12</td><td>此方法位于12行</td></tr><tr><td>invoke-super</td><td>调用父类方法</td></tr><tr><td>const/high16 v0,0x7fo3</td><td>把0x7fo3赋值给v0</td></tr><tr><td>invoke-direct</td><td>调用函数</td></tr><tr><td>return-void</td><td>函数返回void</td></tr><tr><td>.end method</td><td>函数结束</td></tr><tr><td>new-instance</td><td>创建实例</td></tr><tr><td>input-object</td><td>对象赋值</td></tr><tr><td>iget-object</td><td>调用对象</td></tr><tr><td>Invoke-static</td><td>调用静态函数</td></tr></tbody></table></div><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><div class="table-container"><table><thead><tr><th>符号</th><th>类型</th></tr></thead><tbody><tr><td>B</td><td>byte</td></tr><tr><td>C</td><td>char</td></tr><tr><td>D</td><td>double</td></tr><tr><td>F</td><td>float</td></tr><tr><td>I</td><td>int</td></tr><tr><td>J</td><td>long</td></tr><tr><td>S</td><td>short</td></tr><tr><td>V</td><td>void</td></tr><tr><td>Z</td><td>boolean</td></tr><tr><td>[XXX</td><td>Array</td></tr><tr><td>Lxxx/yyy</td><td>Object</td></tr></tbody></table></div><blockquote><p>数组：</p><p>在基本类型前加上前中括号“[”，例如int数组和float数组分别表示为：[I、[F</p><p>对象：</p><p>以L作为开头，格式是LpackageName/objectName<strong>;</strong></p><p>String对象在smali中为：Ljava/lang/String;</p><p>类里面的内部类：LpackageName/objectName$subObjectName;</p></blockquote><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数公式为：</p><p><code>Func-Name (Para-Type1Para-Type2Para-Type3...)Return-Type</code></p><p>参数之间没有间隔。</p><p>举例：</p><ul><li><p>foo ()V</p><p>void foo()</p></li><li><p>foo (III)Z</p><p>boolean foo(int, int, int)</p></li><li><p>foo (Z[I[ILjava/lang/String;J)Ljava/lang/String;</p><p>String foo(boolean, int[], int[], String, long)</p></li></ul><h3 id="文件分析"><a href="#文件分析" class="headerlink" title="文件分析"></a>文件分析</h3><pre class=" language-lang-smali"><code class="language-lang-smali">.class public Lcom/disney/WMW/WMWActivity; .super Lcom/disney/common/BaseActivity;.source "WMWActivity.java"# interfaces.implements Lcom/burstly/lib/ui/IBurstlyAdListener;# annotations.annotation system Ldalvik/annotation/MemberClasses;    value = {        Lcom/disney/WMW/WMWActivity$MessageHandler;,        Lcom/disney/WMW/WMWActivity$FinishActivityArgs;    }.end annotation# static fields.field private static final PREFS_INSTALLATION_ID:Ljava/lang/String; = "installationId"//...# instance fields.field private _activityPackageName:Ljava/lang/String;//...# direct methods.method static constructor <clinit>()V    .locals 3    .prologue    //...    return-void.end method.method public constructor <init>()V    .locals 3    .prologue    //...    return-void.end method.method static synthetic access$100(Lcom/disney/WMW/WMWActivity;)V    .locals 0    .parameter "x0"    .prologue    .line 37    invoke-direct {p0}, Lcom/disney/WMW/WMWActivity;->initIap()V    return-void.end method.method static synthetic access$200(Lcom/disney/WMW/WMWActivity;)Lcom/disney/common/WMWView;    .locals 1    .parameter "x0"    .prologue    .line 37    iget-object v0, p0, Lcom/disney/WMW/WMWActivity;->_view:Lcom/disney/common/WMWView;    return-object v0.end method//...#virtual methods.method public captureScreen()V    .locals 4    .prologue    //...    goto :goto_0.end method.method public didScreenCaptured()V    .locals 6    .prologue    //...    goto :goto_0.end method</code></pre><h4 id="smali寄存器"><a href="#smali寄存器" class="headerlink" title="smali寄存器"></a>smali寄存器</h4><p>Dalvik VM与JVM的最大的区别之一就是Dalvik VM是基于寄存器的。基于寄存器是什么意思呢？也就是说，在smali里的所有操作都必须经过寄存器来进行：</p><p>本地寄存器用v开头数字结尾的符号来表示，如v0、v1、v2、…</p><p>参数寄存器则使用p开头数字结尾的符号来表示，如p0、p1、p2、…</p><p>特别注意的是，p0不一定是函数中的第一个参数：</p><p>在非static函数中，p0代指“this”，p1表示函数的第一个参数，p2代表函数中的第二个参数…</p><p>在static函数中p0才对应第一个参数（因为Java的static方法中没有this方法）。</p><p>本地寄存器没有限制，理论上是可以任意使用的，下面是例子： </p><pre class=" language-lang-java"><code class="language-lang-java">const/4 v0, 0x0iput-boolean v0, p0, Lcom/disney/WMW/WMWActivity;->isRunning:Z</code></pre><p>在上面的两句中，使用了v0本地寄存器，并把值0x0存到v0中，然后第二句用iput-boolean这个指令把v0中的值存放到com.disney.WMW.WMWActivity.isRunning这个成员变量中。</p><p>即相当于：this.isRunning = false;（上面说过，在非static函数中p0代表的是“this”，在这里就是com.disney.WMW.WMWActivity实例）。</p><h4 id="smali中的继承、接口、包信息"><a href="#smali中的继承、接口、包信息" class="headerlink" title="smali中的继承、接口、包信息"></a>smali中的继承、接口、包信息</h4><pre class=" language-lang-smali"><code class="language-lang-smali">.class public Lcom/disney/WMW/WMWActivity; .super Lcom/disney/common/BaseActivity;.source "WMWActivity.java"# interfaces.implements Lcom/burstly/lib/ui/IBurstlyAdListener;# annotations.annotation system Ldalvik/annotation/MemberClasses;    value = {        Lcom/disney/WMW/WMWActivity$MessageHandler;,        Lcom/disney/WMW/WMWActivity$FinishActivityArgs;    }.end annotation</code></pre><p>1-3行定义的是基本信息：这是一个由WMWActivity.java编译得到的smali文件（第3行），它是com.disney.WMW这个package下的一个类（第1行），继承自com.disney.common.BaseActivity（第2行）。</p><p>5-6行定义的是接口信息：这个WMWActivity实现了一个com.burstly.lib.ui这个package下（一个广告SDK）的IBurstyAdListener接口。</p><p>8-14行定义的则是内部类：它有两个成员内部类——MessageHandler和FinishActivityArgs，内部类将在后面小节中会有提及。</p><p>所以对应的Java代码大概是这样：</p><pre class=" language-lang-java"><code class="language-lang-java">class WMWActivity extends BaseActivity implements IBurstlyAdListener{    //...    class MessageHandler {        //...    }    class FinishActivityArgs{        //...    }}</code></pre><h4 id="smali中的成员变量"><a href="#smali中的成员变量" class="headerlink" title="smali中的成员变量"></a>smali中的成员变量</h4><pre class=" language-lang-java"><code class="language-lang-java"># static fields.field private static final PREFS_INSTALLATION_ID:Ljava/lang/String; = "installationId"//...# instance fields.field private _activityPackageName:Ljava/lang/String;//...</code></pre><p>上面定义的static fields和instance fields均为成员变量，格式是：</p><p><code>.field public/private [static] [final] varName:&lt;类型&gt;</code></p><p>然而static fields和instance fields还是有区别的，当然区别很明显，那就是static fields是static的，而instance则不是。</p><p>根据这个区别来获取这些不同的成员变量时也有不同的指令。</p><p>获取的指令有：iget、sget、iget-boolean、sget-boolean、iget-object、sget-object等，</p><p>操作的指令有：iput、sput、iput-boolean、sput-boolean、iput-object、sput-object等。</p><p>没有“-object”后缀的表示操作的成员变量对象是基本数据类型，带“-object”表示操作的成员变量是对象类型，特别地，boolean类型则使用带“-boolean”的指令操作。</p><h5 id="获取static-fields的指令类似是："><a href="#获取static-fields的指令类似是：" class="headerlink" title="获取static fields的指令类似是："></a>获取static fields的指令类似是：</h5><pre class=" language-lang-java"><code class="language-lang-java">sget-object v0, Lcom/disney/WMW/WMWActivity;->PREFS_INSTALLATION_ID:Ljava/lang/String;</code></pre><p>sget-object就是用来获取变量值并保存到紧接着的参数的寄存器中，在这里，把上面出现的<code>PREFS_INSTALLATION_ID</code>这个String成员变量获取并放到v0这个寄存器中，<strong>注意：前面需要该变量所属的类的类型，后面需要加一个冒号和该成员变量的类型</strong>，中间是“-&gt;”表示所属关系。</p><h5 id="获取instance-fields"><a href="#获取instance-fields" class="headerlink" title="获取instance fields"></a>获取instance fields</h5><p>指令与static fields的基本一样，只是由于不是static变量，不能仅仅指出该变量所在类的类型，还需要该变量所在类的实例。看例子：</p><pre class=" language-lang-java"><code class="language-lang-java">iget-object v0, p0, Lcom/disney/WMW/WMWActivity;->_view:Lcom/disney/common/WMWView;</code></pre><p>可以看到iget-object指令比sget-object多了一个参数，就是该变量所在类的实例，在这里就是p0即“this”。</p><h5 id="获取array的还有aget和aget-object"><a href="#获取array的还有aget和aget-object" class="headerlink" title="获取array的还有aget和aget-object"></a>获取array的还有aget和aget-object</h5><p>指令使用和上述类似，不细述。</p><h5 id="put指令的使用和get指令是统一的"><a href="#put指令的使用和get指令是统一的" class="headerlink" title="put指令的使用和get指令是统一的"></a>put指令的使用和get指令是统一的</h5><pre class=" language-lang-java"><code class="language-lang-java">const/4 v3, 0x0sput-object v3, Lcom/disney/WMW/WMWActivity;->globalIapHandler:Lcom/disney/config/GlobalPurchaseHandler;</code></pre><p>相当于：this.globalIapHandler = null;（null = 0x0）</p><pre class=" language-lang-java"><code class="language-lang-java">.local v0, wait:Landroid/os/Message;const/4 v1, 0x2iput v1, v0, Landroid/os/Message;->what:I</code></pre><p>相当于：wait.what = 0x2;（wait是Message的实例）</p><h4 id="smali中的函数调用"><a href="#smali中的函数调用" class="headerlink" title="smali中的函数调用"></a>smali中的函数调用</h4><p>smali中的函数和成员变量一样也分为两种类型，但是不同成员变量中的static和instance之分，而是direct和virtual之分。那么direct method和virtual method有什么区别呢？直白地讲，direct method就是private函数，其余的public和protected函数都属于virtual method。所以在调用函数时，有invoke-direct，invoke-virtual，另外还有invoke-static、invoke-super以及invoke-interface等几种不同的指令。当然其实还有invoke-XXX/range 指令的，这是参数多于4个的时候调用的指令，比较少见，了解下即可。</p><p><strong>invoke-static：</strong></p><p>顾名思义就是调用static函数的，因为是static函数，所以比起其他调用少一个参数</p><pre class=" language-lang-java"><code class="language-lang-java">invoke-static {}, Lcom/disney/WMW/UnlockHelper;->unlockCrankypack()Z</code></pre><p>这里注意到invoke-static后面有一对大括号“{}”，其实是<strong>调用该方法的实例+参数列表</strong>，由于这个方法既不需参数也是static的，所以{}内为空，再看一个例子：</p><pre class=" language-lang-java"><code class="language-lang-java">const-string v0, "fmodex"invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V</code></pre><p>这个是调用static void System.loadLibrary(String)来加载NDK编译的so库用的方法，同样也是这里v0就是参数”fmodex”了。</p><p><strong>invoke-super：</strong></p><p>调用父类方法用的指令，在onCreate、onDestroy等方法都能看到，略。</p><p><strong>invoke-direct：</strong></p><p>调用private函数的，例如</p><pre class=" language-lang-java"><code class="language-lang-java">invoke-direct {p0}, Lcom/disney/WMW/WMWActivity;->getGlobalIapHandler()Lcom/disney/config/GlobalPurchaseHandler;</code></pre><p>这里GlobalPurchaseHandler getGlobalIapHandler()就是定义在WMWActivity中的一个private函数，如果修改smali时错用invoke-virtual或invoke-static将在回编译后程序运行时引发一个常见的VerifyError</p><p><strong>invoke-virtual：</strong></p><p>用于调用protected或public函数，同样注意修改smali时不要错用invoke-direct或invoke-static，例子</p><pre class=" language-lang-java"><code class="language-lang-java">sget-object v0, Lcom/disney/WMW/WMWActivity;->shareHandler:Landroid/os/Handler;invoke-virtual {v0, v3}, Landroid/os/Handler;->removeCallbacksAndMessages(Ljava/lang/Object;)V</code></pre><p>v0是shareHandler:Landroid/os/Handler，v3是传递给removeCallbackAndMessage方法的Ljava/lang/Object参数就可以了。</p><p><strong>invoke-xxxxx/range：</strong></p><p>当方法的参数多于5个时（含5个），不能直接使用以上的指令，而是在后面加上“/range”，使用方法也有所不同：</p><pre class=" language-lang-java"><code class="language-lang-java">invoke-static/range {v0 .. v5}, Lcn/game189/sms/SMS;->checkFee(Ljava/lang/String;Landroid/app/Activity;Lcn/game189/sms/SMSListener;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Z</code></pre><p>刚才看到的例子都是“调用函数”这个操作而已，貌似没有取函数返回的结果的操作？</p><p>在Java代码中调用函数和返回函数结果是一条语句完成的，而在smali里则需要分开来完成，在使用上述指令后，如果调用的函数返回非void，那么还需要用到move-result（返回基本数据类型）和move-result-object（返回对象）指令：</p><pre class=" language-lang-java"><code class="language-lang-java">const/4 v2, 0x0invoke-virtual {p0, v2}, Lcom/disney/WMW/WMWActivity;->getPreferences(I)Landroid/content/SharedPreferences;move-result-object v1</code></pre><p> v1保存的就是调用getPreferences(int)方法返回的SharedPreferences实例。</p><pre class=" language-lang-java"><code class="language-lang-java">invoke-virtual {v2}, Ljava/lang/String;->length()Imove-result v2</code></pre><p>v2保存的则是调用String.length()返回的整型。</p><h4 id="smali中函数实体分析"><a href="#smali中函数实体分析" class="headerlink" title="smali中函数实体分析"></a>smali中函数实体分析</h4><pre class=" language-lang-java"><code class="language-lang-java">.method protected onDestroy()V    .locals 0    .prologue    .line 277    invoke-super {p0}, Lcom/disney/common/BaseActivity;->onDestroy()V    .line 279    return-void.end method</code></pre><p>这是onDestroy()函数，它的作用大家都知道。首先看到函数内第一句：.local 0，这句话很重要，标明了你在这个函数中最少要用到的本地寄存器的个数。在这里，由于只需要调用一个父类的onDestroy()处理，所以只需要用到p0，所以使用到的本地寄存器数为0。如果不清楚这个规则，很容易在植入代码后忘记修改.local 的值，那么回编译后运行时将会得到一个VerifyError错误，而且极难发现问题所在。我正是被这个问题困扰了很多次，最后研究发现.local的值有这个规律，于是在文档查证了一下果然是这个问题。例如我往onDestroy()增加一句：this.existed = true;那么应该改为（注意修改.local的值为1——使用到了v0这一个本地寄存器）：</p><pre class=" language-lang-java"><code class="language-lang-java">.method protected onDestroy()V    .locals 1    .prologue    .line 277    const/4 v0, 0x1    iput-boolean v0, p0, Lcom/disney/WMW/WMWActivity;->exited:Z    invoke-super {p0}, Lcom/disney/common/BaseActivity;->onDestroy()V    .line 279    return-void.end method</code></pre><p>另外注意到.line这个标识，它是标注了该代码在原Java文件中的行数，Dalvik VM运行到.line XX时就将这个值存起来，如果在这一行运行时出错了，就往catLog输出这个值，这样我们就能看到具体是哪一行的问题了。</p><h3 id="smali插桩"><a href="#smali插桩" class="headerlink" title="smali插桩"></a>smali插桩</h3><p>何为插桩，引用一下wiki的解释：程序插桩，最早是由J.C. Huang 教授提出的，它是在保证被测程序原有逻辑完整性的基础上在程序中插入一些探针（又称为“探测仪”），通过探针的执行并抛出程序运行的特征数据，通过对这些数据的分析，可以获得程序的控制流和数据流信息，进而得到逻辑覆盖等动态信息，从而实现测试目的的方法。</p><p>插桩思路是，比如有些应用为防止被修改，会在开启的时候检查签名，签名结果为false的时候就会退出应用。所以就要定位检查的函数，然后通过log把目标值打印出来。</p><ol><li><p>写一个打印log的静态类</p></li><li><p>将其转换成smali文件</p></li><li><p>把文件放入工程里</p></li><li><p>在要打印log的地方添加如下代码：</p><pre class=" language-lang-java"><code class="language-lang-java">invoke-static {v1}, Lcom/softard/MyLog;->Log(Ljava/lang/Object;)V</code></pre></li><li><p>重新打包APK，运行，就可以看到打印结果</p></li></ol><p>补充一份实例：</p><p>先写一个Log类：</p><pre class=" language-lang-java"><code class="language-lang-java">package com.softard.xxxx;import android.util.Log;public class LogUtil {    public static final String TAG = "WOW";    public static void print() {        Log.d(TAG, "Code running in here.");    }}</code></pre><p>然后Android Studio将java代码转换成<code>smali</code></p><pre class=" language-lang-smali"><code class="language-lang-smali">.class public Lcom/softard/xxxx/LogUtil;.super Ljava/lang/Object;.source "LogUtil.java"# static fields.field public static final TAG:Ljava/lang/String; = "WOW"# direct methods.method public constructor <init>()V    .registers 1    .prologue    .line 10    invoke-direct {p0}, Ljava/lang/Object;-><init>()V    return-void.end method.method public static print()V    .registers 2    .prologue    .line 14    const-string v0, "WOW"    const-string v1, "Code running in here."    invoke-static {v0, v1}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I    .line 15    return-void.end method</code></pre><p>然后把<code>LogUtil.smali</code>文件放到反编译后的<code>smali</code>文件夹下的根目录。放根目录是为了绕过包名的影响，方便调用，所以<code>LogUtil.smali</code>文件的包名要去掉：</p><pre class=" language-lang-smali"><code class="language-lang-smali">.class public Lcom/softard/xxxx/LogUtil; -> .class public LLogUtil;</code></pre><p>然后在目标位置调用打印方法：</p><pre class=" language-lang-smali"><code class="language-lang-smali">invoke-virtual {p1, v0}, Landroid/view/View;->setOnClickListener(Landroid/view/View$OnClickListener;)Vinvoke-static {}, LLogUtil;->print()V  <-在此调用.line 51invoke-static {p0}, Lcom/softard/rxdemo/demo/Chapter9;->practice1(Landroid/content/Context;)V</code></pre><blockquote><p>加代码的时候要注意，要找对地方加，就是在上个方法调用完后添加，比如<code>invoke-virtual</code> <code>invoke-static</code>等。而且这些指令后面不能有<code>move-result-object</code>，因为这个指令是获取方法的返回值，所以一般这么加代码：</p><ul><li>在invoke-static/invoke-virtual 指令返回类型是<code>V</code>之后可以加入</li><li>在invoke-static/invoke-virtual 指令返回类型不是<code>V</code>，那么在<code>move-result-object</code>命令之后可以加入</li></ul></blockquote><p>然后打包签名安装运行，可以看到我们要的log</p><pre class=" language-lang-txt"><code class="language-lang-txt">> adb logcat -s WOW16:12:55.443 26400 26400 D WOW     : Code running in here.</code></pre><h3 id="smali修改"><a href="#smali修改" class="headerlink" title="smali修改"></a>smali修改</h3><p>一般不会大量修改代码，而是会改一些关键逻辑。比如if，有时候修改一个判断就可以达到逻辑跳转的目的。</p><pre class=" language-lang-java"><code class="language-lang-java">if-eq vA, VB, cond_** 如果vA等于vB则跳转到cond_**。相当于if (vA==vB)if-ne vA, VB, cond_** 如果vA不等于vB则跳转到cond_**。相当于if (vA!=vB)if-lt vA, VB, cond_** 如果vA小于vB则跳转到cond_**。相当于if (vA<vB)if-le vA, VB, cond_** 如果vA小于等于vB则跳转到cond_**。相当于if (vA<=vB)if-gt vA, VB, cond_** 如果vA大于vB则跳转到cond_**。相当于if (vA>vB)if-ge vA, VB, cond_** 如果vA大于等于vB则跳转到cond_**。相当于if (vA>=vB)if-eqz vA, :cond_** 如果vA等于0则跳转到:cond_** 相当于if (VA==0)if-nez vA, :cond_** 如果vA不等于0则跳转到:cond_**相当于if (VA!=0)if-ltz vA, :cond_** 如果vA小于0则跳转到:cond_**相当于if (VA<0)if-lez vA, :cond_** 如果vA小于等于0则跳转到:cond_**相当于if (VA<=0)if-gtz vA, :cond_** 如果vA大于0则跳转到:cond_**相当于if (VA>0)if-gez vA, :cond_** 如果vA大于等于0则跳转到:cond_**相当于if (VA>=0)</code></pre><p>不建议在程序原有的方法上增加大量逻辑，这样可能会出现很多寄存器方面的错误导致编译失败。比较好的方法是：把想要增加的逻辑先用java写成一个apk，然后把这个apk反编译成smali文件，随后把反编译后的这部分逻辑的smali文件插入到目标程序的smali文件夹中，然后再在原来的方法上采用invoke的方式调用新加入的逻辑。这样的话不管加入再多的逻辑，也只是修改了原程序的几行代码而已。</p><h2 id="汇编ARM指令"><a href="#汇编ARM指令" class="headerlink" title="汇编ARM指令"></a>汇编ARM指令</h2><h3 id="ARM指令中寻址方式"><a href="#ARM指令中寻址方式" class="headerlink" title="ARM指令中寻址方式"></a>ARM指令中寻址方式</h3><ul><li><p>立即数寻址</p><p>也叫立即寻址，是一种特殊寻址方式。操作数本身包含在指令中，只要取出指令也就取到了操作数，该操作数叫立即数，对应寻址方式叫做立即寻址。</p><p>MOV R0, #64; R0←64</p></li><li><p>寄存器寻址</p><p>利用寄存器中的数值作为操作数，也称为寄存器直接寻址。</p><p>ADD R0, R1, R2; R0←R1+R2</p></li><li><p>寄存器间接寻址</p><p>把寄存器中的值作为地址，通过这个地址去取得操作数，操作数本身存放在存储器中。</p><p>LDR R0,[R1]; R0←[R1]</p></li><li><p>寄存器偏移寻址</p><p>这是ARM指令集特有的寻址方式，它是在寄存器寻址得到操作数后再进行位移操作，得到最终操作数。</p><p>MOV R0,R2,LSL #3;  R0←R2*8, R2的值左移3位，结果赋值给R0</p></li><li><p>寄存器基址变址寻址</p><p>是在寄存器间接寻址的基础上扩展来的。它将寄存器中的值与指令中给出的地址偏移量相加，从而得到一个地址，通过这个地址取得操作数。</p><p>LDR R0,[R1, #4];  R0←[R1+4] 将R1的内容加上4形成操作数地址，取得的操作数存入寄存器R0中</p></li><li><p>多寄存器寻址</p><p>可以一次完成多个寄存器值的传送</p><p>LDMIA R0,{R1,R2,R3,R4};   R1←[R0], R2←[R0+4], R3←[R0+8], R4←[R0+12]</p></li><li><p>堆栈寻址</p><p>堆栈按先进后出工作，使用堆栈指针SP指示当前的操作位置，堆栈指针总是指向栈顶</p><p>STMFD SP!, {R1 - R7, LR}    将R1-R7 LR压入堆栈。满递减堆栈</p><p>LDMED SP!,{R1 - R7, LR}    将堆栈中的数据取回到R1-R7，LR寄存器。空递减堆栈</p></li></ul><h3 id="ARM中寄存器"><a href="#ARM中寄存器" class="headerlink" title="ARM中寄存器"></a>ARM中寄存器</h3><p><strong>R0-R3</strong></p><p>用于函数参数及返回值的传递</p><p><strong>R4-R6,R8,R10-R11</strong></p><p>没有特殊规定，就是普通的通用寄存器</p><p><strong>R7</strong></p><p>栈帧指针（Frame Pointer）指向前一个保存的栈帧和链接寄存器（link register lr）在栈上的地址</p><p><strong>R9</strong></p><p>操作系统保留</p><p><strong>R12</strong></p><p>IP intra-procedure scratch</p><p><strong>R13</strong></p><p>SP stack pointer 栈顶指针</p><p><strong>R14</strong></p><p>link register 存放函数的返回地址</p><p><strong>R15</strong></p><p>pogram counter 指向当前指令地址</p><h3 id="ARM常用指令"><a href="#ARM常用指令" class="headerlink" title="ARM常用指令"></a>ARM常用指令</h3><p><strong>ADD</strong>    加指令</p><p><strong>SUB</strong>    减指令</p><p><strong>STR</strong>     把寄存器内容存到栈上</p><p><strong>LDR</strong>    把栈上内容载入一个寄存器中</p><p><strong>.W</strong>        是一个可选指令宽度说明符。不会影响为此指令的行为，它只是确保生成32位指令。</p><p><strong>BL</strong>        执行函数调用，并把使lr指向调用者的下一条指令，即函数的返回地址</p><p><strong>BLX</strong>        同上，但是在ARM和thumb指令集间切换</p><p><strong>CMP</strong>    指令进行比较两个操作数的大小</p><p>未完成</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> smali </tag>
            
            <tag> 逆向 </tag>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Android] 为什么主线程不会因为Looper.loop()方法造成阻塞</title>
      <link href="/2019/05/10/%5BAndroid%5Dwhy-Looper-loop-will-not-block-main-thread/"/>
      <url>/2019/05/10/%5BAndroid%5Dwhy-Looper-loop-will-not-block-main-thread/</url>
      
        <content type="html"><![CDATA[<p>首先，关于Handler相关机制，可以参考我之前整理的<a href="http://wossoneri.github.io/2018/05/10/[Android]handler-message-delivery/">[Android] Handler消息传递机制</a>。</p><p>然后我们分解问题，一点点去看这个问题。</p><h2 id="Looper-loop和主线程的关系"><a href="#Looper-loop和主线程的关系" class="headerlink" title="Looper.loop和主线程的关系"></a>Looper.loop和主线程的关系</h2><p>分析Handler和应用启动的时候讲过，在创建ActivityThread时，主线程会创建Looper，并且进入Loop循环：</p><pre class=" language-lang-java"><code class="language-lang-java">public static void main(String[] args) {        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "ActivityThreadMain");        SamplingProfilerIntegration.start();        // CloseGuard defaults to true and can be quite spammy.  We        // disable it here, but selectively enable it later (via        // StrictMode) on debug builds, but using DropBox, not logs.        CloseGuard.setEnabled(false);        Environment.initForCurrentUser();        // Set the reporter for event logging in libcore        EventLogger.setReporter(new EventLoggingReporter());        // Make sure TrustedCertificateStore looks in the right place for CA certificates        final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());        TrustedCertificateStore.setDefaultUserDirectory(configDir);        Process.setArgV0("<pre-initialized>");          // 这里sMainLooper赋值        Looper.prepareMainLooper();        ActivityThread thread = new ActivityThread();        thread.attach(false);        if (sMainThreadHandler == null) {            sMainThreadHandler = thread.getHandler();        }        if (false) {            Looper.myLooper().setMessageLogging(new                    LogPrinter(Log.DEBUG, "ActivityThread"));        }        // End of event ActivityThreadMain.        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);        Looper.loop();    // Looper进入循环        throw new RuntimeException("Main thread loop unexpectedly exited");    }</code></pre><p>loop()函数代码就不贴了，就是一个<code>while(true)</code>的死循环。</p><p>所以Looper和主线程的关系是，主线程创建的时候会创建一个MainLooper，并且进入循环。</p><pre class=" language-lang-java"><code class="language-lang-java">Looper.prepareMainLooper();Looper.loop();</code></pre><h2 id="主线程阻塞"><a href="#主线程阻塞" class="headerlink" title="主线程阻塞"></a>主线程阻塞</h2><h3 id="关于死循环"><a href="#关于死循环" class="headerlink" title="关于死循环"></a>关于死循环</h3><p>主线程进入一个死循环，是不是就会被阻塞？</p><p>首先，思考一下，如果我们创建一个线程做定时检查某个状态，是不是也会给这个子线程做一个死循环，不断地去循环检查状态。当不需要这个线程的时候，改变flag让这个子线程退出循环并销毁。</p><p>想到这就理解，主线程也是一个线程，它也要维持自己的周期，所以也是需要一个死循环的。所以死循环并不是那么让人担心。</p><h3 id="关于阻塞"><a href="#关于阻塞" class="headerlink" title="关于阻塞"></a>关于阻塞</h3><p>这就涉及到Looper的作用了，Looper里持有一个MessageQueue，这个消息队列存放着外部发来的消息，当有消息过来的时候，Looper就会按顺序把消息一个一个拿出来，进行处理。Looper的loop循环就是一个拿消息的循环。</p><p>也就是说，如果你给我发消息，我会立即去拿消息并且做响应。你不给我消息，我就会阻塞，减少CPU消耗（涉及到epoll）。</p><p>那么主线程会响应什么消息呢？在ActivityThread里有一个命名为H的handler，它处理所有Activity生命周期有关的事件。因为主线程就是UI线程，当UI发生变化，相关消息就会传进来，Looper就会处理消息。</p><p>所以：</p><p><strong>Looper的阻塞，前提是没有输入事件，此时MessageQueue是空的，Looper进入空闲，线程进入阻塞，释放CPU，等待输入事件的唤醒。</strong></p><h2 id="聊聊ANR"><a href="#聊聊ANR" class="headerlink" title="聊聊ANR"></a>聊聊ANR</h2><p>其实担心这个问题的人很多都是被ANR搞怕了，因为ANR就是UI线程做耗时操作了导致卡死状态，然后很多人就在想是不是UI线程进入Loop死循环后，就出现卡死，其实这两个并不是一个问题。</p><p>先上结论和上面的做个对比：</p><p><strong>UI耗时导致卡死，前提是要有输入事件，此时MessageQueue不是空的，Looper正常轮询，线程并没有阻塞，但是该事件执行时间过长（一般5秒），而且与此期间其他的事件（按键按下，屏幕点击..）都没办法处理（卡死），然后就ANR异常了。</strong></p><p>ANR机制的目的还是为了监测主线程的耗时操作，譬如密集CPU运算、大量IO、复杂界面布局等，因为这些都会降低应用程序的响应能力。所以从理念上也能理解，loop死循环只是简单地处理轻量的消息操作，和ANR并没有关系。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Handler </tag>
            
            <tag> Looper </tag>
            
            <tag> Message </tag>
            
            <tag> MessageQueue </tag>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Android][Framework]PackageManagerService处理应用权限流程</title>
      <link href="/2019/04/09/%5BAndroid%5D%5BFramework%5DPackageManagerService-process-app-permission/"/>
      <url>/2019/04/09/%5BAndroid%5D%5BFramework%5DPackageManagerService-process-app-permission/</url>
      
        <content type="html"><![CDATA[<h2 id="app种类"><a href="#app种类" class="headerlink" title="app种类"></a>app种类</h2><p>1、system app (有ApplicationInfo.FLAG_SYSTEM标记)</p><p>2、privileged app (有ApplicationInfo.FLAG_SYSTEM和ApplicationInfo.PRIVATE_FLAG_PRIVILEGE两个标记)</p><h3 id="system-app"><a href="#system-app" class="headerlink" title="system app"></a>system app</h3><p>system app 定义很明了，就是在PMS初始化安装app的时候赋予了ApplicationInfo.FLAG_SYSTEM这个标记</p><p>1、特定shareUID的app<br>代码在PMS的构造函数中</p><pre class=" language-lang-java"><code class="language-lang-java">mSettings.addSharedUserLPw("android.uid.system", Process.SYSTEM_UID,        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);mSettings.addSharedUserLPw("android.uid.phone", RADIO_UID,        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);mSettings.addSharedUserLPw("android.uid.log", LOG_UID,        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);mSettings.addSharedUserLPw("android.uid.nfc", NFC_UID,        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);mSettings.addSharedUserLPw("android.uid.bluetooth", BLUETOOTH_UID,        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);mSettings.addSharedUserLPw("android.uid.shell", SHELL_UID,        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</code></pre><p>2、扫描安装特定目录的app<br>代码在PMS的构造函数中，扫描安装时给予PackageParser.PARSE_IS_SYSTEM标记的app，例如/vendor/overlay，/system/framework，/system/priv-app，/system/app，/vendor/app，/oem/app等，给予的PackageParser.PARSE_IS_SYSTEM最终会转换为ApplicationInfo.FLAG_SYSTEM，部分代码如下</p><pre class=" language-lang-java"><code class="language-lang-java">File vendorOverlayDir = new File(VENDOR_OVERLAY_DIR);    scanDirTracedLI(vendorOverlayDir, mDefParseFlags            | PackageParser.PARSE_IS_SYSTEM            | PackageParser.PARSE_IS_SYSTEM_DIR            | PackageParser.PARSE_TRUSTED_OVERLAY, scanFlags | SCAN_TRUSTED_OVERLAY, 0);File customFrameworkDir = new File("/custom/framework");    scanDirLI(customFrameworkDir, PackageParser.PARSE_IS_SYSTEM            | PackageParser.PARSE_IS_SYSTEM_DIR,            scanFlags | SCAN_NO_DEX, 0);scanDirTracedLI(frameworkDir, mDefParseFlags            | PackageParser.PARSE_IS_SYSTEM            | PackageParser.PARSE_IS_SYSTEM_DIR            | PackageParser.PARSE_IS_PRIVILEGED,            scanFlags | SCAN_NO_DEX, 0);</code></pre><p>flag转换的过程大致如下</p><pre class=" language-lang-java"><code class="language-lang-java">-> scanDirLI(File dir, final int parseFlags, int scanFlags, long currentTime)->  scanPackageTracedLI(PackageParser.Package pkg, final int policyFlags,         int scanFlags, long currentTime, UserHandle user)-> scanPackageLI(PackageParser.Package pkg, final int policyFlags,            int scanFlags, long currentTime, UserHandle user) -> scanPackageDirtyLI(PackageParser.Package pkg,            final int policyFlags, final int scanFlags, long currentTime, UserHandle user)//在scanPackageDirtyLI方法中将flag转换// Apply policyif ((policyFlags&PackageParser.PARSE_IS_SYSTEM) != 0) {    pkg.applicationInfo.flags |= ApplicationInfo.FLAG_SYSTEM;    ...}</code></pre><h3 id="privileged-app"><a href="#privileged-app" class="headerlink" title="privileged app"></a>privileged app</h3><p>privileged app在ApplicationInfo.FLAG_SYSTEM基础上还必须有ApplicationInfo.PRIVATE_FLAG_PRIVILEGED标记</p><p>1、特定shareUID的app<br>特定shareUID的app有ApplicationInfo.FLAG_SYSTEM的同时都有ApplicationInfo.PRIVATE_FLAG_PRIVILEGED</p><p>2、扫描特定目录app时，给予了PackageParser.PARSE_IS_SYSTEM标记和PackageParser.PARSE_IS_PRIVILEGED标记，目录有三个：system/framework,system/priv-app,vendor/priv-app<br>例如：</p><pre class=" language-lang-java"><code class="language-lang-java">//vender/framework目录下有PackageParser.PARSE_IS_SYSTEM没有PackageParser.PARSE_IS_PRIVILEGED标记File vendorFrameworkDir = new File(Environment.getVendorDirectory(), "framework");scanDirTracedLI(vendorFrameworkDir, PackageParser.PARSE_IS_SYSTEM    | PackageParser.PARSE_IS_SYSTEM_DIR,    scanFlags | SCAN_NO_DEX, 0);//system/framework目录下两个标记都有scanDirTracedLI(frameworkDir, mDefParseFlags    | PackageParser.PARSE_IS_SYSTEM    | PackageParser.PARSE_IS_SYSTEM_DIR    | PackageParser.PARSE_IS_PRIVILEGED,    scanFlags | SCAN_NO_DEX, 0);</code></pre><p>PackageParser.PARSE_IS_PRIVILEGED也是在scanPackageDirtyLI方法中转换的</p><pre class=" language-lang-java"><code class="language-lang-java">if ((policyFlags&PackageParser.PARSE_IS_PRIVILEGED) != 0) {            pkg.applicationInfo.privateFlags |= ApplicationInfo.PRIVATE_FLAG_PRIVILEGED;        }</code></pre><h2 id="PMS赋予apk的runtime权限"><a href="#PMS赋予apk的runtime权限" class="headerlink" title="PMS赋予apk的runtime权限"></a>PMS赋予apk的runtime权限</h2><h3 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h3><p>PMS(PackageManagerService)在SystemServer中初始化完成最后调用PMS::systemReady,在systemReady方法中开始授予默认权限</p><pre class=" language-lang-java"><code class="language-lang-java">final DefaultPermissionGrantPolicy mDefaultPermissionPolicy;for (int userId : grantPermissionsUserIds) {            mDefaultPermissionPolicy.grantDefaultPermissions(userId);        }</code></pre><p>DefaultPermissionGrantPolicy这个类就是管理默认权限的，最终的实现都是在PMS代码中</p><pre class=" language-lang-java"><code class="language-lang-java">public void grantDefaultPermissions(int userId) {    // 系统组件赋予Dangerous权限        grantPermissionsToSysComponentsAndPrivApps(userId);    // 指定app的指定权限        grantDefaultSystemHandlerPermissions(userId);    }</code></pre><h3 id="系统组件赋予Dangerous权限"><a href="#系统组件赋予Dangerous权限" class="headerlink" title="系统组件赋予Dangerous权限"></a>系统组件赋予Dangerous权限</h3><pre class=" language-lang-java"><code class="language-lang-java">private void grantPermissionsToSysComponentsAndPrivApps(int userId) {        Log.i(TAG, "Granting permissions to platform components for user " + userId);        synchronized (mService.mPackages) {            for (PackageParser.Package pkg : mService.mPackages.values()) {            // 过滤掉privileged app , FLAG_PERSISTENT标记app ,系统签名相同的app                if (!isSysComponentOrPersistentPlatformSignedPrivAppLPr(pkg)            // 判断targetSdkVersion > 22                        || !doesPackageSupportRuntimePermissions(pkg)            // 请求权限列表为空                        || pkg.requestedPermissions.isEmpty()) {                    continue;                }                Set<String> permissions = new ArraySet<>();                final int permissionCount = pkg.requestedPermissions.size();                for (int i = 0; i < permissionCount; i++) {                    String permission = pkg.requestedPermissions.get(i);                    BasePermission bp = mService.mSettings.mPermissions.get(permission);            // 权限为Dangerous权限                    if (bp != null && bp.isRuntime()) {                        permissions.add(permission);                    }                }                if (!permissions.isEmpty()) {            // 添加权限                    grantRuntimePermissionsLPw(pkg, permissions, true, userId);                }            }        }    }</code></pre><p>接下来看下isSysComponentOrPersistentPlatformSignedPrivAppLPr和isRuntime的内容</p><pre class=" language-lang-java"><code class="language-lang-java">private boolean isSysComponentOrPersistentPlatformSignedPrivAppLPr(PackageParser.Package pkg) {    // UserID 小于10000        if (UserHandle.getAppId(pkg.applicationInfo.uid) < FIRST_APPLICATION_UID) {            return true;        }    // privileged app过滤        if (!pkg.isPrivilegedApp()) {            return false;        }    // 这两个判断过滤掉FLAG_PERSISTENT        PackageSetting sysPkg = mService.mSettings.getDisabledSystemPkgLPr(pkg.packageName);        if (sysPkg != null && sysPkg.pkg != null) {            if ((sysPkg.pkg.applicationInfo.flags & ApplicationInfo.FLAG_PERSISTENT) == 0) {                return false;            }        } else if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_PERSISTENT) == 0) {            return false;        }    // 过滤掉系统签名相同的apk        return PackageManagerService.compareSignatures(mService.mPlatformPackage.mSignatures,                pkg.mSignatures) == PackageManager.SIGNATURE_MATCH;    }public boolean isRuntime() {    // protectionLevel & PermissionInfo.PROTECTION_MASK_BASE 表示当前等级        return (protectionLevel & PermissionInfo.PROTECTION_MASK_BASE)                == PermissionInfo.PROTECTION_DANGEROUS;    }</code></pre><h3 id="指定app的指定权限"><a href="#指定app的指定权限" class="headerlink" title="指定app的指定权限"></a>指定app的指定权限</h3><p>这里是给指定某个app,给予它指定的几个权限，这里的代码十分类似，截取片段如下</p><pre class=" language-lang-java"><code class="language-lang-java">private void grantDefaultSystemHandlerPermissions(int userId) {    ...    // Dialer            if (dialerAppPackageNames == null) {                Intent dialerIntent = new Intent(Intent.ACTION_DIAL);                PackageParser.Package dialerPackage = getDefaultSystemHandlerActivityPackageLPr(                        dialerIntent, userId);                if (dialerPackage != null) {                    grantDefaultPermissionsToDefaultSystemDialerAppLPr(dialerPackage, userId);                }            } else {                for (String dialerAppPackageName : dialerAppPackageNames) {                    PackageParser.Package dialerPackage = getSystemPackageLPr(dialerAppPackageName);                    if (dialerPackage != null) {                        grantDefaultPermissionsToDefaultSystemDialerAppLPr(dialerPackage, userId);                    }                }            }            // SMS            if (smsAppPackageNames == null) {                Intent smsIntent = new Intent(Intent.ACTION_MAIN);                smsIntent.addCategory(Intent.CATEGORY_APP_MESSAGING);                PackageParser.Package smsPackage = getDefaultSystemHandlerActivityPackageLPr(                        smsIntent, userId);                if (smsPackage != null) {                   grantDefaultPermissionsToDefaultSystemSmsAppLPr(smsPackage, userId);                }            } else {                for (String smsPackageName : smsAppPackageNames) {                    PackageParser.Package smsPackage = getSystemPackageLPr(smsPackageName);                    if (smsPackage != null) {                        grantDefaultPermissionsToDefaultSystemSmsAppLPr(smsPackage, userId);                    }                }            }    ...}private void grantDefaultPermissionsToDefaultSystemDialerAppLPr(            PackageParser.Package dialerPackage, int userId) {        if (doesPackageSupportRuntimePermissions(dialerPackage)) {            boolean isPhonePermFixed =                    mService.hasSystemFeature(PackageManager.FEATURE_WATCH, 0);            grantRuntimePermissionsLPw(                    dialerPackage, PHONE_PERMISSIONS, isPhonePermFixed, userId);            grantRuntimePermissionsLPw(dialerPackage, CONTACTS_PERMISSIONS, userId);            grantRuntimePermissionsLPw(dialerPackage, SMS_PERMISSIONS, userId);            grantRuntimePermissionsLPw(dialerPackage, MICROPHONE_PERMISSIONS, userId);        }    }</code></pre><p>两种添加最后都走到了grantRuntimePermissionsLPw，我们接着分析grantRuntimePermissionsLPw函数</p><h3 id="添加权限grantRuntimePermissionsLPw"><a href="#添加权限grantRuntimePermissionsLPw" class="headerlink" title="添加权限grantRuntimePermissionsLPw"></a>添加权限grantRuntimePermissionsLPw</h3><p>grantRuntimePermissionsLPw赋予权限的代码,最终是交给PMS来处理，经过一些列判断后调用关键方法mService.grantRuntimePermission和mService.updatePermissionFlags，代码片段如下</p><pre class=" language-lang-java"><code class="language-lang-java">private final PackageManagerService mService;private void grantRuntimePermissionsLPw(PackageParser.Package pkg, Set<String> permissions,    boolean systemFixed, boolean isDefaultPhoneOrSms, int userId) {    ...    mService.grantRuntimePermission(pkg.packageName, permission, userId);    ...    mService.updatePermissionFlags(permission, pkg.packageName,    newFlags, newFlags, userId);    ...}</code></pre><p>接着看PMS的grantRuntimePermission如何添加权限</p><pre class=" language-lang-java"><code class="language-lang-java">    public void grantRuntimePermission(String packageName, String name, final int userId) {        ...    // 要添加权限，也需要“添加”权限        mContext.enforceCallingOrSelfPermission(                android.Manifest.permission.GRANT_RUNTIME_PERMISSIONS,                "grantRuntimePermission");    enforceCrossUserPermission(Binder.getCallingUid(), userId,                true /* requireFullPermission */, true /* checkShell */,                "grantRuntimePermission");        ...    // 添加权限    final int result = permissionsState.grantRuntimePermission(bp, userId);    switch (result) {    case PermissionsState.PERMISSION_OPERATION_FAILURE: {        return;    }    case PermissionsState.PERMISSION_OPERATION_SUCCESS_GIDS_CHANGED: {        final int appId = UserHandle.getAppId(pkg.applicationInfo.uid);        mHandler.post(new Runnable() {        @Override        public void run() {            killUid(appId, userId, KILL_APP_REASON_GIDS_CHANGED);        }        });    }    break;    }    // PermissionsChanged监听    mOnPermissionChangeListeners.onPermissionsChanged(uid);    // 把数据更新到runtime-permissions.xml中    mSettings.writeRuntimePermissionsForUserLPr(userId, false); }</code></pre><p>最后grantRuntimePermission就是把permission存到mPermissions数据map中，再把数据跟新到/data/system/users/0/runtime-permissions.xml中，片段如下</p><pre class=" language-lang-xml"><code class="language-lang-xml">  <pkg name="com.google.android.apps.messaging">    <item name="android.permission.READ_SMS" granted="true" flags="20" />    <item name="android.permission.RECEIVE_WAP_PUSH" granted="true" flags="20" />    <item name="android.permission.RECEIVE_MMS" granted="true" flags="20" />    <item name="android.permission.RECEIVE_SMS" granted="true" flags="20" />    <item name="android.permission.READ_PHONE_STATE" granted="true" flags="20" />    <item name="android.permission.SEND_SMS" granted="true" flags="20" />    <item name="android.permission.CALL_PHONE" granted="true" flags="20" />    <item name="android.permission.WRITE_CONTACTS" granted="true" flags="20" />    <item name="android.permission.READ_CONTACTS" granted="true" flags="20" />  </pkg>  <pkg name="com.google.android.setupwizard">    <item name="android.permission.ACCESS_COARSE_LOCATION" granted="true" flags="20" />    <item name="android.permission.CALL_PHONE" granted="true" flags="20" />    <item name="android.permission.WRITE_CONTACTS" granted="true" flags="20" />    <item name="android.permission.CAMERA" granted="true" flags="20" />    <item name="android.permission.PROCESS_OUTGOING_CALLS" granted="true" flags="20" />    <item name="android.permission.READ_CONTACTS" granted="true" flags="20" />  </pkg></code></pre><h2 id="PMS赋予apk安装权限"><a href="#PMS赋予apk安装权限" class="headerlink" title="PMS赋予apk安装权限"></a>PMS赋予apk安装权限</h2><p>过程精简如下：</p><pre><code>-&gt; scanDirLI(File dir, final int parseFlags, int scanFlags, long currentTime)-&gt;  scanPackageTracedLI(PackageParser.Package pkg, final int policyFlags,         int scanFlags, long currentTime, UserHandle user)-&gt; scanPackageLI(PackageParser.Package pkg, final int policyFlags,            int scanFlags, long currentTime, UserHandle user) -&gt; scanPackageDirtyLI(PackageParser.Package pkg,            final int policyFlags, final int scanFlags, long currentTime, UserHandle user)-&gt; updateSettingsLI(PackageParser.Package newPackage, String installerPackageName,            int[] allUsers, PackageInstalledInfo res, UserHandle user)-&gt; updateSettingsInternalLI(PackageParser.Package newPackage,            String installerPackageName, int[] allUsers, int[] installedForUsers,            PackageInstalledInfo res, UserHandle user)-&gt; updatePermissionsLPw(String changingPkg, PackageParser.Package pkgInfo,            int flags)-&gt; updatePermissionsLPw(String changingPkg,            PackageParser.Package pkgInfo, String replaceVolumeUuid, int flags)-&gt; grantPermissionsLPw(PackageParser.Package pkg, boolean replace,            String packageOfInterest)</code></pre><p>在grantPermissionsLPw函数中做最后权限赋予操作，代码片段如下：</p><pre class=" language-lang-java"><code class="language-lang-java">    private void grantPermissionsLPw(PackageParser.Package pkg, boolean replace,            String packageOfInterest) {     for (int i=0; i<N; i++) {            final String name = pkg.requestedPermissions.get(i); // 权限名字            final BasePermission bp = mSettings.mPermissions.get(name); // 权限信息        ...            final int level = bp.protectionLevel & PermissionInfo.PROTECTION_MASK_BASE; // 权限级别ProtectionLevel            final boolean appSupportsRuntimePermissions = pkg.applicationInfo.targetSdkVersion                    >= Build.VERSION_CODES.M;        // 根据权限级别定义grant            switch (level) {                case PermissionInfo.PROTECTION_NORMAL: {                    // For all apps normal permissions are install time ones.                    grant = GRANT_INSTALL;                } break;                case PermissionInfo.PROTECTION_DANGEROUS: {                    if (!appSupportsRuntimePermissions && !Build.isPermissionReviewRequired()) {                        // For legacy apps dangerous permissions are install time ones.                        grant = GRANT_INSTALL;                    } else if (origPermissions.hasInstallPermission(bp.name)) {                        // For legacy apps that became modern, install becomes runtime.                        grant = GRANT_UPGRADE;                    } else if (mPromoteSystemApps                        && isSystemApp(ps)                        && mExistingSystemPackages.contains(ps.name)) {                        // For legacy system apps, install becomes runtime.                        // We cannot check hasInstallPermission() for system apps since those                        // permissions were granted implicitly and not persisted pre-M.                        grant = GRANT_UPGRADE;                    } else {                        // For modern apps keep runtime permissions unchanged.                        grant = GRANT_RUNTIME;                    }                } break;                case PermissionInfo.PROTECTION_SIGNATURE: {                    // For all apps signature permissions are install time ones.                    allowedSig = grantSignaturePermission(perm, pkg, bp, origPermissions);                    if (allowedSig) {                        grant = GRANT_INSTALL;                    }                } break;            }        ...            if (grant != GRANT_DENIED) {                if (!isSystemApp(ps) && ps.installPermissionsFixed) {                    // If this is an existing, non-system package, then                    // we can't add any new permissions to it.                    if (!allowedSig && !origPermissions.hasInstallPermission(perm)) {                        // Except...  if this is a permission that was added                        // to the platform (note: need to only do this when                        // updating the platform).                        if (!isNewPlatformPermissionForPackage(perm, pkg)) {                            grant = GRANT_DENIED;                        }                    }                }        // 根据grant 选择权限给予方式                switch (grant) {                    case GRANT_INSTALL: {                        for (int userId : UserManagerService.getInstance().getUserIds()) {                            if (origPermissions.getRuntimePermissionState(                                    bp.name, userId) != null) {                                // Revoke the runtime permission and clear the flags.                                origPermissions.revokeRuntimePermission(bp, userId);                                origPermissions.updatePermissionFlags(bp, userId,                                      PackageManager.MASK_PERMISSION_FLAGS, 0);                                // If we revoked a permission permission, we have to write.                                changedRuntimePermissionUserIds = ArrayUtils.appendInt(                                        changedRuntimePermissionUserIds, userId);                            }                        }                        // install权限                        if (permissionsState.grantInstallPermission(bp) !=                                PermissionsState.PERMISSION_OPERATION_FAILURE) {                            changedInstallPermission = true;                        }                    } break;                    case GRANT_RUNTIME: {                        // Grant previously granted runtime permissions.                        for (int userId : UserManagerService.getInstance().getUserIds()) {                            PermissionState permissionState = origPermissions                                    .getRuntimePermissionState(bp.name, userId);                            int flags = permissionState != null                                    ? permissionState.getFlags() : 0;                            if (origPermissions.hasRuntimePermission(bp.name, userId)) {                                if (permissionsState.grantRuntimePermission(bp, userId) ==                                        PermissionsState.PERMISSION_OPERATION_FAILURE) {                                    // If we cannot put the permission as it was, we have to write.                                    changedRuntimePermissionUserIds = ArrayUtils.appendInt(                                            changedRuntimePermissionUserIds, userId);                                }                                // If the app supports runtime permissions no need for a review.                                /// M: CTA requirement - permission control                                if (Build.isPermissionReviewRequired()                                        && appSupportsRuntimePermissions                                        && (flags & PackageManager                                                .FLAG_PERMISSION_REVIEW_REQUIRED) != 0) {                                    flags &= ~PackageManager.FLAG_PERMISSION_REVIEW_REQUIRED;                                    // Since we changed the flags, we have to write.                                    changedRuntimePermissionUserIds = ArrayUtils.appendInt(                                            changedRuntimePermissionUserIds, userId);                                }                            /// M: CTA requirement - permission control                            } else if (Build.isPermissionReviewRequired()                                    && !appSupportsRuntimePermissions) {                                if (CtaUtils.isPlatformPermission(bp.sourcePackage, bp.name)                                        && pkgReviewRequired) {                                    if ((flags & FLAG_PERMISSION_REVIEW_REQUIRED) == 0) {                                        /// M: CTA requirement - review UI for all apps  @{                                        Slog.d(TAG, "add review UI for legacy pkg = " +                                                pkg.packageName + ", permission = " +                                                bp.name + ", userId = " + userId +                                                ", uid = " + pkg.mSharedUserId);                                        ///@}                                        flags |= FLAG_PERMISSION_REVIEW_REQUIRED;                                        // We changed the flags, hence have to write.                                        changedRuntimePermissionUserIds = ArrayUtils.appendInt(                                                changedRuntimePermissionUserIds, userId);                                    }                                }                // runtime权限                                if (permissionsState.grantRuntimePermission(bp, userId)                                        != PermissionsState.PERMISSION_OPERATION_FAILURE) {                                    // We changed the permission, hence have to write.                                    changedRuntimePermissionUserIds = ArrayUtils.appendInt(                                            changedRuntimePermissionUserIds, userId);                                }                            /// M: CTA requirement - review UI for all apps  @{                            } else if (appSupportsRuntimePermissions &&                                    pkgReviewRequired) {                                if (CtaUtils.isPlatformPermission(bp.sourcePackage, bp.name)) {                                    if ((flags & FLAG_PERMISSION_REVIEW_REQUIRED) == 0 &&                                            (flags & PackageManager.FLAG_PERMISSION_SYSTEM_FIXED)                                            == 0) {                                        Slog.d(TAG, "add review UI for non-legacy pkg = " +                                                pkg.packageName + ", permission = " +                                                bp.name + ", userId = " + userId +                                                ", uid = " + pkg.mSharedUserId);                                        flags |= FLAG_PERMISSION_REVIEW_REQUIRED;                                        // We changed the flags, hence have to write.                                        changedRuntimePermissionUserIds = ArrayUtils.appendInt(                                                changedRuntimePermissionUserIds, userId);                                    }                                }                            }                            ///@}                            // Propagate the permission flags.                            permissionsState.updatePermissionFlags(bp, userId, flags, flags);                        }                    } break;                    case GRANT_UPGRADE: {                        // Grant runtime permissions for a previously held install permission.                        PermissionState permissionState = origPermissions                                .getInstallPermissionState(bp.name);                        final int flags = permissionState != null ? permissionState.getFlags() : 0;                        if (origPermissions.revokeInstallPermission(bp)                                != PermissionsState.PERMISSION_OPERATION_FAILURE) {                            // 跟新应用的权限                            origPermissions.updatePermissionFlags(bp, UserHandle.USER_ALL,                                    PackageManager.MASK_PERMISSION_FLAGS, 0);                            changedInstallPermission = true;                        }                        // If the permission runtime-permissions.xmlis not to be promoted to runtime we ignore it and                        // also its other flags as they are not applicable to install permissions.                        if ((flags & PackageManager.FLAG_PERMISSION_REVOKE_ON_UPGRADE) == 0) {                            for (int userId : currentUserIds) {                                if (permissionsState.grantRuntimePermission(bp, userId) !=                                        PermissionsState.PERMISSION_OPERATION_FAILURE) {                                    // Transfer the permission flags.                                    permissionsState.updatePermissionFlags(bp, userId,                                            flags, flags);                                    // If we granted the permission, we have to write.                                    changedRuntimePermissionUserIds = ArrayUtils.appendInt(                                            changedRuntimePermissionUserIds, userId);                                }                            }                        }                    } break;                    default: {                        if (packageOfInterest == null                                || packageOfInterest.equals(pkg.packageName)) {                            Slog.w(TAG, "Not granting permission " + perm                                    + " to package " + pkg.packageName                                    + " because it was previously installed without");                        }                    } break;                }            } else {                if (permissionsState.revokeInstallPermission(bp) !=                        PermissionsState.PERMISSION_OPERATION_FAILURE) {                    // Also drop the permission flags.                    permissionsState.updatePermissionFlags(bp, UserHandle.USER_ALL,                            PackageManager.MASK_PERMISSION_FLAGS, 0);                    changedInstallPermission = true;                    Slog.i(TAG, "Un-granting permission " + perm                            + " from package " + pkg.packageName                            + " (protectionLevel=" + bp.protectionLevel                            + " flags=0x" + Integer.toHexString(pkg.applicationInfo.flags)                            + ")");                } else if ((bp.protectionLevel&PermissionInfo.PROTECTION_FLAG_APPOP) == 0) {                    // Don't print warning for app op permissions, since it is fine for them                    // not to be granted, there is a UI for the user to decide.                    if (packageOfInterest == null || packageOfInterest.equals(pkg.packageName)) {                        Slog.w(TAG, "Not granting permission " + perm                                + " to package " + pkg.packageName                                + " (protectionLevel=" + bp.protectionLevel                                + " flags=0x" + Integer.toHexString(pkg.applicationInfo.flags)                                + ")");                    }                }            }        }        if ((changedInstallPermission || replace) && !ps.installPermissionsFixed &&                !isSystemApp(ps) || isUpdatedSystemApp(ps)){            // This is the first that we have heard about this package, so the            // permissions we have now selected are fixed until explicitly            // changed.            ps.installPermissionsFixed = true;        }        // 把runtime权限跟新到runtime-permissions.xml中        for (int userId : changedRuntimePermissionUserIds) {            mSettings.writeRuntimePermissionsForUserLPr(userId, runtimePermissionsRevoked);        }        Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);    }</code></pre><p>grantPermissionsLPw函数根据权限等级，来赋予权限。注意：这里的安装时赋予的runtime权限是之前已经赋予过此apk的权限才会执行到GRANT_RUNTIME<br>回到上面的精简过程：<br>updateSettingsInternalLI方法中调用updatePermissionsLPw后，最后会调用mSettings.writeLPr();<br>这些权限信息就被写到data/system/packages.xml中了，举例片段代码：</p><pre class=" language-lang-xml"><code class="language-lang-xml">...<package name="com.android.settings" codePath="/system/priv-app/Settings" nativeLibraryPath="/system/priv-app/Settings/lib" primaryCpuAbi="arm64-v8a" publicFlags="944258629" privateFlags="8" ft="15f7a5ec8a8" it="15f7a5ec8a8" ut="15f7a5ec8a8" version="25" sharedUserId="1000" isOrphaned="true">        <sigs count="1">            <cert index="1" />        </sigs>        <perms>            <item name="android.permission.BIND_INCALL_SERVICE" granted="true" flags="0" />            <item name="android.permission.WRITE_SETTINGS" granted="true" flags="0" />            <item name="com.google.android.gm.permission.WRITE_GMAIL" granted="true" flags="0" />            <item name="android.permission.CONFIGURE_WIFI_DISPLAY" granted="true" flags="0" />            <item name="android.permission.CONFIGURE_DISPLAY_COLOR_MODE" granted="true" flags="0" />            <item name="android.permission.ACCESS_WIMAX_STATE" granted="true" flags="0" />            <item name="com.qualcomm.permission.READPROC" granted="true" flags="0" />            <item name="android.permission.RESTART_PACKAGES" granted="true" flags="0" />            <item name="android.permission.USE_CREDENTIALS" granted="true" flags="0" />            <item name="android.permission.MODIFY_AUDIO_SETTINGS" granted="true" flags="0" />            <item name="android.permission.ACCESS_CHECKIN_PROPERTIES" granted="true" flags="0" />            <item name="android.permission.MODIFY_AUDIO_ROUTING" granted="true" flags="0" />    ...</code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>1、PMS扫描安装时赋予安装权限</p><p>2、PMS在systemReady函数中调用mDefaultPermissionPolicy.grantDefaultPermissions来赋予运行权限即dangerous权限</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Framework </tag>
            
            <tag> PackageManagerService </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[JVM] Dalvik配置与JVM</title>
      <link href="/2019/04/09/%5BJVM%5Ddalvik-and-jvm/"/>
      <url>/2019/04/09/%5BJVM%5Ddalvik-and-jvm/</url>
      
        <content type="html"><![CDATA[<p>内容有点乱，有空再整理一下</p><h2 id="JVM内存"><a href="#JVM内存" class="headerlink" title="JVM内存"></a>JVM内存</h2><p>在了解dalvik之前，需要认识一下JVM，我整理了一张图：</p><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/JVM.png?raw=true" alt></p><h2 id="dalvik"><a href="#dalvik" class="headerlink" title="dalvik"></a>dalvik</h2><p>在dalvik中，GC的类型有三种：</p><p>1、GC_EXPLICIT：</p><p>​    应用主动调用System.gc()产生的GC事件。</p><p>2、GC_FOR_ALLOC：</p><p>​    内存分配时，发现可用内存不够时触发的GC事件。</p><p>3、GC_CONCURRENT：</p><p>   给Java层的class分配内存后，计算已分配的大小达到阈值(当前DVM heap size小一点)时会触发的GC事件。</p><p>因为第2和第3中GC是由系统触发的，所以应用是无法减少这两种类型的GC事件。但需要减少这两种GC事件是，可以通过配置dalvik的系统属性或者修改dalvik的GC算法来实现，本文只对修改dalvik的系统属性的方式进行介绍。</p><p>dalvik与GC相关的属性有：</p><p>dalvik.vm.heapstartsize：初始化dalvik分配的内存大小。</p><p>dalvik.vm.heapsize：在mainfest中设置android:largeheap=”true”时，应用的最大内存，超过这个值会有OOM产生。</p><p>dalvik.vm.heaputilization、dalvik.vm.heapminfree 、dalvik.vm.heapmaxfree：dalvik GC时使用的参数。</p><p>设备列出的dalvik属性</p><pre class=" language-lang-txt"><code class="language-lang-txt">dalvik.vm.heapstartsize=14mdalvik.vm.heapgrowthlimit=192mdalvik.vm.heapsize=512mdalvik.vm.heaptargetutilization=0.75dalvik.vm.heapminfree=6mdalvik.vm.heapmaxfree=8mdalvik.vm.heapstartsize=8mdalvik.vm.heapgrowthlimit=96mdalvik.vm.heapsize=256mdalvik.vm.heaptargetutilization=0.75dalvik.vm.heapminfree=2mdalvik.vm.heapmaxfree=8mdalvik.vm.heapstartsize=8mdalvik.vm.heapgrowthlimit=128mdalvik.vm.heapsize=512mdalvik.vm.heaptargetutilization=0.75dalvik.vm.heapminfree=2mdalvik.vm.heapmaxfree=8m512m gives enough for the rest of the system and 128m splits 512m in half giving the java heap zize enough for apps to load fast and run smoothly, ive tested this on a few devices and each one passed.超级急速流畅型： dalvik.vm.startheapsize=16m dalvik.vm.heapsize=48m dalvik.vm.execution-mode=int:jit dalvik.vm.dexopt-flags=v=n,o=v dalvik.vm.checkjni=false 常用稳定加流畅型： dalvik.vm.startheapsize=8m dalvik.vm.heapsize=40m dalvik.vm.execution-mode=int:fast dalvik.vm.dexopt-flags=m=y dalvik.vm.checkjni=false 超级稳定大内存型： dalvik.vm.startheapsize=4m dalvik.vm.heapsize=30m dalvik.vm.execution-mode=int:portable dalvik.vm.dexopt-flags=v=a,o=v dalvik.vm.verify-bytecode=true dalvik.vm.checkjni=true</code></pre><p>Dalvik虚拟机 Dalvik虚拟机是Android操作系统的核心，是一切应用程序的基础。</p><p>所有程序在运行时均有Dalvik虚拟机对其进行解析和执行。 </p><p>以下参数参加源码：platform/dalvik/kitkat-release/./vm/alloc/HeapSource.cpp</p><ul><li><p>dalvik.vm.heapstartsize</p><p>本参数控制Dalvik虚拟机在启动一个应用程序之后为其分配的初始堆栈大小，可填写的值为2m~48m。这里分配的内存容量会影响到整个系统对RAM的使用程度，和第一次使用应用程序时的流畅程序。这个值越大，系统消耗RAM则越快，但是应用程序打开后的反应也越快。值越小，系统的RAM剩余则越多，但是程序在启动后会很卡。它被转化为<code>-Xms</code>的选项。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">parseRuntimeOption("dalvik.vm.heapstartsize", heapstartsizeOptsBuf, "-Xms", "4m");</code></pre></li><li><p>dalvik.vm.heapsize</p><p>本参数控制单个Dalvik虚拟机可以分配到的最大堆栈量。这里分配的内存容量会影响到整个系统对RAM的使用程序，和程序在运行一段时间后的反应速度。这个值越大，系统消耗RAM则越快，但是程序会运行的非常稳定，尤其是游戏和视频程序的内容加载速度可以大幅度提升。值越小，系统的RAM剩余则越多，但是程序会很卡，尤其是游戏在切换场景Loading的时候会花费很多的时间。若应用程序需要使用超过这个值的内存时，将会触发系统的垃圾收集器，系统和程序就会卡顿。它被转化为<code>-Xmx</code>选项。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">parseRuntimeOption("dalvik.vm.heapsize", heapsizeOptsBuf, "-Xmx", "16m");</code></pre></li><li><p>dalvik.vm.heapgrowthlimit</p><p>它指定标准app的最大堆栈，如果在mainfest中设置Android:largeheap=”true”时，应用会使用最大内存，超过这个值会有  OOM产生。它被转化为<code>-XX:HeapGrowthLimit</code>选项。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">parseRuntimeOption("dalvik.vm.heapgrowthlimit", heapgrowthlimitOptsBuf, "-XX:HeapGrowthLimit=");</code></pre></li><li><p>dalvik.vm.heaptargetutilization</p><p>它为VM提供了关于应该允许托管堆满的程度的提示。它被转化为<code>-XX:HeapTargetUtilization</code>选项。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">parseRuntimeOption("dalvik.vm.heaptargetutilization",                         heaptargetutilizationOptsBuf,                         "-XX:HeapTargetUtilization=");</code></pre></li><li><p>dalvik.vm.heapminfree &amp; dalvik.vm.heapmaxfree</p><p>它们分别被转化为<code>-XX:HeapMinFree</code>和<code>-XX:HeapMaxFree</code>。它们与<code>-XX：HeapTargetUtilization</code>结合使用，以确定堆需要增长时堆的增长量。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">parseRuntimeOption("dalvik.vm.heapminfree", heapminfreeOptsBuf, "-XX:HeapMinFree=");parseRuntimeOption("dalvik.vm.heapmaxfree", heapmaxfreeOptsBuf, "-XX:HeapMaxFree=");</code></pre></li><li><p>dalvik.vm.lockprof.threshold： 本参数控制Dalvik虚拟机调试记录程序内部锁资源争夺的阈值，默认值是500。多用于程序的数据统计，对性能较调意义不大。 </p></li><li><p>dalvik.vm.stack-trace-file： 本参数控制Dalvik虚拟机的堆栈记录调试文件。用于系统调试，一般用户对其调整无意义。 </p></li><li><p>dalvik.vm.execution-mode： 本参数控制Dalvik虚拟机的程序执行机制。可填写的值有”int:portable”、”int:fast”和”int:jit”。 int:portable表示以兼容模式运行(脚本翻译模式)，此模式下程序的兼容性最高，但其执行效率最低(程序优化度依赖于dalvik虚拟机版本)。官方默认此模式。　int:fast表示以快速自优化模式运行(脚本翻译和预优化混合)，此模式下程序的兼容性很高，执行效率也比较高。因为此时dalvik虚拟机允许程序使用自己的预定义优化模式和代码(包括C/C++/汇编代码)。推荐使用。　int:jit表示以Just-In-Time模式运行(JIT模式)，此模式下程序的兼容性最差，但程序一旦加载后其运行效率最高(与C/C++直接编 写的程序效率无异)，因为在此模式下dalvik虚拟机会预先将Java程序翻译成针对机器平台的本地语言(Native)，同时完全允许代码中的所有预 优化和代码，允许所有不安全的非托管代码，同时不严谨的程序如果运行在JIT模式可能会造成内存泄露。但要注意，很多Dalvik虚拟机并不支持此模式 (如官方2.2)。 </p></li><li><p>dalvik.vm.dexopt-flags： 本参数控制Dalvik虚拟机的程序代码校验和优化。可填写的值有m、v和o。　m为标准选项，可以是m=y或m=n。若m=y则启用不安全代码的校验和托管代码的优化。兼容性和安全性最高，推荐使用。　v为校验选项，可与o并存。可以是v=a或v=n。若v=a则表示校验所有代码，v=n则关闭代码的校验。　o为优化选项，可与v并存。可以是o=v或o=a。若o=v则表示优化以校验过的代码，o=a则表示优化所有代码。　例如：　dalvik.vm.dexopt-flags=m=y　dalvik.vm.dexopt-flags=v=n,o=v 注意，这个参数只会影响到安装APK之后或初次使用APK时生成dex文件时有效。若整个系统(包括应用程序)为odex化，则无意义。 </p></li><li><p>dalvik.vm.verify-bytecode： 本参数控制Dalvik虚拟机是否验证应用程序的可执行代码。可以与上一个参数配合使用。可填写的值为true和false。　其具体意义与dalvik.vm.dexopt-flags的v=n一模一样。但可以与dalvik.vm.dexopt-flags配合使用以取得更好的效果。 例如：　dalvik.vm.dexopt-flags=v=n,o=v　dalvik.vm.verify-bytecode=false　这样可以令后来安装的apk文件可以被优化而不被检验。 </p></li><li><p>dalvik.vm.checkjni： 本参数控制Dalvik虚拟机在调用外部jni链接库的时候是否对其做安全性检验。可填写的值为true和false。　此参数会覆盖ro.kernel.android.checkjni。　若值为true，会增加程序的兼容性和稳定性，但也会增加其加载和执行的时间。 推荐为false。 dalvik.vm.deadlock-predict： 本参数控制Dalvik虚拟机对程序死锁预测处理。可填写的值有off、warn和err。　off表示关闭死锁预测功能(默认设置)。　warn表示在继续程序运行的同时只记录该死锁预测(如果为真死锁就会出现程序假死现象，然后等N久出现关闭)。　err表示预测到死锁时马上弹出FC。 注意：有些Dalvik虚拟机版本并不支持此参数。</p></li></ul><p>所以，如果设定：</p><p>dalvik.vm.heapstartsize=8m</p><p>dalvik.vm.heapgrowthlimit=64m</p><p>dalvik.vm.heapsize=256m</p><p>所以，每开启一个App，就会划出8m空间给它。如果使用过程超出8m，就会再次增加8m。但是只能增加7次空间，因为最大的空间为64m。超过了就会产生OOM。</p><p>由heapsize=256m，单个虚拟机分配的最大内存，相当于可以运行4个64m的应用。超过内存的部分就会进行内存回收，一方面是强制关闭一些应用，另一方面是加载新应用划分新的内存，这时候设备就会出现卡顿。</p><p>有些人喜欢用小widget，比如每个只占3-5m，如果按照8m去分配，每个小应用都会多浪费3m的内存。这种情况就可以把heapstartsize改小，可以增加可用内存。heapgrowthlimit倒不用改，因为现在应用使用内存整体都比较高。</p><p>内存分配流程</p><ol><li>首先判断一下需要申请的size是不是过大，如果申请的size超过了堆的最大限制，则转入步骤6</li><li>尝试分配，如果成功则返回，失败则转入步骤3</li><li>判断是否gc正在进行垃圾回收，如果正在进行则等待回收完成之后，尝试分配。如果成功则返回，失败则转入步骤4</li><li>自己启动gc进行垃圾回收，这里gcForMalloc的参数是false。所以不会回收软引用，回收完成后尝试分配，如果成功则返回，失败则转入步骤5</li><li>调用dvmHeapSourceAllocAndGrow尝试分配，这个函数会扩张堆。所以heap startup的时候可以给一个比较小的初始堆，实在不够用再调用它进行扩张</li><li>进入回收软引用阶段，这里gcForMalloc的参数是ture，所以需要回收软引用。然后调用dvmHeapSourceAllocAndGrow尝试分配，如果失败则抛出OOM。</li></ol><p>参数调整总结</p><pre class=" language-lang-txt"><code class="language-lang-txt">dalvik.vm.heapstartsize  堆分配的初始大小，调整这个值会影响到应用的流畅性和整体ram消耗。这个值越小，系统ram消耗越慢，但是由于初始值较小，一些较大的应用需要扩张这个堆，从而引发gc和堆调整的策略，会应用反应更慢。相反，这个值越大系统ram消耗越快，但是程序更流畅。dalvik.vm.heapgrowthlimit       极限堆大小，dvm heap是可增长的，但是正常情况下dvm heap的大小是不会超过dalvik.vm.heapgrowthlimit的值。如果受控的应用dvm heap size超过该值，则将引发oom。dalvik.vm.heapsize使用大堆时，极限堆大小。一旦dalvik heap size超过这个值，直接引发oom。在android开发中，如果要使用大堆，需要在manifest中指定android:largeHeap为true。这样dvm heap最大可达dalvik.vm.heapsize。[dalvik.vm.heaptargetutilization]: [0.75]   可以设定内存利用率的百分比，当实际的利用率偏离这个百分比的时候，虚拟机会在GC的时候调整堆内存大小，让实际占用率向个百分比靠拢。</code></pre><p><strong>dalvim GC策略是：</strong></p><p>1.在一次GC后，根据当前Heap中已分配的内存大小除以dalvik.vm.heaputilization(0.75),得到一个目标值。</p><p>2.如果目标值不在（已分配的值+dalvik.vm.heapminfree）到（已分配的值+dalvik.vm.heapmaxfree）这个区间，即取区间边界值做为目标值(运行一段时间后第1步得到的目标值肯定会超过这个范围)。</p><p>3.虚拟机记录这个目标值，当做当前允许总的可以分配到的内存。同时根据目标值减去固定值（200~500K),当做触发GC_CONCURRENT事件的阈值。</p><p>4.当下一次分配内存，分配成功时。重新计算已分配的内存大小；若有达到GC_CONCURRENT的阈值，则产生GC。</p><p>5.当下一次分配内存，开始分配失败时。则会产生GC_FOR_ALLOC事件，释放内存；然后再尝试分配。</p><p>可以通过调整dalvik.vm.heapminfree 和dalvik.vm.heapmaxfree属性的值，减少GC_FOR_ALLOC和GC_CONCURRENT的次数，如果这两个值设置的过大，则会导致一次GC的时间过长，从而会看到明显的卡顿现象，设置的值既要使GC的次数减少，也不能是一次GC的时间过长。</p><p>  在有的平台上，可以通过代码对单个应用的dalvik的属性进行设置，以减少对全局设置对系统的影响，可以再App里面通过如下的方式对当前的App的dalvik属性设置：</p><pre class=" language-lang-java"><code class="language-lang-java">import dalvik.system.VMRuntime;  import android.os.SystemProperties;  ...  VMRuntime.getRuntime().setTargetHeapUtilization(0.75f);  VMRuntime.getRuntime().setTargetHeapMinFree(2*1024*1024);  VMRuntime.getRuntime().setTargetHeapConcurrentStart(8*1024*1024);  ...</code></pre><p>如果想通过系统进行控制，也可以在framework里面的ActivityThread的handleBindApplication函数里面进行设置：</p><pre class=" language-lang-java"><code class="language-lang-java">import dalvik.system.VMRuntime;  import android.os.SystemProperties;  import java.lang.*;  ...  if( data.processName.equals("com.android.launcher")) {  VMRuntime.getRuntime().setTargetHeapUtilization(0.75f);      VMRuntime.getRuntime().setTargetHeapMinFree(2*1024*1024);      VMRuntime.getRuntime().setTargetHeapConcurrentStart(8*1024*1024);  }  ...</code></pre>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> dalvik </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Android] 后台任务系列之JobScheduler</title>
      <link href="/2019/02/09/%5BAndroid%5DBackground-task-Jobscheduler/"/>
      <url>/2019/02/09/%5BAndroid%5DBackground-task-Jobscheduler/</url>
      
        <content type="html"><![CDATA[<p>上次分析<a href="http://wossoneri.github.io/2019/11/08/[Android][Framework]AndroidO-Broadcast-Limit/">Android O广播的问题</a>遗留了一个东西没提，那就是官方推荐使用的<code>JobScheduler</code>。这篇就简单了解一下这是个什么东西。</p><h1 id="JobScheduler是什么"><a href="#JobScheduler是什么" class="headerlink" title="JobScheduler是什么"></a>JobScheduler是什么</h1><p><code>JobScheduler</code>允许开发者创建在后台执行的job，当预置的条件被满足时，这些Job将会在后台被执行。</p><p>在Android开发中，我们会遇到很多这样的情况，比如在未来的某个时间点或者未来满足某种条件(比如插入电源或者连接WiFi)的情况下下去执行一些操作。在Android L上，Google提供了一个叫做<code>JobScheduler</code>的组件来帮助我们处理这种情况。</p><p><code>JobScheduler</code> Api可以在我们的App中执行一些操作，这些操作将会在我们预置的一些条件被满足的时候被执行。和<code>AlarmManager</code>不一样，执行这些操作的时间并不是严格准确的。  <code>JobScheduler</code>会把一系列的job收集起来一起执行，这样既允许我们的job被执行，又能兼顾到手机电量的使用情况，达到节电的目的。</p><h1 id="JobScheduler怎么用"><a href="#JobScheduler怎么用" class="headerlink" title="JobScheduler怎么用"></a>JobScheduler怎么用</h1><p>JobScheduler的使用非常简单，只需要三步：</p><ul><li>创建JobService类</li><li>创建JobInfo，通过builder设定Job的执行选项</li><li>获取JobScheduler服务执行任务</li></ul><p>下面按照这三步放一个简单代码示例。</p><h2 id="JobService"><a href="#JobService" class="headerlink" title="JobService"></a>JobService</h2><p><code>JobService</code>的作用是，在<code>JobScheduler</code>监测到系统状态达到对应启动条件时，会启动<code>JobService</code>执行任务。所以我们需要继承<code>JobService</code>创建一个自己的service，然后实现<code>onStartJob</code>和<code>onStopJob</code>这两个方法。</p><pre class=" language-lang-java"><code class="language-lang-java">public class JobSchedulerService extends JobService {    private static final int MESSAGE_ID = 100;    private Handler mJobHandler = new Handler(new Handler.Callback() {        @Override        public boolean handleMessage(Message msg) {            Log.i("WOW", "handle message!!!!");            //请注意，我们手动调用了jobFinished方法。            //当onStartJob返回true的时候，我们必须在合适时机手动调用jobFinished方法            //否则该应用中的其他job将不会被执行            jobFinished((JobParameters) msg.obj, false);            //第一个参数JobParameter来自于onStartJob(JobParameters params)中的params，            // 这也说明了如果我们想要在onStartJob中执行异步操作，必须要保存下来这个JobParameter。            return true;        }    });    // JobService运行在主线程 需要另外开启线程做耗时工作    @Override    public boolean onStartJob(JobParameters params) {        Log.i("WOW", "onStartJob");        // 注意到我们在使用Hanlder的时候把传进来的JobParameters保存下来了        mJobHandler.sendMessage(Message.obtain(mJobHandler, MESSAGE_ID, params));        // 返回false说明job已经完成  不是个耗时的任务        // 返回true说明job在异步执行  需要手动调用jobFinished告诉系统job完成        // 这里我们返回了true,因为我们要做耗时操作。        // 返回true意味着耗时操作花费的事件比onStartJob执行的事件更长        // 并且意味着我们会手动的调用jobFinished方法        return true;    }    @Override    public boolean onStopJob(JobParameters params) {        Log.i("WOW", "onStopJob");        mJobHandler.removeMessages(MESSAGE_ID);        // 当系统收到一个cancel job的请求时，并且这个job仍然在执行(onStartJob返回true)，系统就会调用onStopJob方法。        // 但不管是否调用onStopJob，系统只要收到取消请求，都会取消该job        // true 需要重试        // false 不再重试 丢弃job        return false;    }</code></pre><p>然后在Manifest文件给service添加一个权限</p><pre class=" language-lang-xml"><code class="language-lang-xml"><service android:name=".JobSchedulerService"         android:permission="android.permission.BIND_JOB_SERVICE" /></code></pre><h2 id="JobInfo"><a href="#JobInfo" class="headerlink" title="JobInfo"></a>JobInfo</h2><p><code>JobInfo</code>是对任务的描述，比如说需要监听哪些状态、重试策略、任务执行时间、是否持久化等等。 <code>JobInfo.Builder</code>的构造函数需要传入一个<code>jobId</code>，是<code>Job</code>的唯一标志，后续通过该<code>jobId</code>来取消<code>Job</code>。 通过<code>Builder</code>模式构造<code>JobInfo</code>。</p><pre class=" language-lang-java"><code class="language-lang-java">//Builder构造方法接收两个参数，第一个参数是jobId，每个app或者说uid下不同的Job,它的jobId必须是不同的//第二个参数是我们自定义的JobService,系统会回调我们自定义的JobService中的onStartJob和onStopJob方法JobInfo.Builder builder = new JobInfo.Builder(JOB_ID,                             new ComponentName(this, JobSchedulerService.class));builder.setMinimumLatency(2000) // 2s后执行       .setOverrideDeadline(10000); // 最晚10s后执行</code></pre><h2 id="JobScheduler"><a href="#JobScheduler" class="headerlink" title="JobScheduler"></a>JobScheduler</h2><p>通过服务获取<code>JobScheduler</code>执行任务即可。</p><pre class=" language-lang-java"><code class="language-lang-java">JobScheduler mJobScheduler = (JobScheduler) getSystemService(Context.JOB_SCHEDULER_SERVICE);int result = mJobScheduler.schedule(builder.build());if (result <= 0) {  Log.i("WOW", "result is " + result + " Schedule failed");}</code></pre><h1 id="JobScheduler-API详解"><a href="#JobScheduler-API详解" class="headerlink" title="JobScheduler API详解"></a>JobScheduler API详解</h1><h2 id="JobService细节"><a href="#JobService细节" class="headerlink" title="JobService细节"></a>JobService细节</h2><p>在前面的代码注释已经有所说明</p><p>启动任务之后，会调用onStartJob方法，因为JobService运行在主线程，所以如果在任务开始时，如果要执行耗时的操作，就需要创建一个线程去做。</p><p>如果onStartJob执行的是不耗时的任务，就可以返回false，表示任务执行结束。</p><p>如果onStartJob起了一个线程执行耗时任务，就要返回true，表示任务还在执行，需要等任务真正结束后手动调用JobFinished()方法告诉系统任务已经结束。</p><h2 id="JobInfo细节"><a href="#JobInfo细节" class="headerlink" title="JobInfo细节"></a>JobInfo细节</h2><pre class=" language-lang-java"><code class="language-lang-java">JobInfo job=new JobInfo.Builder(i,componentName).setMinimumLatency(5000)//最小延时 5秒.setOverrideDeadline(60000).setRequiredNetworkType(JobInfo.NETWORK_TYPE_ANY)//任意网络.setMinimumLatency(5000)//5秒 最小延时、.setOverrideDeadline(60000)//maximum最多执行时间  .setRequiredNetworkType(JobInfo.NETWORK_TYPE_UNMETERED)//免费的网络---wifi 蓝牙 USB.setRequiredNetworkType(JobInfo.NETWORK_TYPE_ANY)//任意网络---  /**   设置重试/退避策略，当一个任务调度失败的时候执行什么样的测量采取重试。    initialBackoffMillis:第一次尝试重试的等待时间间隔ms    *backoffPolicy:对应的退避策略。比如等待的间隔呈指数增长。    */.setBackoffCriteria(long initialBackoffMillis, int backoffPolicy).setBackoffCriteria(JobInfo.MAX_BACKOFF_DELAY_MILLIS, JobInfo.BACKOFF_POLICY_LINEAR).setPeriodic (long intervalMillis)//设置执行周期，每隔一段时间间隔任务最多可以执行一次。.setPeriodic(long intervalMillis,long flexMillis)//在周期执行的末端有一个flexMiliis长度的窗口期，任务就可以在这个窗口期执行。 //设置设备重启后，这个任务是否还要保留。需要权限：  RECEIVE_BOOT_COMPLETED.setPersisted(boolean isPersisted);.setRequiresCharging(boolean )//是否需要充电.setRequiresDeviceIdle(boolean)//是否需要等设备出于空闲状态的时候.addTriggerContentUri(uri)//监听uri对应的数据发生改变，就会触发任务的执行。.setTriggerContentMaxDelay(long duration)//设置Content发生变化一直到任务被执行中间的最大延迟时间//设置Content发生变化一直到任务被执行中间的延迟。如果在这个延迟时间内content发生了改变，延迟时间会重写计算。.setTriggerContentUpdateDelay(long durationMilimms)</code></pre><p>需要注意的是</p><p><code>setRequiredNetworkType(int networkType)</code>,<code>setRequiresCharging(boolean requireCharging)</code>,<code>setRequiresDeviceIdle(boolean requireIdle)</code></p><p>这几个方法可能会使得你的任务无法执行，除非调用setOverrideDeadline(long time)设置了最大延迟时间，使得你的任务在为满足条件的情况下也会被执行。</p><p><code>setMinimumLatency(long minLatencyMillis)</code>：这个方法指定我们的Job至少要多少毫秒之后执行，比如<code>setMinimumLatency(5000)</code>,就表明我们这是了这个JobScheduler之后，这个Job至少要5秒之后执行，前五秒肯定是不会执行的。这个参数和<code>setPeriodic</code>互斥。两个同时设置会抛出异常。</p><p><code>setRequiredNetworkType(int networkType)</code>:来启动我们这个Job时所需要的网络类型，一共有三个值<code>JobInfo.NETWORK_TYPE_NONE</code>表明启动我们这个Job时不需要任何的网络连接；<code>JobInfo.NETWORK_TYPE_ANY</code>表明启动我们这个Job时只要连着网就可以，不要求网络类型。<code>JobInfo.NETWORK_TYPE_UNMETERED</code>表明启动我们这个Job时需要连接Wifi.</p><h2 id="Android-O-对JobScheduler的改进"><a href="#Android-O-对JobScheduler的改进" class="headerlink" title="Android O 对JobScheduler的改进"></a>Android O 对JobScheduler的改进</h2><ul><li><p>您现在可以将工作队列与计划作业关联。要将一个工作项添加到作业的队列中，请调用 <a href="https://developer.android.com/reference/android/app/job/JobScheduler.html#enqueue(android.app.job.JobInfo,%20android.app.job.JobWorkItem" target="_blank" rel="noopener"><code>JobScheduler.enqueue()</code></a>)。当作业运行时，它可以将待定工作从队列中剥离并进行处理。这种功能可以处理之前需要启动后台服务（尤其是实现 <code>IntentService</code> 的服务）的许多用例。</p></li><li><p>您现在可以通过调用 <a href="https://developer.android.com/reference/android/app/job/JobInfo.Builder.html#setClipData(android.content.ClipData,%20int" target="_blank" rel="noopener"><code>JobInfo.Builder.setClipData()</code></a>) 的方式将 <code>ClipData</code> 与作业关联。利用此选项，您可以将 URI 权限授予与作业关联，类似于这些权限传递到 <code>Context.startService()</code> 的方式。您也可以将 URI 权限授予用于工作队列上的 intent。</p></li><li><p>计划作业现在支持多个新的约束条件：</p><ul><li><p><a href="https://developer.android.com/reference/android/app/job/JobInfo.html#isRequireStorageNotLow(" target="_blank" rel="noopener"><code>JobInfo.isRequireStorageNotLow()</code></a>)</p><p>如果设备的可用存储空间非常低，作业将不会运行。</p></li><li><p><a href="https://developer.android.com/reference/android/app/job/JobInfo.html#isRequireBatteryNotLow(" target="_blank" rel="noopener"><code>JobInfo.isRequireBatteryNotLow()</code></a>)</p><p>如果电池电量等于或低于临界阈值，作业将不会运行；临界阈值是指设备显示 <strong>Low battery warning</strong> 系统对话框的电量。</p></li><li><p><a href="https://developer.android.com/reference/android/app/job/JobInfo.html#NETWORK_TYPE_METERED" target="_blank" rel="noopener"><code>NETWORK_TYPE_METERED</code></a></p><p>作业需要一个按流量计费的网络连接，比如大多数移动数据网络数据套餐。</p></li></ul></li></ul><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="JobSchedulerService启动"><a href="#JobSchedulerService启动" class="headerlink" title="JobSchedulerService启动"></a>JobSchedulerService启动</h2><p>首先因为知道JobScheduler是通过系统服务拿到的：</p><pre class=" language-lang-java"><code class="language-lang-java">(JobScheduler) getSystemService(Context.JOB_SCHEDULER_SERVICE);</code></pre><p>所以可以想到，Android启动时所有的系统服务都是在SystemServer里启动：</p><pre class=" language-lang-java"><code class="language-lang-java">//frameworks/base/services/java/com/android/server/SystemServer.javamSystemServiceManager.startService(JobSchedulerService.class);</code></pre><p>于是代码进入JobSchedulerService.java</p><pre class=" language-lang-java"><code class="language-lang-java">//frameworks/base/services/core/java/com/android/server/job/JobSchedulerService.javapublic final class JobSchedulerService extends com.android.server.SystemService              implements StateChangedListener, JobCompletedListener {</code></pre><p>官方代码注释里有一句说明：</p><blockquote><p>The JobSchedulerService knows nothing about constraints, or the state of active jobs. It receives callbacks from the various controllers and completed jobs and operates accordingly.</p></blockquote><p>就是<code>JobSchedulerService</code>对Job的状态和约束都不了解，完全是通过各种controller的回调去处理各种Job。</p><p>然后我们看其构造函数</p><pre class=" language-lang-java"><code class="language-lang-java">public JobSchedulerService(Context context) {  super(context);  // 先创建在主线程的JobHandler  mHandler = new JobHandler(context.getMainLooper());  mConstants = new Constants(mHandler);  // binder服务端  mJobSchedulerStub = new JobSchedulerStub();  mJobs = JobStore.initAndGet(this);  // Create the controllers.  mControllers = new ArrayList<StateController>();  mControllers.add(ConnectivityController.get(this));  mControllers.add(TimeController.get(this));  mControllers.add(IdleController.get(this));  mControllers.add(BatteryController.get(this));  mControllers.add(AppIdleController.get(this));  mControllers.add(ContentObserverController.get(this));  mControllers.add(DeviceIdleJobsController.get(this));}</code></pre><h3 id="JobHandler"><a href="#JobHandler" class="headerlink" title="JobHandler"></a>JobHandler</h3><p>是一个在主线程运行的Handler，主要处理四个消息。</p><pre class=" language-lang-java"><code class="language-lang-java">private class JobHandler extends Handler {  public JobHandler(Looper looper) {    super(looper);  }  @Override  public void handleMessage(Message message) {    synchronized (mLock) {      if (!mReadyToRock) {        return;      }    }    switch (message.what) {      case MSG_JOB_EXPIRED:                ...        break;      case MSG_CHECK_JOB:                ...        break;      case MSG_CHECK_JOB_GREEDY:                ...        break;      case MSG_STOP_JOB:                ...        break;    }    maybeRunPendingJobsH();    // Don't remove JOB_EXPIRED in case one came along while processing the queue.    removeMessages(MSG_CHECK_JOB);  }  ...}</code></pre><h3 id="Constants"><a href="#Constants" class="headerlink" title="Constants"></a>Constants</h3><p>这里面定义了一些与系统全局设置保持同步的常量。 这一类或其任何域的访问应该同时持有JobSchedulerService.mLock锁来完成。</p><pre class=" language-lang-java"><code class="language-lang-java">private final class Constants extends ContentObserver {}</code></pre><h3 id="JobSchedulerStub"><a href="#JobSchedulerStub" class="headerlink" title="JobSchedulerStub"></a>JobSchedulerStub</h3><p>JobSchedulerStub作为实现接口IJobScheduler的binder服务端。</p><pre class=" language-lang-java"><code class="language-lang-java">final class JobSchedulerStub extends IJobScheduler.Stub {}</code></pre><h3 id="JobStore-initAndGet"><a href="#JobStore-initAndGet" class="headerlink" title="JobStore.initAndGet"></a>JobStore.initAndGet</h3><p>这个方法是创建了一个JobStore的单例由JobSchedulerService使用。</p><pre class=" language-lang-java"><code class="language-lang-java">// frameworks/base/services/core/java/com/android/server/job/JobStore.java/** Used by the {@link JobSchedulerService} to instantiate the JobStore. */static JobStore initAndGet(JobSchedulerService jobManagerService) {  synchronized (sSingletonLock) {    if (sSingleton == null) {      sSingleton = new JobStore(jobManagerService.getContext(),                                jobManagerService.getLock(),                                     Environment.getDataDirectory());    }    return sSingleton;  }}</code></pre><h3 id="JobStore"><a href="#JobStore" class="headerlink" title="JobStore"></a>JobStore</h3><p>该类的作用是维护作业计划程序正在跟踪的作业主列表。 这些作业通过引用进行比较，因此此类中的任何函数都不应复制。 还处理持久作业的读/写。</p><p>创建一个JobStore实例，进行从磁盘读取文件。该方法会创建job目录以及jobs.xml文件, 以及从文件中读取所有的JobStatus。</p><pre class=" language-lang-java"><code class="language-lang-java">private JobStore(Context context, Object lock, File dataDir) {  mLock = lock;  mContext = context;  mDirtyOperations = 0;  File systemDir = new File(dataDir, "system");  File jobDir = new File(systemDir, "job");  jobDir.mkdirs();  // 创建/data/system/job/jobs.xml  mJobsFile = new AtomicFile(new File(jobDir, "jobs.xml"));  mJobSet = new JobSet();  readJobMapFromDisk(mJobSet);}</code></pre><p>readJobMapFromDisk方法从磁盘读取Job信息，先看一下Job.xml文件结构</p><pre class=" language-lang-xml"><code class="language-lang-xml"><job-info version="0"><job jobid="101" package="con.chico.dong.test"   class="com.chico.dong.test.TimingJobService"   sourcePackageName="com.chico.dong.test"   sourceUserId="0"  uid="10090"   priority="0"  flags="0">  <constraints connectivity="true"/>  <periodic period="86400000" flex="86400000" deadline="1531466690997" delay="1531380290997"/>  <extras/></job></job-info></code></pre><p>可以看出这个xml中主要记录了每一个Job的jobid, JobService的名字，包名，以及触发该Job的一些条件信息。</p><p>对于xml解析就不分析了，这个思路都一样的，就是流程上是从xml中读取job的信息，然后利用这些信息创建<code>JobStatus</code>, <code>JobStatus</code>对象包含了JobInfo信息（Jobid，package，class），还有该Job的delay，deadline信息，用于schedule。JobStatus添加到mJobSet。</p><h3 id="StateController"><a href="#StateController" class="headerlink" title="StateController"></a>StateController</h3><p>构造函数还创建了7个StateController：</p><div class="table-container"><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>ConnectivityController</td><td>注册监听网络连接状态的广播</td></tr><tr><td>TimeController</td><td>注册监听job时间到期的广播</td></tr><tr><td>IdleController</td><td>注册监听屏幕亮/灭,dream进入/退出,状态改变的广播</td></tr><tr><td>BatteryController</td><td>注册监听电池是否充电,电量状态的广播</td></tr><tr><td>AppIdleController</td><td>监听app是否空闲</td></tr><tr><td>ContentObserverController</td><td>通过ContentObserver监测content URIs的变化</td></tr><tr><td>DeviceIdleJobsController</td><td>根据doze状态为app设置约束。</td></tr></tbody></table></div><p>前面提到过，<code>JobSchedulerService</code>是根据这些controller的回调处理Job的，所以简单看一下ConnectivityController</p><pre class=" language-lang-java"><code class="language-lang-java">public interface StateChangedListener {    public void onControllerStateChanged();    public void onRunJobNow(JobStatus jobStatus);    public void onDeviceIdleStateChanged(boolean deviceIdle);}public abstract class StateController {    protected static final boolean DEBUG = JobSchedulerService.DEBUG;    protected final Context mContext;    protected final Object mLock;    protected final StateChangedListener mStateChangedListener;    public StateController(StateChangedListener stateChangedListener, Context context,            Object lock) {        mStateChangedListener = stateChangedListener;        mContext = context;        mLock = lock;    }    public abstract void maybeStartTrackingJobLocked(JobStatus jobStatus, JobStatus lastJob);    public void prepareForExecutionLocked(JobStatus jobStatus) {}    public abstract void maybeStopTrackingJobLocked(JobStatus jobStatus, JobStatus incomingJob, boolean forUpdate);    public void rescheduleForFailure(JobStatus newJob, JobStatus failureToReschedule) {}    public abstract void dumpControllerStateLocked(PrintWriter pw, int filterUid);}</code></pre><pre class=" language-lang-java"><code class="language-lang-java">public class ConnectivityController extends StateController implements ConnectivityManager.OnNetworkActiveListener {    public static ConnectivityController get(JobSchedulerService jms) {        synchronized (sCreationLock) {            if (mSingleton == null) {                //单例模式                mSingleton = new ConnectivityController(jms, jms.getContext());            }            return mSingleton;        }    }    private ConnectivityController(StateChangedListener stateChangedListener, Context context) {        super(stateChangedListener, context);        //注册监听网络连接状态的广播，且采用BackgroundThread线程        IntentFilter intentFilter = new IntentFilter();        intentFilter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);        mContext.registerReceiverAsUser(                mConnectivityChangedReceiver, UserHandle.ALL, intentFilter, null,                BackgroundThread.getHandler());        ConnectivityService cs =                (ConnectivityService)ServiceManager.getService(Context.CONNECTIVITY_SERVICE);        if (cs != null) {            if (cs.getActiveNetworkInfo() != null) {                mNetworkConnected = cs.getActiveNetworkInfo().isConnected();            }            mNetworkUnmetered = mNetworkConnected && !cs.isActiveNetworkMetered();        }    }}</code></pre><p>所以可以知道，Android O以后禁止了一些广播的发送后，都是由这些Controller进行动态注册广播，由这些controller转交给JobScheduler进行处理。</p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h1 id="对遗留问题的说明"><a href="#对遗留问题的说明" class="headerlink" title="对遗留问题的说明"></a>对遗留问题的说明</h1><p>所以很明显，Android Framework对JobInfo已经设计好一些状态处理，比如说网络变化。所以这样不再用广播吊起更多App而引起性能问题了。</p><p>Ref</p><p><a href="https://www.jianshu.com/p/caed2a5966fe" target="_blank" rel="noopener">https://www.jianshu.com/p/caed2a5966fe</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 后台任务 </tag>
            
            <tag> JobScheduler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Android] Android O 广播限制</title>
      <link href="/2019/02/08/%5BAndroid%5D%5BFramework%5DAndroidO-Broadcast-Limit/"/>
      <url>/2019/02/08/%5BAndroid%5D%5BFramework%5DAndroidO-Broadcast-Limit/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>因为项目需要迁移到8.0平台，发现有一个系统应用打不开，从log发现如下描述：</p><pre class=" language-lang-shell"><code class="language-lang-shell">BroadcastQueue: Background execution not allowed: receiving Intent {...}</code></pre><p>实际上，在Android O，像下面的隐式广播都不再起作用：</p><pre class=" language-lang-java"><code class="language-lang-java">sendBroadcast(new Intent("this.is.an.implicit.broadcast"));</code></pre><p>通常来讲，这个广播会被所有注册这个action的receiver接收到。即便是在Android O版本，还有两类receiver仍然会接收这个广播：</p><ol><li>targetSdkVersion &lt;= 25的应用</li><li>通过registerReceiver()注册的并有已经启动的进程的应用</li></ol><p>但是通过Manifest文件静态注册的BroadcastReceiver是不会接收这个广播的，反而会打印出一些开头提到的log</p><pre class=" language-lang-shell"><code class="language-lang-shell">W/BroadcastQueue: Background execution not allowed: receiving Intent { act=android.intent.action.PACKAGE_REMOVED dat=package:com.commonsware.cwac.cam2.demo flg=0x4000010 (has extras) } to com.commonsware.android.sysevents.pkg/.OnPackageChangeReceiver</code></pre><h1 id="症结"><a href="#症结" class="headerlink" title="症结"></a>症结</h1><p>这个问题看起来可能与电池有关，因为自从Android 6.0中引入Doze模式以来，各种后台处理会引起类似现象。但事实上，电池问题是次要的，真正的原因是进程混乱。</p><p>对此谷歌工程师是这样反馈的：</p><blockquote><p>为了帮助了解发生了什么，我需要澄清一下，此更改的目的并不直接与电池使用有关，而是要解决平台中长期存在的问题：处于内存压力下的设备可能会进入错误的内存抖动状态。这些状态通常是由于广播引起的：某些广播或广播的发送相对频繁，许多应用程序正在通过清单进行监听（因此需要启动以接收它），但是没有足够的RAM来保留所有状态这些应用程序的进程在缓存中进行处理，因此，每次发送广播时，系统最终都会不断地在各个进程中进行跳动。无论设备当前是否已接通电源，这都是一个问题。实际上，这在Android TV设备（始终插上电源）上可能经常会成为问题，因为它们的RAM往往很紧！</p></blockquote><p>这就好理解了，尤其是很多开发者为了唤醒自己的app，注册了非常多的静态广播（我看过喜马拉雅注册了100多个静态广播，毫无下限），每当系统发送一个广播时，就会出现唤醒很多app的情况，又因为系统内存有限，启动一些app后另一些app又被杀掉。这样不仅耗电，还影响使用性能。</p><h1 id="Android-O-广播限制"><a href="#Android-O-广播限制" class="headerlink" title="Android O 广播限制"></a>Android O 广播限制</h1><p>如果应用注册了BroadcastReceiver，则每次发送广播的时候，应用的BroadcastReceiver都会消耗资源。如果多个应用注册了接收基于系统事件的广播，就会出现，触发广播的系统事件会导致所有应用快速的连续消耗资源，从而降低用户体验。为了缓解这个问题，Android N对广播施加了一些限制，而Android O让这些限制更加严格。</p><h2 id="Android-N做的限制"><a href="#Android-N做的限制" class="headerlink" title="Android N做的限制"></a>Android N做的限制</h2><ul><li>Android 7.0 及其更高版本不再接收 <code>CONNECTIVITY_ACTION</code> 的静态广播（在清单注册的receiver）。但是如果是通过 <code>Context.registerReceiver()</code> 注册的动态广播，相关BroadcastReceiver还是可以接收到 <code>CONNECTIVITY_ACTION</code> 广播。</li><li>应用无法再发送或者接收 <code>ACTION_NEW_PICTURE</code> 或 <code>ACTION_NEW_VIDEO</code> 广播了。这项优化影响所有的App，不只是针对Android 7.0。</li></ul><h2 id="Android-O进一步的限制"><a href="#Android-O进一步的限制" class="headerlink" title="Android O进一步的限制"></a>Android O进一步的限制</h2><ul><li><p>在Android 8.0 或更高版本的应用无法继续在其AndroidManifest中为隐式广播注册BroadcastReceiver。 <em>隐式广播</em>是一种不专门针对该应用的广播。 例如，<code>ACTION_PACKAGE_REPLACED</code> 就是一种隐式广播，因为该广播将被发送给所有已注册侦听器，让后者知道设备上的某些软件包已被替换。 不过，<code>ACTION_MY_PACKAGE_REPLACED</code> 不是隐式广播，因为不管已为该广播注册侦听器的其他应用有多少，它都会只被发送给软件包已被替换的应用。</p></li><li><p>应用可以继续在它们的清单中注册显式广播。</p></li><li>应用可以在运行时使用 <code>Context.registerReceiver()</code> 为任意广播（不管是隐式还是显式）注册接收器。</li><li>需要<a href="https://developer.android.com/guide/topics/manifest/permission-element.html#plevel" target="_blank" rel="noopener">签名权限</a>的广播不受此限制所限，因为这些广播只会发送到使用相同证书签名的应用，而不是发送到设备上的所有应用。</li></ul><p>在许多情况下，之前注册隐式广播的应用使用 <code>JobScheduler</code> 作业可以获得类似的功能。 例如，一款社交照片应用可能需要不时地执行数据清理，并且倾向于在设备连接到充电器时执行此操作。 之前，应用已经在清单中为 <code>ACTION_POWER_CONNECTED</code> 注册了一个接收器；当应用接收到该广播时，它会检查清理是否必要。 为了迁移到 Android 8.0 或更高版本，应用将该接收器从其清单中移除。 应用将清理作业安排在设备处于空闲状态和充电时运行。</p><h2 id="例外的隐式广播"><a href="#例外的隐式广播" class="headerlink" title="例外的隐式广播"></a>例外的隐式广播</h2><p>很多隐式广播当前已不受此限制所限。 应用可以继续在其清单中为这些广播注册接收器，不管应用适配哪个 API 级别。 </p><blockquote><p>注意：即使这些隐式广播仍然可以在后台工作，但你应该尽量避免对它们注册监听。</p></blockquote><ul><li><p><strong>ACTION_LOCKED_BOOT_COMPLETED，ACTION_BOOT_COMPLETED</strong></p><p>因为这些广播只在开机时发送一次，并且很多app需要接收这个广播来安排作业等操作。</p></li><li><p><strong>ACTION_USER_INITIALIZE，”android.intent.action.USER_ADDED”，”android.intent.action.USER_REMOVED”</strong></p><p>这些广播被privileged权限所保护，大多数普通app并收不到这些广播。</p></li><li><p><strong>“android.intent.action.TIME_SET”， ACTION_TIMEZONE_CHANGED， ACTION_NEXT_ALARM_CLOCK_CHANGED</strong></p><p>当时间、时区或闹钟有变化时，时钟应用会需要接收这些广播以更新时钟。</p></li><li><p><strong>ACTION_LOCALE_CHANGED</strong></p><p>这个广播只会在定位变化的时候发送，并不会很频繁。有些应用会需要这些定位变化来更新数据。</p></li><li><p><strong>ACTION_USB_ACCESSORY_ATTACHED，ACTION_USB_ACCESSORY_DETACHED，ACTION_USB_DEVICE_ATTACHED，ACTION_USB_DEVICE_DETACHED</strong></p><p>如果应用程序需要了解这些与USB相关的事件，那么除了注册广播之外，目前没有其他好的选择。</p></li><li><p><strong>ACTION_CONNECTION_STATE_CHANGED，ACTION_CONNECTION_STATE_CHANGED，ACTION_ACL_CONNECTED，ACTION_ACL_DISCONNECTED</strong></p><p>如果应用收到这些蓝牙事件的广播，则用户体验不太可能会受到影响。</p></li><li><p><strong>ACTION_CARRIER_CONFIG_CHANGED，TelephonyIntents.ACTION_SUBSCRIPTION_CHANGED，TelephonyIntents.SECRET_CODE_ACTION，ACTION_PHONE_STATE_CHANGED，ACTION_PHONE_ACCOUNT_REGISTERED，ACTION_PHONE_ACCOUNT_UNREGISTERED</strong></p><p>OEM电话应用程序可能需要接收这些广播。</p></li><li><p><strong>LOGIN_ACCOUNTS_CHANGED_ACTION</strong></p><p>一些应用程序需要了解登录帐户的更改，以便它们可以为新帐户和更改的帐户设置计划的操作。</p></li><li><p><strong>ACTION_ACCOUNT_REMOVED</strong></p><p>拥有帐户可见性的应用在删除帐户后会收到此广播。 如果这是应用程序需要执行的唯一帐户更改，则强烈建议应用程序使用此广播，而不要使用不建议使用的<code>LOGIN_ACCOUNTS_CHANGED_ACTION</code>。</p></li><li><p><strong>ACTION_PACKAGE_DATA_CLEARED</strong></p><p>仅当用户从“设置”中明确清除其数据时才发送，因此广播接收器不太可能严重影响用户体验。</p></li><li><p><strong>ACTION_PACKAGE_FULLY_REMOVED</strong></p><p>某些应用可能需要在删除另一个软件包后更新其存储的数据； 对于这些应用，没有什么好办法可以注册此广播。</p><blockquote><p><strong>Note:</strong> <em>其他</em>与包相关的广播（例如，ACTION_PACKAGE_REPLACED）不受新限制。 这些广播非常普遍，因此可能会对性能产生影响，因此将其排除在外。</p></blockquote></li><li><p><strong>ACTION_NEW_OUTGOING_CALL</strong></p><p>响应用户发出呼叫而采取行动的应用需要接收此广播。</p></li><li><p><strong>ACTION_DEVICE_OWNER_CHANGED</strong></p><p>该广播不是经常发送； 一些应用程序需要接收它，以便他们知道设备的安全状态已更改。</p></li><li><p><strong>ACTION_EVENT_REMINDER</strong></p><p>由calendar provider发送，以将事件提醒发布到日历应用程序。 由于日历提供程序不知道日历应用程序是什么，因此此广播必须是隐式的。</p></li><li><p><strong>ACTION_MEDIA_MOUNTED，ACTION_MEDIA_CHECKING，ACTION_MEDIA_UNMOUNTED，ACTION_MEDIA_EJECT，ACTION_MEDIA_UNMOUNTABLE，ACTION_MEDIA_REMOVED，ACTION_MEDIA_BAD_REMOVAL</strong></p><p>这些广播是由于用户与设备的物理交互（安装或删除存储卷）或作为启动初始化的一部分（随着可用卷被挂载）而发送的，因此它们并不常见，通常在用户的控制之下 。</p></li><li><p><strong>SMS_RECEIVED_ACTION，WAP_PUSH_RECEIVED_ACTION</strong></p><p>SMS收件人apps依赖这些广播。</p></li></ul><h1 id="Android-O问题的解决方案"><a href="#Android-O问题的解决方案" class="headerlink" title="Android O问题的解决方案"></a>Android O问题的解决方案</h1><p>检查在应用的清单中定义的BroadcastReceiver。 如果清单里为显式广播声明了接收器，则必须予以替换。 可能的解决方法包括：</p><ul><li><p>通过调用 <code>Context.registerReceiver()</code> 动态创建BroadcastReceiver而不是在清单中声明一个静态的BroadcastReceiver。</p></li><li><p>使用JobSchedular检查条件是否会触发隐式广播。</p></li><li><p>如果在单个进程中使用广播在应用程序组件之间进行通信，请切换为使用LocalBroadcastManager。</p></li><li><p>如果使用广播在自己的多个进程中的应用程序组件之间进行通信，请切换为使用显式广播。</p></li><li><p>如果你想接收系统发送的隐式广播（例如ACTION_PACKAGE_ADDED），建议保持targetSdkVersion为25或更低。</p></li><li><p>如果非要发送隐式广播，则可以通过查找接收方并发送各个显式广播来突破禁令：</p><pre class=" language-lang-java"><code class="language-lang-java">private static void sendImplicitBroadcast(Context ctxt, Intent i) {  PackageManager pm=ctxt.getPackageManager();  List<ResolveInfo> matches=pm.queryBroadcastReceivers(i, 0);  for (ResolveInfo resolveInfo : matches) {    Intent explicit=new Intent(i);    ComponentName cn=      new ComponentName(resolveInfo.activityInfo.applicationInfo.packageName,        resolveInfo.activityInfo.name);    explicit.setComponent(cn);    ctxt.sendBroadcast(explicit);  }}</code></pre></li></ul><p>官方文档建议：在大多数情况下，应用都可以使用 <code>JobScheduler</code> 克服这些限制。 这种方法允许应用安排其在未活跃运行时执行工作，不过仍能够使系统可以在不影响用户体验的情况下安排这些作业。 Android 8.0 提供针对 <code>JobScheduler</code> 的多项改进，让用户可以更轻松地使用计划作业取代 Service 和BroadcastReceiver： <a href="https://developer.android.com/about/versions/oreo/android-8.0.html#jobscheduler" target="_blank" rel="noopener">JobScheduler 改进</a>。后面会整理一篇JobScheduler继续跟进这个问题。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://commonsware.com/blog/2017/04/11/android-o-implicit-broadcast-ban.html" target="_blank" rel="noopener">https://commonsware.com/blog/2017/04/11/android-o-implicit-broadcast-ban.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Broadcast </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Android][Framework] 全方位理解Android权限之底层实现概览</title>
      <link href="/2019/01/11/%5BAndroid%5D%5BFramework%5DAndroid-permission-1/"/>
      <url>/2019/01/11/%5BAndroid%5D%5BFramework%5DAndroid-permission-1/</url>
      
        <content type="html"><![CDATA[<h1 id="0000-目录"><a href="#0000-目录" class="headerlink" title="0000 目录"></a>0000 目录</h1><p>这个阶段搞了很多和Android文件权限相关的问题，虽然一知半解，但也算是对Android权限机制有一些自己的理解。遂将这些内容整理出来。因为权限这部分涉及到的内容很多，故将知识分为几块内容分别去整理。目前能想到的概要如下（现在因为进度原因有些修改）：</p><ol><li><a href="http://wossoneri.github.io/2019/01/11/[Android][Framework]Android-permission-1/">Android 权限底层实现原理概述</a></li><li><a href="http://wossoneri.github.io/2019/11/17/[Android][Framework]Android-permission-2/">Android 权限系统一</a></li><li>Android uid，gid的生成与权限机制的联系</li><li>Android packageManagerService与权限的千丝万缕（源码解析）</li><li>Android 从recovery模式下的OTA升级理解权限</li><li>Android ROOT 原理</li><li>Android 签名</li><li>Android 权限大杀器 — Selinux的策略</li></ol><p>这是第一篇。2，3，4已经有一些草稿了，但离发出来还有一些时间。5，6，7还在规划中。可以关注新弄的公众号softard，后面比较完善的文章都会在这个号上及时更新。当然一些普通的随笔还是在<a href="wossoneri.github.io">wossoneri.github.io</a>的博客更新。</p><h1 id="0001-Overview"><a href="#0001-Overview" class="headerlink" title="0001 Overview"></a>0001 Overview</h1><h2 id="Linux-File-Permission"><a href="#Linux-File-Permission" class="headerlink" title="Linux File Permission"></a>Linux File Permission</h2><p>众所周知，Android的内核是linux的内核。对于linux来说，系统的一切都是文件。同时，linux为文件系统设计了一套完善的权限机制。下面简单提一下linux文件权限的核心：</p><p>比如在Android手机adb shell下查看一个目录</p><pre class=" language-lang-shell"><code class="language-lang-shell"># ls -ld data/data/drwxrwx--x 113 system system 4096 1970-01-01 15:08 data/data/</code></pre><p>其中，<code>drwxrwx--x</code>这10位代表文件权限，第一位文件类型可以忽略（这里类型是文件夹），后面每三位代表文件拥有的权限，包括rwx（可读，可写，可执行）。<code>system system</code>表示文件属于system用户和属于system组。</p><p>翻译过来是，system用户对该文件拥有读写执行权限，system组对该文件拥有读写执行权限，其他用户对该文件拥有执行权限。简单来说就是771权限。</p><h2 id="Android-Permission"><a href="#Android-Permission" class="headerlink" title="Android Permission"></a>Android Permission</h2><p>Permission权限是Android系统定义的一套权限机制，用于控制APP访问某个硬件设备或某个Android系统的组件。<br>举两个常见的例子： </p><ol><li>如果你的App想要访问存储卡，你需要在你的AndroidManifest文件中使用对应的permission用于向系统请求权限 。</li><li>你可以给你的Activity组件加个自定义的访问权限，这样任何想启动该Activity的程序必须在它的AndroidManifest中进行权限的请求。见<a href>Android自定义权限</a>。</li></ol><p>那么为什么你在AndroidManifest文件请求storage权限你就可以访问设备文件？linux文件属性的权限和Permission到底是怎么联系起来的呢？下面我们来具体来讲。</p><h1 id="0010-packages-list-amp-packages-xml"><a href="#0010-packages-list-amp-packages-xml" class="headerlink" title="0010 packages.list &amp; packages.xml"></a>0010 packages.list &amp; packages.xml</h1><p>Android开机阶段会扫描所有App，从Manifest文件中把App信息和权限存到<code>packages.xml</code>和<code>packages.list</code>文件中，具体的处理过程会在后面第三篇去分析。</p><p>因为文件包含所有已安装应用的信息，所以我们尝试安装一个App（com.softard.test），并且查看其信息：</p><p><strong>packages.list</strong></p><pre class=" language-lang-txt"><code class="language-lang-txt">com.softard.test 10052 1 /data/user/0/com.softard.test default none</code></pre><p>这里10052是uid，至于其怎么生成的后面第二篇再详谈。</p><p><strong>packages.xml</strong></p><pre class=" language-lang-xml"><code class="language-lang-xml"><package name="com.softard.test" codePath="/data/app/com.softard.test-1" nativeLibraryPath="/data/app/com.softard.test-1/lib" publicFlags="944291654" privateFlags="0" ft="8bbd70" it="89023c" ut="8bc04d" version="1" userId="10052">        <sigs count="1">            <cert index="10" key="308..../>        </sigs>        <proper-signing-keyset identifier="11" />    </package></code></pre><p>然后对App做个修改，将其改成系统App并签名放到<code>system/app/Test</code>下，再看这两个文件：</p><pre class=" language-lang-txt"><code class="language-lang-txt">com.softard.test 1000 0 /data/user/0/com.softard.test platform 3009,3002,1023,1015,3003,3001,1021,1000,2002,2950,1010,1007</code></pre><p>看到uid变成了1000，selinux从default变成platform，权限组从none变成3009,3002,1023,1015,3003,3001,1021,1000,2002,2950,1010,1007。而且应用一下子增加了一堆权限：</p><pre class=" language-lang-xml"><code class="language-lang-xml"> <package name="com.softard.test" codePath="/system/app/Test" nativeLibraryPath="/system/app/Test/lib" primaryCpuAbi="armeabi-v7a" publicFlags="944291397" privateFlags="0" ft="1683b80c790" it="1683b80c790" ut="1683b80c790" version="1" sharedUserId="1000" isOrphaned="true">        <sigs count="1">            <cert index="0" />        </sigs>        <perms>            <item name="android.permission.BIND_INCALL_SERVICE" granted="true" flags="0" />            <item name="android.permission.WRITE_SETTINGS" granted="true" flags="0" />            <item name="android.permission.CONFIGURE_WIFI_DISPLAY" granted="true" flags="0" />            <item name="android.permission.CONFIGURE_DISPLAY_COLOR_MODE" granted="true" flags="0" />            <item name="android.permission.ACCESS_WIMAX_STATE" granted="true" flags="0" />            <item name="android.permission.RECOVERY" granted="true" flags="0" />            <item name="com.qualcomm.permission.READPROC" granted="true" flags="0" />            <item name="android.permission.USE_CREDENTIALS" granted="true" flags="0" />            <item name="android.permission.MODIFY_AUDIO_SETTINGS" granted="true" flags="0" />            <item name="android.permission.ACCESS_CHECKIN_PROPERTIES" granted="true" flags="0" />            <item name="com.zqautomotive.oris.wechat.provider.WRITE" granted="true" flags="0" />            <item name="android.permission.INSTALL_LOCATION_PROVIDER" granted="true" flags="0" />            <item name="android.permission.MANAGE_ACCOUNTS" granted="true" flags="0" />            <item name="android.permission.SYSTEM_ALERT_WINDOW" granted="true" flags="0" />            <item name="android.permission.BROADCAST_PHONE_ACCOUNT_REGISTRATION" granted="true" flags="0" />            <item name="android.permission.CONTROL_LOCATION_UPDATES" granted="true" flags="0" />            <item name="android.permission.CLEAR_APP_USER_DATA" granted="true" flags="0" />            <item name="com.zqautomotive.oris.wechat.provider.READ" granted="true" flags="0" />            <item name="android.permission.BROADCAST_CALLLOG_INFO" granted="true" flags="0" />            <item name="android.permission.NFC" granted="true" flags="0" />            <item name="android.permission.CALL_PRIVILEGED" granted="true" flags="0" />            <item name="android.permission.CHANGE_NETWORK_STATE" granted="true" flags="0" />            <item name="android.permission.MASTER_CLEAR" granted="true" flags="0" />            <item name="android.permission.WRITE_SYNC_SETTINGS" granted="true" flags="0" />            <item name="android.permission.RECEIVE_BOOT_COMPLETED" granted="true" flags="0" />            <item name="android.permission.PEERS_MAC_ADDRESS" granted="true" flags="0" />            <item name="android.permission.DEVICE_POWER" granted="true" flags="0" />            <item name="android.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS" granted="true" flags="0" />            <item name="android.permission.READ_PROFILE" granted="true" flags="0" />            <item name="android.permission.BLUETOOTH" granted="true" flags="0" />            <item name="android.permission.WRITE_MEDIA_STORAGE" granted="true" flags="0" />            <item name="android.permission.WRITE_BLOCKED_NUMBERS" granted="true" flags="0" />            <item name="com.qualcomm.permission.USE_QCRIL_MSG_TUNNEL" granted="true" flags="0" />            <item name="android.permission.ACCESS_SURFACE_FLINGER" granted="true" flags="0" />            <item name="com.zqautomotive.voice_controller.GET_SPEECH_RESULT" granted="true" flags="0" />            <item name="android.permission.AUTHENTICATE_ACCOUNTS" granted="true" flags="0" />            <item name="android.permission.INTERNET" granted="true" flags="0" />            <item name="android.permission.REORDER_TASKS" granted="true" flags="0" />            <item name="zq.permissio.CONNECTION_MQTT_SERVICE" granted="true" flags="0" />            <item name="android.permission.BLUETOOTH_ADMIN" granted="true" flags="0" />            <item name="android.permission.CONTROL_VPN" granted="true" flags="0" />            <item name="android.permission.UPDATE_DEVICE_STATS" granted="true" flags="0" />            <item name="android.permission.MANAGE_FINGERPRINT" granted="true" flags="0" />            <item name="com.qualcomm.permission.IZAT" granted="true" flags="0" />            <item name="android.permission.BIND_CONNECTION_SERVICE" granted="true" flags="0" />            <item name="android.permission.MANAGE_USB" granted="true" flags="0" />            <item name="android.permission.INTERACT_ACROSS_USERS_FULL" granted="true" flags="0" />            <item name="android.permission.STOP_APP_SWITCHES" granted="true" flags="0" />            <item name="android.permission.BATTERY_STATS" granted="true" flags="0" />            <item name="android.permission.PACKAGE_USAGE_STATS" granted="true" flags="0" />            <item name="android.permission.MOUNT_UNMOUNT_FILESYSTEMS" granted="true" flags="0" />            <item name="android.permission.TETHER_PRIVILEGED" granted="true" flags="0" />            <item name="android.permission.WRITE_SECURE_SETTINGS" granted="true" flags="0" />            <item name="android.permission.MOVE_PACKAGE" granted="true" flags="0" />            <item name="android.permission.READ_BLOCKED_NUMBERS" granted="true" flags="0" />            <item name="com.qualcomm.permission.wfd.QC_WFD" granted="true" flags="0" />            <item name="android.permission.READ_SEARCH_INDEXABLES" granted="true" flags="0" />            <item name="android.permission.ACCESS_IMS_CALL_SERVICE" granted="true" flags="0" />            <item name="android.permission.BLUETOOTH_PRIVILEGED" granted="true" flags="0" />            <item name="android.permission.HARDWARE_TEST" granted="true" flags="0" />            <item name="android.intent.category.MASTER_CLEAR.permission.C2D_MESSAGE" granted="true" flags="0" />            <item name="android.permission.BIND_JOB_SERVICE" granted="true" flags="0" />            <item name="android.permission.CONFIRM_FULL_BACKUP" granted="true" flags="0" />            <item name="android.permission.SET_TIME" granted="true" flags="0" />            <item name="android.permission.WRITE_APN_SETTINGS" granted="true" flags="0" />            <item name="android.permission.CHANGE_WIFI_STATE" granted="true" flags="0" />            <item name="android.permission.MANAGE_USERS" granted="true" flags="0" />            <item name="android.permission.SET_PREFERRED_APPLICATIONS" granted="true" flags="0" />            <item name="android.permission.DELETE_CACHE_FILES" granted="true" flags="0" />            <item name="android.permission.ACCESS_NETWORK_STATE" granted="true" flags="0" />            <item name="zq.permissio.CONNECTION_ACTIVATION_SERVICE" granted="true" flags="0" />            <item name="android.permission.DISABLE_KEYGUARD" granted="true" flags="0" />            <item name="android.permission.BACKUP" granted="true" flags="0" />            <item name="android.permission.CHANGE_CONFIGURATION" granted="true" flags="0" />            <item name="android.permission.USER_ACTIVITY" granted="true" flags="0" />            <item name="android.permission.READ_LOGS" granted="true" flags="0" />            <item name="android.permission.COPY_PROTECTED_DATA" granted="true" flags="0" />            <item name="android.permission.INTERACT_ACROSS_USERS" granted="true" flags="0" />            <item name="android.permission.SET_KEYBOARD_LAYOUT" granted="true" flags="0" />            <item name="android.permission.USE_FINGERPRINT" granted="true" flags="0" />            <item name="android.permission.WRITE_USER_DICTIONARY" granted="true" flags="0" />            <item name="android.permission.READ_SYNC_STATS" granted="true" flags="0" />            <item name="android.permission.REBOOT" granted="true" flags="0" />            <item name="android.permission.OEM_UNLOCK_STATE" granted="true" flags="0" />            <item name="android.permission.MANAGE_DEVICE_ADMINS" granted="true" flags="0" />            <item name="android.permission.CHANGE_APP_IDLE_STATE" granted="true" flags="0" />            <item name="android.permission.SET_POINTER_SPEED" granted="true" flags="0" />            <item name="android.permission.MANAGE_NOTIFICATIONS" granted="true" flags="0" />            <item name="android.permission.READ_SYNC_SETTINGS" granted="true" flags="0" />            <item name="android.permission.OVERRIDE_WIFI_CONFIG" granted="true" flags="0" />            <item name="android.permission.FORCE_STOP_PACKAGES" granted="true" flags="0" />            <item name="android.permission.ACCESS_NOTIFICATIONS" granted="true" flags="0" />            <item name="android.permission.VIBRATE" granted="true" flags="0" />            <item name="com.android.certinstaller.INSTALL_AS_USER" granted="true" flags="0" />            <item name="android.permission.READ_USER_DICTIONARY" granted="true" flags="0" />            <item name="android.permission.ACCESS_WIFI_STATE" granted="true" flags="0" />            <item name="android.permission.CHANGE_WIMAX_STATE" granted="true" flags="0" />            <item name="android.permission.MODIFY_PHONE_STATE" granted="true" flags="0" />            <item name="android.permission.STATUS_BAR" granted="true" flags="0" />            <item name="android.permission.READ_FRAME_BUFFER" granted="true" flags="0" />            <item name="android.permission.LOCATION_HARDWARE" granted="true" flags="0" />            <item name="android.permission.WAKE_LOCK" granted="true" flags="0" />            <item name="android.permission.INJECT_EVENTS" granted="true" flags="0" />            <item name="android.permission.DELETE_PACKAGES" granted="true" flags="0" />        </perms>        <proper-signing-keyset identifier="1" />    </package></code></pre><p>所以问题来了，改成系统应用后uid为什么变成1000？后面代表权限组的一串数字又都是什么？</p><h1 id="0011-Android-File-Permission"><a href="#0011-Android-File-Permission" class="headerlink" title="0011 Android File Permission"></a>0011 Android File Permission</h1><h2 id="android-filesystem-config-h"><a href="#android-filesystem-config-h" class="headerlink" title="android_filesystem_config.h"></a>android_filesystem_config.h</h2><p>在Android中，所有权限的定义都在：<code>system/core/include/private/android_filesystem_config.h</code></p><p>在这个头文件中定义了Android系统的一些用户，包含root用户，system用户，shell用户所对应的值等等。</p><pre class=" language-lang-c"><code class="language-lang-c">/* This is the master Users and Groups config for the platform. * DO NOT EVER RENUMBER */#define AID_ROOT             0  /* traditional unix root user */#define AID_SYSTEM        1000  /* system server */#define AID_RADIO         1001  /* telephony subsystem, RIL */#define AID_BLUETOOTH     1002  /* bluetooth subsystem */#define AID_GRAPHICS      1003  /* graphics devices */#define AID_INPUT         1004  /* input devices */#define AID_AUDIO         1005  /* audio devices */#define AID_CAMERA        1006  /* camera devices */#define AID_LOG           1007  /* log devices */#define AID_COMPASS       1008  /* compass device */#define AID_MOUNT         1009  /* mountd socket */#define AID_WIFI          1010  /* wifi subsystem */#define AID_ADB           1011  /* android debug bridge (adbd) */#define AID_INSTALL       1012  /* group for installing packages */#define AID_MEDIA         1013  /* mediaserver process */#define AID_DHCP          1014  /* dhcp client */#define AID_SDCARD_RW     1015  /* external storage write access */#define AID_VPN           1016  /* vpn system */#define AID_KEYSTORE      1017  /* keystore subsystem */#define AID_USB           1018  /* USB devices */#define AID_DRM           1019  /* DRM server */#define AID_MDNSR         1020  /* MulticastDNSResponder (service discovery) */#define AID_GPS           1021  /* GPS daemon */#define AID_UNUSED1       1022  /* deprecated, DO NOT USE */#define AID_MEDIA_RW      1023  /* internal media storage write access */#define AID_MTP           1024  /* MTP USB driver access */#define AID_UNUSED2       1025  /* deprecated, DO NOT USE */#define AID_DRMRPC        1026  /* group for drm rpc */#define AID_NFC           1027  /* nfc subsystem */#define AID_SDCARD_R      1028  /* external storage read access */#define AID_CLAT          1029  /* clat part of nat464 */#define AID_LOOP_RADIO    1030  /* loop radio devices */#define AID_MEDIA_DRM     1031  /* MediaDrm plugins */#define AID_PACKAGE_INFO  1032  /* access to installed package details */#define AID_SDCARD_PICS   1033  /* external storage photos access */#define AID_SDCARD_AV     1034  /* external storage audio/video access */#define AID_SDCARD_ALL    1035  /* access all users external storage */#define AID_LOGD          1036  /* log daemon */#define AID_SHARED_RELRO  1037  /* creator of shared GNU RELRO files */#define AID_DBUS          1038  /* dbus-daemon IPC broker process */#define AID_TLSDATE       1039  /* tlsdate unprivileged user */#define AID_MEDIA_EX      1040  /* mediaextractor process */#define AID_AUDIOSERVER   1041  /* audioserver process */#define AID_METRICS_COLL  1042  /* metrics_collector process */#define AID_METRICSD      1043  /* metricsd process */#define AID_WEBSERV       1044  /* webservd process */#define AID_DEBUGGERD     1045  /* debuggerd unprivileged user */#define AID_MEDIA_CODEC   1046  /* mediacodec process */#define AID_CAMERASERVER  1047  /* cameraserver process */#define AID_FIREWALL      1048  /* firewalld process */#define AID_TRUNKS        1049  /* trunksd process (TPM daemon) */#define AID_NVRAM         1050  /* Access-controlled NVRAM */#define AID_DNS           1051  /* DNS resolution daemon (system: netd) */#define AID_DNS_TETHER    1052  /* DNS resolution daemon (tether: dnsmasq) *//* Changes to this file must be made in AOSP, *not* in internal branches. */#define AID_SHELL         2000  /* adb and debug shell user */#define AID_CACHE         2001  /* cache access */#define AID_DIAG          2002  /* access to diagnostic resources *//* The range 2900-2999 is reserved for OEM, and must never be * used here */#define AID_OEM_RESERVED_START 2900#define AID_OEM_RESERVED_END   2999/* The 3000 series are intended for use as supplemental group id's only. * They indicate special Android capabilities that the kernel is aware of. */#define AID_NET_BT_ADMIN  3001  /* bluetooth: create any socket */#define AID_NET_BT        3002  /* bluetooth: create sco, rfcomm or l2cap sockets */#define AID_INET          3003  /* can create AF_INET and AF_INET6 sockets */#define AID_NET_RAW       3004  /* can create raw INET sockets */#define AID_NET_ADMIN     3005  /* can configure interfaces and routing tables. */#define AID_NET_BW_STATS  3006  /* read bandwidth statistics */#define AID_NET_BW_ACCT   3007  /* change bandwidth statistics accounting */#define AID_NET_BT_STACK  3008  /* bluetooth: access config files */#define AID_READPROC      3009  /* Allow /proc read access */#define AID_WAKELOCK      3010  /* Allow system wakelock read/write access *//* The range 5000-5999 is also reserved for OEM, and must never be used here. */#define AID_OEM_RESERVED_2_START 5000#define AID_OEM_RESERVED_2_END   5999#define AID_EVERYBODY     9997  /* shared between all apps in the same profile */#define AID_MISC          9998  /* access to misc storage */#define AID_NOBODY        9999#define AID_APP          10000  /* first app user */#define AID_ISOLATED_START 99000 /* start of uids for fully isolated sandboxed processes */#define AID_ISOLATED_END   99999 /* end of uids for fully isolated sandboxed processes */#define AID_USER        100000  /* offset for uid ranges for each user */#define AID_SHARED_GID_START 50000 /* start of gids for apps in each user to share */#define AID_SHARED_GID_END   59999 /* start of gids for apps in each user to share */</code></pre><p>从头文件定义，就知道每个权限组都是由一串数字代表的。除了数字，该文件还定义了一个结构体数组，映射数字对应的字符串：</p><pre class=" language-lang-c"><code class="language-lang-c">static const struct android_id_info android_ids[] = {    { "root",          AID_ROOT, },    { "system",        AID_SYSTEM, },    { "radio",         AID_RADIO, },    { "bluetooth",     AID_BLUETOOTH, },    { "graphics",      AID_GRAPHICS, },    { "input",         AID_INPUT, },    { "audio",         AID_AUDIO, },    { "camera",        AID_CAMERA, },    { "log",           AID_LOG, },    { "compass",       AID_COMPASS, },    { "mount",         AID_MOUNT, },    { "wifi",          AID_WIFI, },    { "adb",           AID_ADB, },    { "install",       AID_INSTALL, },    { "media",         AID_MEDIA, },    { "dhcp",          AID_DHCP, },    { "sdcard_rw",     AID_SDCARD_RW, },    { "vpn",           AID_VPN, },    { "keystore",      AID_KEYSTORE, },    { "usb",           AID_USB, },    { "drm",           AID_DRM, },    { "mdnsr",         AID_MDNSR, },    { "gps",           AID_GPS, },    // AID_UNUSED1    { "media_rw",      AID_MEDIA_RW, },    { "mtp",           AID_MTP, },    // AID_UNUSED2    { "drmrpc",        AID_DRMRPC, },    { "nfc",           AID_NFC, },    { "sdcard_r",      AID_SDCARD_R, },    { "clat",          AID_CLAT, },    { "loop_radio",    AID_LOOP_RADIO, },    { "mediadrm",      AID_MEDIA_DRM, },    { "package_info",  AID_PACKAGE_INFO, },    { "sdcard_pics",   AID_SDCARD_PICS, },    { "sdcard_av",     AID_SDCARD_AV, },    { "sdcard_all",    AID_SDCARD_ALL, },    { "logd",          AID_LOGD, },    { "shared_relro",  AID_SHARED_RELRO, },    { "dbus",          AID_DBUS, },    { "tlsdate",       AID_TLSDATE, },    { "mediaex",       AID_MEDIA_EX, },    { "audioserver",   AID_AUDIOSERVER, },    { "metrics_coll",  AID_METRICS_COLL },    { "metricsd",      AID_METRICSD },    { "webserv",       AID_WEBSERV },    { "debuggerd",     AID_DEBUGGERD, },    { "mediacodec",    AID_MEDIA_CODEC, },    { "cameraserver",  AID_CAMERASERVER, },    { "firewall",      AID_FIREWALL, },    { "trunks",        AID_TRUNKS, },    { "nvram",         AID_NVRAM, },    { "dns",           AID_DNS, },    { "dns_tether",    AID_DNS_TETHER, },    { "shell",         AID_SHELL, },    { "cache",         AID_CACHE, },    { "diag",          AID_DIAG, },    { "net_bt_admin",  AID_NET_BT_ADMIN, },    { "net_bt",        AID_NET_BT, },    { "inet",          AID_INET, },    { "net_raw",       AID_NET_RAW, },    { "net_admin",     AID_NET_ADMIN, },    { "net_bw_stats",  AID_NET_BW_STATS, },    { "net_bw_acct",   AID_NET_BW_ACCT, },    { "net_bt_stack",  AID_NET_BT_STACK, },    { "readproc",      AID_READPROC, },    { "wakelock",      AID_WAKELOCK, },    { "everybody",     AID_EVERYBODY, },    { "misc",          AID_MISC, },    { "nobody",        AID_NOBODY, },};</code></pre><p>好了，了解这个文件我们再来看我们应用的信息：</p><pre class=" language-lang-txt"><code class="language-lang-txt">com.softard.test 1000 0 /data/user/0/com.softard.test platform 3009,3002,1023,1015,3003,3001,1021,1000,2002,1010,1007</code></pre><p>我们把数字对应的信息截取下来：</p><pre class=" language-lang-xml"><code class="language-lang-xml">#define AID_SYSTEM        1000  "system"    /* system server */        #define AID_LOG           1007  "log"        /* log devices */        #define AID_WIFI          1010  "wifi"        /* wifi subsystem */    #define AID_SDCARD_RW     1015  "sdcard_rw"    /* external storage write access */#define AID_GPS           1021  "gps"        /* GPS daemon */#define AID_MEDIA_RW      1023  "media_rw"    /* internal media storage write access */#define AID_DIAG          2002  "diag"        /* access to diagnostic resources */#define AID_NET_BT_ADMIN  3001  "net_bt_admin"/* bluetooth: create any socket */#define AID_NET_BT        3002  "net_bt"    /* bluetooth: create sco, rfcomm or l2cap sockets */#define AID_INET          3003  "inet"        /* can create AF_INET and AF_INET6 sockets */#define AID_READPROC      3009  "readproc"    /* Allow /proc read access */</code></pre><p>所以，当我指定应用为系统应用时，就将uid指定为了1000。并且拥有了各种属于系统的权限组。</p><p>那么，指定系统应用后是怎么获得这一系列的gid呢？这一块源码流程很多，放到后面集中分析。</p><p>好了，现在我们了解<code>system/core/include/private/android_filesystem_config.h</code>文件定义以后，其实就前进了一大步。注意一下代码所在源码位置，位于<code>system/core</code>下，其实它已经是Android内核部分了，所以后面涉及到权限内容，都会导入这个头文件。</p><p>现在来看一段源码再来熟悉一下这部分内容：</p><pre class=" language-lang-java"><code class="language-lang-java">FileUtils.setPermissions(fstr.getFD(), 0640, SYSTEM_UID, PACKAGE_INFO_GID);</code></pre><p>这是位于<code>frameworks/base/services/core/java/com/android/server/pm/Settings.java</code>的一段代码，功能就是创建<code>packages.list</code>文件。从函数名称和参数可以知道，它是给文件添加权限的，通过这段代码可以推测出：它给packages.list文件赋予了0640的权限，权限隶属于system，权限组为package_info。</p><p>然后我们进入系统看一看是不是这样：</p><pre class=" language-lang-shell"><code class="language-lang-shell">/data/system # ls -l packages.list-rw-r----- 1 system package_info 13627 1970-01-01 11:27 packages.list</code></pre><p>有没有发现原来Android底层权限其实也不是很难理解嘛？</p><p>这时，又有一个问题了，创建文件你可以这样设定权限，但系统文件/文件夹的默认权限又是从哪来的？这就要引入另外一个文件了。</p><h2 id="fs-config-c"><a href="#fs-config-c" class="headerlink" title="fs_config.c"></a>fs_config.c</h2><p>写过Android App的你肯定知道，App的一些数据都放在<code>/data/data</code>目录下。正常情况下这个目录是不可以访问的：</p><pre class=" language-lang-shell"><code class="language-lang-shell">/data/data $ lsls: .: Permission denied</code></pre><p>我们看一下这个目录的权限：</p><pre class=" language-lang-shell"><code class="language-lang-shell">/data/data $ ls -lddrwxrwx--x 310 system system 12288 2019-01-11 09:51 .</code></pre><p>我们作为shell用户，只有一个x权限， 当然访问不了。那如果我要给shell赋予访问权限改怎么改呢？</p><p>这就需要了解一下<code>system/core/libcutils/fs_config.c</code>文件了。系统目录和文件的用户组以及权限都是在这个文件里定义的：</p><pre class=" language-lang-c"><code class="language-lang-c">/* Rules for directories.** These rules are applied based on "first match", so they** should start with the most specific path and work their** way up to the root.*/static const struct fs_path_config android_dirs[] = {    { 00770, AID_SYSTEM, AID_CACHE,  0, "cache" },    { 00500, AID_ROOT,   AID_ROOT,   0, "config" },    { 00771, AID_SYSTEM, AID_SYSTEM, 0, "data/app" },    { 00771, AID_SYSTEM, AID_SYSTEM, 0, "data/app-private" },    { 00771, AID_SYSTEM, AID_SYSTEM, 0, "data/app-ephemeral" },    { 00771, AID_ROOT,   AID_ROOT,   0, "data/dalvik-cache" },    { 00771, AID_SYSTEM, AID_SYSTEM, 0, "data/data" },    { 00771, AID_SHELL,  AID_SHELL,  0, "data/local/tmp" },    { 00771, AID_SHELL,  AID_SHELL,  0, "data/local" },    { 01771, AID_SYSTEM, AID_MISC,   0, "data/misc" },    { 00770, AID_DHCP,   AID_DHCP,   0, "data/misc/dhcp" },    { 00771, AID_SHARED_RELRO, AID_SHARED_RELRO, 0, "data/misc/shared_relro" },    { 00775, AID_MEDIA_RW, AID_MEDIA_RW, 0, "data/media" },    { 00775, AID_MEDIA_RW, AID_MEDIA_RW, 0, "data/media/Music" },    { 00750, AID_ROOT,   AID_SHELL,  0, "data/nativetest" },    { 00750, AID_ROOT,   AID_SHELL,  0, "data/nativetest64" },    { 00775, AID_ROOT,   AID_ROOT,   0, "data/preloads" },    { 00771, AID_SYSTEM, AID_SYSTEM, 0, "data" },    { 00755, AID_ROOT,   AID_SYSTEM, 0, "mnt" },    { 00755, AID_ROOT,   AID_ROOT,   0, "root" },    { 00750, AID_ROOT,   AID_SHELL,  0, "sbin" },    { 00751, AID_ROOT,   AID_SDCARD_R, 0, "storage" },    { 00755, AID_ROOT,   AID_SHELL,  0, "system/bin" },    { 00755, AID_ROOT,   AID_SHELL,  0, "system/vendor" },    { 00755, AID_ROOT,   AID_SHELL,  0, "system/xbin" },    { 00755, AID_ROOT,   AID_ROOT,   0, "system/etc/ppp" },    { 00755, AID_ROOT,   AID_SHELL,  0, "vendor" },    { 00777, AID_ROOT,   AID_ROOT,   0, "sdcard" },    { 00755, AID_ROOT,   AID_ROOT,   0, 0 },};/* Rules for files.** These rules are applied based on "first match", so they** should start with the most specific path and work their** way up to the root. Prefixes ending in * denotes wildcard** and will allow partial matches.*/static const char conf_dir[] = "/system/etc/fs_config_dirs";static const char conf_file[] = "/system/etc/fs_config_files";static const struct fs_path_config android_files[] = {    { 00440, AID_ROOT,      AID_SHELL,     0, "system/etc/init.goldfish.rc" },    { 00550, AID_ROOT,      AID_SHELL,     0, "system/etc/init.goldfish.sh" },    { 00550, AID_ROOT,      AID_SHELL,     0, "system/etc/init.ril" },    { 00555, AID_ROOT,      AID_ROOT,      0, "system/etc/ppp/*" },    { 00555, AID_ROOT,      AID_ROOT,      0, "system/etc/rc.*" },    { 00440, AID_ROOT,      AID_ROOT,      0, "system/etc/recovery.img" },    { 00444, AID_ROOT,      AID_ROOT,      0, conf_dir + 1 },    { 00444, AID_ROOT,      AID_ROOT,      0, conf_file + 1 },    { 00644, AID_SYSTEM,    AID_SYSTEM,    0, "data/app/*" },    { 00644, AID_MEDIA_RW,  AID_MEDIA_RW,  0, "data/media/*" },    { 00644, AID_SYSTEM,    AID_SYSTEM,    0, "data/app-private/*" },    { 00644, AID_SYSTEM,    AID_SYSTEM,    0, "data/app-ephemeral/*" },    { 00644, AID_APP,       AID_APP,       0, "data/data/*" },    { 00640, AID_ROOT,      AID_SHELL,     0, "data/nativetest/tests.txt" },    { 00640, AID_ROOT,      AID_SHELL,     0, "data/nativetest64/tests.txt" },    { 00750, AID_ROOT,      AID_SHELL,     0, "data/nativetest/*" },    { 00750, AID_ROOT,      AID_SHELL,     0, "data/nativetest64/*" },    /* the following two files are INTENTIONALLY set-uid, but they     * are NOT included on user builds. */    { 04750, AID_ROOT,      AID_SHELL,     0, "system/xbin/su" },    { 06755, AID_ROOT,      AID_ROOT,      0, "system/xbin/procmem" },    /* the following files have enhanced capabilities and ARE included in user builds. */    { 00750, AID_ROOT,      AID_SHELL,     CAP_MASK_LONG(CAP_SETUID) | CAP_MASK_LONG(CAP_SETGID), "system/bin/run-as" },    { 00700, AID_SYSTEM,    AID_SHELL,     CAP_MASK_LONG(CAP_BLOCK_SUSPEND), "system/bin/inputflinger" },    /* Support FIFO scheduling mode in SurfaceFlinger. */    { 00755, AID_SYSTEM,    AID_GRAPHICS,     CAP_MASK_LONG(CAP_SYS_NICE), "system/bin/surfaceflinger" },    { 00750, AID_ROOT,      AID_ROOT,      0, "system/bin/uncrypt" },    { 00750, AID_ROOT,      AID_ROOT,      0, "system/bin/install-recovery.sh" },    { 00755, AID_ROOT,      AID_SHELL,     0, "system/bin/*" },    { 00755, AID_ROOT,      AID_ROOT,      0, "system/lib/valgrind/*" },    { 00755, AID_ROOT,      AID_ROOT,      0, "system/lib64/valgrind/*" },    { 00755, AID_ROOT,      AID_SHELL,     0, "system/xbin/*" },    { 00755, AID_ROOT,      AID_SHELL,     0, "system/vendor/bin/*" },    { 00755, AID_ROOT,      AID_SHELL,     0, "system/vendor/xbin/*" },    { 00755, AID_ROOT,      AID_SHELL,     0, "vendor/bin/*" },    { 00755, AID_ROOT,      AID_SHELL,     0, "vendor/xbin/*" },    { 00750, AID_ROOT,      AID_SHELL,     0, "sbin/*" },    { 00755, AID_ROOT,      AID_ROOT,      0, "bin/*" },    { 00750, AID_ROOT,      AID_SHELL,     0, "init*" },    { 00750, AID_ROOT,      AID_SHELL,     0, "sbin/fs_mgr" },    { 00640, AID_ROOT,      AID_SHELL,     0, "fstab.*" },    { 00644, AID_ROOT,      AID_ROOT,      0, 0 },};</code></pre><p>感觉也不用多说，<code>android_dirs[]</code>负责文件夹的权限配置，<code>android_files[]</code>负责文件的权限配置。</p><p>从里面定义找找刚提到的<code>/data/data</code>目录</p><pre class=" language-lang-c"><code class="language-lang-c">{ 00771, AID_SYSTEM, AID_SYSTEM, 0, "data/data" },</code></pre><p>你看，就是这么回事儿而已。如果要改成shell权限的话，只需要这样改就可以了：</p><pre class=" language-lang-c"><code class="language-lang-c">{ 00771, AID_SYSTEM, AID_SHELL, 0, "data/data" },</code></pre><p>当然，如果系统里还要添加其他目录、文件需要指定权限，只需要在这个文件里添加一行即可。</p><h1 id="0100-Android-App-Permission"><a href="#0100-Android-App-Permission" class="headerlink" title="0100 Android App Permission"></a>0100 Android App Permission</h1><p>讲到这里，还遗留一个开头提出的问题：</p><blockquote><p>为什么你在AndroidManifest文件请求storage权限你就可以访问设备文件？</p></blockquote><p>0010里提到过，PackageManagerService在启动后会扫描所有已经安装的App，然后加载和解析他们的Androidmanifest文件，生成<code>packages.list</code>和<code>packages.xml</code>等文件。解析过程就包括了permission的解析与拦截。</p><p><code>frameworks/base/core/res/AndroidManifest.xml</code> 这个文件中定义了Permission拦截规则，下面列举几个：</p><pre class=" language-lang-xml"><code class="language-lang-xml"><!-- Allows an application to read from external storage.     <p>Any app that declares the {@link #WRITE_EXTERNAL_STORAGE} permission is implicitly     granted this permission.</p>     <p>This permission is enforced starting in API level 19.  Before API level 19, this     permission is not enforced and all apps still have access to read from external storage.     You can test your app with the permission enforced by enabling <em>Protect USB     storage</em> under Developer options in the Settings app on a device running Android 4.1 or     higher.</p>     <p>Also starting in API level 19, this permission is <em>not</em> required to     read/write files in your application-specific directories returned by     {@link android.content.Context#getExternalFilesDir} and     {@link android.content.Context#getExternalCacheDir}.     <p class="note"><strong>Note:</strong> If <em>both</em> your <a     href="{@docRoot}guide/topics/manifest/uses-sdk-element.html#min">{@code     minSdkVersion}</a> and <a     href="{@docRoot}guide/topics/manifest/uses-sdk-element.html#target">{@code     targetSdkVersion}</a> values are set to 3 or lower, the system implicitly     grants your app this permission. If you don't need this permission, be sure your <a     href="{@docRoot}guide/topics/manifest/uses-sdk-element.html#target">{@code     targetSdkVersion}</a> is 4 or higher.     <p>Protection level: dangerous--><permission android:name="android.permission.READ_EXTERNAL_STORAGE"            android:permissionGroup="android.permission-group.STORAGE"            android:label="@string/permlab_sdcardRead"            android:description="@string/permdesc_sdcardRead"            android:protectionLevel="dangerous" /><!-- Allows applications to access information about Wi-Fi networks.         <p>Protection level: normal--><permission android:name="android.permission.ACCESS_WIFI_STATE"            android:description="@string/permdesc_accessWifiState"            android:label="@string/permlab_accessWifiState"            android:protectionLevel="normal" /><!-- @SystemApi Allows applications to set the system time.    <p>Not for use by third-party applications. --><permission android:name="android.permission.SET_TIME"            android:protectionLevel="signature|privileged" /></code></pre><p>这里看一下<code>protectionLevel</code>，normal是一般权限，即不需要动态申请，直接在Manifest里注册即可获得的权限。dangerous是敏感权限，需要动态申请告知用户才能获取的权限。signature|privileged一般是系统priv-app才拥有的权限，也就是拥有系统签名的系统应用。</p><p>他的拦截规则大概是，如果App申请了signature|privileged权限，但他是普通开发者的三方App，PMS就会将其从申请权限的列表里将该权限删除。这样你的App实际上就没有获得对应的权限了。</p><p>那么，文件属性的权限是怎么和Permission联系起来的？不出意外，系统也有一个关联文件的定义<code>frameworks/base/data/etc/platform.xml</code>：</p><pre class=" language-lang-xml"><code class="language-lang-xml"><!-- This file is used to define the mappings between lower-level system     user and group IDs and the higher-level permission names managed     by the platform.     Be VERY careful when editing this file!  Mistakes made here can open     big security holes.--><permissions>    <!-- ================================================================== -->    <!-- ================================================================== -->    <!-- ================================================================== -->    <!-- The following tags are associating low-level group IDs with         permission names.  By specifying such a mapping, you are saying         that any application process granted the given permission will         also be running with the given group ID attached to its process,         so it can perform any filesystem (read, write, execute) operations         allowed for that group. -->    <permission name="android.permission.BLUETOOTH_ADMIN" >        <group gid="net_bt_admin" />    </permission>    <permission name="android.permission.BLUETOOTH" >        <group gid="net_bt" />    </permission>    <permission name="android.permission.BLUETOOTH_STACK" >        <group gid="net_bt_stack" />        <group gid="wakelock" />    </permission>    <permission name="android.permission.NET_TUNNELING" >        <group gid="vpn" />    </permission>    <permission name="android.permission.INTERNET" >        <group gid="inet" />    </permission>    <permission name="android.permission.READ_LOGS" >        <group gid="log" />    </permission>    <permission name="android.permission.WRITE_MEDIA_STORAGE" >        <group gid="media_rw" />        <group gid="sdcard_rw" />    </permission>    <permission name="android.permission.ACCESS_MTP" >        <group gid="mtp" />    </permission>    <permission name="android.permission.NET_ADMIN" >        <group gid="net_admin" />    </permission>    <!-- The group that /cache belongs to, linked to the permission         set on the applications that can access /cache -->    <permission name="android.permission.ACCESS_CACHE_FILESYSTEM" >        <group gid="cache" />    </permission>    <!-- RW permissions to any system resources owned by group 'diag'.         This is for carrier and manufacture diagnostics tools that must be         installable from the framework. Be careful. -->    <permission name="android.permission.DIAGNOSTIC" >        <group gid="input" />        <group gid="diag" />    </permission>    <!-- Group that can read detailed network usage statistics -->    <permission name="android.permission.READ_NETWORK_USAGE_HISTORY">        <group gid="net_bw_stats" />    </permission>    <!-- Group that can modify how network statistics are accounted -->    <permission name="android.permission.MODIFY_NETWORK_ACCOUNTING">        <group gid="net_bw_acct" />    </permission>    <permission name="android.permission.LOOP_RADIO" >        <group gid="loop_radio" />    </permission>    <!-- Hotword training apps sometimes need a GID to talk with low-level         hardware; give them audio for now until full HAL support is added. -->    <permission name="android.permission.MANAGE_VOICE_KEYPHRASES">        <group gid="audio" />    </permission>    <permission name="android.permission.ACCESS_FM_RADIO" >        <!-- /dev/fm is gid media, not audio -->        <group gid="media" />    </permission>    <!-- These are permissions that were mapped to gids but we need         to keep them here until an upgrade from L to the current         version is to be supported. These permissions are built-in         and in L were not stored in packages.xml as a result if they         are not defined here while parsing packages.xml we would         ignore these permissions being granted to apps and not         propagate the granted state. From N we are storing the         built-in permissions in packages.xml as the saved storage         is negligible (one tag with the permission) compared to         the fragility as one can remove a built-in permission which         no longer needs to be mapped to gids and break grant propagation. -->    <permission name="android.permission.READ_EXTERNAL_STORAGE" />    <permission name="android.permission.WRITE_EXTERNAL_STORAGE" />    <!-- ================================================================== -->    <!-- ================================================================== -->    <!-- ================================================================== -->    <!-- The following tags are assigning high-level permissions to specific         user IDs.  These are used to allow specific core system users to         perform the given operations with the higher-level framework.  For         example, we give a wide variety of permissions to the shell user         since that is the user the adb shell runs under and developers and         others should have a fairly open environment in which to         interact with the system. -->    <assign-permission name="android.permission.MODIFY_AUDIO_SETTINGS" uid="media" />    <assign-permission name="android.permission.ACCESS_SURFACE_FLINGER" uid="media" />    <assign-permission name="android.permission.WAKE_LOCK" uid="media" />    <assign-permission name="android.permission.UPDATE_DEVICE_STATS" uid="media" />    <assign-permission name="android.permission.UPDATE_APP_OPS_STATS" uid="media" />    <assign-permission name="android.permission.GET_PROCESS_STATE_AND_OOM_SCORE" uid="media" />    <assign-permission name="android.permission.MODIFY_AUDIO_SETTINGS" uid="audioserver" />    <assign-permission name="android.permission.ACCESS_SURFACE_FLINGER" uid="audioserver" />    <assign-permission name="android.permission.WAKE_LOCK" uid="audioserver" />    <assign-permission name="android.permission.UPDATE_DEVICE_STATS" uid="audioserver" />    <assign-permission name="android.permission.UPDATE_APP_OPS_STATS" uid="audioserver" />    <assign-permission name="android.permission.MODIFY_AUDIO_SETTINGS" uid="cameraserver" />    <assign-permission name="android.permission.ACCESS_SURFACE_FLINGER" uid="cameraserver" />    <assign-permission name="android.permission.WAKE_LOCK" uid="cameraserver" />    <assign-permission name="android.permission.UPDATE_DEVICE_STATS" uid="cameraserver" />    <assign-permission name="android.permission.UPDATE_APP_OPS_STATS" uid="cameraserver" />    <assign-permission name="android.permission.ACCESS_SURFACE_FLINGER" uid="graphics" />    <!-- This is a list of all the libraries available for application         code to link against. -->    <library name="android.test.runner"            file="/system/framework/android.test.runner.jar" />    <library name="javax.obex"            file="/system/framework/javax.obex.jar" />    <library name="org.apache.http.legacy"            file="/system/framework/org.apache.http.legacy.jar" />    <!-- These are the standard packages that are white-listed to always have internet         access while in power save mode, even if they aren't in the foreground. -->    <allow-in-power-save package="com.android.providers.downloads" />    <!-- These are the standard packages that are white-listed to always have internet         access while in data mode, even if they aren't in the foreground. -->    <allow-in-data-usage-save package="com.android.providers.downloads" />    <!-- These are the packages that are white-listed to be able to run as system user -->    <system-user-whitelisted-app package="com.android.settings" />    <!-- These are the packages that shouldn't run as system user -->    <system-user-blacklisted-app package="com.android.wallpaper.livepicker" /></permissions></code></pre><p>这个文件定义了所有权限所属的gid。从里面找一下<code>READ_EXTERNAL_STORAGE</code>权限，emmmm，什么都没做。这是因为6.0之后存储权限变成动态，需要用户确认才可以获取权限，所以这里不作处理。动态权限这部分代码先不分析了，来看一下老版本的文件：</p><pre class=" language-lang-xml"><code class="language-lang-xml"><permission name="android.permission.READ_EXTERNAL_STORAGE" >    <group gid="sdcard_r" /></permission></code></pre><p>那明确了，<code>READ_EXTERNAL_STORAGE</code>权限获取的gid是<code>sdcard_r</code>，然后查看上面的文件定义，对应<code>AID_SDCARD_R</code>，数值是1028。实际上在7.0上得到的是<code>sdcard_rw</code>，即1015。</p><p>PMS在解析每个Permission时会根据这个文件将Permission关联的gid 加入到一个gid的数组中去，从而硬件设备所对应的设备文件就能被该应用程序访问。这块具体代码流程放到下一篇去分析。想自己跟代码的话可以从该函数看起：</p><pre class=" language-lang-java"><code class="language-lang-java">private void grantRequestedRuntimePermissions(PackageParser.Package pkg, int[] userIds,                                              String[] grantedPermissions) {    for (int userId : userIds) {        grantRequestedRuntimePermissionsForUser(pkg, userId, grantedPermissions);    }    // We could have touched GID membership, so flush out packages.list    synchronized (mPackages) {        mSettings.writePackageListLPr();    }}</code></pre><p>回到存储权限，既然系统会根据permission给App添加合适的gid，那么我们在看下内置存储的权限为</p><pre class=" language-lang-shell"><code class="language-lang-shell">/sdcard # ls -lddrwxrwx--x 27 root sdcard_rw 4096 1970-01-01 18:30 .</code></pre><p>所以获得<code>sdcard_rw</code>权限组的应用才可以访问内置存储。</p><p>到此Android权限的底层实现原理简单介绍完了，不过目前这里还留有一个坑，那就是我在测试App里添加STORAGE权限后，安装到设备里，通过查看进程属性，发现：</p><pre class=" language-lang-shell"><code class="language-lang-shell"># ps | grep softardu0_a53    3530  638   969076 30720 binder_thr b07244fc S com.softard.test# cat /proc/3530/statusName:    com.softard.testState:    S (sleeping)Tgid:    3530Pid:    3530PPid:    638TracerPid:    0Uid:    10053    10053    10053    10053Gid:    10053    10053    10053    10053Ngid:    0FDSize:    256Groups:    9997 50053</code></pre><p>Groups没有对应的gid，但是程序的确可以访问<code>/sdcard</code></p><p>然后我又给App系统签名，作为系统应用放进去再看，</p><pre class=" language-lang-shell"><code class="language-lang-shell"># ps | grep softsystem    3560  629   985352 49184 SyS_epoll_ abea53b8 S com.softard.test# cat /proc/3560/statusName:    com.softard.testState:    S (sleeping)Tgid:    3560Pid:    3560PPid:    629TracerPid:    0Uid:    1000    1000    1000    1000Gid:    1000    1000    1000    1000Ngid:    0FDSize:    256Groups:    1000 1007 1010 1015 1021 1023 2002 2950 3001 3002 3003 3009 9997 41000</code></pre><p>这时候Groups有sdcard_rw权限了。然后从设置里手动关掉存储权限，App无法读取文件，再次检查gid发现这个1015依旧存在。</p><p>WTF，7.0的表现跟5.0完全不一样？又是一个坑…后面抽空再填吧…</p><p>行吧，这篇概览就这样了，后面就开始从眼花缭乱的源码角度去看这一切的实现。</p><h1 id="0101-Reference"><a href="#0101-Reference" class="headerlink" title="0101 Reference"></a>0101 Reference</h1><p><a href="https://blog.csdn.net/xiong521hua/article/details/70186065" target="_blank" rel="noopener">Android文件属性的权限和Permission的联系</a></p><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/tbc.png?raw=true" alt></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Framework </tag>
            
            <tag> permission </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Android][Framework]记一个Uri相关的奇葩bug</title>
      <link href="/2019/01/04/%5BAndroid%5D%5BFramework%5DA-wired-bug-related-uri/"/>
      <url>/2019/01/04/%5BAndroid%5D%5BFramework%5DA-wired-bug-related-uri/</url>
      
        <content type="html"><![CDATA[<p>安装爱奇艺之后，搜索一个外链视频，然后点击播放，就会出现crash。</p><p>这个Bug只在我们的系统里出现，在手机上安装不存在这个现象。</p><p>那就很奇怪了，我们的系统又做了什么错事？作为负责系统的，我慌的一逼，赶紧抓一份log分析。</p><p>crash log：</p><pre class=" language-lang-txt"><code class="language-lang-txt">--------- beginning of crash01-04 15:54:29.614  3743  3743 E AndroidRuntime: FATAL EXCEPTION: main01-04 15:54:29.614  3743  3743 E AndroidRuntime: Process: com.qiyi.video.pad, PID: 374301-04 15:54:29.614  3743  3743 E AndroidRuntime: java.lang.RuntimeException: Unable to start activity ComponentInfo{com.qiyi.video.pad/org.qiyi.android.video.activitys.CommonWebViewNewActivity}: java.lang.UnsupportedOperationException: This isn't a hierarchical URI.01-04 15:54:29.614  3743  3743 E AndroidRuntime:     at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2665)01-04 15:54:29.614  3743  3743 E AndroidRuntime:     at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2726)01-04 15:54:29.614  3743  3743 E AndroidRuntime:     at android.app.ActivityThread.-wrap12(ActivityThread.java)01-04 15:54:29.614  3743  3743 E AndroidRuntime:     at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1477)01-04 15:54:29.614  3743  3743 E AndroidRuntime:     at android.os.Handler.dispatchMessage(Handler.java:102)01-04 15:54:29.614  3743  3743 E AndroidRuntime:     at android.os.Looper.loop(Looper.java:154)01-04 15:54:29.614  3743  3743 E AndroidRuntime:     at android.app.ActivityThread.main(ActivityThread.java:6119)01-04 15:54:29.614  3743  3743 E AndroidRuntime:     at java.lang.reflect.Method.invoke(Native Method)01-04 15:54:29.614  3743  3743 E AndroidRuntime:     at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:900)01-04 15:54:29.614  3743  3743 E AndroidRuntime:     at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:790)01-04 15:54:29.614  3743  3743 E AndroidRuntime: Caused by: java.lang.UnsupportedOperationException: This isn't a hierarchical URI.01-04 15:54:29.614  3743  3743 E AndroidRuntime:     at android.net.Uri.getQueryParameter(Uri.java:1685)01-04 15:54:29.614  3743  3743 E AndroidRuntime:     at com.qiyi.h.com1.aX(Unknown Source)01-04 15:54:29.614  3743  3743 E AndroidRuntime:     at org.qiyi.android.video.activitys.CommonWebViewNewActivity.aCW(Unknown Source)01-04 15:54:29.614  3743  3743 E AndroidRuntime:     at org.qiyi.android.video.activitys.CommonWebViewNewActivity.aiS(Unknown Source)01-04 15:54:29.614  3743  3743 E AndroidRuntime:     at org.qiyi.android.video.activitys.CommonWebViewNewActivity.v(Unknown Source)01-04 15:54:29.614  3743  3743 E AndroidRuntime:     at org.qiyi.android.video.activitys.CommonWebViewBaseActivity.onCreate(Unknown Source)01-04 15:54:29.614  3743  3743 E AndroidRuntime:     at android.app.Activity.performCreate(Activity.java:6720)01-04 15:54:29.614  3743  3743 E AndroidRuntime:     at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1119)01-04 15:54:29.614  3743  3743 E AndroidRuntime:     at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2618)01-04 15:54:29.614  3743  3743 E AndroidRuntime:     ... 9 more01-04 15:54:29.621  1228  2156 W ActivityManager:   Force finishing activity com.qiyi.video.pad/org.qiyi.android.video.activitys.CommonWebViewNewActivity</code></pre><p>根据</p><pre class=" language-lang-txt"><code class="language-lang-txt">UnsupportedOperationException: This isn't a hierarchical URI.</code></pre><p>所以简单跟踪一下Uri代码：</p><p>报错的地方在：</p><pre class=" language-lang-java"><code class="language-lang-java">/** * Returns a set of the unique names of all query parameters. Iterating * over the set will return the names in order of their first occurrence. * * @throws UnsupportedOperationException if this isn't a hierarchical URI * * @return a set of decoded names */public Set<String> getQueryParameterNames() {    if (isOpaque()) {        throw new UnsupportedOperationException(NOT_HIERARCHICAL);    }</code></pre><p>这里就是抛出<code>this isn&#39;t a hierarchical URI</code>异常的地方，所以查看<code>isOpaque</code>什么情况下返回<code>true</code>：</p><pre class=" language-lang-java"><code class="language-lang-java">/** * Returns true if this URI is opaque like "mailto:nobody@google.com". The * scheme-specific part of an opaque URI cannot start with a '/'. */public boolean isOpaque() {    return !isHierarchical();}</code></pre><p>额，也就是说要调查<code>isHierarchical</code>在什么时候返回<code>false</code>。</p><pre class=" language-lang-java"><code class="language-lang-java">/** * Returns true if this URI is hierarchical like "http://google.com". * Absolute URIs are hierarchical if the scheme-specific part starts with * a '/'. Relative URIs are always hierarchical. */public abstract boolean isHierarchical();</code></pre><p>emmmm，它是个抽象方法，那就看一下他的实现。因为实在Uri.java定义的，查找继承Uri的类们，看其实现方法。从代码里搜到所有的继承都在Uri.java的内部类，所以直接搜，最后定位到是在<code>StringUri</code>里面实现的<code>isHierarchical()</code>方法处理后返回的<code>false</code>。</p><pre class=" language-lang-java"><code class="language-lang-java">public boolean isHierarchical() {    int ssi = findSchemeSeparator();    if (ssi == NOT_FOUND) {        // All relative URIs are hierarchical.        return true;    }    if (uriString.length() == ssi + 1) {        // No ssp.        return false;    }    // If the ssp starts with a '/', this is hierarchical.    return uriString.charAt(ssi + 1) == '/';}/** Finds the first ':'. Returns -1 if none found. */private int findSchemeSeparator() {    return cachedSsi == NOT_CALCULATED        ? cachedSsi = uriString.indexOf(':')        : cachedSsi;}</code></pre><p>这个方法逻辑是：</p><ul><li>先从uriString里面查找<code>:</code>并记录其位置</li><li>如果没找到，直接返回<code>true</code>，相当于不做处理</li><li>再判断uriString的长度是否到<code>:</code>为止，如果是返回<code>false</code></li><li>最后判断<code>:</code>后面的字符是否是<code>/</code></li></ul><p>所以知道最后处理的uriString是什么就很关键了，通过添加log，编译系统，找到最后出问题的uriString是：</p><pre class=" language-lang-txt"><code class="language-lang-txt">uristring is deviceId=22b0e7ce4a35edca010和谐&platform=GPad&network=1&ov=7.1.1:1.和谐&location=121.372360,31.176649</code></pre><p>行吧。我就用你爱奇艺播放个视频而已，你看看你干了些什么？又读我设备ID，又读当前位置，还给我搞出来一个Bug。我TM一刀…算了40米的长刀拔出来太麻烦，还是看问题吧。</p><p>这个Uri本来应该在第一处判断就返回<code>true</code>的，但是因为版本号有一个<code>7.1.1:1.xxxx</code>，结果匹配上了冒号，最终因为<code>:</code>后面没有<code>/</code>返回一个<code>false</code>状态。</p><p>好嘛，半天是因为我们定义release版本号导致的这个问题。</p><p>最后也算长了点经验，以后在Android里字串连接的时候尽量不要用<code>:</code>了，否则不知道什么时候在哪里会挖出来一个坑。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Framework </tag>
            
            <tag> uri </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Android][Recovery]自动挂载system分区</title>
      <link href="/2018/12/10/%5BAndroid%5D%5BRecovery%5Drecovery-auto-mount-system/"/>
      <url>/2018/12/10/%5BAndroid%5D%5BRecovery%5Drecovery-auto-mount-system/</url>
      
        <content type="html"><![CDATA[<p>前一篇<a href="http://wossoneri.github.io/2018/12/10/[Android][Recovery]enable-shell-in-recovery/">Recovery打开adb shell</a>里提到system目录是用来挂载系统<code>/system</code>分区的，所以是一个空目录。这一点是通过打开adb shell后，查看文件目录知道的。</p><p>因为原本<code>cache</code>目录也是空的，但是通过shell能看到<code>/cache</code>目录里的文件和Android系统是一致的，也就说明，这个目录是挂载进来的。因此推测<code>system</code>也应该是用来挂载的。</p><p>关于挂载<code>/system</code>，在Recovery里有实现代码动态挂载：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">// bootable/recovery/recovery.cppcase Device::MOUNT_SYSTEM:    char system_root_image[PROPERTY_VALUE_MAX];    property_get("ro.build.system_root_image", system_root_image, "");    // For a system image built with the root directory (i.e.    // system_root_image == "true"), we mount it to /system_root, and symlink /system    // to /system_root/system to make adb shell work (the symlink is created through    // the build system).    // Bug: 22855115    if (strcmp(system_root_image, "true") == 0) {        if (ensure_path_mounted_at("/", "/system_root") != -1) {            ui->Print("Mounted /system.\n");        }    } else {        if (ensure_path_mounted("/system") != -1) {            ui->Print("Mounted /system.\n");        }    }    break;</code></pre><p>但是实现开机挂载，我们就要去看init.rc了。</p><pre class=" language-lang-rc"><code class="language-lang-rc">mvim /bootable/recovery/etc/init.rcimport /init.recovery.${ro.hardware}.rcon early-init    # Set the security context of /postinstall if present.    restorecon /postinstall    start ueventd    start healthdon init    export ANDROID_ROOT /system    export ANDROID_DATA /data    export EXTERNAL_STORAGE /sdcard    symlink /system/etc /etc    mkdir /sdcard    mkdir /udisk    mkdir /system    mkdir /data    mkdir /cache    mkdir /sideload    mkdir /firmware    mount tmpfs tmpfs /tmp    chown root shell /tmp    chmod 0775 /tmp    write /proc/sys/kernel/panic_on_oops 1    write /proc/sys/vm/max_map_count 1000000on fs    mkdir /dev/usb-ffs 0770 shell shell    mkdir /dev/usb-ffs/adb 0770 shell shell    mount functionfs adb /dev/usb-ffs/adb uid=2000,gid=2000    write /sys/class/android_usb/android0/enable 0    write /sys/class/android_usb/android0/idVendor 18D1    write /sys/class/android_usb/android0/idProduct D001    write /sys/class/android_usb/android0/f_ffs/aliases adb    write /sys/class/android_usb/android0/functions adb    write /sys/class/android_usb/android0/iManufacturer ${ro.product.manufacturer}    write /sys/class/android_usb/android0/iProduct ${ro.product.model}    write /sys/class/android_usb/android0/iSerial ${ro.serialno}</code></pre><p>首先会去访问<code>init.recovery.${ro.hardware}.rc</code>的内容，这个文件不存在，然后后面的流程也没有做mount操作。</p><p>作为对比，看一下Android系统的init文件</p><pre class=" language-lang-shell"><code class="language-lang-shell">mvim /device/qcom/xxxx/imit.target.rcon fs    wait /dev/block/bootdevice    mount_all fstab.qcom    write /proc/sys/vm/swappiness 100</code></pre><p>好了，Android系统启动的时候做了一个mount_all操作。来看一下fstab.qcom文件</p><pre class=" language-lang-txt"><code class="language-lang-txt"># Android fstab file.# The filesystem that contains the filesystem checker binary (typically /system) cannot# specify MF_CHECK, and must come before any filesystems that do specify MF_CHECK#TODO: Add 'check' as fs_mgr_flags with data partition.# Currently we dont have e2fsck compiled. So fs check would failed.#<src>                                                <mnt_point>  <type>  <mnt_flags and options>                     <fs_mgr_flags>/dev/block/bootdevice/by-name/system         /system      ext4    ro,barrier=1,discard                                wait, verify/dev/block/bootdevice/by-name/userdata       /data        ext4    nosuid,nodev,barrier=1,noauto_da_alloc,discard      wait,forceencrypt=footer/devices/soc/7864900.sdhci/mmc_host*        /storage/sdcard1   vfat    nosuid,nodev         wait,voldmanaged=sdcard1:auto,noemulatedsd,encryptable=footer/devices/soc/78db000.usb/msm_hsusb_host*    /storage/usbotg    vfat    nosuid,nodev         wait,voldmanaged=usbotg:auto/dev/block/bootdevice/by-name/config         /frp  emmc    defaults                                            defaults/dev/block/bootdevice/by-name/misc          /misc              emmc    defaults             defaults</code></pre><p>我们的system就在这个表里。所以要挂载<code>system</code>，只需要在Recovery的init.rc添加：</p><pre class=" language-lang-rc"><code class="language-lang-rc">wait /dev/block/bootdevice/by-name/systemmount ext4 /dev/block/bootdevice/by-name/system /system wait rw barrier=1</code></pre><p>然后还要注意，挂载点应该（没专门验证）是空目录，所以如果在Recovery开启了shell，要把它删掉。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Recovery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[转][Android][Recovery]Recovery打开adb shell</title>
      <link href="/2018/12/10/%5BAndroid%5D%5BRecovery%5Denable-shell-in-recovery/"/>
      <url>/2018/12/10/%5BAndroid%5D%5BRecovery%5Denable-shell-in-recovery/</url>
      
        <content type="html"><![CDATA[<p>Android recovery 模式下出于安全的考虑，一般禁止adb和adb shell 登陆。如果需要在recovery 模式下进行debug，需要做一些配置修改。</p><p>烧录user版本系统，进入recovery后，输入adb shell命令，提示</p><pre class=" language-lang-shell"><code class="language-lang-shell">error: no devices/emulators found</code></pre><p>我们先确认recovery.img是否包含有adb (adb的源码在/system/core/adb)</p><pre class=" language-lang-shell"><code class="language-lang-shell">ls out/target/product/bullhead/recovery/root/sbinadbd      healthd   recovery  ueventd   watchdogd</code></pre><p>然后检查/bootable/recovery/etc/init.rc下和adbd相关的启动配置</p><pre class=" language-lang-shell"><code class="language-lang-shell">service adbd /sbin/adbd --root_seclabel=u:r:su:s0 --device_banner=recovery    disabled    socket adbd stream 660 system system    seclabel u:r:adbd:s0# Always start adbd on userdebug and eng buildson property:ro.debuggable=1    write /sys/class/android_usb/android0/enable 1    start adbd# Restart adbd so it can run as rooton property:service.adb.root=1    write /sys/class/android_usb/android0/enable 0    restart adbd    write /sys/class/android_usb/android0/enable 1</code></pre><p>从上面可知init.rc 中adbd 是配置的，disabled 表示开机不启动，如  ro.debuggable 被置为1，那么adb 就会开启，或是service.adb.root设置为1，则重启adbd。</p><p>看下</p><pre class=" language-lang-shell"><code class="language-lang-shell">mvim build/core/main.mkifeq (true,$(strip $(enable_target_debugging)))  # Target is more debuggable and adbd is on by default  ADDITIONAL_DEFAULT_PROPERTIES += ro.debuggable=1  # Enable Dalvik lock contention logging.  ADDITIONAL_BUILD_PROPERTIES += dalvik.vm.lockprof.threshold=500  # Include the debugging/testing OTA keys in this build.  INCLUDE_TEST_OTA_KEYS := trueelse # !enable_target_debugging  # Target is less debuggable and adbd is off by default  ADDITIONAL_DEFAULT_PROPERTIES += ro.debuggable=0endif # !enable_target_debugging</code></pre><p>关于enable_target_debugging</p><pre class=" language-lang-shell"><code class="language-lang-shell">## user/userdebug ##user_variant := $(filter user userdebug,$(TARGET_BUILD_VARIANT))enable_target_debugging := truetags_to_install :=ifneq (,$(user_variant))  # Target is secure in user builds.  ADDITIONAL_DEFAULT_PROPERTIES += ro.secure=1  ADDITIONAL_DEFAULT_PROPERTIES += security.perf_harden=1  ifeq ($(user_variant),user)    ADDITIONAL_DEFAULT_PROPERTIES += ro.adb.secure=1  endif  ifeq ($(user_variant),userdebug)    # Pick up some extra useful tools    tags_to_install += debug  else    # Disable debugging in plain user builds.    enable_target_debugging :=  endif  # Disallow mock locations by default for user builds  ADDITIONAL_DEFAULT_PROPERTIES += ro.allow.mock.location=0else # !user_variant  # Turn on checkjni for non-user builds.  ADDITIONAL_BUILD_PROPERTIES += ro.kernel.android.checkjni=1  # Set device insecure for non-user builds.  ADDITIONAL_DEFAULT_PROPERTIES += ro.secure=0  # Allow mock locations by default for non user builds  ADDITIONAL_DEFAULT_PROPERTIES += ro.allow.mock.location=1endif # !user_variant</code></pre><p>可知默认为enable_target_debugging := true，根据user_variant的值如果为user，则enable_target_debugging :=，这又和TARGET_BUILD_VARIANT有关，此变量对应于VARIANT_CHOICES=(user userdebug eng)中的一个值，由我们来选择，相关的实现在/build/envsetup.sh中。</p><p>根据上面可知，编译时如果选择userdebug或是eng，则ro.debuggable=1，如果我们要在user下也开启这些功能，就需要修改设置</p><pre class=" language-lang-shell"><code class="language-lang-shell">enable_target_debugging := truero.debuggable=0</code></pre><p>重新编译recovery.img，刷机后，进入recovery，输入adb shell命令，提示：</p><pre class=" language-lang-shell"><code class="language-lang-shell">Exec ‘/system/bin/sh’ failed:No such fileor directory(2)</code></pre><p>表示没有sh这个文件，无法进入shell，检查ramdisk 文件系统 system 目录out/target/product/bullhead/recovery/root/system为空。(其实这个system是用来挂载Android的/system的，关于挂载后面会讲)</p><p>但我们知道boot.img下是可以的，看system/core/rootdir/init.rc检查boot.img 启动的init.rc。查找关于/sh的代码</p><pre class=" language-lang-shell"><code class="language-lang-shell">service console /system/bin/sh    class core    console    disabled    user shell    group shell log    seclabel u:r:shell:s0on property:ro.debuggable=1    # Give writes to anyone for the trace folder on debug builds.    # The folder is used to store method traces.    chmod 0773 /data/misc/trace    start console</code></pre><p>所以依葫芦画瓢，我们在Recovery的/bootable/recovery/etc/init.rc添加上面的代码。</p><p>好了，虽然这一步会在Recovery启动时启动sh，但是Recovery里面没有这个文件啊（前面说了/system是个空目录，用来挂载系统的）。所以需要编译时创建这个文件，因此在/build/core/Makefile增加创建目录的代码和把系统sh拷贝到Recovery的对应目录下</p><pre class=" language-lang-shell"><code class="language-lang-shell">define build-recoveryimage-target    @echo ----- Making recovery image ------    $(hide) mkdir -p $(TARGET_RECOVERY_OUT)    $(hide) mkdir -p $(TARGET_RECOVERY_ROOT_OUT)/etc $(TARGET_RECOVERY_ROOT_OUT)/sdcard $(TARGET_RECOVERY_ROOT_OUT)/tmp    ...    # 添加下面代码    $(hide) mkdir -p $(TARGET_RECOVERY_ROOT_OUT)/system/bin    $(hide) cp -r $(PRODUCT_OUT)/system/bin/sh $(TARGET_RECOVERY_ROOT_OUT)/system/bin/</code></pre><blockquote><p>这里有个问题，就是clean掉项目重新编译的时候，系统的sh还没有生成，所以这里的拷贝操作会因为找不到sh文件而出错，需要调整代码位置。</p></blockquote><p>但这样还是不行，在recovery模式下，二进制文件都是静态连接方式，recovery模式中没有共享库，缺动态链接库加载器(/system/bin/linker，Android动态连接器linker与静态连接器ld)</p><p>检查sh 连接的动态库：</p><pre class=" language-lang-shell"><code class="language-lang-shell">arm-linux-androideabi-objdump -x out/target/product/xxxx/system/bin/sh | grep NEEDEDNEEDED libc.so</code></pre><p>知道需要改libc的编译。</p><p>所以需要修改/external/mksh/Android.mk</p><pre class=" language-lang-shell"><code class="language-lang-shell">#LOCAL_SYSTEM_SHARED_LIBRARIES := libcLOCAL_STATIC_LIBRARIES := libcLOCAL_FORCE_STATIC_EXECUTABLE := true</code></pre><p>再次编译recovery.img，刷机，进入Recovery模式后就可以使用adb shell了。</p><p>关于没有ls命令，这些命令不可用的原理和sh一样，可以自己试着去改。</p><blockquote><p> Reference</p><p><a href="https://blog.csdn.net/LoongEmbedded/article/details/67638687" target="_blank" rel="noopener">https://blog.csdn.net/LoongEmbedded/article/details/67638687</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Recovery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Android][Framework] 在Android rom添加系统jar包</title>
      <link href="/2018/12/10/%5BAndroid%5D%5BFramework%5Dadd-system-jar/"/>
      <url>/2018/12/10/%5BAndroid%5D%5BFramework%5Dadd-system-jar/</url>
      
        <content type="html"><![CDATA[<h1 id="编译jar包"><a href="#编译jar包" class="headerlink" title="编译jar包"></a>编译jar包</h1><p>在代码对应的Makefile里设定Module名，并且声明编译成java library</p><pre class=" language-lang-mk"><code class="language-lang-mk">include $(CLEAR_VARS)....LOCAL_MODULE := my-module...include $(BUILD_JAVA_LIBRARY)</code></pre><h1 id="添加到系统Makefile"><a href="#添加到系统Makefile" class="headerlink" title="添加到系统Makefile"></a>添加到系统Makefile</h1><p>在系统的Makefile下，比如在/build/target/product/core_minimal.mk添加如下</p><pre class=" language-lang-mk"><code class="language-lang-mk">PRODUCT_PACKAGES += \    ...    my-modulePRODUCT_BOOT_JARS := \    ...    my-module</code></pre><p>然后就可以整编。</p><p>这里要注意，有些jar包编译会报错，比如：</p><pre class=" language-lang-shell"><code class="language-lang-shell">Error: out/target/common/obj/JAVA_LIBRARIES/com.system.info_intermediates/classes.jar: unknown package name of class file com/system/info/SystemInfo.class</code></pre><p>这是说jar包里出现了com/system/info/SystemInfo.class这个路径。错误的原因是系统里有一个jar包的检查机制，为了安全性，系统会有一个白名单，约束jar包内文件的包名。</p><p>文件在build/core/tasks/package_whitelist.txt</p><p>里面是正则匹配了一些基本的jar包文件规则，在里面添加即可。</p><h1 id="使用jar包"><a href="#使用jar包" class="headerlink" title="使用jar包"></a>使用jar包</h1><p>编译到系统后就可以在Makefile定义的路径下找到jar包。然后如果想在系统调用，在对应的Makefile里添加编译依赖即可。比如我要在SystemServer通过调用jar包方法读取单片机信息，那么编译的是service.jar，所以就对/framework/base/services/Android.mk进行修改，添加：</p><pre class=" language-lang-mk"><code class="language-lang-mk">LOCAL_STATIC_JAVA_LIBRARIES := $(addprefix services.,$(services)) \                                my-module</code></pre><p>然后在SystemServer内添加包名：</p><pre class=" language-lang-java"><code class="language-lang-java">import com.mymodlue.name;</code></pre><p>这样就完成了系统jar包的制作以及使用。</p><blockquote><p>Reference</p><p><a href="https://blog.csdn.net/zhudaozhuan/article/details/51789002" target="_blank" rel="noopener">https://blog.csdn.net/zhudaozhuan/article/details/51789002</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> jar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Android][Framework]从全局AlertDialog聊聊WindowManager</title>
      <link href="/2018/12/09/%5BAndroid%5D%5BFramework%5Dsystem-AlertDialog-and-WindowManager/"/>
      <url>/2018/12/09/%5BAndroid%5D%5BFramework%5Dsystem-AlertDialog-and-WindowManager/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>在SystemUI里添加了一个broadcastReceiver，需求接收到消息后弹出一个用户提示</p><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/AlertDialog1.jpg" alt="dialog1"></p><p>实现代码也很简单，</p><pre class=" language-lang-java"><code class="language-lang-java">AlertDialog.Builder builder = new AlertDialog.Builder(mContext);builder.setTitle(R.string.device_temp_high)    .setMessage(warn_format)    .setPositiveButton(R.string.okay, new DialogInterface.OnClickListener() {        @Override        public void onClick(DialogInterface dialogInterface, int i) {        }    }).setCancelable(false).create().show();</code></pre><p>但实际上，这个mContext只能从onReceive(Context context, Intent intent)获取到一个。而这个<code>Context</code>根本无法更新UI。关于<code>Context</code>的具体讨论见：<a href="http://wossoneri.github.io/2018/12/09/[Android]mastering-android-context/">带你掌握Android Context</a></p><p>所以，运行时会报出如下错误：</p><pre class=" language-lang-text"><code class="language-lang-text">Unable to add window — token null is not for an application”</code></pre><p>拿不到<code>Context</code>，emmm，怎么弹出这个对话框呢？</p><p>还好，Android系统留了一些后手。</p><p>将其转换成全局AlertDialog也很简单。</p><p>首先，对AlertDialog添加SYSTEM_ALERT类型</p><pre class=" language-lang-java"><code class="language-lang-java">AlertDialog dlg = builder.create();        dlg.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);dlg.show();</code></pre><p>其次，增加对应权限</p><pre class=" language-lang-xml"><code class="language-lang-xml"><uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW" /></code></pre><p>这样弹窗就变成系统的弹窗了。</p><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/AlertDialog2.png" alt="dialog2"></p><h1 id="TYPE-SYSTEM-ALERT"><a href="#TYPE-SYSTEM-ALERT" class="headerlink" title="TYPE_SYSTEM_ALERT"></a>TYPE_SYSTEM_ALERT</h1><p>草稿整理中.. TBC..</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> App </tag>
            
            <tag> AlertDialog </tag>
            
            <tag> WindowManager </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Android][Framework]系统jar包，sdk的制作及引用</title>
      <link href="/2018/12/09/%5BAndroid%5D%5BFramework%5Dmastering-system-jar-and-sdk/"/>
      <url>/2018/12/09/%5BAndroid%5D%5BFramework%5Dmastering-system-jar-and-sdk/</url>
      
        <content type="html"><![CDATA[<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>因为我是开发ROM的，所以系统的一些改动需要暴露给我们自己的APP。比如：</p><p>之前在PowerManager里面添加过一个新接口，用来释放所有的wake lock，接口调用如下：</p><pre class=" language-lang-java"><code class="language-lang-java">PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);pm.releaseAll();</code></pre><p>现在我们的系统APK需要调用这个方法，但是因为SDK不包含该方法，导致APK编译不通过。所以需要我编译一个包含新接口方法的jar包交给APK编译。（生成jar包的方法见<a href>该文章</a>）</p><h1 id="编译Jar包"><a href="#编译Jar包" class="headerlink" title="编译Jar包"></a>编译Jar包</h1><p>其实编译系统jar包很简单</p><pre class=" language-lang-shell"><code class="language-lang-shell">make framework</code></pre><p>即可得到framework.jar。</p><p>这时候把jar包导入到项目里，发现缺找不到jar包里的方法。这是因为，Android N使用了Jack编译。所以编出来的jar包里面没有class文件，取而代之的是一个优化过的dex文件。</p><p>如果要得到包含class文件的jar包，只需要将Jack编译关闭即可。</p><pre class=" language-lang-shell"><code class="language-lang-shell">#include $(BUILD_JAVA_LIBRARY)include $(BUILD_STATIC_JAVA_LIBRARY)LOCAL_JACK_ENABLED := disabled</code></pre><p>这样再次编译出来的jar包就是包含class文件的jar包。</p><h1 id="Android-Studio导入framework-jar"><a href="#Android-Studio导入framework-jar" class="headerlink" title="Android Studio导入framework.jar"></a>Android Studio导入framework.jar</h1><ol><li><p>拷贝framework.jar包到app/libs目录下</p></li><li><p>右键点击framework.jar，选择add as library，作为库添加到项目。此时看到我们的gradle里dependencies多了一行。</p><pre class=" language-lang-groovy"><code class="language-lang-groovy">implementation files('libs/framework.jar')</code></pre></li><li><p>因为我们希望这个包只在编译时起作用，所以需要把implementation改为compileOnly，帮助通过编译，不打包到apk。</p><pre class=" language-lang-groovy"><code class="language-lang-groovy">compileOnly files('libs/framework.jar')</code></pre><p>也可以通过打开项目的File-&gt;Project structure，界面左侧选择<code>app</code>，右侧选择<code>Dependencies</code>。引用列表里找到libs/classes.jar，右侧scope选择compileOnly即可。</p></li><li><p>还在Project structure同样的界面，把</p><p><code>{include=[*.jar], dir=libs}</code></p><p>删掉。或者把dependencies中的一行删掉：</p><pre class=" language-lang-groovy"><code class="language-lang-groovy">// implementation fileTree(include: ['*.jar'], dir: 'libs')</code></pre><p>目的是明确classes.jar所在的libs目录不作为一般的库导入。</p></li><li><p>在build.gradle添加如下内容，使其加入编译</p><pre class=" language-lang-groovy"><code class="language-lang-groovy">allprojects {    repositories {        maven{url 'https://maven.aliyun.com/repository/public'}        google()        jcenter()    }    // 添加下面代码    gradle.projectsEvaluated {        tasks.withType(JavaCompile) {            options.compilerArgs << '-Xbootclasspath/p:app/libs/framework.jar'        }    }}</code></pre></li><li><p>在model的build.gradle里面加入自动更改model.iml文件的代码。这个代码的作用是将classes.jar放在索引的第一个，这样编译的时候就会先从我们的jar包查找API，而不是从SDK加载。</p><pre class=" language-lang-groovy"><code class="language-lang-groovy">preBuild {    doLast {        def imlFile = file(project.name + ".iml")        println 'Change ' + project.name + '.iml order'        try {            def parsedXml = (new XmlParser()).parse(imlFile)            def jdkNode = parsedXml.component[1].orderEntry.find { it.'@type' == 'jdk' }            parsedXml.component[1].remove(jdkNode)            def sdkString = "Android API " + android.compileSdkVersion.substring("android-".length()) + " Platform"            new Node(parsedXml.component[1], 'orderEntry', ['type': 'jdk', 'jdkName': sdkString, 'jdkType': 'Android SDK'])            groovy.xml.XmlUtil.serialize(parsedXml, new FileOutputStream(imlFile))        } catch (FileNotFoundException e) {            // nop, iml not found        }    }}</code></pre></li></ol><p>至此，需要的操作都已经完成。现在在Activity里使用我们的新接口：</p><pre class=" language-lang-java"><code class="language-lang-java">PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);pm.releaseAll();</code></pre><p>此时，<code>releaseAll</code>虽然显示为红色，但是编译时可以通过的。编译完成放在我们的系统里就可以运行了。</p><p>此方法也可以解决@hide方法无法访问的问题，自己做一个去掉@hide注解的jar包调用即可。但是你的App必须有系统签名。</p><h1 id="SDK制作"><a href="#SDK制作" class="headerlink" title="SDK制作"></a>SDK制作</h1><p>前面的方法，虽然可以让App访问系统自定义的API，但是，有些APP做了很多的外部库引用，我们的jar包因为包含很多系统方法，会导致正常的类引用出现奇怪的错误。这些错误很难解决，所以就讨论了另外一个方案：做一个SDK，在SDK中调用系统的方法，然后让APP调用我的SDK。</p><p>下面是Android Studio制作SDK的步骤：</p><ol><li><p>创建一个新项目</p></li><li><p>右键项目new module-&gt;Android Library-&gt;输入库名 mysdk</p></li><li><p>在module内创建一个新的class文件，尝试调用系统内部的方法</p><pre class=" language-lang-java"><code class="language-lang-java">public class MySDK {    public static void forceStopPackage(Context context, String packageName) {        ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);        am.forceStopPackage(packageName);    }}</code></pre><p>我在SDK暴露出来一个系统方法，这样App要杀掉应用就不需要使用反射，直接调用我的SDK就可以。</p></li><li><p>把framework.jar放到module的lib目录下，在module内的gradle添加以下代码以编译出module：</p><pre class=" language-lang-shell"><code class="language-lang-shell">dependencies {    compileOnly files('libs/framework.jar')    ...}gradle.projectsEvaluated {    tasks.withType(JavaCompile) {        options.compilerArgs.add('-Xbootclasspath/p:libs/framework.jar')    }}task makeJar(type: Copy){    delete 'build/libs/MySdk.jar'    from('build/intermediates/bundles/default/')    into('build/libs/')    include('classes.jar')    rename('classes.jar','MySdk.jar')}makeJar.dependsOn(build)</code></pre></li><li><p>在Gradle菜单双击makeJar进行模块编译，会在sdk里的build/outputs/aar出现</p><p><code>mysdk-debug.aar</code>和<code>mysdk-release.aar</code>两个库文件。</p></li><li><p>将aar文件拷贝到App项目的lib目录下，gradle添加</p><pre class=" language-lang-shell"><code class="language-lang-shell">android {    repositories {        flatDir {            dirs 'libs'        }    }}dependencies {    ...    compile(name:'mysdk', ext:'aar')}</code></pre><p>然后就可以在对应Activity里快乐地使用<code>MySDK.forceStopPackage()</code>调用系统方法了。而且这还有个好处，一些系统API调用需要在Manifest添加对应权限，这样调用后就不需要添加权限了。</p></li></ol><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>gradle版本变化报错：</p><p><code>Invoke-customs are only supported starting with android 0 --min-api 26</code></p><p>解决办法：在build.gradle下添加如下代码</p><pre class=" language-lang-groovy"><code class="language-lang-groovy">android {    compileOptions {        sourceCompatibility JavaVersion.VERSION_1_8        targetCompatibility JavaVersion.VERSION_1_8    }}</code></pre><p><a href="https://stackoverflow.com/a/50198499/4522227" target="_blank" rel="noopener">https://stackoverflow.com/a/50198499/4522227</a></p><blockquote><p>Ref:<a href="https://blog.csdn.net/zhonghe1114/article/details/80923730" target="_blank" rel="noopener">https://blog.csdn.net/zhonghe1114/article/details/80923730</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Framework </tag>
            
            <tag> jar </tag>
            
            <tag> sdk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Android][Framework]设置默认WiFi配置</title>
      <link href="/2018/11/14/%5BAndroid%5D%5BFramework%5DSet-default-wifi-ap-conf/"/>
      <url>/2018/11/14/%5BAndroid%5D%5BFramework%5DSet-default-wifi-ap-conf/</url>
      
        <content type="html"><![CDATA[<p>点击Wifi热点配置选项，会弹出一个对话框，<code>WifiApDialog.java</code>。这个对话框会在onCreate的时候填入一些默认内容：</p><pre class=" language-lang-java"><code class="language-lang-java">if (mWifiConfig != null) {    mSsid.setText(mWifiConfig.SSID);    if (mWifiConfig.apBand == 0) {        mBandIndex = 0;    } else {        mBandIndex = 1;    }    mSecurity.setSelection(mSecurityTypeIndex);    if (mSecurityTypeIndex == WPA2_INDEX) {        mPassword.setText(mWifiConfig.preSharedKey);    }}</code></pre><p>内容都是从mWifiConfig获取的，这个mWifiConfig是在构造的时候赋值：</p><pre class=" language-lang-java"><code class="language-lang-java">// TetherSettings.javaprivate void initWifiTethering() {    final Activity activity = getActivity();    mWifiConfig = mWifiManager.getWifiApConfiguration(); // 这里获取的    mSecurityType = getResources().getStringArray(R.array.wifi_ap_security);    mCreateNetwork = findPreference(WIFI_AP_SSID_AND_SECURITY);    mRestartWifiApAfterConfigChange = false;    if (mWifiConfig == null) {        final String s = activity.getString(            com.android.internal.R.string.wifi_tether_configure_ssid_default);        mCreateNetwork.setSummary(String.format(activity.getString(CONFIG_SUBTEXT),                                                s, mSecurityType[WifiApDialog.OPEN_INDEX]));    } else {        int index = WifiApDialog.getSecurityTypeIndex(mWifiConfig);        mCreateNetwork.setSummary(String.format(activity.getString(CONFIG_SUBTEXT),                                                mWifiConfig.SSID,                                                mSecurityType[index]));    }}@Overridepublic Dialog onCreateDialog(int id) {    if (id == DIALOG_AP_SETTINGS) {        final Activity activity = getActivity();        mDialog = new WifiApDialog(activity, this, mWifiConfig);        return mDialog;    }    return null;}</code></pre><p>继续跟代码</p><pre class=" language-lang-java"><code class="language-lang-java">// WifiServiceImpl.java/** * see {@link WifiManager#getWifiApConfiguration()} * @return soft access point configuration */public WifiConfiguration getWifiApConfiguration() {    enforceAccessPermission();    return mWifiStateMachine.syncGetWifiApConfiguration();}</code></pre><pre class=" language-lang-java"><code class="language-lang-java">// WifiStateMachine.javapublic WifiConfiguration syncGetWifiApConfiguration() {    return mWifiApConfigStore.getApConfiguration();}</code></pre><pre class=" language-lang-java"><code class="language-lang-java">// WifiApConfigStore.java/** * Generate a default WPA2 based configuration with a random password. * We are changing the Wifi Ap configuration storage from secure settings to a * flat file accessible only by the system. A WPA2 based default configuration * will keep the device secure after the update. */private WifiConfiguration getDefaultApConfiguration() {    WifiConfiguration config = new WifiConfiguration();    config.SSID = mContext.getResources().getString(        R.string.wifi_tether_configure_ssid_default);    config.allowedKeyManagement.set(KeyMgmt.WPA2_PSK);    String randomUUID = UUID.randomUUID().toString();    //first 12 chars from xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx    config.preSharedKey = randomUUID.substring(0, 8) + randomUUID.substring(9, 13);    return config;}</code></pre><p>所以，只需要在<code>getDefaultApConfiguration</code>配置默认的热点相关内容。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Framework </tag>
            
            <tag> Wifi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Android][Framework]SystemProperties</title>
      <link href="/2018/11/14/%5BAndroid%5D%5BFramework%5DSystemProperties/"/>
      <url>/2018/11/14/%5BAndroid%5D%5BFramework%5DSystemProperties/</url>
      
        <content type="html"><![CDATA[<h1 id="属性简介"><a href="#属性简介" class="headerlink" title="属性简介"></a>属性简介</h1><p>在Android 系统中，为统一管理系统的属性，设计了一个统一的属性系统。每个属性都有一个名称和值，他们都是字符串格式。属性被大量使用在Android系统中，用来记录系统设置或进程之间的信息交换。属性是在整个系统中全局可见的。每个进程可以get/set属性。在编译的过程中会将各种系统参数汇总到build.prop 以及default.prop 这两个文件中，主要属性集中在build.prop中。</p><p>系统在开机后将读取配置信息并构建共享缓冲区，加快查询速度。另外一个方面，SettingsProvider会在系统第一次初始化时(刷机第一次启动)后，将从Defaults.xml中读取数据然后写入数据库Settings.db 目录。并构建一个缓冲系统供其他应用查询。下面将详细讲述。</p><h1 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h1><p>系统属性根据不同的应用类型，分为：</p><ul><li><p>不可变型</p><p>属性名称以“ro.”开头，那么这个属性被视为只读属性。一旦设置，属性值不能改变。</p></li><li><p>持久型</p><p>属性名称以“persist.”开头，当设置这个属性时，其值也将写入/data/property。</p></li><li><p>网络型</p><p>属性名称以“net.”开头，当设置这个属性时，“net.change”属性将会自动设置，以加入到最后修改的属性名。（这是很巧妙的。 netresolve模块的使用这个属性来追踪在net.*属性上的任何变化。）</p></li><li><p>启动和停止服务</p><p>属性“ ctrl.start ”和“ ctrl.stop ”是用来启动和停止服务。每一项服务必须在/init.rc中定义.系统启动时，与init守护进程将解析init.rc和启动属性服务。一旦收到设置“ ctrl.start ”属性的请求，属性服务将使用该属性值作为服务名找到该服务，启动该服务。这项服务的启动结果将会放入“ init.svc.&lt;服务名&gt;“属性中 。客户端应用程序可以轮询那个属性值，以确定结果。</p></li></ul><h1 id="源码流程"><a href="#源码流程" class="headerlink" title="源码流程"></a>源码流程</h1><p>首先，关于属性，是有长度定义的：</p><p>Bionic/libc/include/sys/system_properties.h</p><pre class=" language-lang-h"><code class="language-lang-h">#define PROP_NAME_MAX    32#define PROP_VALUE_MAX    92</code></pre><p>即属性名长度最大32字节，属性值长度最大92字节。</p><p>如果把属性值修改超出最大长度，会报错：</p><pre class=" language-lang-bash"><code class="language-lang-bash">error: ro.product.model cannot exceed 91 bytes: xxxxxxxxxxxxx...xxxxxxxxx</code></pre><p>在系统初始化过程中，Android系统会分配一块共享内存用来存储properties。这些是由<code>init</code>守护进程完成的，其源代码位于：<code>system/core/init</code>。<code>init</code>守护进程将启动一个属性服务。</p><p>属性服务在<code>init</code>守护进程中运行。每一个客户端想要设置属性时，必须连接属性服务，再向其发送信息。属性服务将会在共享内存区中修改和创建属性。客户端想获得属性信息，可以从共享内存直接读取。这提高了读取性能。</p><pre class=" language-lang-c++"><code class="language-lang-c++">// system/core/init/init.cppint main(int argc, char** argv) {    ...    if (!is_first_stage) {        property_init();    }    ....    property_load_boot_defaults();    ...    start_property_service();}</code></pre><p>看具体调用</p><pre class=" language-lang-c++"><code class="language-lang-c++">// system/core/init/property_service.cppvoid property_init() {    if (__system_property_area_init()) { // 分配内存        ERROR("Failed to initialize property area\n");        exit(1);    }}void property_load_boot_defaults() {    load_properties_from_file(PROP_PATH_RAMDISK_DEFAULT, NULL);}/* * Filter is used to decide which properties to load: NULL loads all keys, * "ro.foo.*" is a prefix match, and "ro.foo.bar" is an exact match. */static void load_properties_from_file(const char* filename, const char* filter) {    Timer t;    std::string data;    if (read_file(filename, &data)) {        data.push_back('\n');        load_properties(&data[0], filter);    }    NOTICE("(Loading properties from %s took %.2fs.)\n", filename, t.duration());}</code></pre><p>在加载默认属性的时候property_load_boot_defaults，读取的<code>PROP_PATH_RAMDISK_DEFAULT</code>来自于</p><pre class=" language-lang-h"><code class="language-lang-h">// bionic/libc/include/sys/_system_properties.h/* 旧版本 */#define PROP_PATH_RAMDISK_DEFAULT  "/default.prop"#define PROP_PATH_SYSTEM_BUILD     "/system/build.prop"#define PROP_PATH_SYSTEM_DEFAULT   "/system/default.prop"#define PROP_PATH_LOCAL_OVERRIDE   "/data/local.prop"/* 新版本 N+ */#define PROP_PATH_RAMDISK_DEFAULT    "/default.prop"#define PROP_PATH_SYSTEM_BUILD        "/system/build.prop"#define PROP_PATH_VENDOR_BUILD        "/vendor/build.prop"#define PROP_PATH_LOCAL_OVERRIDE    "/data/local.prop"#define PROP_PATH_FACTORY            "/factory/factory.prop"</code></pre><p>在builtins.cpp中会从系统文件中读取默认的属性，并写入共享内存中。相同的属性会被后读入的属性替换。</p><pre class=" language-lang-c++"><code class="language-lang-c++">// system/core/init/property_service.cppvoid load_system_props() {    load_properties_from_file(PROP_PATH_SYSTEM_BUILD, NULL);    load_properties_from_file(PROP_PATH_VENDOR_BUILD, NULL);    load_properties_from_file(PROP_PATH_FACTORY, "ro.*");    load_recovery_id_prop();}</code></pre><p>再看上层如何访问属性的。</p><pre class=" language-lang-java"><code class="language-lang-java">// SystemProperties.java 定义了get和set方法private static native String native_get(String key);private static native String native_get(String key, String def);/** * Get the value for the given key. * @return an empty string if the key isn't found * @throws IllegalArgumentException if the key exceeds 32 characters */public static String get(String key) {    if (key.length() > PROP_NAME_MAX) {        throw new IllegalArgumentException("key.length > " + PROP_NAME_MAX);    }    return native_get(key);}/** * Get the value for the given key. * @return if the key isn't found, return def if it isn't null, or an empty string otherwise * @throws IllegalArgumentException if the key exceeds 32 characters */public static String get(String key, String def) {    if (key.length() > PROP_NAME_MAX) {        throw new IllegalArgumentException("key.length > " + PROP_NAME_MAX);    }    return native_get(key, def);}</code></pre><p>该接口类在初始化运行环境中注册对应的cpp接口android_os_SystemProperties.cpp，实际操作通过JNI调用的是cpp文件对应的接口：</p><pre class=" language-lang-c++"><code class="language-lang-c++">// frameworks/base/core/jni/AndroidRuntime.cppnamespace android {extern int register_android_os_SystemProperties(JNIEnv *env);}</code></pre><pre class=" language-lang-c++"><code class="language-lang-c++">// frameworks/base/core/jni/android_os_SystemProperties.cppstatic void SystemProperties_set(JNIEnv *env, jobject clazz, jstring keyJ, jstring valJ){    int err;    const char* key;    const char* val;    key = env->GetStringUTFChars(keyJ, NULL);    if (valJ == NULL) {        val = "";       /* NULL pointer not allowed here */    } else {        val = env->GetStringUTFChars(valJ, NULL);    }    err = property_set(key, val);    env->ReleaseStringUTFChars(keyJ, key);            if (valJ != NULL) {        env->ReleaseStringUTFChars(valJ, val);    }}</code></pre><p>设置key的value时，需要作鉴权，根据设置程序所在进程的fd获知uid值，比如system server进程可以设置net打头的key，不可以设置gsm打头的key，相关的定义如下：</p><pre class=" language-lang-h"><code class="language-lang-h">system/core/include/private/android_filesystem_config.h#define AID_ROOT             0  /* traditional unix root user */#define AID_SYSTEM        1000  /* system server */#define AID_RADIO         1001  /* telephony subsystem, RIL */#define AID_DHCP          1014  /* dhcp client */#define AID_SHELL         2000  /* adb and debug shell user */#define AID_CACHE         2001  /* cache access */#define AID_APP          10000 /* first app user */</code></pre><p>通过查看property_service.c，我们可以明确以下事实：</p><p>1、  属性名不是随意取的。在property_perms数组中定义了当前系统上可用的所有属性的前缀，以及相对应的存取权限UID。对属性的设置要满足权限要求，同时命名也要在这些定义的范围内。</p><p>2、  PA_COUNT_MAX指定了系统（共享内存区域中）最多能存储多少个属性。</p><p>这一段可以从property_set_impl方法逻辑看property前缀</p><pre class=" language-lang-c++"><code class="language-lang-c++">/* White list of permissions for setting property services. */struct {    const char *prefix;    unsigned int uid;    unsigned int gid;} property_perms[] = {    { "net.rmnet0.",      AID_RADIO,    0 },    { "net.gprs.",        AID_RADIO,    0 },    { "net.ppp",          AID_RADIO,    0 },    { "net.qmi",          AID_RADIO,    0 },    { "net.lte",          AID_RADIO,    0 },    { "net.cdma",         AID_RADIO,    0 },    { "ril.",             AID_RADIO,    0 },    { "gsm.",             AID_RADIO,    0 },    { "persist.radio",    AID_RADIO,    0 },    { "net.dns",          AID_RADIO,    0 },    { "sys.usb.config",   AID_RADIO,    0 },    { "net.",             AID_SYSTEM,   0 },    { "dev.",             AID_SYSTEM,   0 },    { "runtime.",         AID_SYSTEM,   0 },    { "hw.",              AID_SYSTEM,   0 },    { "sys.",             AID_SYSTEM,   0 },    { "sys.powerctl",     AID_SHELL,    0 },    { "service.",         AID_SYSTEM,   0 },    { "wlan.",            AID_SYSTEM,   0 },    { "gps.",             AID_GPS,      0 },    { "bluetooth.",       AID_BLUETOOTH,   0 },    { "dhcp.",            AID_SYSTEM,   0 },    { "dhcp.",            AID_DHCP,     0 },    { "debug.",           AID_SYSTEM,   0 },    { "debug.",           AID_SHELL,    0 },    { "log.",             AID_SHELL,    0 },    { "service.adb.root", AID_SHELL,    0 },    { "service.adb.tcp.port", AID_SHELL,    0 },    { "persist.logd.size",AID_SYSTEM,   0 },    { "persist.sys.",     AID_SYSTEM,   0 },    { "persist.service.", AID_SYSTEM,   0 },    { "persist.security.", AID_SYSTEM,   0 },    { "persist.gps.",      AID_GPS,      0 },    { "persist.service.bdroid.", AID_BLUETOOTH,   0 },    { "selinux."         , AID_SYSTEM,   0 },    { "wc_transport.",     AID_BLUETOOTH,   AID_SYSTEM },    { "build.fingerprint", AID_SYSTEM,   0 },    { "partition."        , AID_SYSTEM,   0},#ifdef DOLBY_UDC    { "dolby.audio",      AID_MEDIA,    0 },#endif // DOLBY_UDC#ifdef DOLBY_DAP    // used for setting Dolby specific properties    { "dolby.", AID_SYSTEM,   0 },#endif // DOLBY_DAP    { "sys.audio.init",   AID_MEDIA,    0 },    { NULL, 0, 0 }};</code></pre><p>在开机启动后的init操作中，会执行一个loop循环，当检测到有新的设置时，进入设置流程，鉴权失败会提示相关的异常，如sys_prop: permission denied uid:1000  name:gsm.phone.id</p><h1 id="system-build-prop"><a href="#system-build-prop" class="headerlink" title="system/build.prop"></a>system/build.prop</h1><h2 id="system-build-prop文件"><a href="#system-build-prop文件" class="headerlink" title="system/build.prop文件"></a>system/build.prop文件</h2><pre class=" language-lang-shell"><code class="language-lang-shell">## ADDITIONAL_BUILD_PROPERTIES#...dalvik.vm.heapminfree=6mdalvik.vm.heapstartsize=14mdalvik.vm.heapgrowthlimit=192mdalvik.vm.heapsize=512mdalvik.vm.heaptargetutilization=0.75dalvik.vm.heapmaxfree=8m...import /system/vendor/vendor.prop#IMPORT REGIONALIZATION VENDOR PROP PATH LAST IN ORDER TO OVERRIDE PROPERTIES#import /persist/speccfg/vendor_persist.propimport /system/vendor/default.propimport /system/vendor/power.prop</code></pre><h2 id="system-build-prop生成过程"><a href="#system-build-prop生成过程" class="headerlink" title="system/build.prop生成过程"></a>system/build.prop生成过程</h2><p>从build.prop输出，从注释内容可以看到：</p><ol><li>执行build/tools/buildinfo.sh</li><li>把device/qcom/msmxxxx/system.prop的内容拷贝到$(OUT_TARGET_DEVICE)/system/build.prop</li><li>将ADDITIONAL_BUILD_PROPERTIES也添加到$(OUT_TARGET_DEVICE)/system/build.prop</li></ol><h2 id="在system-build-prop添加自定义属性"><a href="#在system-build-prop添加自定义属性" class="headerlink" title="在system/build.prop添加自定义属性"></a>在system/build.prop添加自定义属性</h2><ol><li>在buildinfo.sh中添加自定义property</li><li>最简单的就是在system.prop里添加一行，然后编译会将其追加到目标文件的</li><li>ADDITIONAL_BUILD_PROPERTIES 是MakeFile的一个声明，也就是在MakeFile中通过<code>ADDITIONAL_BUILD_PROPERTIES += persist.sys.xxxx=1</code>这种方式就可以添加自定义的属性。</li></ol><h1 id="和自定属性相关的实例"><a href="#和自定属性相关的实例" class="headerlink" title="和自定属性相关的实例"></a>和自定属性相关的实例</h1><p>可以使用System Properties记录用户习惯。</p><p>比如，我的设备需要提供Wifi热点功能，当用户主动打开热点后，需要用一个属性记录用户习惯，当设备关机重启后，根据该属性自动打开热点。</p><p>所以首先创建一个persist属性，写在<code>/device/平台/型号/system.prop</code>文件最后。</p><pre class=" language-lang-txt"><code class="language-lang-txt">persist.sys.hotspot.enable=off</code></pre><p>然后在手动开关热点的时候，记录用户的操作到该属性中：</p><pre class=" language-lang-java"><code class="language-lang-java">// ConnectivityManager.java@SystemApipublic void startTethering(int type, boolean showProvisioningUi,        final OnStartTetheringCallback callback, Handler handler) {    ...    if (type == ConnectivityManager.TETHERING_WIFI) {        SystemProperties.set("persist.sys.hotspot.enable", "on");    }    ...}@SystemApipublic void stopTethering(int type) {    ...    if (type == ConnectivityManager.TETHERING_WIFI) {        SystemProperties.set("persist.sys.hotspot.enable", "off");    }    ...}</code></pre><p>最后在开机的时候根据记录的用户习惯，自动打开热点：</p><pre class=" language-lang-java"><code class="language-lang-java">private void startWifiTether() {    String state = SystemProperties.get("persist.sys.hotspot.enable", "off");    if (TextUtils.equals(state, "on")) {        WifiManager wifimanager = (WifiManager) mContext.getSystemService(Context.WIFI_SERVICE);        wifimanager.setWifiEnabled(false); // disable wifi when using wifi hotspot        wifimanager.setWifiApEnabled(null, true);    }}</code></pre><blockquote><p>Ref</p><p><a href="https://www.cnblogs.com/l2rf/p/6610348.html" target="_blank" rel="noopener">https://www.cnblogs.com/l2rf/p/6610348.html</a></p><p><a href="https://www.cnblogs.com/Peter-Chen/p/3946129.html" target="_blank" rel="noopener">https://www.cnblogs.com/Peter-Chen/p/3946129.html</a></p><p><a href="https://blog.csdn.net/ameyume/article/details/8056492" target="_blank" rel="noopener">https://blog.csdn.net/ameyume/article/details/8056492</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> SystemProperties </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Android] 查看MTD，EMMC，MMC三种设备的分区</title>
      <link href="/2018/11/06/%5BAndroid%5DMTD-MMC-EMMC-partition-layout/"/>
      <url>/2018/11/06/%5BAndroid%5DMTD-MMC-EMMC-partition-layout/</url>
      
        <content type="html"><![CDATA[<h1 id="Begining"><a href="#Begining" class="headerlink" title="Begining"></a>Begining</h1><p>因为在做系统升级，AOSP的recovery下有一个flash_image工具，这个工具可以在开机状态下刷写系统分区。源码位置在/bootable/recovery/mtdutils/flash_image.c。</p><p>但在实际操作中，发现flash_image会报错：</p><pre class=" language-lang-shell"><code class="language-lang-shell">error scanning partitions: No such file or directory</code></pre><p>说找不到分区。调查源码发现</p><pre class=" language-lang-c"><code class="language-lang-c">// flash_image.cif (mtd_scan_partitions() <= 0) die("error scanning partitions");// mtdutils.c  mtd_scan_partitions()/* Parse the contents of the file, which looks like: * *     # cat /proc/mtd *     dev:    size   erasesize  name *     mtd0: 00080000 00020000 "bootloader" *     mtd1: 00400000 00020000 "mfg_and_gsm" *     mtd2: 00400000 00020000 "0000000c" *     mtd3: 00200000 00020000 "0000000d" *     mtd4: 04000000 00020000 "system" *     mtd5: 03280000 00020000 "userdata" */</code></pre><p>大概就是会通过<code>/proc/mtd</code>这个文件查找分区信息，然后进行刷写。然后我去找这个文件，结果发现设备里面并没有这个文件。于是开始查找这个mtd相关信息。</p><p>Android设备有多个分区存储不同的数据，通常的分区有recovery，boot，system，data和cache分区。几乎每个设备都有它自己的分区设计，这个和生产商有关，但常见的有MTD，EMMC和MMC设备。</p><h1 id="MTD"><a href="#MTD" class="headerlink" title="MTD"></a>MTD</h1><p>Memory Technology Device，内存技术设备，是用于访问memory设备（ROM、flash）的Linux子系统。MTD的主要目的是为了使新的memory设备的驱动更加简单，为此它在硬件和上层之间提供了一个抽象的接口，并进行了一个层次划分，层次从上到下大致为：设备文件、MTD设备层、MTD原始设备层、硬件驱动层。MTD的所有源代码在/drivers/mtd子目录下。</p><blockquote><p>更详细的MTD设备分析见<a href="https://opensourceforu.com/2012/01/working-with-mtd-devices/" target="_blank" rel="noopener">https://opensourceforu.com/2012/01/working-with-mtd-devices/</a></p></blockquote><h2 id="MTD设备文件"><a href="#MTD设备文件" class="headerlink" title="MTD设备文件"></a>MTD设备文件</h2><pre class=" language-lang-shell"><code class="language-lang-shell">~ $ ls /dev/mtd* -lcrw-rw----    1 root     root      90,   0 Jan  1 00:00 /dev/mtd0crw-rw----    1 root     root      90,   1 Jan  1 00:00 /dev/mtd0rocrw-rw----    1 root     root      90,   2 Jan  1 00:00 /dev/mtd1crw-rw----    1 root     root      90,   3 Jan  1 00:00 /dev/mtd1rocrw-rw----    1 root     root      90,   4 Jan  1 00:00 /dev/mtd2crw-rw----    1 root     root      90,   5 Jan  1 00:00 /dev/mtd2rocrw-rw----    1 root     root      90,   6 Jan  1 00:00 /dev/mtd3crw-rw----    1 root     root      90,   7 Jan  1 00:00 /dev/mtd3robrw-rw----    1 root     root      31,   0 Jan  1 00:00 /dev/mtdblock0brw-rw----    1 root     root      31,   1 Jan  1 00:00 /dev/mtdblock1brw-rw----    1 root     root      31,   2 Jan  1 00:00 /dev/mtdblock2brw-rw----    1 root     root      31,   3 Jan  1 00:00 /dev/mtdblock3/dev/mtd:crw-rw-rw-    1 root     root      90,   0 Jan  1 00:00 0cr--r--r--    1 root     root      90,   1 Jan  1 00:00 0rocrw-rw-rw-    1 root     root      90,   2 Jan  1 00:00 1cr--r--r--    1 root     root      90,   3 Jan  1 00:00 1rocrw-rw-rw-    1 root     root      90,   4 Jan  1 00:00 2cr--r--r--    1 root     root      90,   5 Jan  1 00:00 2rocrw-rw-rw-    1 root     root      90,   6 Jan  1 00:00 3cr--r--r--    1 root     root      90,   7 Jan  1 00:00 3ro/dev/mtdblock:brw-------    1 root     root      31,   0 Jan  1 00:00 0brw-------    1 root     root      31,   1 Jan  1 00:00 1brw-------    1 root     root      31,   2 Jan  1 00:00 2brw-------    1 root     root      31,   3 Jan  1 00:00 3</code></pre><p>可以看到有mtdN和对应的/dev/mtd/N、mtdblockN和对应的/dev/mtdblock/N两类MTD设备，分别是字符设备，主设备号90和块设备，主设备号31。其中/dev/mtd0和/dev/mtd/0是完全等价的，/dev/mtdblock0和/dev/mtdblock/0是完全等价的，而/dev/mtd0和/dev/mtdblock0则是同一个MTD分区的两种不同应用描述，操作上是有区别的。</p><h3 id="dev-mtdN设备"><a href="#dev-mtdN设备" class="headerlink" title="/dev/mtdN设备"></a>/dev/mtdN设备</h3><p>/dev/mtdN 是MTD架构中实现的mtd分区所对应的字符设备(将mtd设备分成多个区，每个区就为一个字符设备)，其里面添加了一些ioctl，支持很多命令，如MEMGETINFO，MEMERASE等。</p><p>mtd-utils中的flash_eraseall等工具，就是以这些ioctl为基础而实现的工具，实现一些关于Flash的操作。比如，mtd 工具中 flash_eraseall中：</p><pre class=" language-lang-shell"><code class="language-lang-shell">if (ioctl(fd, MEMGETINFO, &meminfo) != 0) {   fprintf(stderr, "%s: %s: unable to get MTD device info\n",exe_name, mtd_device);   return 1;}</code></pre><p>MEMGETINFO是Linux MTD中的drivers/mtd/mtdchar.c中的ioctl命令，使用mtd字符设备需要加载mtdchar内核模块。该代码解释了上面的第一个现象。</p><h3 id="dev-mtdblockN设备"><a href="#dev-mtdblockN设备" class="headerlink" title="/dev/mtdblockN设备"></a>/dev/mtdblockN设备</h3><p>/dev/mtdblockN，是<strong>Flash驱动</strong>中用add_mtd_partitions()添加MTD设备分区，而生成的对应的块设备。MTD块设备驱动程序可以让flash器件伪装成块设备，实际上它通过把整块的erase block放到ram里面进行访问，然后再更新到flash，用户可以在这个块设备上创建通常的文件系统。</p><p>而对于MTD块设备，MTD设备层是不提供ioctl的实现方法的，也就不会有对应的MEMGETINFO命令之类，因此不能使用nandwrite,flash_eraseall,flash_erase等工具去对/dev/mtdblockN去进行操作，否则就会出现上面的现象一，同时也解释了现象3——用mtd2擦除分区后，在用mtdblock2进行umount就会造成混乱。</p><p>mtd块设备的大小可以通过proc文件系统进行查看：</p><pre class=" language-lang-shell"><code class="language-lang-shell">~ $ cat /proc/partitionsmajor minor  #blocks  name  31     0        512 mtdblock0  31     1       1024 mtdblock1  31     2       5632 mtdblock2  31     3       9216 mtdblock3 254     0   30760960 mmcblk0     254     1   30756864 mmcblk0p1</code></pre><p>后面的两个是SD块设备的分区大小。每个block的大小是1KB。</p><h2 id="MTD设备分区"><a href="#MTD设备分区" class="headerlink" title="MTD设备分区"></a>MTD设备分区</h2><p>通过proc文件系统查看mtd设备的分区情况：</p><pre class=" language-lang-shell"><code class="language-lang-shell">~ $ cat /proc/mtddev:    size   erasesize  namemtd0: 00080000 00020000 "boot"mtd1: 00100000 00020000 "kernel"mtd2: 00580000 00020000 "roofs70"mtd3: 00900000 00020000 "app"</code></pre><p>可以发现，实际上mtdN和mtdblockN描述的是同一个MTD分区，对应同一个硬件分区，两者的大小是一样的，只不过是MTD设备层提供给上层的视图不一样，给上层提供了字符和块设备两种操作视图——为了上层使用的便利和需要，比如mount命令的需求，你只能挂载块设备(有文件系统)，而不能对字符设备进行挂载，否则会出现上面的现象2:无效参数。</p><p>这里对于mtd和mtdblock设备的使用场景进行简单总结：</p><ol><li>mtd-utils工具只能应用与/dev/mtdN的MTD字符设备</li><li>mount、umount命令只对/dev/mtdblockN的MTD块设备有效</li><li>/dev/mtdN和/dev/mtdblockN是同一个MTD设备的同一个分区（N一样）</li></ol><h1 id="EMMC"><a href="#EMMC" class="headerlink" title="EMMC"></a>EMMC</h1><p>Embedded MultiMedia Card</p><p>分区信息可以从<code>/proc/emmc</code></p><pre class=" language-lang-shell"><code class="language-lang-shell">cat /proc/emmcdev:        size     erasesize namemmcblk0p17: 00040000 00000200 "misc"mmcblk0p21: 0087f400 00000200 "recovery"mmcblk0p22: 00400000 00000200 "boot"mmcblk0p25: 22dffe00 00000200 "system"mmcblk0p29: 002ffc00 00000200 "local"mmcblk0p27: 090ffe00 00000200 "cache"mmcblk0p26: 496ffe00 00000200 "userdata"mmcblk0p30: 014bfe00 00000200 "devlog"mmcblk0p31: 00040000 00000200 "pdata"mmcblk0p28: 09800000 00000200 "lib"</code></pre><p>来获取。</p><h1 id="MMC"><a href="#MMC" class="headerlink" title="MMC"></a>MMC</h1><p>MultiMedia Card</p><p>它的分区信息只能从<code>/proc/partitions</code>获得：</p><pre class=" language-lang-shell"><code class="language-lang-shell">cat /proc/partitionsmajor minor  #blocks  name 254        0     524288 zram0 179        0   15388672 mmcblk0 179        1      86016 mmcblk0p1 179        2          1 mmcblk0p2 179        3          8 mmcblk0p3 179        4        512 mmcblk0p4 179        5        512 mmcblk0p5 179        6        512 mmcblk0p6 179        7        512 mmcblk0p7 179        8       2048 mmcblk0p8 179        9       2048 mmcblk0p9 179       10        256 mmcblk0p10 179       11        256 mmcblk0p11 179       12      16384 mmcblk0p12 179       13       1536 mmcblk0p13 179       14       1536 mmcblk0p14 179       15         32 mmcblk0p15 179       16       1536 mmcblk0p16 179       17         16 mmcblk0p17 179       18      33792 mmcblk0p18 179       19       1024 mmcblk0p19 179       20       1024 mmcblk0p20 179       21      65536 mmcblk0p21 179       22      65536 mmcblk0p22 179       23       1024 mmcblk0p23 179       24    2883584 mmcblk0p24 179       25     262144 mmcblk0p25 179       26      32768 mmcblk0p26 179       27       1024 mmcblk0p27 179       28        512 mmcblk0p28 179       29         32 mmcblk0p29 179       30     524288 mmcblk0p30 179       31         32 mmcblk0p31 259        0        512 mmcblk0p32 259        1       1024 mmcblk0p33 259        2      32768 mmcblk0p34 259        3        512 mmcblk0p35 259        4       4096 mmcblk0p36 259        5        256 mmcblk0p37 259        6        256 mmcblk0p38 259        7        256 mmcblk0p39 259        8        256 mmcblk0p40 259        9        256 mmcblk0p41 259       10        256 mmcblk0p42 259       11        256 mmcblk0p43 259       12        256 mmcblk0p44 259       13          8 mmcblk0p45 259       14      65536 mmcblk0p46 259       15        512 mmcblk0p47 259       16        512 mmcblk0p48 259       17   10670063 mmcblk0p49 179       32       4096 mmcblk0rpmb 179       64   30375936 mmcblk1 179       65   30371840 mmcblk1p1 253        0   10670047 dm-0</code></pre><p>但这里显示的一堆盘符并不直观，所以还需要通过name表找到盘符对应分区关系：</p><pre class=" language-lang-shell"><code class="language-lang-shell">msm8937_32:/ # ls -l /dev/block/platform/soc/7824900.sdhci/by-name/total 0lrwxrwxrwx 1 root root 21 1970-01-01 09:07 DDR -> /dev/block/mmcblk0p15lrwxrwxrwx 1 root root 21 1970-01-01 09:07 aboot -> /dev/block/mmcblk0p19lrwxrwxrwx 1 root root 21 1970-01-01 09:07 abootbak -> /dev/block/mmcblk0p20lrwxrwxrwx 1 root root 21 1970-01-01 09:07 apdp -> /dev/block/mmcblk0p43lrwxrwxrwx 1 root root 21 1970-01-01 09:07 boot -> /dev/block/mmcblk0p21lrwxrwxrwx 1 root root 21 1970-01-01 09:07 cache -> /dev/block/mmcblk0p25lrwxrwxrwx 1 root root 21 1970-01-01 09:07 cmnlib -> /dev/block/mmcblk0p37lrwxrwxrwx 1 root root 21 1970-01-01 09:07 cmnlib64 -> /dev/block/mmcblk0p39lrwxrwxrwx 1 root root 21 1970-01-01 09:07 cmnlib64bak -> /dev/block/mmcblk0p40lrwxrwxrwx 1 root root 21 1970-01-01 09:07 cmnlibbak -> /dev/block/mmcblk0p38lrwxrwxrwx 1 root root 21 1970-01-01 09:07 config -> /dev/block/mmcblk0p29lrwxrwxrwx 1 root root 21 1970-01-01 09:07 devcfg -> /dev/block/mmcblk0p10lrwxrwxrwx 1 root root 21 1970-01-01 09:07 devcfgbak -> /dev/block/mmcblk0p11lrwxrwxrwx 1 root root 21 1970-01-01 09:07 devinfo -> /dev/block/mmcblk0p23lrwxrwxrwx 1 root root 21 1970-01-01 09:07 dip -> /dev/block/mmcblk0p33lrwxrwxrwx 1 root root 21 1970-01-01 09:07 dpo -> /dev/block/mmcblk0p45lrwxrwxrwx 1 root root 21 1970-01-01 09:07 dsp -> /dev/block/mmcblk0p12lrwxrwxrwx 1 root root 20 1970-01-01 09:07 fsc -> /dev/block/mmcblk0p2lrwxrwxrwx 1 root root 21 1970-01-01 09:07 fsg -> /dev/block/mmcblk0p16lrwxrwxrwx 1 root root 21 1970-01-01 09:07 keymaster -> /dev/block/mmcblk0p41lrwxrwxrwx 1 root root 21 1970-01-01 09:07 keymasterbak -> /dev/block/mmcblk0p42lrwxrwxrwx 1 root root 21 1970-01-01 09:07 keystore -> /dev/block/mmcblk0p28lrwxrwxrwx 1 root root 21 1970-01-01 09:07 limits -> /dev/block/mmcblk0p31lrwxrwxrwx 1 root root 21 1970-01-01 09:07 logdump -> /dev/block/mmcblk0p46lrwxrwxrwx 1 root root 21 1970-01-01 09:07 mcfg -> /dev/block/mmcblk0p36lrwxrwxrwx 1 root root 21 1970-01-01 09:07 mdtp -> /dev/block/mmcblk0p34lrwxrwxrwx 1 root root 21 1970-01-01 09:07 misc -> /dev/block/mmcblk0p27lrwxrwxrwx 1 root root 20 1970-01-01 09:07 modem -> /dev/block/mmcblk0p1lrwxrwxrwx 1 root root 21 1970-01-01 09:07 modemst1 -> /dev/block/mmcblk0p13lrwxrwxrwx 1 root root 21 1970-01-01 09:07 modemst2 -> /dev/block/mmcblk0p14lrwxrwxrwx 1 root root 21 1970-01-01 09:07 mota -> /dev/block/mmcblk0p32lrwxrwxrwx 1 root root 21 1970-01-01 09:07 msadp -> /dev/block/mmcblk0p44lrwxrwxrwx 1 root root 21 1970-01-01 09:07 odm -> /dev/block/mmcblk0p47lrwxrwxrwx 1 root root 21 1970-01-01 09:07 oem -> /dev/block/mmcblk0p30lrwxrwxrwx 1 root root 21 1970-01-01 09:07 persist -> /dev/block/mmcblk0p26lrwxrwxrwx 1 root root 21 1970-01-01 09:07 recovery -> /dev/block/mmcblk0p22lrwxrwxrwx 1 root root 20 1970-01-01 09:07 rpm -> /dev/block/mmcblk0p6lrwxrwxrwx 1 root root 20 1970-01-01 09:07 rpmbak -> /dev/block/mmcblk0p7lrwxrwxrwx 1 root root 20 1970-01-01 09:07 sbl1 -> /dev/block/mmcblk0p4lrwxrwxrwx 1 root root 20 1970-01-01 09:07 sbl1bak -> /dev/block/mmcblk0p5lrwxrwxrwx 1 root root 21 1970-01-01 09:07 sec -> /dev/block/mmcblk0p17lrwxrwxrwx 1 root root 21 1970-01-01 09:07 splash -> /dev/block/mmcblk0p18lrwxrwxrwx 1 root root 20 1970-01-01 09:07 ssd -> /dev/block/mmcblk0p3lrwxrwxrwx 1 root root 21 1970-01-01 09:07 ssign -> /dev/block/mmcblk0p48lrwxrwxrwx 1 root root 21 1970-01-01 09:07 syscfg -> /dev/block/mmcblk0p35lrwxrwxrwx 1 root root 21 1970-01-01 09:07 system -> /dev/block/mmcblk0p24lrwxrwxrwx 1 root root 20 1970-01-01 09:07 tz -> /dev/block/mmcblk0p8lrwxrwxrwx 1 root root 20 1970-01-01 09:07 tzbak -> /dev/block/mmcblk0p9lrwxrwxrwx 1 root root 21 1970-01-01 09:07 userdata -> /dev/block/mmcblk0p49</code></pre><p>这样结合两个表就可以找到对应的盘符了。</p><p>比如，<code>system</code>分区对应着<code>mmcblk0p24</code>。</p><p>如果设备里有<code>parted</code>工具，就可以看更多信息</p><h2 id="parted-工具"><a href="#parted-工具" class="headerlink" title="parted 工具"></a>parted 工具</h2><p>从上面的<code>cat /proc/partitions</code>看到<strong>mmcblk0</strong>是储存所有分区信息的主block，如果设备root过，就可以通过<code>parted</code>获取上面的信息：</p><pre class=" language-lang-shell"><code class="language-lang-shell">parted /dev/block/mmcblk0</code></pre><p>使用参数p(rint)打印信息</p><p><img src="https://iwf1.com/wordpress/wp-content/uploads/2016/02/Android-repartition-parted-print-partitions-table.jpg" alt></p><p>上面打印出来的大小单位都不统一，所以可以改成用<strong>unit b</strong>将单位统一成bytes，这样看起来会更加方便。</p><p>help查看可用参数</p><p><img src="https://iwf1.com/wordpress/wp-content/uploads/2016/02/Android-repartition-parted-help.jpg" alt></p><blockquote><p>更多parted操作见<a href="https://iwf1.com/how-to-re-partition-your-android-tablet-or-smartphone-all-options-included-change-size-fs-type-etc/2" target="_blank" rel="noopener">https://iwf1.com/how-to-re-partition-your-android-tablet-or-smartphone-all-options-included-change-size-fs-type-etc/2</a></p></blockquote><p>Reference</p><p><a href="https://my.oschina.net/shelllife/blog/123482" target="_blank" rel="noopener">https://my.oschina.net/shelllife/blog/123482</a></p><p><a href="https://www.cnblogs.com/shangdawei/p/4514128.html" target="_blank" rel="noopener">https://www.cnblogs.com/shangdawei/p/4514128.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Recovery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Android][Recovery] Recovery下找不到sdcard路径</title>
      <link href="/2018/11/02/%5BAndroid%5D%5BRecovery%5Drecovery-cannot-locate-sdcard/"/>
      <url>/2018/11/02/%5BAndroid%5D%5BRecovery%5Drecovery-cannot-locate-sdcard/</url>
      
        <content type="html"><![CDATA[<p>做升级的时候，把更新包拷贝到sd卡中，然后调用接口进行重启升级</p><pre class=" language-lang-java"><code class="language-lang-java">File update_file = new File("/sdcard/update.zip");try {    Log.d("WOW", "install " + update_file.getAbsolutePath());    RecoverySystem.installPackage(getBaseContext(), update_file);} catch (IOException e) {    e.printStackTrace();}</code></pre><p>之后进入Recovery模式后报错：</p><pre class=" language-lang-txt"><code class="language-lang-txt">Supported API: 3charge_status 3, charged 0, status 0, capacity 62Finding update package...Opening update package...E:unknow volume for path [/storage/emulated/0/update.zip]E:failed to map fileInstallation aborted.</code></pre><p>说是找不到<code>/storage/emulated/0</code>这个路径？</p><p>因为上层用Java写路径的时候，获取的是Android的路径，我们知道，adb shell里面是有<code>/sdcard</code>的路径的，这个路径实际上并不是插入的SD卡路径，而是一个内置路径。</p><blockquote><p>内置路径通过 ls -l 可以看到 /sdcard 的映射<br>lrwxrwxrwx   1 root   root       21 1970-01-01 08:00 sdcard -&gt; /storage/self/primary<br>也就是说下面几个路径是一样的<br>/sdcard/<br>/storage/emulated/0<br>/storage/self/primary</p><p>而外置sd卡路径是<br>/storage/0658-0900</p></blockquote><p>所以，我们代码里写的是<code>/sdcard</code>但是传到Recovery的路径就变成<code>/storage/emulated/0</code>了。</p><p>我们的需求是把升级包放到sdcard里面去，所以就需要修改Recovery里的文件路径。</p><p>实际要做的就是把获得到的路径里面<code>/storage/emulated/0</code>替换成<code>/sdcard</code>即可：</p><blockquote><p>Recovery里面的sd卡路径就是/sdcard/</p></blockquote><pre class=" language-lang-c++"><code class="language-lang-c++">    if (update_package) {        // For backwards compatibility on the cache partition only, if        // we're given an old 'root' path "CACHE:foo", change it to        // "/cache/foo".        if (strncmp(update_package, "CACHE:", 6) == 0) {            int len = strlen(update_package) + 10;            char* modified_path = (char*)malloc(len);            if (modified_path) {                strlcpy(modified_path, "/cache/", len);                strlcat(modified_path, update_package+6, len);                printf("(replacing path \"%s\" with \"%s\")\n",                       update_package, modified_path);                update_package = modified_path;            }            else                printf("modified_path allocation failed\n");        } else if(strncmp(update_package, "/storage/emulated/0/", 20) == 0) {            int len = strlen(update_package) + 20;            char* modified_path = (char*)malloc(len);            if (modified_path) {                strlcpy(modified_path, "/sdcard/", len);                strlcat(modified_path, update_package+20, len);                printf("(replacing path \"%s\" with \"%s\")\n",                       update_package, modified_path);                update_package = modified_path;            }            else                printf("modified_path allocation failed\n");        }</code></pre><p>Ref <a href="https://blog.csdn.net/wed110/article/details/9943915?utm_source=blogxgwz1" target="_blank" rel="noopener">https://blog.csdn.net/wed110/article/details/9943915?utm_source=blogxgwz1</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Recovery </tag>
            
            <tag> Framework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Android][Framework] 制作OTA升级包</title>
      <link href="/2018/09/21/%5BAndroid%5D%5BFramework%5Dcreate-ota-update-zip/"/>
      <url>/2018/09/21/%5BAndroid%5D%5BFramework%5Dcreate-ota-update-zip/</url>
      
        <content type="html"><![CDATA[<h1 id="OTA-软件包工具"><a href="#OTA-软件包工具" class="headerlink" title="OTA 软件包工具"></a>OTA 软件包工具</h1><p><code>build/tools/releasetools</code> 中提供的 ota_from_target_files 工具可以构建两种类型的软件包：完整更新软件包和增量更新软件包。该工具将 Android 构建系统生成的 target_files .zip 文件作为输入文件。</p><h2 id="完整更新"><a href="#完整更新" class="headerlink" title="完整更新"></a>完整更新</h2><p>完整更新是指软件包将对设备的整个最终状态（system分区、boot分区和recovery分区）进行更新。只要设备能够接收软件包并启动恢复系统，软件包就可以安装所需的版本，而不受设备当前状态的影响。</p><p>示例：使用发布工具为假设的 <strong>msm8953_32</strong> 设备构建完整更新：</p><pre class=" language-lang-shell"><code class="language-lang-shell"># first, build the target-files .zip. build/envsetup.sh && lunch msm8953_32-usermkdir dist_outputmake dist DIST_DIR=dist_output</code></pre><p>target_files .zip 包含构建 OTA 软件包所需的所有内容。</p><pre><code>./build/tools/releasetools/ota_from_target_files dist_output/tardis-target_files.zip ota_update.zip</code></pre><p>ota_update.zip 现已准备就绪，可以发送到测试设备（所有内容均使用测试密钥进行签名）。</p><h2 id="增量更新"><a href="#增量更新" class="headerlink" title="增量更新"></a>增量更新</h2><p>增量更新包含一组要应用于设备上的已有数据的二进制补丁程序。以下原因可能会导致此类更新软件包非常小：</p><ul><li>未更改的文件不需要包含在其中。</li><li>更改的文件通常与之前的版本非常相似，因此软件包中只需包含针对两个文件之间的不同之处进行的编码。</li></ul><p>只有当设备具有构建相应软件包所使用的旧版本或源版本时，您才能在设备上安装增量更新软件包。要构建增量更新，您需要拥有上一个版本（您要更新的版本）中的 target_files .zip 以及新版本中的 target_files .zip。</p><pre class=" language-lang-shell"><code class="language-lang-shell">./build/tools/releasetools/ota_from_target_files -i PREVIOUS-tardis-target_files.zip dist_output/tardis-target_files.zip incremental_ota_update.zip # make incremental from the older version</code></pre><p>该版本与上一个版本非常类似，而且增量更新软件包（约 1 MB）比对应的完整更新软件包 (60 MB) 小得多。</p><p>仅当设备运行的上一个版本与相应增量更新软件包的起点版本完全一样时，才向其分发该增量更新软件包。如果尝试在运行其他版本的设备上安装该增量包，系统将会显示恢复错误图标。此时用户只要重新启动设备，即可回到旧系统；软件包会先验证它要更新的所有文件是否已回到之前的状态，然后再对其执行操作，因此，如果发生上述情况，设备不应留在半升级状态。</p><h1 id="制作升级包"><a href="#制作升级包" class="headerlink" title="制作升级包"></a>制作升级包</h1><p>为了减小升级包的大小，我们选择制作差分包（增量升级包）。</p><p>要制作差分升级包，需要先做出两个全升级包，然后根据这两个包制作出差分升级包。</p><h2 id="编译系统"><a href="#编译系统" class="headerlink" title="编译系统"></a>编译系统</h2><p>制作升级包之前需要先对系统代码进行整编。编译之前记得清空out目录，因为系统编译不会自动检查删除当前版本弃用的文件。</p><pre class=" language-lang-shell"><code class="language-lang-shell">. build/envsetup.shlunch msm8953make clobbermake -j20</code></pre><p>编译完成就会在<code>$OUT</code>目录下生成所有的img文件。</p><blockquote><p>可以通过printenv查看<code>$OUT</code>指向哪里。</p></blockquote><h2 id="编译升级包"><a href="#编译升级包" class="headerlink" title="编译升级包"></a>编译升级包</h2><p>使用</p><pre class=" language-lang-shell"><code class="language-lang-shell">make otapackage</code></pre><p>编译结束会在<code>$OUT/obj/PACKAGING/target_files_intermediates/</code>目录下生成升级用的<code>.zip</code>包。比如:<strong>msm8953-target_files-eng.Data.BU.zip</strong> </p><h2 id="制作差分包"><a href="#制作差分包" class="headerlink" title="制作差分包"></a>制作差分包</h2><p>有了升级包，将其拷贝到一个目录下保存，比如<code>OTA/old</code>，然后对源码做一些修改，保证有更新。然后clean掉<code>$OUT</code>目录，再次整编，制作升级包，然后把新的升级包拷贝到<code>OTA/new</code>目录下。</p><p>最后使用ota_from_target_files脚本制作差分包就可以了：</p><pre class=" language-lang-shell"><code class="language-lang-shell">./build/tools/releasetools/ota_from_target_files -i OTA/old/*.zip OTA/old/*.zip OTA/update/update.zip</code></pre><h2 id="差分包签名"><a href="#差分包签名" class="headerlink" title="差分包签名"></a>差分包签名</h2><p>使用</p><pre class=" language-lang-bash"><code class="language-lang-bash">make otapackage</code></pre><p>生成的包是系统签过名的。耳机通过脚本做出来的差分包也是签过名的：</p><pre class=" language-lang-shell"><code class="language-lang-shell">$ unzip update.zipArchive: update.zipsigned by SignApk  inflating: META-INF/com/android/metadata  inflating: META-INF/com/google/android/update-binary  inflating: META-INF/com/google/android/updater-script  inflating: META-INF/com/android/otacert  inflating: META-INF/MANIFEST.MF  inflating: META-INF/CERT.SF  inflating: META-INF/CERT.RSA$ keytool -printcert -file META-INF/CERT.RSA</code></pre><p>能够打印出我们的keystore。</p><p>如果手动修改自定义升级包，需要再次签名</p><pre class=" language-lang-shell"><code class="language-lang-shell">./build/tools/releasetools/ota_from_target_files \    -k ~/.android-certs/releasekey \    signed-target_files.zip \    signed-ota_update.zip</code></pre><h1 id="编写升级包制作脚本"><a href="#编写升级包制作脚本" class="headerlink" title="编写升级包制作脚本"></a>编写升级包制作脚本</h1><p>脚本在croot目录执行，思路是首先制作一个升级包放在<code>OTA/old</code>目录下，之后每次编译，都会编译出升级包放在<code>OTA/new</code>目录下，制作完差分包后，把新的升级包移动到<code>OTA/old</code>目录作为下一次升级的基础包。</p><pre class=" language-lang-shell"><code class="language-lang-shell">#!/bin/shOTA_PATH="OTA/"OTA_OLD="OTA/old/"OTA_NEW="OTA/new/"OTA_DIFF="OTA/update/"create_dir(){    if [ ! -d "$1" ]    then        mkdir "$1"        echo "Create $1"    fi}check_dir_empty(){    if [ "`ls -A $1`" = "" ]; then        echo "Couldn\`t find update package in folder $1"        exit 404    fi}create_dir $OTA_PATHcreate_dir $OTA_OLDcreate_dir $OTA_NEWcreate_dir $OTA_DIFF#. build/envsetup.shmake otapackage -j20# copy this time's build upgrade package to OTA/newcp $OUT/obj/PACKAGING/target_files_intermediates/*.zip OTA/new# compare this one to old one to make a diff packagecheck_dir_empty $OTA_OLDcheck_dir_empty $OTA_NEW./build/tools/releasetools/ota_from_target_files -i $OTA_OLD*.zip $OTA_NEW*.zip OTA/update/update.zipcheck_dir_empty $OTA_UPDATEecho "update.zip created in $OTA_UPDATE"# put this zip to old foldermv $OTA_NEW*.zip $OTA_OLDecho "Finished!"</code></pre><blockquote><p>Ref:<br><a href="https://blog.csdn.net/mike8825/article/details/47871481" target="_blank" rel="noopener">https://blog.csdn.net/mike8825/article/details/47871481</a><br><a href="https://source.android.com/devices/tech/ota" target="_blank" rel="noopener">https://source.android.com/devices/tech/ota</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> OTA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Android][Framework] 添加系统服务</title>
      <link href="/2018/09/15/%5BAndroid%5D%5BFramework%5Dcreate-system-service/"/>
      <url>/2018/09/15/%5BAndroid%5D%5BFramework%5Dcreate-system-service/</url>
      
        <content type="html"><![CDATA[<p>做系统开发，有时候需要自己定义一些接口供App使用， 同时为了方便维护管理，就会需要自己建立一个服务，把新的功能集中在一起。下面就是新建一个系统服务的基本步骤。</p><ol><li><p>添加接口</p><p>frameworks/base/core/java/android/app/IDemoManager.aidl</p><pre class=" language-lang-java"><code class="language-lang-java">package android.app;interface IDemoManager{    int getCpuTemperature();}</code></pre></li><li><p>添加服务，实现aidl文件定义的接口</p><p>frameworks/base/services/core/java/com/android/server/DemoManagerService.java</p><pre class=" language-lang-java"><code class="language-lang-java">package com.android.server;import android.app.IDemoManager;import android.content.Context;import android.util.Slog;public class DemoManagerService extends IDemoManager.Stub {    private Context mContext;    public DemoManagerService(Context context) {        mContext = context;        Slog.d("Demo", "Construct");    }    @Override    public int getCpuTemperature() {        return 100; // Test code    }}</code></pre></li><li><p>添加对应的Manager</p><p>frameworks/base/core/java/android/app/DemoManager.java</p><pre class=" language-lang-java"><code class="language-lang-java">package android.app;import android.content.Context;import android.os.RemoteException;import android.util.Slog;public class DemoManager {    Context mContext;    IDemoManager mService;    public DemoManager(Context context, IDemoManager service) {        mContext = context;        mService = service;    }    public int getCpuTemperature() {        if (mService != null) {            try {                return mService.getCpuTemperature();            } catch (RemoteException e) {                Slog.e("Demo", "RemoteException " + e);            }        }        return -1;    }}</code></pre></li><li><p>添加aidl到Makefile src</p><p>frameworks/base/Android.mk</p><pre class=" language-lang-java"><code class="language-lang-java">LOCAL_SRC_FILES += \    core/java/android/app/IDemoManager.aidl \</code></pre></li><li><p>添加DEMO_SERVICE常量</p><p>frameworks/base/core/java/android/content/Context.java</p><pre class=" language-lang-java"><code class="language-lang-java">public static final String DEMO_SERVICE = "demo";</code></pre></li><li><p>注册系统服务</p><p>frameworks/base/core/java/android/app/SystemServiceRegistry.java</p><pre class=" language-lang-java"><code class="language-lang-java">registerService(Context.DEMO_SERVICE, DemoManager.class,    new CachedServiceFetcher<DemoManager>() {        @Override        public DemoManager createService(ContextImpl ctx) {            IBinder b = ServiceManager.getService(Context.DEMO_SERVICE);            return new DemoManager(ctx, IDemoManager.Stub.asInterface(b));}});</code></pre></li><li><p>开机启动服务</p><p>frameworks/base/services/java/com/android/server/SystemServer.java</p><pre class=" language-lang-java"><code class="language-lang-java">try {    ServiceManager.addService(Context.DEMO_SERVICE, new DemoManagerService(context));} catch (Throwable e) {    Slog.e("Demo", "Failed to start Demo Service " + e);}</code></pre></li><li><p>编译源码，因为添加了接口，所以需要</p><pre class=" language-lang-bash"><code class="language-lang-bash">make update-api</code></pre><p>更新接口。然后再整编刷机。</p></li><li><p>service list 查看服务，不存在，这是因为selinux权限没加。</p></li><li><p>添加sepolicy权限</p><p>device/qcom/sepolicy/msm8937/service.te</p><pre class=" language-lang-java"><code class="language-lang-java">type demo_service, system_api_service, system_server_service, service_manager_type;</code></pre><p>device/qcom/sepolicy/msm8937/service_contexts</p><pre class=" language-lang-java"><code class="language-lang-java">demo  u:object_r:demo_service:s0</code></pre></li><li><p>重新编译代码，使用下面测试代码验证</p><pre class=" language-lang-java"><code class="language-lang-java">import android.app.DemoManager;DemoManager om = (DemoManager) getSystemService(Context.DEMO_SERVICE);Log.d(TAG, "Current temperature is " + om.getCpuTemperature());</code></pre><p>最终log打印出100，服务添加完成。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Service </tag>
            
            <tag> Framework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Android][Framework]裁剪SystemServer服务以及关闭SystemFeature</title>
      <link href="/2018/08/30/%5BAndroid%5D%5BFramework%5Dcrop-SystemServer-and-SystemFeature/"/>
      <url>/2018/08/30/%5BAndroid%5D%5BFramework%5Dcrop-SystemServer-and-SystemFeature/</url>
      
        <content type="html"><![CDATA[<p>我的博客即将搬运同步至腾讯云+社区，邀请大家一同入驻：<a href="https://cloud.tencent.com/developer/support-plan?invite_code=2m9rytyjmp6o0" target="_blank" rel="noopener">https://cloud.tencent.com/developer/support-plan?invite_code=2m9rytyjmp6o0</a></p><h2 id="SystemServer服务裁剪"><a href="#SystemServer服务裁剪" class="headerlink" title="SystemServer服务裁剪"></a>SystemServer服务裁剪</h2><p>有些系统，因为应用场景的不同，需要的服务也不一样。比如Android Things，为了应对IOT的应用场景，它就裁剪掉了很多服务。下面介绍一下裁剪服务的方法。</p><p>关于服务，要提一下SystemServer，具体介绍见<a href="http://wossoneri.github.io/2018/03/25/[Android][Framework]start-of-SystemServer/">另一篇文章：http://wossoneri.github.io</a>。SystemServer启动了系统的核心服务，除此之外，SystemServer还启动了很多其他服务，具体是在startOtherServices()方法中。我们要裁剪不需要的服务就可以从这里入手。</p><p>比如要关闭打印机服务：</p><p>可以直接把相关启动服务的代码注释掉：</p><pre class=" language-lang-java"><code class="language-lang-java">//mSystemServiceManager.startService(PRINT_MANAGER_SERVICE_CLASS);</code></pre><p>当然这样修改后，以后如果要再打开，还需要再次修改SystemServer，然后编译jar包，push到设备使其生效。</p><p><strong>所以建议使用下面的改法：</strong></p><p>首先定义boolean变量，从全局属性读取配置，</p><pre class=" language-lang-java"><code class="language-lang-java">boolean disablePrinter = SystemProperties.getBoolean("config.disable_printer", false);</code></pre><p>然后在启动服务的代码段添加对这个属性的判断：</p><pre class=" language-lang-java"><code class="language-lang-java">if (!disablePrinter && mPackageManager.hasSystemFeature(PackageManager.FEATURE_PRINTING)) {    mSystemServiceManager.startService(PRINT_MANAGER_SERVICE_CLASS);}</code></pre><p>之后在MakeFile增加自定义的系统权限：</p><pre class=" language-lang-java"><code class="language-lang-java">PRODUCT_PROPERTY_OVERRIDES += \    config.disable_printer=true</code></pre><p>以后如果要打开这个服务，就把true变成false就可以了。</p><p>如果要调试，从修改设备的 <code>/system/build.prop</code> 然后重启即可。非常方便有木有！</p><p>如果要修改，删掉out目录下的build.prop，重新编译system（或者直接修改build.prop然后make snod），烧录启动系统之后，运行如下命令进行验证：</p><pre class=" language-lang-bash"><code class="language-lang-bash">service check printer</code></pre><p>这样就不会再启动不需要的服务了。</p><h2 id="裁剪服务引发的问题"><a href="#裁剪服务引发的问题" class="headerlink" title="裁剪服务引发的问题"></a>裁剪服务引发的问题</h2><p>服务不是你不让它Start就完事儿了，系统那么大，总有一些地方会获取服务对象做一些调用处理。比如我们刚裁减掉了打印机服务，然后打开Settings就遇到了crash：</p><pre class=" language-lang-log"><code class="language-lang-log">E AndroidRuntime: FATAL EXCEPTION: mainE AndroidRuntime: Process: com.android.settings, PID: 3496E AndroidRuntime: java.lang.RuntimeException: Unable to start activity ComponentInfo{com.android.settings/com.android.settings.Settings}: java.lang.NullPointerException: Attempt to invoke interface method 'java.util.List android.print.IPrintManager.getPrintServices(int, int)' on a null object referenceE AndroidRuntime:     at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2665)E AndroidRuntime:     at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2726)E AndroidRuntime:     at android.app.ActivityThread.-wrap12(ActivityThread.java)E AndroidRuntime:     at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1477)E AndroidRuntime:     at android.os.Handler.dispatchMessage(Handler.java:102)E AndroidRuntime:     at android.os.Looper.loop(Looper.java:154)E AndroidRuntime:     at android.app.ActivityThread.main(ActivityThread.java:6119)E AndroidRuntime:     at java.lang.reflect.Method.invoke(Native Method)E AndroidRuntime:     at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:900)E AndroidRuntime:     at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:790)E AndroidRuntime: Caused by: java.lang.NullPointerException: Attempt to invoke interface method 'java.util.List android.print.IPrintManager.getPrintServices(int, int)' on a null object referenceE AndroidRuntime:     at android.print.PrintManager.getPrintServices(PrintManager.java:635)E AndroidRuntime:     at android.print.PrintServicesLoader.onStartLoading(PrintServicesLoader.java:88)E AndroidRuntime:     at android.content.Loader.startLoading(Loader.java:290)E AndroidRuntime:     at android.app.LoaderManagerImpl$LoaderInfo.start(LoaderManager.java:283)E AndroidRuntime:     at android.app.LoaderManagerImpl.installLoader(LoaderManager.java:579)E AndroidRuntime:     at android.app.LoaderManagerImpl.createAndInstallLoader(LoaderManager.java:566)E AndroidRuntime:     at android.app.LoaderManagerImpl.initLoader(LoaderManager.java:619)E AndroidRuntime:     at com.android.settings.search.DynamicIndexableContentMonitor.register(DynamicIndexableContentMonitor.java:136)E AndroidRuntime:     at com.android.settings.SettingsActivity.onStart(SettingsActivity.java:868)E AndroidRuntime:     at android.app.Instrumentation.callActivityOnStart(Instrumentation.java:1249)E AndroidRuntime:     at android.app.Activity.performStart(Activity.java:6737)E AndroidRuntime:     at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2628)E AndroidRuntime:     ... 9 more</code></pre><p>通过堆栈信息，可以知道PrintManager.getPrintServices出现了空指针。这里也不用看代码就能猜到，因为我们开机没有启动打印服务，所以肯定get不到这个服务的。</p><p>然后考虑修改方案，增加非空保护是不是就可以了？Naive！我们的目的是裁剪打印服务，所以我们的修改点并不在这个服务本身，而是删除所以调用这个服务的地方。</p><p>所以堆栈显示的PrintManager，PrintServicesLoader什么的统统不要改，我们要看代码结构，看看是怎么调用进来的。通过阅读代码，了解到系统里有很多Loader类型的对象，其中一个子类就是PrintServicesLoader。然后这些Loader是由LoaderManager管理启动的。而LoaderManager在DynamicIndexableContentMonitor.java出现过一次初始化操作。</p><p>看下DynamicIndexableContentMonitor.java代码：</p><pre class=" language-lang-java"><code class="language-lang-java">public void register(Activity activity, int loaderId) {    ...    boolean hasFeaturePrinting = mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_PRINTING);    ...    if (hasFeaturePrinting) {        activity.getLoaderManager().initLoader(loaderId, null, this);    }    ...</code></pre><p>有木有发现一个熟悉的代码？</p><p>对，代码里再次出现了一个有关SystemFeature的判断！上一次出现时SystemServer启动服务前也做了相同的判断。</p><p>所以要裁剪掉打印机服务，我们只需要将FEATURE_PRINTING关闭即可。</p><blockquote><p>通过修改SystemFeature判断后，在SystemServer里面的裁剪代码就可以不再添加了。但是有些服务的裁剪Android并没有添加系统特性的处理，所以还是建议使用我的方法进行裁剪。</p></blockquote><h2 id="SystemFeature加载流程"><a href="#SystemFeature加载流程" class="headerlink" title="SystemFeature加载流程"></a>SystemFeature加载流程</h2><p>先看一看<code>FEATURE_PRINTING</code></p><p><a href="http://android.macpod.net/xref/android-7.1.1_r1/frameworks/base/core/java/android/content/pm/PackageManager.java" target="_blank" rel="noopener">PackageManager.java</a></p><pre class=" language-lang-java"><code class="language-lang-java">/** * Feature for {@link #getSystemAvailableFeatures} and {@link #hasSystemFeature}: * The device supports printing. */@SdkConstant(SdkConstantType.FEATURE)public static final String FEATURE_PRINTING = "android.software.print";/** * Get a list of features that are available on the * system. * * @return An array of FeatureInfo classes describing the features * that are available on the system, or null if there are none(!!). */public abstract FeatureInfo[] getSystemAvailableFeatures();/** * Check whether the given feature name is one of the available features as * returned by {@link #getSystemAvailableFeatures()}. This tests for the * presence of <em>any</em> version of the given feature name; use * {@link #hasSystemFeature(String, int)} to check for a minimum version. * * @return Returns true if the devices supports the feature, else false. */public abstract boolean hasSystemFeature(String name);/** * Check whether the given feature name and version is one of the available * features as returned by {@link #getSystemAvailableFeatures()}. Since * features are defined to always be backwards compatible, this returns true * if the available feature version is greater than or equal to the * requested version. * * @return Returns true if the devices supports the feature, else false. */public abstract boolean hasSystemFeature(String name, int version);</code></pre><p>都是抽象方法，我们去PMS查找对应的实现</p><p><a href="http://android.macpod.net/xref/android-7.1.1_r1/frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java" target="_blank" rel="noopener">PackageManagerService.java</a></p><pre class=" language-lang-java"><code class="language-lang-java">public @NonNull ParceledListSlice<FeatureInfo> getSystemAvailableFeatures() {    synchronized (mPackages) {        final ArrayList<FeatureInfo> res = new ArrayList<>(mAvailableFeatures.values());        final FeatureInfo fi = new FeatureInfo();        fi.reqGlEsVersion = SystemProperties.getInt("ro.opengles.version",                                                    FeatureInfo.GL_ES_VERSION_UNDEFINED);        res.add(fi);        return new ParceledListSlice<>(res);    }}@Overridepublic boolean hasSystemFeature(String name, int version) {    synchronized (mPackages) {        final FeatureInfo feat = mAvailableFeatures.get(name);        if (feat == null) {            return false;        } else {            return feat.version >= version;        }    }}</code></pre><p>这里的逻辑都是通过mAvailableFeatures得到所有的feature，查找该成员变量的相关代码</p><pre class=" language-lang-java"><code class="language-lang-java">final ArrayMap<String, FeatureInfo> mAvailableFeatures;SystemConfig systemConfig = SystemConfig.getInstance();mGlobalGids = systemConfig.getGlobalGids();mSystemPermissions = systemConfig.getSystemPermissions();mAvailableFeatures = systemConfig.getAvailableFeatures();</code></pre><p>了解到，首先获取一个SystemConfig的单例，然后通过getAvailableFeatures方法获取可用的feature。</p><p><a href="http://android.macpod.net/xref/android-7.1.1_r1/frameworks/base/core/java/com/android/server/SystemConfig.java" target="_blank" rel="noopener">SystemConfig.java</a></p><pre class=" language-lang-java"><code class="language-lang-java">// These are the features this devices supports that were read from the// system configuration files.final ArrayMap<String, FeatureInfo> mAvailableFeatures = new ArrayMap<>();public ArrayMap<String, FeatureInfo> getAvailableFeatures() {    return mAvailableFeatures;}private void addFeature(String name, int version) {    FeatureInfo fi = mAvailableFeatures.get(name);    if (fi == null) {        fi = new FeatureInfo();        fi.name = name;        fi.version = version;        mAvailableFeatures.put(name, fi);    } else {        fi.version = Math.max(fi.version, version);    }}private void removeFeature(String name) {    if (mAvailableFeatures.remove(name) != null) {        Slog.d(TAG, "Removed unavailable feature " + name);    }}</code></pre><p>根据mAvailableFeatures的注释，设备支持的feature是从配置文件里读取出来的。调用读取配置文件的地方是：</p><pre class=" language-lang-java"><code class="language-lang-java">SystemConfig() {    // Read configuration from system    readPermissions(Environment.buildPath(        Environment.getRootDirectory(), "etc", "sysconfig"), ALLOW_ALL);    // Read configuration from the old permissions dir    readPermissions(Environment.buildPath(        Environment.getRootDirectory(), "etc", "permissions"), ALLOW_ALL);    // Allow ODM to customize system configs around libs, features and apps    int odmPermissionFlag = ALLOW_LIBS | ALLOW_FEATURES | ALLOW_APP_CONFIGS;    readPermissions(Environment.buildPath(        Environment.getOdmDirectory(), "etc", "sysconfig"), odmPermissionFlag);    readPermissions(Environment.buildPath(        Environment.getOdmDirectory(), "etc", "permissions"), odmPermissionFlag);    // Only allow OEM to customize features    readPermissions(Environment.buildPath(        Environment.getOemDirectory(), "etc", "sysconfig"), ALLOW_FEATURES);    readPermissions(Environment.buildPath(        Environment.getOemDirectory(), "etc", "permissions"), ALLOW_FEATURES);}</code></pre><p>到此就很明白了，它是读取了几个目录：</p><ul><li>/system/etc/permission</li><li>/system/etc/sysconfig</li><li>/oem/etc/permission</li><li>/oem/etc/sysconfig</li><li>/odm/etc/permission</li><li>/odm/etc/sysconfig</li></ul><p>然后遍历xml文件，进行解析处理。SystemFeature就是解析的Feature标签。</p><p>最后再总结一下加载流程：</p><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/SystemFeature.png?raw=true" alt></p><h2 id="屏蔽SystemFeature"><a href="#屏蔽SystemFeature" class="headerlink" title="屏蔽SystemFeature"></a>屏蔽SystemFeature</h2><p>知道原理就好做了，在系统扫描的几个目录中使用grep命令查找控制打印机的字串，找到:</p><p>/system/etc/permission/handheld_core_hardware.xml</p><pre class=" language-lang-xml"><code class="language-lang-xml">    <!-- basic system services -->    <feature name="android.software.app_widgets" />    <feature name="android.software.connectionservice" />    <feature name="android.software.voice_recognizers" notLowRam="true" />    <feature name="android.software.backup" />    <feature name="android.software.home_screen" />    <feature name="android.software.input_methods" />    <feature name="android.software.print" />   <------这个就是打印特性</code></pre><p>将其注释掉就可以在手机进行测试了。</p><p>但是，我们还需要修改源码，保证以后编译系统这个值都是被屏蔽的。</p><p>查找MakeFile，找到如下:</p><pre class=" language-lang-mk"><code class="language-lang-mk">PRODUCT_COPY_FILES := \ frameworks/native/data/etc/handheld_core_hardware.xml:system/etc/permissions/handheld_core_hardware.xml</code></pre><p>这个文件在源码中的位置是<code>frameworks/native/data/etc/</code>。找到该源码文件，将不要的Feature注释掉，然后重新编译源码，启动系统，一切正常！打印机相关的服务彻底被屏蔽掉了，系统启动速度，资源消耗又变小了一点点。嗯，是很小的一点点，我们还可以把VR，红外线等等很多服务裁剪掉，以适应不同应用场景下的精简系统。</p><blockquote><p>具体的feature说明可以看<a href="https://developer.android.com/guide/topics/manifest/uses-feature-element" target="_blank" rel="noopener">官方文档</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Framework </tag>
            
            <tag> 系统裁剪 </tag>
            
            <tag> SystemFeature </tag>
            
            <tag> SystemServer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Protocol Buffer]Java使用Protocol Buffer</title>
      <link href="/2018/07/22/%5BProtocolBuffer%5DProtocol-Buffer-basics-java/"/>
      <url>/2018/07/22/%5BProtocolBuffer%5DProtocol-Buffer-basics-java/</url>
      
        <content type="html"><![CDATA[<h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p><a href="https://developers.google.com/protocol-buffers/docs/proto" target="_blank" rel="noopener">Protocol Buffer 语法指南</a></p><p><a href="https://developers.google.com/protocol-buffers/docs/reference/java/index.html" target="_blank" rel="noopener">Java API</a></p><p><a href="https://developers.google.com/protocol-buffers/docs/reference/java-generated" target="_blank" rel="noopener">Java Generated Code Guide</a></p><p><a href="https://developers.google.com/protocol-buffers/docs/encoding" target="_blank" rel="noopener">Encoding Reference</a></p><h2 id="为何选择Protocol-Buffer"><a href="#为何选择Protocol-Buffer" class="headerlink" title="为何选择Protocol Buffer"></a>为何选择Protocol Buffer</h2><p>下面一个例子是一个简单的通讯录，可以读写人物信息到文件。每个人都有姓名，ID，email和电话号码。</p><p>你会如何序列化和检索这样的结构化数据？下面有几种方案：</p><ul><li>使用Java序列化。因为它内置于语言中，所以是最常见的实现，但它有许多众所周知的问题。并且和使用C ++或Python编写的应用程序共享数据时效果并不好。</li><li>你可以发明一种特殊的方法将数据项编码为单个字符串，比如4个int型的编码:”12:3:-23:67”。这是一个简单灵活的方案，虽然它确实需要编写一次性编码和解析代码，并且解析会产生很小的运行时间成本。这个很适合于编码很简单的数据。</li><li>序列化数据到XML。由于XML的可读性，这个方案会更加受欢迎，而且有许多语言的绑定库。因此如果要与其他项目分享数据时就是一个好的选择。然而，XML是众所周知的空间密集型，并且编/解码会对应用程序造成巨大的性能损失。此外，遍历XML DOM树比通常在类中遍历简单字段要复杂得多。</li></ul><p>对于解决这个问题，Protocol Buffer是灵活，高效，自动化的解决方案。使用协议缓冲区，你可以编写.proto描述存储的数据结构。由此，Protocol Buffer编译器创建一个类，该类使用有效的二进制格式实现Protocol Buffer数据的自动编码和解析。生成的类为构成Protocol Buffer的字段提供getter和setter，并负责将Protocol Buffer作为一个单元进行读写的详细信息。重要的是，Protocol Buffer格式支持随着时间的推移扩展格式的想法，使得代码仍然可以读取用旧格式编码的数据。</p><h2 id="定义你的Protocol格式"><a href="#定义你的Protocol格式" class="headerlink" title="定义你的Protocol格式"></a>定义你的Protocol格式</h2><p>要创建你的地址簿，你需要首先创建一个<code>.proto</code>文件。这个文件里的定义很简单：为每一个你需要序列化的数据结构添加一个消息，然后为消息中的每一个域指定一个name和type。</p><p><code>addressbook.proto</code>：</p><pre class=" language-lang-protobuf"><code class="language-lang-protobuf">syntax = "proto2";package tutorial;option java_package = "com.example.tutorial";option java_outer_classname = "AddressBookProtos";message Person {    required string name = 1;    required int32 id = 2;    optional string email = 3;    enum PhoneType {        MOBILE = 0;        HOME = 1;        WORK = 2;    }    message PhoneNumber {        required string number = 1;        optional PhoneType type = 2 [default = HOME];    }    repeated PhoneNumber phones = 4;}message AddressBook {    repeated Person people = 1;}</code></pre><p>文件语法类似于C++或Java，下面具体了解一下文件结构。</p><p>文件由包声明开始，这有助于防止不同项目之间的命名冲突。在Java语言中，包名用作Java包，除非明确指定了一个<code>java_package</code>（如代码所做）。即使你定义了<code>java_package</code>，你也仍然要定义一个普通的<code>package</code>来避免在Protocol Buffer命名空间的名称冲突，尤其是在非Java语言中。</p><p>包声明之后是两行Java的可选项：<code>java_package</code>和<code>java_outer_classname</code>。</p><ul><li><code>java_package</code>，指定生成的类应该以什么Java包名称存在。如果没有明确指定，它简单地匹配由<code>package</code>声明的包名，但这些名称通常不是合适的Java包名称（因为它们通常不以域名开头）。</li><li><code>java_outer_classname</code>，定义应包含此文件中所有类的类名。如果没有显示指定<code>java_outer_classname</code>，它会把文件名转换为驼峰命名来生成。比如，”my_proto.proto”会转化成”MyProto”作为外部类名。</li></ul><p>下一行就是<code>message</code>的定义。消息只是包含一组类型字段的聚合。许多标准的简单数据类型都可用作字段类型，包括bool，int32，float，double和string。你也可以使用其他<code>message</code>类型作为域类型为当前<code>message</code>增加深层次的结构。上面例子中，Person message就包含了PhoneNumber message，同时，AddressBook message也包含了Person message。你甚至可以在其他message内定义内联的message类型，PhoneNumber就是这样的。如果你希望其中一个字段具有预定义的值列表之一，你可以使用enum实现。代码中PhoneNumber就是<code>MOBILE</code>,<code>HOME</code>或者<code>WORK</code>三种。</p><p>每个元素的”=1”，”=2”标记标识该字段在二进制编码中使用的唯一“标记”。标记1-15比高的数字需要的编码少一个字节，因此，作为优化，您可以决定将这些标记用于常用或重复元素，将标记16和更高的数字留给不太常用的可选元素。重复字段中的每个元素都需要重新编码标记号，因此重复字段特别适合此优化。</p><p>必须使用以下修饰符之一注释每个字段：</p><ul><li><p><code>required</code>：必须提供该字段的值，否则该消息将被视为未初始化(uninitialized)。如果编译一个未初始化的消息会抛出<code>RuntimeException</code>的异常。解析未初始化的消息会抛出<code>IOException</code>的异常。除此之外，<code>required</code>的字段和<code>optional</code>表现一致。</p></li><li><p><code>optional</code>：该字段可以不赋予初始值。如果一个<code>optional</code>字段值没有设置，会赋予一个默认值。对于简单的类型，你可以指定你自己的默认值，就像前面对PhoneNumber内type做的一样：</p><pre class=" language-lang-java"><code class="language-lang-java">optional PhoneType type = 2 [default = HOME];</code></pre><p>否则，系统会给与一个默认值：数字是0，字符串是空字串，bool值是false。</p><p>对于嵌入的message，默认值总是该message的默认实例或者<code>prototype</code>，该消息没有设置任何字段。调用accessor以获取尚未显式设置的<code>optional</code>（或<code>required</code>）字段的值始终返回该字段的默认值。</p></li><li><p><code>repeated</code>：该字段可以重复任意次数（包括零）。重复值的顺序将保留在协议缓冲区中。将重复字段视为动态大小的数组。</p></li></ul><h2 id="编译Protocol-Buffers"><a href="#编译Protocol-Buffers" class="headerlink" title="编译Protocol Buffers"></a>编译Protocol Buffers</h2><p>现在有了一个<code>.proto</code>文件，你需要做的下一件事是生成读取和写入AddressBook（以及Person和PhoneNumber）消息所需的类。要完成它，你需要运行Protocol Buffer编译器<code>protoc</code>编译<code>.proto</code>文件：</p><pre class=" language-lang-bash"><code class="language-lang-bash">protoc -I=$SRC_DIR --java_out=$DST_DIR $SRC_DIR/addressbook.proto</code></pre><p>比如我的环境下，</p><pre class=" language-lang-bash"><code class="language-lang-bash">{18-07-20 15:08}wOw-RMBP:~/Projects/Protobuf wow% lsaddressbook.proto{18-07-20 15:08}wOw-RMBP:~/Projects/Protobuf wow% protoc -I=./ --java_out=./ ./addressbook.proto{18-07-20 15:09}wOw-RMBP:~/Projects/Protobuf wow% lsaddressbook.proto com</code></pre><p>生成的文件结构为</p><pre class=" language-lang-bash"><code class="language-lang-bash">|____addressbook.proto|____com| |____example| | |____tutorial| | | |____AddressBookProtos.java</code></pre><p>生成的java文件有2816行，就不贴出来了。下面会对java文件做一些解释。</p><h2 id="Protocol-Buffer-API"><a href="#Protocol-Buffer-API" class="headerlink" title="Protocol Buffer API"></a>Protocol Buffer API</h2><p>从<code>AddressBookProtos.java</code>看到定义了一个<code>AddressBookProtos</code>类，其中嵌套了你在<code>addressbook.proto</code>中指定的每条消息的类。每个类都有自己的<code>Builder</code>类，你可以通过其创建实例。</p><pre class=" language-lang-java"><code class="language-lang-java">public final class AddressBookProtos {    public interface PersonOrBuilder extends      // @@protoc_insertion_point(interface_extends:tutorial.Person)      com.google.protobuf.MessageOrBuilder {    }    public  static final class Person extends      com.google.protobuf.GeneratedMessageV3 implements      // @@protoc_insertion_point(message_implements:tutorial.Person)      PersonOrBuilder {    }    public interface PhoneNumberOrBuilder extends        // @@protoc_insertion_point(interface_extends:tutorial.Person.PhoneNumber)        com.google.protobuf.MessageOrBuilder {    }    public  static final class PhoneNumber extends        com.google.protobuf.GeneratedMessageV3 implements        // @@protoc_insertion_point(message_implements:tutorial.Person.PhoneNumber)        PhoneNumberOrBuilder {    }    public interface AddressBookOrBuilder extends      // @@protoc_insertion_point(interface_extends:tutorial.AddressBook)      com.google.protobuf.MessageOrBuilder {    }    public  static final class AddressBook extends      com.google.protobuf.GeneratedMessageV3 implements      // @@protoc_insertion_point(message_implements:tutorial.AddressBook)      AddressBookOrBuilder {    }}</code></pre><p>messages和builders都为消息的每个字段都有自动生成的访问器方法;消息只有getter，而构建器有getter和setter。以下是Person类的一些访问器（为简洁起见省略了实现）：</p><pre class=" language-lang-java"><code class="language-lang-java">// required string name = 1;public boolean hasName();public String getName();// required int32 id = 2;public boolean hasId();public int getId();// optional string email = 3;public boolean hasEmail();public String getEmail();// repeated .tutorial.Person.PhoneNumber phones = 4;public List<PhoneNumber> getPhonesList();public int getPhonesCount();public PhoneNumber getPhones(int index);</code></pre><p>同时，Person.Builder也有相同的getter和setter</p><pre class=" language-lang-java"><code class="language-lang-java">// required string name = 1;public boolean hasName();public java.lang.String getName();public Builder setName(String value);public Builder clearName();// required int32 id = 2;public boolean hasId();public int getId();public Builder setId(int value);public Builder clearId();// optional string email = 3;public boolean hasEmail();public String getEmail();public Builder setEmail(String value);public Builder clearEmail();// repeated .tutorial.Person.PhoneNumber phones = 4;public List<PhoneNumber> getPhonesList();public int getPhonesCount();public PhoneNumber getPhones(int index);public Builder setPhones(int index, PhoneNumber value);public Builder addPhones(PhoneNumber value);public Builder addAllPhones(Iterable<PhoneNumber> value);public Builder clearPhones();</code></pre><p>每个字段都有简单的JavaBeans样式的getter和setter。每个单独的字段都有getter，如果已设置该字段，则返回true。最后，每个字段都有一个清除方法，将字段取消设置回其空状态。</p><p>Repeated字段有一些额外的方法：一个<code>Count</code>方法（它只是列表大小的简写），getter和setter通过索引get或set列表的特定元素，<code>add</code>方法将新元素附加到列表，以及一个<code>addAll</code>方法，它将整个容器中的元素添加到列表中。</p><p>注意这些accessor方法如何使用驼峰式命名，即使<code>.proto</code>文件使用带下划线的小写。此转换由Protocol Buffer编译器自动完成，以便生成的类与标准Java样式约定匹配。您应该始终在<code>.proto</code>文件中使用带有下划线的小写字母作为字段名称，这确保了所有生成语言的良好命名实践。有关良好的.proto样式的更多信息，请参阅<a href="https://developers.google.com/protocol-buffers/docs/style" target="_blank" rel="noopener">样式指南</a>。</p><h3 id="Enums和内嵌类"><a href="#Enums和内嵌类" class="headerlink" title="Enums和内嵌类"></a>Enums和内嵌类</h3><p>生成的代码包含<code>PhoneType</code>集合，内嵌于<code>Person</code>类中。</p><pre class=" language-lang-java"><code class="language-lang-java">public enum PhoneType    implements com.google.protobuf.ProtocolMessageEnum {    /**       * <code>MOBILE = 0;</code>       */    MOBILE(0),    /**       * <code>HOME = 1;</code>       */    HOME(1),    /**       * <code>WORK = 2;</code>       */    WORK(2),    ;    /**       * <code>MOBILE = 0;</code>       */    public static final int MOBILE_VALUE = 0;    /**       * <code>HOME = 1;</code>       */    public static final int HOME_VALUE = 1;    /**       * <code>WORK = 2;</code>       */    public static final int WORK_VALUE = 2;    ...}</code></pre><p>内嵌类<code>Person.PhoneNumber</code>也一并生成，代码结构在前面API可以看到。</p><h3 id="Builders-vs-Messages"><a href="#Builders-vs-Messages" class="headerlink" title="Builders vs. Messages"></a>Builders vs. Messages</h3><p>Protocol Buffer编译器生成的消息类都是不可变的。一旦构造了消息对象，就不能像Java String一样修改它。要构造消息，必须首先构造构建器，将要设置的任何字段设置为所选值，然后调用构建器的<code>build</code>方法。</p><p>你可能已经注意到每个修改消息的构建器的方法都返回另一个构建器。返回的对象实际上是您调用该方法的同一个构建器。为方便起见，它会返回，以便您可以在一行代码中将多个setter串在一起。（链式编程）</p><p>下面是个创建<code>Person</code>对象的例子：</p><pre class=" language-lang-java"><code class="language-lang-java">Person john =  Person.newBuilder()    .setId(1234)    .setName("John Doe")    .setEmail("jdoe@example.com")    .addPhones(      Person.PhoneNumber.newBuilder()        .setNumber("555-4321")        .setType(Person.PhoneType.HOME))    .build();</code></pre><h3 id="标准Message方法"><a href="#标准Message方法" class="headerlink" title="标准Message方法"></a>标准Message方法</h3><p>每个message和builder类还包含许多其他方法，可用于检查或操作整个消息，包括：</p><ul><li><code>isInitialized()</code>：检查是否已设置所有必填字段。</li><li><code>toString()</code>：返回一个人类可读的消息表示，对调试特别有用。</li><li><code>mergeFrom(Message other)</code>：(仅限构建器）将其他内容合并到此消息中，覆盖奇异标量字段，合并复合字段以及连接重复字段。</li><li><code>clear()</code>：(仅限构建器）将所有字段清除回空状态。</li></ul><p>这些方法实现了所有Java消息和构建器共享的<code>Message</code>和<code>Message.Builder</code>接口。有关更多信息，请参阅<a href="https://developers.google.com/protocol-buffers/docs/reference/java/com/google/protobuf/Message" target="_blank" rel="noopener">Message的完整API文档</a>。</p><h3 id="解析和序列化"><a href="#解析和序列化" class="headerlink" title="解析和序列化"></a>解析和序列化</h3><p>最后，每个Protocol Buffer类都有使用Protocol Buffer二进制格式编写和读取所选类型消息的方法。这些包括：</p><ul><li><code>byte [] toByteArray();</code>：序列化消息并返回包含其原始字节的字节数组。</li><li><code>static Person parseFrom(byte[] data);</code>：解析来自给定字节数组的消息。</li><li><code>void writeTo(OutputStream output);</code>：序列化消息并将其写入OutputStream。</li><li><code>static Person parseFrom(InputStream input);</code>：读取并解析来自InputStream的消息。</li></ul><p>这些只是解析和序列化提供的几个选项。</p><h2 id="编写一个Message"><a href="#编写一个Message" class="headerlink" title="编写一个Message"></a>编写一个Message</h2><p>现在让我们尝试使用生成的Protocol Buffer类。你希望地址簿应用程序能够做的第一件事是将个人详细信息写入你的地址簿文件。为此，你需要创建并填充Protocol Buffer类的实例，然后将它们写入输出流。</p><p>这是一个从文件读取AddressBook的程序，根据用户输入向其添加一个新Person，并将新的AddressBook再次写回文件。直接调用或引用协议编译器生成的代码的部分将用*标识。</p><pre class=" language-lang-java"><code class="language-lang-java">* import com.example.tutorial.AddressBookProtos.AddressBook;* import com.example.tutorial.AddressBookProtos.Person;import java.io.BufferedReader;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.InputStreamReader;import java.io.IOException;import java.io.PrintStream;class AddPerson {  // This function fills in a Person message based on user input.  static Person PromptForAddress(BufferedReader stdin,                                 PrintStream stdout) throws IOException {    * Person.Builder person = Person.newBuilder();    stdout.print("Enter person ID: ");    * person.setId(Integer.valueOf(stdin.readLine()));    stdout.print("Enter name: ");    * person.setName(stdin.readLine());    stdout.print("Enter email address (blank for none): ");    String email = stdin.readLine();    if (email.length() > 0) {      * person.setEmail(email);    }    while (true) {      stdout.print("Enter a phone number (or leave blank to finish): ");      String number = stdin.readLine();      if (number.length() == 0) {        break;      }      * Person.PhoneNumber.Builder phoneNumber =      *   Person.PhoneNumber.newBuilder().setNumber(number);      stdout.print("Is this a mobile, home, or work phone? ");      String type = stdin.readLine();      if (type.equals("mobile")) {        * phoneNumber.setType(Person.PhoneType.MOBILE);      } else if (type.equals("home")) {        * phoneNumber.setType(Person.PhoneType.HOME);      } else if (type.equals("work")) {        * phoneNumber.setType(Person.PhoneType.WORK);      } else {        stdout.println("Unknown phone type.  Using default.");      }      * person.addPhones(phoneNumber);    }    * return person.build();  }  // Main function:  Reads the entire address book from a file,  //   adds one person based on user input, then writes it back out to the same  //   file.  public static void main(String[] args) throws Exception {    if (args.length != 1) {      System.err.println("Usage:  AddPerson ADDRESS_BOOK_FILE");      System.exit(-1);    }    * AddressBook.Builder addressBook = AddressBook.newBuilder();    // Read the existing address book.    try {      * addressBook.mergeFrom(new FileInputStream(args[0]));    } catch (FileNotFoundException e) {      System.out.println(args[0] + ": File not found.  Creating a new file.");    }    // Add an address.    * addressBook.addPeople(      PromptForAddress(new BufferedReader(new InputStreamReader(System.in)),                       System.out));    // Write the new address book back to disk.    FileOutputStream output = new FileOutputStream(args[0]);    * addressBook.build().writeTo(output);    output.close();  }}</code></pre><h2 id="读取一个Message"><a href="#读取一个Message" class="headerlink" title="读取一个Message"></a>读取一个Message</h2><p>当然，如果你无法从中获取任何信息，那么地址簿就不会有多大用处！此示例读取上面示例创建的文件并打印其中的所有信息。</p><pre class=" language-lang-java"><code class="language-lang-java">* import com.example.tutorial.AddressBookProtos.AddressBook;* import com.example.tutorial.AddressBookProtos.Person;import java.io.FileInputStream;import java.io.IOException;import java.io.PrintStream;class ListPeople {  // Iterates though all people in the AddressBook and prints info about them.  static void Print(AddressBook addressBook) {    for (Person person: addressBook.getPeopleList()) {      System.out.println("Person ID: " + * person.getId());      System.out.println("  Name: " + * person.getName());      if (person.hasEmail()) {        System.out.println("  E-mail address: " + * person.getEmail());      }      for (* Person.PhoneNumber phoneNumber : person.getPhonesList()) {        switch (* phoneNumber.getType()) {          case * MOBILE:            System.out.print("  Mobile phone #: ");            break;          case * HOME:            System.out.print("  Home phone #: ");            break;          case * WORK:            System.out.print("  Work phone #: ");            break;        }        System.out.println(* phoneNumber.getNumber());      }    }  }  // Main function:  Reads the entire address book from a file and prints all  //   the information inside.  public static void main(String[] args) throws Exception {    if (args.length != 1) {      System.err.println("Usage:  ListPeople ADDRESS_BOOK_FILE");      System.exit(-1);    }    // Read the existing address book.    * AddressBook addressBook =    *   AddressBook.parseFrom(new FileInputStream(args[0]));    Print(addressBook);  }}</code></pre><h2 id="拓展一个Protocol-Buffer"><a href="#拓展一个Protocol-Buffer" class="headerlink" title="拓展一个Protocol Buffer"></a>拓展一个Protocol Buffer</h2><p>在释放使用Protocol Buffer的代码之后，你无疑会想要“改进”Protocol Buffer的定义。如果你希望你的新缓冲区向后兼容，并且你的旧缓冲区是向前兼容的 - 而且你几乎肯定想要这个 - 那么你需要遵循一些规则。在新版本的协议缓冲区中：</p><ul><li>不得更改任何现有字段的标记号。</li><li>不得添加或删除任何必填字段。</li><li>可以删除可选或重复的字段。</li><li>可以添加新的可选或重复字段，但必须使用新的标记号（即从未在此Protocol Buffer中使用的标记号，甚至不包括已删除的字段）。</li></ul><p>如果你遵循这些规则，旧代码将可以阅读新消息并简单地忽略任何新字段。对于旧代码，已删除的可选字段将只具有其默认值，删除的重复字段将为空。新代码也将透明地读取旧消息。但是，请记住旧的消息中不会出现新的可选字段，因此您需要明确检查它们是否设置为<code>has_</code>，或者使用<code>[default = value]</code>在<code>.proto</code>文件中提供合理的默认值。标签号后面。如果未为可选元素指定默认值，则使用特定于类型的默认值：对于string，默认值为空字符串。对于boolean，默认值为false。对于numeric，默认值为零。另请注意，如果添加了新的重复字段，则新代码将无法判断它是否为空（通过新代码）或从未设置（通过旧代码），因为它没有<code>has_</code>标志。</p><h2 id="进阶用法"><a href="#进阶用法" class="headerlink" title="进阶用法"></a>进阶用法</h2><p>Protocol Buffer 的用途不仅仅是简单的访问器和序列化。请务必浏览<a href="https://developers.google.com/protocol-buffers/docs/reference/java/index.html" target="_blank" rel="noopener">Java API参考</a>，以了解你可以使用它们做些什么。</p><p>Protocol Buffer类提供的一个关键特性是反射。你可以迭代消息的字段并操纵它们的值，而无需针对任何特定的消息类型编写代码。使用反射的一种非常有用的方法是将Protocol Buffer 转换为其他编码，例如XML或JSON。更高级的反射用法可能是找到两个相同类型的消息之间的差异，或者开发一种“Protocol Buffer的正则表达式”，你可以在其中编写与某些消息内容匹配的表达式。如果你运用自己的想象力，可以将Protocol Buffer应用于比你最初预期更广泛的问题！</p><p>反射是作为<code>Message</code>和<code>Message.Builder</code>接口的一部分提供的。</p>]]></content>
      
      
      <categories>
          
          <category> Syntax </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Protocol Buffer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Android][Framework]带有so的三方应用集成</title>
      <link href="/2018/07/16/%5BAndroid%5D%5BFramework%5Dembed-apk-with-so/"/>
      <url>/2018/07/16/%5BAndroid%5D%5BFramework%5Dembed-apk-with-so/</url>
      
        <content type="html"><![CDATA[<p>集成带有So文件的三方应用时，如果不处理so文件，会导致应用打不开的情况，所以针对这些so文件需要做一些额外的处理。</p><p><strong>方法一</strong></p><p>把解压的lib文件放在makefile 目录，通过遍历lib目录一个个编译到目标文件夹</p><pre class=" language-lang-java"><code class="language-lang-java">LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := GaoDeMapLOCAL_MODULE_TAGS := optionalLOCAL_MODULE_CLASS := APPSLOCAL_MODULE_SUFFIX := $(COMMON_ANDROID_PACKAGE_SUFFIX)LOCAL_PRIVILEGED_MODULE := trueLOCAL_SRC_FILES := apk/amapauto.apkLOCAL_MULTILIB := 32JNI_LIBS :=$(foreach FILE,$(shell find $(LOCAL_PATH)/lib/armeabi-v7a/ -name *.so), $(eval JNI_LIBS += $(FILE)))LOCAL_PREBUILT_JNI_LIBS := $(subst $(LOCAL_PATH),,$(JNI_LIBS))LOCAL_CERTIFICATE := PRESIGNEDinclude $(BUILD_PREBUILT)</code></pre><p>文件目录</p><pre class=" language-lang-bash"><code class="language-lang-bash">|____GaodeMap| |____Android.mk| |____apk| | |____amapauto.apk| |____.DS_Store| |____lib| | |____armeabi-v7a| | | |____libapssdk.so| | | |____libGNet.so| | | |____libcocklogic.so|____Android.mk|____.DS_Store|____Baidu| |____Android.mk| |____apk| | |____BaiduMapAuto.apk| |____.DS_Store| |____lib| | |____armeabi| | | |____libbd_etts.so| | | |____libBaiduTraceSDK_v2_1_12.so| | | |____libBDSpeechDecoder_V1.so|____Ximalaya| |____Android.mk| |____apk| | |____ximalaya.apk| |____.DS_Store| |____lib| | |____armeabi| | | |____libxmediaplayer_x.so| | | |____libvideo.so|____QingTing| |____Android.mk| |____apk| | |____QingTingFm.apk| |____.DS_Store| |____lib| | |____armeabi| | | |____libtnet-2.1.20.1-agoo.so| | | |____libcocklogic.so| | | |____libgifimage.so| | | |____libRSSupport.so| | | |____librsjni.so|____QQMusic| |____Android.mk| |____apk| | |____qqmusiccar.apk| |____.DS_Store| |____lib| | |____armeabi| | | |____libdesdecrypt.so| | | |____libqm_native_decoder_ape.so</code></pre><p><strong>方法二</strong></p><p>使用@符号，自动把APK内容解压</p><pre class=" language-lang-makefile"><code class="language-lang-makefile">LOCAL_PATH := $(call my-dir)MY_ABI := armeabiinclude $(CLEAR_VARS)LOCAL_MODULE := BaiduMapLOCAL_MODULE_TAGS := optionalLOCAL_MODULE_CLASS := APPSLOCAL_MODULE_SUFFIX := $(COMMON_ANDROID_PACKAGE_SUFFIX)LOCAL_SRC_FILES := BaiduMapAuto.apkLOCAL_PREBUILT_JNI_LIBS := \    @lib/$(MY_ABI)/libapp_BaiduNaviApplib.so \    @lib/$(MY_ABI)/libapp_BaiduVIlib.so \    @lib/$(MY_ABI)/libaudiomessage-jni.so \    @lib/$(MY_ABI)/libBaiduTraceSDK_v2_1_12.so \    @lib/$(MY_ABI)/libbd_etts.so \    @lib/$(MY_ABI)/libBDSpeechDecoder_V1.so \    @lib/$(MY_ABI)/libbdtts.so \    @lib/$(MY_ABI)/libcrash_analysis.so \    @lib/$(MY_ABI)/libetts_domain_data_builder.so \    @lib/$(MY_ABI)/libgnustl_shared.so \    @lib/$(MY_ABI)/liblocnaviSDK.so \    @lib/$(MY_ABI)/liblocSDK6a.so \    @lib/$(MY_ABI)/libmapautolicense.soLOCAL_CERTIFICATE := PRESIGNEDinclude $(BUILD_PREBUILT)</code></pre><p>编译输出内容</p><pre class=" language-lang-bash"><code class="language-lang-bash">PRODUCT_COPY_FILES device/qcom/common/media/media_profiles.xml:system/etc/media_profiles.xml ignored.PRODUCT_COPY_FILES device/qcom/common/media/media_codecs.xml:system/etc/media_codecs.xml ignored.No private recovery resources for TARGET_DEVICE msm8937_32620+0 records in620+0 records out634880 bytes (635 kB, 620 KiB) copied, 0.00572881 s, 111 MB/sStarting build with ninjaninja: Entering directory `.'[ 75% 3/4] target Prebuilt: BaiduMap (out/target/product/msm8937_32/obj/APPS/BaiduMap_intermediates/package.apk)Archive:  out/target/product/msm8937_32/obj/APPS/BaiduMap_intermediates/package.apk  inflating: out/target/product/msm8937_32/obj/APPS/BaiduMap_intermediates/uncompressedlibs/lib/armeabi/libaudiomessage-jni.so  inflating: out/target/product/msm8937_32/obj/APPS/BaiduMap_intermediates/uncompressedlibs/lib/armeabi/libbdtts.so  inflating: out/target/product/msm8937_32/obj/APPS/BaiduMap_intermediates/uncompressedlibs/lib/armeabi/libgnustl_shared.so  inflating: out/target/product/msm8937_32/obj/APPS/BaiduMap_intermediates/uncompressedlibs/lib/armeabi/libbd_etts.so  inflating: out/target/product/msm8937_32/obj/APPS/BaiduMap_intermediates/uncompressedlibs/lib/armeabi/libcrash_analysis.so  inflating: out/target/product/msm8937_32/obj/APPS/BaiduMap_intermediates/uncompressedlibs/lib/armeabi/libapp_BaiduVIlib.so  inflating: out/target/product/msm8937_32/obj/APPS/BaiduMap_intermediates/uncompressedlibs/lib/armeabi/liblocSDK6a.so  inflating: out/target/product/msm8937_32/obj/APPS/BaiduMap_intermediates/uncompressedlibs/lib/armeabi/liblocnaviSDK.so  inflating: out/target/product/msm8937_32/obj/APPS/BaiduMap_intermediates/uncompressedlibs/lib/armeabi/libapp_BaiduNaviApplib.so  inflating: out/target/product/msm8937_32/obj/APPS/BaiduMap_intermediates/uncompressedlibs/lib/armeabi/libBDSpeechDecoder_V1.so  inflating: out/target/product/msm8937_32/obj/APPS/BaiduMap_intermediates/uncompressedlibs/lib/armeabi/libetts_domain_data_builder.so  inflating: out/target/product/msm8937_32/obj/APPS/BaiduMap_intermediates/uncompressedlibs/lib/armeabi/libBaiduTraceSDK_v2_1_12.so  inflating: out/target/product/msm8937_32/obj/APPS/BaiduMap_intermediates/uncompressedlibs/lib/armeabi/libmapautolicense.sodeleting: lib/armeabi/libaudiomessage-jni.sodeleting: lib/armeabi/libbdtts.sodeleting: lib/armeabi/libgnustl_shared.sodeleting: lib/armeabi/libbd_etts.sodeleting: lib/armeabi/libcrash_analysis.sodeleting: lib/armeabi/libapp_BaiduVIlib.sodeleting: lib/armeabi/liblocSDK6a.sodeleting: lib/armeabi/liblocnaviSDK.sodeleting: lib/armeabi/libapp_BaiduNaviApplib.sodeleting: lib/armeabi/libBDSpeechDecoder_V1.sodeleting: lib/armeabi/libetts_domain_data_builder.sodeleting: lib/armeabi/libBaiduTraceSDK_v2_1_12.sodeleting: lib/armeabi/libmapautolicense.so  adding: lib/armeabi/libBDSpeechDecoder_V1.so (stored 0%)  adding: lib/armeabi/libBaiduTraceSDK_v2_1_12.so (stored 0%)  adding: lib/armeabi/libapp_BaiduNaviApplib.so (stored 0%)  adding: lib/armeabi/libapp_BaiduVIlib.so (stored 0%)  adding: lib/armeabi/libaudiomessage-jni.so (stored 0%)  adding: lib/armeabi/libbd_etts.so (stored 0%)  adding: lib/armeabi/libbdtts.so (stored 0%)  adding: lib/armeabi/libcrash_analysis.so (stored 0%)  adding: lib/armeabi/libetts_domain_data_builder.so (stored 0%)  adding: lib/armeabi/libgnustl_shared.so (stored 0%)  adding: lib/armeabi/liblocSDK6a.so (stored 0%)  adding: lib/armeabi/liblocnaviSDK.so (stored 0%)  adding: lib/armeabi/libmapautolicense.so (stored 0%)[100% 4/4] Install: out/target/product/msm8937_32/system/app/BaiduMap/BaiduMap.apkmake: Leaving directory '/wkspc/meiglink/LA.UM.5.6'#### make completed successfully (20 seconds) ####</code></pre><p><strong>方法三</strong></p><p><code>@</code>符号有时候并不会生效，所以就需要把so手动解压lib目录到mk的同级目录，然后执行make</p><pre class=" language-lang-shell"><code class="language-lang-shell">LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)MY_ABI := armeabiLOCAL_MODULE := XimalayaFMLOCAL_MODULE_TAGS := optionalLOCAL_MODULE_CLASS := APPSLOCAL_MODULE_SUFFIX := $(COMMON_ANDROID_PACKAGE_SUFFIX)LOCAL_SRC_FILES := XimalayaFM.apkLOCAL_MULTILIB := 32LOCAL_PREBUILT_JNI_LIBS := \    lib/$(MY_ABI)/libBugly.so \    lib/$(MY_ABI)/libchat.so \    lib/$(MY_ABI)/libdetect.so \    lib/$(MY_ABI)/libencrypt.so \    lib/$(MY_ABI)/liblive.so \    lib/$(MY_ABI)/libLivenessModule.so \    lib/$(MY_ABI)/liblocSDK7b.so \    lib/$(MY_ABI)/libmain.so \    lib/$(MY_ABI)/libmediadatacryto.so \    lib/$(MY_ABI)/libmsc.so \    lib/$(MY_ABI)/libndkbitmap.so \    lib/$(MY_ABI)/libpl_droidsonroids_gif.so \    lib/$(MY_ABI)/librecord.so \    lib/$(MY_ABI)/libsgmain.so \    lib/$(MY_ABI)/libsgnocaptcha.so \    lib/$(MY_ABI)/libsgsecuritybody.so \    lib/$(MY_ABI)/libsoundtouch.so \    lib/$(MY_ABI)/libttEncrypt.so \    lib/$(MY_ABI)/libvideo.so \    lib/$(MY_ABI)/libweibosdkcore.so \    lib/$(MY_ABI)/libweike.so \    lib/$(MY_ABI)/libxmediaplayer_x.so \    lib/$(MY_ABI)/libxmediaplayer.so \    lib/$(MY_ABI)/libxmediaplayerv7.so \    lib/$(MY_ABI)/0kb.so \    lib/$(MY_ABI)/libNewMediaProcessor.so \    lib/$(MY_ABI)/libaar_alijtca_plus.so \    lib/$(MY_ABI)/libandroid-asr.so \    lib/$(MY_ABI)/libdubscore-jni-armeabi-v7a.so \    lib/$(MY_ABI)/libfb.so \    lib/$(MY_ABI)/libfolly_json.so \    lib/$(MY_ABI)/libframesequence.so \    lib/$(MY_ABI)/libgifimage.so \    lib/$(MY_ABI)/libglog.so \    lib/$(MY_ABI)/libglog_init.so \    lib/$(MY_ABI)/libgnustl_shared.so \    lib/$(MY_ABI)/libicu_common.so \    lib/$(MY_ABI)/libijkffmpeg-armeabi-v7a.so \    lib/$(MY_ABI)/libijkplayer-armeabi-v7a.so \    lib/$(MY_ABI)/libijksdl-armeabi-v7a.so \    lib/$(MY_ABI)/libimagepipeline.so \    lib/$(MY_ABI)/libjsc.so \    lib/$(MY_ABI)/libmarsxlog.so \    lib/$(MY_ABI)/libmm.so \    lib/$(MY_ABI)/libmyspinnative.so \    lib/$(MY_ABI)/libprivatedata.so \    lib/$(MY_ABI)/libreactnativejni.so \    lib/$(MY_ABI)/librtmp-jni.so \    lib/$(MY_ABI)/libsoundbalance.so \    lib/$(MY_ABI)/libstlport_shared.so \    lib/$(MY_ABI)/libucrop.so \    lib/$(MY_ABI)/libutility.so \    lib/$(MY_ABI)/libxmffcmd-armeabi-v7a.so \    lib/$(MY_ABI)/libxmrecorder-armeabi-v7a.so \    lib/$(MY_ABI)/libyoga.so \    lib/$(MY_ABI)/libzegoliveroom.soLOCAL_MODULE_PATH := $(TARGET_OUT)/vendor/appLOCAL_CERTIFICATE := PRESIGNEDinclude $(BUILD_PREBUILT)</code></pre><p><strong>方法四</strong></p><p>但是手动解压非常麻烦，所以就修改脚本进行处理。</p><p>因为带so的APK在编译过程中会先解压缩如out/target/product/xxx/obj/APPS/LauncherB_intermediates/uncompressedlibs/lib/armeabi/libfacialproc_jni.so</p><p>所以编译的时候会遍历这个目录：</p><pre class=" language-lang-shell"><code class="language-lang-shell">LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)MY_ABI := armeabiLOCAL_MODULE := XimalayaFMLOCAL_MODULE_TAGS := optionalLOCAL_MODULE_CLASS := APPSLOCAL_MODULE_SUFFIX := $(COMMON_ANDROID_PACKAGE_SUFFIX)LOCAL_SRC_FILES := XimalayaFM.apkAPK_LibList :=$(subst $(LOCAL_PATH)/uncompressedlibs,,\    $(foreach FILE,$(shell unzip -l $(LOCAL_PATH)/$(LOCAL_SRC_FILES) 'lib/*.so'|grep 'arm'),$(eval APK_LibList += $(FILE))))#$(info $(APK_LibList))ARM64_LIB := $(findstring arm64-v8a,$(APK_LibList))ARMV7A_LIB := $(findstring armeabi-v7a,$(APK_LibList))ARM_LIB := $(findstring armeabi,$(APK_LibList))ARCH_LIB := $(if $(TARGET_ARCH),$(if $(ARM64_LIB),$(ARM64_LIB),$(if $(ARMV7A_LIB),$(ARMV7A_LIB),$(ARM_LIB))),$(if $(ARMV7A_LIB),$(ARMV7A_LIB),$(ARM_LIB)))TARGET_BIT := $(if $(findstring arm64,$(ARCH_LIB)),64,32)$(info $(ARCH_LIB) $(TARGET_BIT))PRIVATE_EMBEDDED_JNI_LIBS := 'lib/$(ARCH_LIB)/*.so'JNI_LIBS :=$(foreach FILE,$(shell if unzip -l $(LOCAL_PATH)/$(LOCAL_SRC_FILES) $(PRIVATE_EMBEDDED_JNI_LIBS) > /dev/null ; then \      rm -rf $(LOCAL_PATH)/uncompressedlibs && \      mkdir $(LOCAL_PATH)/uncompressedlibs; \      unzip $(LOCAL_PATH)/$(LOCAL_SRC_FILES) $(PRIVATE_EMBEDDED_JNI_LIBS) -d $(LOCAL_PATH)/uncompressedlibs > /dev/null && \      find $(LOCAL_PATH)/uncompressedlibs -name *.so; \      fi),$(eval JNI_LIBS += $(FILE)))LOCAL_PREBUILT_JNI_LIBS := $(subst $(LOCAL_PATH),,$(JNI_LIBS))LOCAL_MULTILIB := $(TARGET_BIT)LOCAL_MODULE_PATH := $(TARGET_OUT)/vendor/appLOCAL_CERTIFICATE := PRESIGNEDinclude $(BUILD_PREBUILT)</code></pre><p>方法四有时候也会出问题，出现编译失败的情况，方法三是最保险的。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Framework </tag>
            
            <tag> 应用集成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Android][Framework]使用bootchart分析开机数据</title>
      <link href="/2018/07/10/%5BAndroid%5D%5BFramework%5Dbootchart/"/>
      <url>/2018/07/10/%5BAndroid%5D%5BFramework%5Dbootchart/</url>
      
        <content type="html"><![CDATA[<h2 id="Mac安装Bootchart"><a href="#Mac安装Bootchart" class="headerlink" title="Mac安装Bootchart"></a>Mac安装Bootchart</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>通过下面链接下载<code>bootchart</code>源码：<a href="http://prdownloads.sourceforge.net/bootchart/bootchart-0.9.tar.bz2" target="_blank" rel="noopener">bootchart-0.9.tar.bz2</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>解压缩，因为是ant构建的，需要安装ant</p><pre class=" language-lang-bash"><code class="language-lang-bash">brew install ant</code></pre><p>进入源码目录，执行</p><pre class=" language-lang-java"><code class="language-lang-java">ant</code></pre><p>目录会生成<code>bootchart.jar</code></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>然后手机开启<code>Bootchart</code>的过程最终会生成<code>bootchart.tgz</code>的文件，这个文件就是要处理的源文件，通过下面命令，可以在当前目录生成png图片。</p><pre class=" language-lang-java"><code class="language-lang-java">java  -jar   bootchar.jar   /path/to/bootchart.tgz</code></pre><h2 id="Android开启Bootchart"><a href="#Android开启Bootchart" class="headerlink" title="Android开启Bootchart"></a>Android开启Bootchart</h2><p>在旧版Android中（6.0之前版本）需要修改一些文件，重新编译boot.img才可以开启<code>bootchart</code>，这个修改方法可以上网搜索一下。现在的Android系统已经配置好<code>bootchart</code>，只需要做以下操作就可以启动：</p><pre class=" language-lang-bash"><code class="language-lang-bash">//在data/bootchart/目录中新建start文件adb shell 'touch /data/bootchart/start'/** 在start文件中写入采用时间timeout=120s* 这里的时间可以自定义，通过查看源代码可知最长时间不能超过10*60 s */adb shell 'echo 120 > /data/bootchart/start'//在data/bootchart/目录中新建stop文件adb shell 'touch /data/bootchart/stop'//在stop文件中写入1标记，用于停止采集数据adb shell 'echo 1 > /data/bootchart/stop'</code></pre><p>重启之后，看到<code>/data/bootchart/</code>目录下文件为：</p><pre class=" language-lang-bash"><code class="language-lang-bash">header kernel_pacct proc_diskstats.log proc_ps.log proc_stat.log start</code></pre><p>那可以看到stop文件消失了。所以这里需要注意把start文件也删除，不然下次重启手机又会启动<code>bootchart</code>，而启动它是要耗费资源的。</p><h2 id="采集数据"><a href="#采集数据" class="headerlink" title="采集数据"></a>采集数据</h2><p>可以把生成出来的5个文件pull出来打包，也可以使用系统提供的脚本做这个操作。系统脚本在 <code>AOSP/system/core/init/grab-bootchart.sh</code>。我把脚本放在前面bootchart源码目录中，然后做了一些修改以适应我的开发环境。</p><pre class=" language-lang-bash"><code class="language-lang-bash">#!/bin/sh## This script is used to retrieve a bootchart log generated by init.# All options are passed to adb, for better or for worse.# See the readme in this directory for more on bootcharting.TMPDIR=~/Temprm -rf $TMPDIRmkdir -p $TMPDIR# log在手机的路径LOGROOT=/data/bootchartTARBALL=bootchart.tgz# 5个文件FILES="header proc_stat.log proc_ps.log proc_diskstats.log kernel_pacct"# 把文件pull到本地电脑for f in $FILES; do    adb "${@}" pull $LOGROOT/$f $TMPDIR/$f 2>&1 > /dev/nulldone# 文件打包(cd $TMPDIR && tar -czf $TARBALL $FILES)#bootchart ${TMPDIR}/${TARBALL}#gnome-open ${TARBALL%.tgz}.png# 通过bootchart源码生成png  这和linux环境不一样java -jar bootchart.jar ${TMPDIR}/bootchart.tgzrm -rf $TMPDIRecho "./${TARBALL%.tgz}.png is generated"</code></pre><p>这样就能生成直观的开机状态统计图了。</p><p><a href="https://blog.csdn.net/whurs/article/details/67062678" target="_blank" rel="noopener">Bootchart分析Android6.0开机性能</a></p><p><a href="https://blog.csdn.net/fu_kevin0606/article/details/53928748" target="_blank" rel="noopener">Android7.0 bootchart工具使用说明</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Framework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Android][Framework]系统手势和状态栏</title>
      <link href="/2018/07/05/%5BAndroid%5D%5BFramework%5DSystem-Gesture-and-statusbar/"/>
      <url>/2018/07/05/%5BAndroid%5D%5BFramework%5DSystem-Gesture-and-statusbar/</url>
      
        <content type="html"><![CDATA[<p>PhoneWindowManager.java</p><p>PhoneWindowManager在init的时候会监听系统手势：</p><pre class=" language-lang-java"><code class="language-lang-java">/** {@inheritDoc} */@Overridepublic void init(Context context, IWindowManager windowManager,                 WindowManagerFuncs windowManagerFuncs) {...// monitor for system gesturesmSystemGestures = new SystemGesturesPointerEventListener(context,new SystemGesturesPointerEventListener.Callbacks() {    @Override    public void onSwipeFromTop() {        if (mStatusBar != null) {            requestTransientBars(mStatusBar);        }    }    @Override    public void onSwipeFromBottom() {        if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_BOTTOM) {            requestTransientBars(mNavigationBar);        }    }    @Override    public void onSwipeFromRight() {        if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_RIGHT) {            requestTransientBars(mNavigationBar);        }    }    @Override    public void onSwipeFromLeft() {        if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_LEFT) {            requestTransientBars(mNavigationBar);        }    }    @Override    public void onFling(int duration) {        if (mPowerManagerInternal != null) {            mPowerManagerInternal.powerHint(                    PowerManagerInternal.POWER_HINT_INTERACTION, duration);        }    }    @Override    public void onDebug() {        // no-op    }    @Override    public void onDown() {        mOrientationListener.onTouchStart();    }    @Override    public void onUpOrCancel() {        mOrientationListener.onTouchEnd();    }    @Override    public void onMouseHoverAtTop() {        mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);        Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);        msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_STATUS;        mHandler.sendMessageDelayed(msg, 500);    }    @Override    public void onMouseHoverAtBottom() {        mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);        Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);        msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_NAVIGATION;        mHandler.sendMessageDelayed(msg, 500);    }    @Override    public void onMouseLeaveFromEdge() {        mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);    }});    ...}</code></pre><p>监听使用的是SystemGesturesPointerEventListener</p><pre class=" language-lang-java"><code class="language-lang-java">/* * Listens for system-wide input gestures, firing callbacks when detected. * @hide */public class SystemGesturesPointerEventListener implements PointerEventListener {</code></pre><p>由注释可见，这个Listener监听系统级别的输入手势，由回调触发处理。</p><p>这个Listener实现了一个接口：</p><pre class=" language-lang-java"><code class="language-lang-java">public interface PointerEventListener {    /**     * 1. onPointerEvent will be called on the service.UiThread.     * 2. motionEvent will be recycled after onPointerEvent returns so if it is needed later a     * copy() must be made and the copy must be recycled.     **/    public void onPointerEvent(MotionEvent motionEvent);}</code></pre><p>这个接口位于WindowManagerPolicy，是一个比较关键的接口。</p><p>回到Listener，看一下其对这个接口的具体实现：</p><pre class=" language-lang-java"><code class="language-lang-java">@Overridepublic void onPointerEvent(MotionEvent event) {    if (mGestureDetector != null && event.isTouchEvent()) {        mGestureDetector.onTouchEvent(event);    }    switch (event.getActionMasked()) {        case MotionEvent.ACTION_DOWN:            mSwipeFireable = true;            mDebugFireable = true;            mDownPointers = 0;            captureDown(event, 0);            if (mMouseHoveringAtEdge) {                mMouseHoveringAtEdge = false;                mCallbacks.onMouseLeaveFromEdge();            }            mCallbacks.onDown();            break;        case MotionEvent.ACTION_POINTER_DOWN:            captureDown(event, event.getActionIndex());            if (mDebugFireable) {                mDebugFireable = event.getPointerCount() < 5;                if (!mDebugFireable) {                    if (DEBUG) Slog.d(TAG, "Firing debug");                    mCallbacks.onDebug();                }            }            break;        case MotionEvent.ACTION_MOVE:            if (mSwipeFireable) {                final int swipe = detectSwipe(event);                mSwipeFireable = swipe == SWIPE_NONE;                if (swipe == SWIPE_FROM_TOP) {                    if (DEBUG) Slog.d(TAG, "Firing onSwipeFromTop");                    mCallbacks.onSwipeFromTop();                } else if (swipe == SWIPE_FROM_BOTTOM) {                    if (DEBUG) Slog.d(TAG, "Firing onSwipeFromBottom");                    mCallbacks.onSwipeFromBottom();                } else if (swipe == SWIPE_FROM_RIGHT) {                    if (DEBUG) Slog.d(TAG, "Firing onSwipeFromRight");                    mCallbacks.onSwipeFromRight();                } else if (swipe == SWIPE_FROM_LEFT) {                    if (DEBUG) Slog.d(TAG, "Firing onSwipeFromLeft");                    mCallbacks.onSwipeFromLeft();                }            }            break;        case MotionEvent.ACTION_HOVER_MOVE:            if (event.isFromSource(InputDevice.SOURCE_MOUSE)) {                if (!mMouseHoveringAtEdge && event.getY() == 0) {                    mCallbacks.onMouseHoverAtTop();                    mMouseHoveringAtEdge = true;                } else if (!mMouseHoveringAtEdge && event.getY() >= screenHeight - 1) {                    mCallbacks.onMouseHoverAtBottom();                    mMouseHoveringAtEdge = true;                } else if (mMouseHoveringAtEdge                        && (event.getY() > 0 && event.getY() < screenHeight - 1)) {                    mCallbacks.onMouseLeaveFromEdge();                    mMouseHoveringAtEdge = false;                }            }            break;        case MotionEvent.ACTION_UP:        case MotionEvent.ACTION_CANCEL:            mSwipeFireable = false;            mDebugFireable = false;            mCallbacks.onUpOrCancel();            break;        default:            if (DEBUG) Slog.d(TAG, "Ignoring " + event);    }}</code></pre><p>其中mCallbacks就是</p><pre class=" language-lang-java"><code class="language-lang-java">    interface Callbacks {        void onSwipeFromTop();        void onSwipeFromBottom();        void onSwipeFromRight();        void onSwipeFromLeft();        void onFling(int durationMs);        void onDown();        void onUpOrCancel();        void onMouseHoverAtTop();        void onMouseHoverAtBottom();        void onMouseLeaveFromEdge();        void onDebug();    }</code></pre><p>即定义好的10种手势。</p><p>里面switch语句处理的操作也是MotionEvent最基本的操作。这里主要看一下从上往下滑动的事件是怎么计算的：</p><pre class=" language-lang-java"><code class="language-lang-java">case MotionEvent.ACTION_MOVE:    if (mSwipeFireable) {        final int swipe = detectSwipe(event);        mSwipeFireable = swipe == SWIPE_NONE;        if (swipe == SWIPE_FROM_TOP) {            if (DEBUG) Slog.d(TAG, "Firing onSwipeFromTop");            mCallbacks.onSwipeFromTop();</code></pre><ol><li>在MotionEvent.ACTION_DOWN的时候，将mSwipeFireable置为true</li><li>通过detectSwipe()方法计算滑动方向</li><li>确定SWIPE_FROM_TOP事件，调用对应回调</li></ol><p>来看看detectSwipe方法，具体见注释。</p><pre class=" language-lang-java"><code class="language-lang-java">private int detectSwipe(MotionEvent move) {    // 返回此event中历史的点数    final int historySize = move.getHistorySize();    final int pointerCount = move.getPointerCount();    for (int p = 0; p < pointerCount; p++) {        final int pointerId = move.getPointerId(p);        final int i = findIndex(pointerId);        if (i != UNTRACKED_POINTER) {            for (int h = 0; h < historySize; h++) {                // 两次事件的间隔                final long time = move.getHistoricalEventTime(h);                final float x = move.getHistoricalX(p, h);                final float y = move.getHistoricalY(p,  h);                final int swipe = detectSwipe(i, time, x, y);                if (swipe != SWIPE_NONE) {                    return swipe;                }            }            final int swipe = detectSwipe(i, move.getEventTime(), move.getX(p), move.getY(p));            if (swipe != SWIPE_NONE) {                return swipe;            }        }    }    return SWIPE_NONE;}private int detectSwipe(int i, long time, float x, float y) {    final float fromX = mDownX[i];    final float fromY = mDownY[i];    final long elapsed = time - mDownTime[i];    if (DEBUG) Slog.d(TAG, "pointer " + mDownPointerId[i]            + " moved (" + fromX + "->" + x + "," + fromY + "->" + y + ") in " + elapsed);    if (fromY <= mSwipeStartThreshold/*status_bar_height 意味着从status_bar范围内开始*/            && y > fromY + mSwipeDistanceThreshold/*status_bar_height 划出status_bar范围*/            && elapsed < SWIPE_TIMEOUT_MS/*500ms*/) {        return SWIPE_FROM_TOP;    }    if (fromY >= screenHeight - mSwipeStartThreshold            && y < fromY - mSwipeDistanceThreshold            && elapsed < SWIPE_TIMEOUT_MS) {        return SWIPE_FROM_BOTTOM;    }    if (fromX >= screenWidth - mSwipeStartThreshold            && x < fromX - mSwipeDistanceThreshold            && elapsed < SWIPE_TIMEOUT_MS) {        return SWIPE_FROM_RIGHT;    }    if (fromX <= mSwipeStartThreshold            && x > fromX + mSwipeDistanceThreshold            && elapsed < SWIPE_TIMEOUT_MS) {        return SWIPE_FROM_LEFT;    }    return SWIPE_NONE;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Framework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Python]写给Dr.Wu的简单爬虫例子</title>
      <link href="/2018/06/27/%5BPython%5Dspider-explaination/"/>
      <url>/2018/06/27/%5BPython%5Dspider-explaination/</url>
      
        <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>这次要爬的数据来自网站：<a href="http://www.qlaee.com/zhuanlist.jsp?flag=3&amp;p=1&amp;columnumber=302&amp;codemyid=qlpreweb21" target="_blank" rel="noopener">http://www.qlaee.com/zhuanlist.jsp?flag=3&amp;p=1&amp;columnumber=302&amp;codemyid=qlpreweb21</a></p><p>界面大概是这样的：<img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/spider01.png?raw=true" alt="image-20180627023119678"></p><p>需要的数据就是图中的表格，表格的每一项都还有详情页面，如下图：</p><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/spider02.png?raw=true" alt="image-20180627030546296"></p><h2 id="处理第一个页面"><a href="#处理第一个页面" class="headerlink" title="处理第一个页面"></a>处理第一个页面</h2><p>上图表格可以看到，这个数据共有8页，对于多页的处理，需要找到其页面的网址，然后通过页面网址的序号进行多页面的遍历。</p><p>我们把鼠标右击下一页，复制下一页的网址，看到如下：</p><p><a href="http://www.qlaee.com/news_list3.jsp?p=2&amp;columnumber=302&amp;countyid=&amp;outareat=&amp;areaunit=&amp;cityid=&amp;baseprice=&amp;codemyid=qlpreweb21&amp;outareaf=" target="_blank" rel="noopener">http://www.qlaee.com/news_list3.jsp?p=2&amp;columnumber=302&amp;countyid=&amp;outareat=&amp;areaunit=&amp;cityid=&amp;baseprice=&amp;codemyid=qlpreweb21&amp;outareaf=</a></p><p>其实也可以再获取下一页的网址，对比，发现变化的是p=2，所以对这8页的处理逻辑为</p><pre class=" language-lang-python"><code class="language-lang-python">for i in range(1, 9):    url = "http://www.qlaee.com/news_list3.jsp?p=" + str(i) \    + "&columnumber=302&countyid=&outareat=&areaunit=&cityid=&baseprice=&codemyid=qlpreweb21&outareaf="</code></pre><p>得到每个页面的网址，就可以用requests进行页面爬取。</p><pre class=" language-lang-python"><code class="language-lang-python">html = requests.get(url).content.decode('utf-8')</code></pre><p>爬到的页面部分关键数据如下：</p><pre class=" language-lang-html"><code class="language-lang-html"><div class="list-news">    <table border="0" cellpadding="0" cellspacing="0" width="100%" style="border-left: 1px solid #DEDEDE; border-right: 1px solid #DEDEDE">        <tr class="x_hei">            <td bgcolor="#A6C7EE" height="24" align="center" width="160">项目编号</td>            <td bgcolor="#A6C7EE" align="center" width="320">项目名称</td>            <td align="center" bgcolor="#A6C7EE" width="140">挂牌价格</td>            <td align="center" bgcolor="#A6C7EE" width="100">挂牌时间</td>            <td align="center" bgcolor="#A6C7EE" width="100">交易状态</td>        </tr>        <tr class="x_hei">            <td bgcolor="#E4EEFA" height="24" align="center" width="160"><a href="zhuanr_info.jsp?proid=1ce451df-6eb0-11e8-ab33-0894ef1b2f8f&columnumber=315&codemyid=qlpreweb21&parentid=302" target="_blank">3707020101201806130003</a> </td>            <td bgcolor="#E4EEFA" align="left" width="320">　<a href="zhuanr_info.jsp?proid=1ce451df-6eb0-11e8-ab33-0894ef1b2f8f&columnumber=315&codemyid=qlpreweb21&parentid=302" target="_blank">潍坊市潍城区于河出租土地4.8亩</a></td>            <td align="center" bgcolor="#E4EEFA" width="140">1100元/亩/年</td>            <td align="center" bgcolor="#E4EEFA" width="100">2018-06-13</td>            <td width="98" align="center" bgcolor="#E4EEFA">                <span lang="en-us">挂牌中</span>            </td>        </tr>        <tr class="x_hei">            <td bgcolor="#E4EEFA" height="24" align="center" width="160"><a href="zhuanr_info.jsp?proid=958f33b5-6ead-11e8-ab33-0894ef1b2f8f&columnumber=315&codemyid=qlpreweb21&parentid=302" target="_blank">3707020101201806130002</a> </td>            <td bgcolor="#E4EEFA" align="left" width="320">　<a href="zhuanr_info.jsp?proid=958f33b5-6ead-11e8-ab33-0894ef1b2f8f&columnumber=315&codemyid=qlpreweb21&parentid=302" target="_blank">潍坊市潍城区于河出租土地4.8亩</a></td>            <td align="center" bgcolor="#E4EEFA" width="140">1200元/亩/年</td>            <td align="center" bgcolor="#E4EEFA" width="100">2018-06-13</td>            <td width="98" align="center" bgcolor="#E4EEFA">                <span lang="en-us">挂牌中</span>            </td>        </tr></code></pre><p>拿到源码数据，就需要使用 <code>BeautifulSoup</code> 对源码进行解析。不过解析前需要分析一下代码结构。</p><p>表格数据是标准的 <code>&lt;tr&gt;&lt;td&gt;</code> 标签，但因为界面上还有其他的表格，所以不能直接过滤 <code>&lt;tr&gt;&lt;td&gt;</code> 。通过对比，我们需要的每一行数据包裹在 <code>&lt;tr class=&quot;x_hei&quot;&gt;</code> ，所以过滤 <code>x_hei</code> 即可。</p><pre class=" language-lang-python"><code class="language-lang-python">soup = BeautifulSoup(html, 'html.parser')trs = soup.find_all('tr', attrs={'class': 'x_hei'})</code></pre><p>拿到所有的 <code>&lt;tr&gt;</code> ，即表格的每一行。 <code>&lt;trs&gt;</code> 是个 <code>list</code> ，先看下标题数据：</p><pre class=" language-lang-python"><code class="language-lang-python">[<td align="center" bgcolor="#A6C7EE" height="24" width="160">项目编号</td>, <td align="center" bgcolor="#A6C7EE" width="320">项目名称</td>, <td align="center" bgcolor="#A6C7EE" width="140">挂牌价格</td>, <td align="center" bgcolor="#A6C7EE" width="100">挂牌时间</td>, <td align="center" bgcolor="#A6C7EE" width="100">交易状态</td>]</code></pre><p>遍历该<code>list</code>，提取每一行的文字内容即可。对文字的提取，可以看到规律，文字包裹在 <code>&gt; &lt;/</code>中，所以用正则表达式就可以轻松拿到想要的数据。</p><pre class=" language-lang-python"><code class="language-lang-python">for index, item in enumerate(td):    item = str(item)    pattern = re.compile(r'>(.*?)</', re.S | re.M)    text = re.findall(pattern, item)    tmp_list.append(text[0])</code></pre><p>然后看下具体内容数据：</p><pre class=" language-lang-python"><code class="language-lang-python">[<td align="center" bgcolor="#E4EEFA" height="24" width="160"> <a href="zhuanr_info.jsp?proid=1ce451df-6eb0-11e8-ab33-0894ef1b2f8f&amp;columnumber=315&amp;codemyid=qlpreweb21&amp;parentid=302" target="_blank">3707020101201806130003</a> </td>,  <td align="left" bgcolor="#E4EEFA" width="320">　<a href="zhuanr_info.jsp?proid=1ce451df-6eb0-11e8-ab33-0894ef1b2f8f&amp;columnumber=315&amp;codemyid=qlpreweb21&amp;parentid=302" target="_blank">潍坊市潍城区于河出租土地4.8亩</a></td>,  <td align="center" bgcolor="#E4EEFA" width="140">1100元/亩/年</td>,  <td align="center" bgcolor="#E4EEFA" width="100">2018-06-13</td>,  <td align="center" bgcolor="#E4EEFA" width="98"><span lang="en-us">挂牌中</span></td>]</code></pre><p>和标题略有一些出入，内容前两项包裹在 <code>&lt;a&gt;</code> 中，即有着对应内容的网址链接，中间两项在 <code>&lt;td&gt;</code>中，最后一项在一个<code>&lt;span&gt;</code>中。</p><p>所以需要另外处理这些内容</p><pre class=" language-lang-python"><code class="language-lang-python">if index == 0:    result = re.findall(r'<a.*?>(.*?)</a>', item, re.S | re.M)    link = re.findall(r'<a.*?href="(.*?)"', item, re.S | re.M)    web = "http://www.qlaee.com/" + link[0]    web_list.append(web)elif index == 1:    result = re.findall(r'<a.*?>(.*?)</a>', item, re.S | re.M)elif index == 2:    result = re.findall(r'<td.*?>(.*?)</td>', item, re.S | re.M)elif index == 3:    result = re.findall(r'<td.*?>(.*?)</td>', item, re.S | re.M)elif index == 4:    result = re.findall(r'<span.*?>(.*?)</span>', item, re.S | re.M)</code></pre><p>这里注意，使用一个全局的<code>web_list</code>保存网址链接，用作下一步的页面爬取。</p><p>到这里，这个页面的数据就爬取完成。</p><h2 id="详情页数据提取"><a href="#详情页数据提取" class="headerlink" title="详情页数据提取"></a>详情页数据提取</h2><p>依然先用<code>requests</code>获取页面数据，然后使用同样的方法处理数据。这里主要提一下差异：</p><p>通过提取源码，知道这个页面表格被 <code>&lt;div&gt;</code> 包裹：</p><pre class=" language-lang-html"><code class="language-lang-html"><!-- 详细信息 --><div class="content-list1">    <h3 class="no-line">潍坊市潍城区于河出租土地4.8亩</h3>    <div class="info-content">        <table width="100%" border="0" align="center" cellpadding="0" cellspacing="1">            <tr>                <th width="28%" height="24" align="right" bgcolor="#E4EEFA" >项目编号&nbsp;&nbsp;</th>                <td width="32%" >3707020101201806130003</td>                <th width="20%" align="right" bgcolor="#E4EEFA" >转让方名称&nbsp;&nbsp;</th>                <td width="20%" >庄仕宏</td>            </tr>            <tr>                <th height="24" align="right" bgcolor="#E4EEFA" >土地性质&nbsp;&nbsp;</th>                <td >耕地</td>                <th align="right" bgcolor="#E4EEFA" ><span style="letter-spacing: 2em;margin-right: -2em;">其他</span>&nbsp;&nbsp;</th>                <td ></td>            </tr>            <tr>                <th height="24" align="right" bgcolor="#E4EEFA" ><span style="letter-spacing: 2em;margin-right: -2em;">坐落</span>&nbsp;&nbsp;</th>                <td colspan="3" >潍坊市&nbsp;潍城区&nbsp;于河[乡、镇（街道）]&nbsp;南庄[村（居）]</td>            </tr>            <!-- 地块信息 -->            <tr>                <th height="24" align="right" bgcolor="#E4EEFA" >地块编号&nbsp;&nbsp;</th>                <td >nzjzzh100</td>                <th align="right" bgcolor="#E4EEFA" ><span style="letter-spacing: 2em;margin-right: -2em;">用途</span>&nbsp;&nbsp;</th>                <td ></td>            </tr>            <tr>                <th height="24" align="right" bgcolor="#E4EEFA" >四至情况&nbsp;&nbsp;</th>                <td  colspan="3">庄仕峰|斗九路|斗八路|斗九路</td>            </tr>            <!-- end -->            <tr>                <th height="24" align="right" bgcolor="#E4EEFA" >拟转出面积&nbsp;&nbsp;</th>                <td >4.8亩</td>                <th align="right" bgcolor="#E4EEFA" >拟转出年限&nbsp;&nbsp;</th>                <td >6年</td>            </tr>            <tr>                <th height="24" align="right" bgcolor="#E4EEFA" >拟转出方式&nbsp;&nbsp;</th>                <td>出租</td>                <th align="right" bgcolor="#E4EEFA" >挂牌时间&nbsp;&nbsp;</th>                <td>2018-06-13</td>            </tr>            <tr>                <th height="24" align="right" bgcolor="#E4EEFA" >是否属再次转出&nbsp;&nbsp;</th>                <td >否</td>                <th align="right" bgcolor="#E4EEFA" >交易方式&nbsp;&nbsp;</th>                <td >协议</td>            </tr>            <tr>                <th height="24" align="right" bgcolor="#E4EEFA" >标的是否存在抵押、查封等情况&nbsp;&nbsp;</th>                <td >否</td>                <th align="right" bgcolor="#E4EEFA" >挂牌价格&nbsp;&nbsp;</th>                <td >1100元/亩/年</td>            </tr>            <tr>                <th height="24" align="right" bgcolor="#E4EEFA" >中心联系方式&nbsp;&nbsp;</th>                <td ></td>                <th align="right" bgcolor="#E4EEFA" >项目联系方式&nbsp;&nbsp;</th>                <td ></td>            </tr>            <tr>                <th height="24" align="right" bgcolor="#E4EEFA" >结算方式&nbsp;&nbsp;</th>                <td  colspan="3">分期支付</td>            </tr>            <tr>                <th height="48" align="right" valign="top" bgcolor="#E4EEFA" ><span style="letter-spacing: 2em;margin-right: -2em;">备注</span>&nbsp;&nbsp;</th>                <td colspan="3" valign="top" >交通便利，水电通畅，地块平整</td>            </tr>        </table>    </div></div></div></td></tr></tbody></table></div></code></pre><p>所以先拿到对应的 <code>&lt;div&gt;</code></p><pre class=" language-lang-python"><code class="language-lang-python">div = soup.find_all('div', attrs={'class': 'content-list1'})[0]</code></pre><p>再看其内部数据</p><ul><li><p>主标题，被 <code>&lt;h3&gt;</code> 包裹</p><p><code>&lt;h3 class=&quot;no-line&quot;&gt;潍坊市潍城区于河出租土地4.8亩&lt;/h3&gt;</code> </p></li><li><p>数据标题，被 <code>&lt;th&gt;</code> 包裹</p><p><code>&lt;th width=&quot;28%&quot; height=&quot;24&quot; align=&quot;right&quot; bgcolor=&quot;#E4EEFA&quot; &gt;项目编号&amp;nbsp;&amp;nbsp;&lt;/th&gt;</code></p></li><li><p>数据内容，被 <code>&lt;td&gt;</code> 包裹</p><p><code>&lt;td width=&quot;32%&quot; &gt;3707020101201806130003&lt;/td&gt;</code></p></li><li><p>特殊项，被 <code>&lt;span&gt;</code> 包裹</p><p><code>&lt;th height=&quot;48&quot; align=&quot;right&quot; valign=&quot;top&quot; bgcolor=&quot;#E4EEFA&quot; &gt;&lt;span style=&quot;letter-spacing: 2em;margin-right: -2em;&quot;&gt;备注&lt;/span&gt;&amp;nbsp;&amp;nbsp;&lt;/th&gt;</code></p></li></ul><p>知道这些，就可以按照观察到的进行分别处理，先把标题全部取出来存到一个<code>list</code>中，再把数据全部取数来按顺序存到另一个<code>list</code>中即可。</p><pre class=" language-lang-python"><code class="language-lang-python">def get_detail(iurl):    print("handling url:" + iurl)    html = requests.get(iurl, timeout=10).content.decode('utf-8')    soup = BeautifulSoup(html, 'html.parser')    # print(soup)    div = soup.find_all('div', attrs={'class': 'content-list1'})[0]    # for title    if len(list2) == 0:        title_list = []        title_list.append("项目名称")        ths = div.find_all('th')        for th in ths:            th = str(th)            text = re.findall(r'<span.*?>(.*?)</span>', th, re.S | re.M)            if len(text) is 0:                text = re.findall(r'<th.*?>(.*?)</th>', th, re.S | re.M)            result = text[0].strip()            title_list.append(result)        list2.append(handle_list(title_list))    # for content    tmp_list = []    title = div.find_all('h3')    pattern = re.compile(r'>(.*?)</', re.S | re.M)    text = re.findall(pattern, str(title))    tmp_list.append(text[0])    tds = div.find_all('td')    for td in tds:        td = str(td)        text = re.findall(r'<td.*?>(.*?)</td>', td, re.S | re.M)        if len(text) is 0:            text = [""]        result = text[0].strip()        tmp_list.append(result)    list2.append(handle_list(tmp_list))</code></pre><h2 id="数据保存"><a href="#数据保存" class="headerlink" title="数据保存"></a>数据保存</h2><p>前面的数据都存在一个<code>list</code>中，最后的展示，当然是存在excel中比较好，所以建议使用<code>openpyxl</code>，因为支持<code>xlsx</code>格式。</p><pre class=" language-lang-python"><code class="language-lang-python">def save_list_to_excel(listX, name):    file_path = '/Users/wow/Desktop/spider.xlsx'    if os.path.exists(file_path):        wb = openpyxl.load_workbook(file_path)    else:        wb = openpyxl.Workbook()    ws = wb.create_sheet(title=name)    for index_x, row in enumerate(listX):        for index_y, col in enumerate(row):            ws.cell(index_x + 1, index_y + 1, col)    wb.save(filename=file_path)</code></pre><p>使用很简单，先判断文件是否存在，不存在新建表格，存在打开表格，在原来基础上按顺序添加新内容即可。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>整体的代码很简单。为了代码易读，所以都用的最基本的语法。后面会增加一些多进程处理页面，也会对页面处理方法进行封装，尽量适配更多的相似页面。</p><pre class=" language-lang-python"><code class="language-lang-python"># coding: utf-8import requestsfrom bs4 import BeautifulSoupimport reimport openpyxlimport oslist1 = []web_list = []list2 = []def fetch_page1(index, item):    global web_list    if index == 0:        result = re.findall(r'<a.*?>(.*?)</a>', item, re.S | re.M)        link = re.findall(r'<a.*?href="(.*?)"', item, re.S | re.M)        web = "http://www.qlaee.com/" + link[0]        web_list.append(web)    elif index == 1:        result = re.findall(r'<a.*?>(.*?)</a>', item, re.S | re.M)    elif index == 2:        result = re.findall(r'<td.*?>(.*?)</td>', item, re.S | re.M)    elif index == 3:        result = re.findall(r'<td.*?>(.*?)</td>', item, re.S | re.M)    elif index == 4:        result = re.findall(r'<span.*?>(.*?)</span>', item, re.S | re.M)    else:        result = []    if len(result) > 0:        return result[0]    else:        return ""def get_page():    global list1    get_title = True    for i in range(1, 2):        print("handling page " + str(i))        # url = "http://www.qlaee.com/chengjlist.jsp?p=" + str(i) \        #       + "&columnumber=-1&codemyid=qlpreweb23"        url = "http://www.qlaee.com/news_list3.jsp?p=" + str(i) \              + "&columnumber=302&countyid=&outareat=&areaunit=&cityid=&baseprice=&codemyid=qlpreweb21&outareaf="        html = requests.get(url).content.decode('utf-8')        soup = BeautifulSoup(html, 'html.parser')        trs = soup.find_all('tr', attrs={'class': 'x_hei'})        if get_title is False:            trs.pop(0)        for tr in trs:            tmp_list = []            td = tr.find_all('td')            print(td)            if len(td) < 0:                continue            for index, item in enumerate(td):                item = str(item)                if get_title is True:                    pattern = re.compile(r'>(.*?)</', re.S | re.M)                    text = re.findall(pattern, item)                    tmp_list.append(text[0])                else:                    tmp_list.append(fetch_page1(index, item))            get_title = False            list1.append(tmp_list)    save_list_to_excel(list1, "info2")def get_detail(iurl):    print("handling url:" + iurl)    html = requests.get(iurl, timeout=10).content.decode('utf-8')    soup = BeautifulSoup(html, 'html.parser')    # print(soup)    div = soup.find_all('div', attrs={'class': 'content-list1'})[0]    # for title    if len(list2) == 0:        title_list = []        title_list.append("项目名称")        ths = div.find_all('th')        for th in ths:            th = str(th)            text = re.findall(r'<span.*?>(.*?)</span>', th, re.S | re.M)            if len(text) is 0:                text = re.findall(r'<th.*?>(.*?)</th>', th, re.S | re.M)            result = text[0].strip()            title_list.append(result)        list2.append(handle_list(title_list))    # for content    tmp_list = []    title = div.find_all('h3')    pattern = re.compile(r'>(.*?)</', re.S | re.M)    text = re.findall(pattern, str(title))    tmp_list.append(text[0])    tds = div.find_all('td')    for td in tds:        td = str(td)        text = re.findall(r'<td.*?>(.*?)</td>', td, re.S | re.M)        if len(text) is 0:            text = [""]        result = text[0].strip()        tmp_list.append(result)    list2.append(handle_list(tmp_list))def save_list_to_excel(listX, name):    file_path = '/Users/wow/Desktop/spider.xlsx'    if os.path.exists(file_path):        wb = openpyxl.load_workbook(file_path)    else:        wb = openpyxl.Workbook()    ws = wb.create_sheet(title=name)    for index_x, row in enumerate(listX):        for index_y, col in enumerate(row):            ws.cell(index_x + 1, index_y + 1, col)    wb.save(filename=file_path)def handle_list(list_ori):    list_end = list_ori[-12:]    list_start = list_ori[0:-12]    for i, item in enumerate(list_end):        list_start.insert(6 + i, item)    return list_startif __name__ == "__main__":    get_page()    if len(web_list) > 0:        for index, url in enumerate(web_list):            get_detail(url)        save_list_to_excel(list2, "detail")</code></pre><h2 id="最后恭喜阿根廷小组赛突围"><a href="#最后恭喜阿根廷小组赛突围" class="headerlink" title="最后恭喜阿根廷小组赛突围"></a>最后恭喜阿根廷小组赛突围</h2><p>现在阿根廷中后场整体不行，进世界杯都磕磕绊绊，后面淘汰赛估计也够呛了。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Android]暗码机制</title>
      <link href="/2018/06/20/%5BAndroid%5DSecretCode/"/>
      <url>/2018/06/20/%5BAndroid%5DSecretCode/</url>
      
        <content type="html"><![CDATA[<p>今天客户邮件过来一段代码让我加一下，说是用暗码启动MainActivity。</p><pre class=" language-lang-java"><code class="language-lang-java"><intent-filter>    <action android:name="android.provider.Telephony.SECRET_CODE"/>    <data android:host="368222" android:scheme="android_secret_code"/></intent-filter></code></pre><p>因为之前改过Dialer，定制过相关的暗码功能，所以没多想就直接把intent-filter加在MainActivity中了。然后测试告诉我，输入”*#*#368222#*#*“不起作用。嗯？</p><p>后来一想，好像哪里不太一样，<code>Telephony.SECRET_CODE</code> 好像是系统定义的，不是定制的。然后扒拉一下源码：</p><p>packages/apps/Dialer/java/com/android/dialer/app/SpecialCharSequenceMgr.java</p><pre class=" language-lang-java"><code class="language-lang-java">  /**   * Handles secret codes to launch arbitrary activities in the form of *#*#<code>#*#*.   *   * @param context the context to use   * @param input the text to check for a secret code in   * @return true if a secret code was encountered and handled   */  static boolean handleSecretCode(Context context, String input) {    // Secret codes are accessed by dialing *#*#<code>#*#*    int len = input.length();    if (len <= 8 || !input.startsWith("*#*#") || !input.endsWith("#*#*")) {      return false;    }    String secretCode = input.substring(4, len - 4);    TelephonyManagerCompat.handleSecretCode(context, secretCode);    return true;  }</code></pre><p>packages/apps/Dialer/java/com/android/contacts/common/compat/TelephonyManagerCompat.java</p><pre class=" language-lang-java"><code class="language-lang-java">  /**   * Handles secret codes to launch arbitrary activities.   *   * @param context the context to use   * @param secretCode the secret code without the "*#*#" prefix and "#*#*" suffix   */  public static void handleSecretCode(Context context, String secretCode) {    // Must use system service on O+ to avoid using broadcasts, which are not allowed on O+.    if (BuildCompat.isAtLeastO()) {      context.getSystemService(TelephonyManager.class).sendDialerSpecialCode(secretCode);    } else {      // System service call is not supported pre-O, so must use a broadcast for N-.      Intent intent =          new Intent(SECRET_CODE_ACTION, Uri.parse("android_secret_code://" + secretCode));      context.sendBroadcast(intent);    }  }</code></pre><p>嗯，原来<code>*#*#</code> 和  <code>#*#*</code> 是定义好的暗码前后缀，拿到暗码之后，发送了一个广播。</p><p>所以需要创建一个receiver来handle这个广播：</p><pre class=" language-lang-java"><code class="language-lang-java">public class SecretCodeReceiver extends BroadcastReceiver {    private static final String TAG = "SecretCodeReceiver";    @Override    public void onReceive(Context context, Intent intent) {        String action = intent.getAction();        Log.d(TAG, "Action = " + action);        Intent i = new Intent(Intent.ACTION_MAIN);        i.setClass(context, MainActivity.class);        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);        context.startActivity(i);    }}</code></pre><p>然后把intent-filter放在这个receiver中间</p><pre class=" language-lang-java"><code class="language-lang-java"><receiver android:name="com.xx.receiver.SecretCodeReceiver">    <intent-filter>    <action android:name="android.provider.Telephony.SECRET_CODE"/>    <data android:host="368222" android:scheme="android_secret_code"/>    </intent-filter></receiver></code></pre><p>emmmm…好了</p><p>发现系统这一套暗码机制还挺好用的，也不理解客户之前为何还要定制一套暗码。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Secret Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[转载][Linux]CentOS安装Darwin Streaming Server搭建RTSP流媒体服务器</title>
      <link href="/2018/06/05/%5BLinux%5Destablish-rstp-server/"/>
      <url>/2018/06/05/%5BLinux%5Destablish-rstp-server/</url>
      
        <content type="html"><![CDATA[<h4 id="安装环境库"><a href="#安装环境库" class="headerlink" title="安装环境库"></a>安装环境库</h4><p>yum -y install gcc gcc-c++ perl ld-linux.so.2 libstdc++.so.6</p><h4 id="下载Darwin-Streaming-Server-v5-5-5-并安装"><a href="#下载Darwin-Streaming-Server-v5-5-5-并安装" class="headerlink" title="下载Darwin Streaming Server v5.5.5 并安装"></a>下载Darwin Streaming Server v5.5.5 并安装</h4><pre class=" language-lang-bash"><code class="language-lang-bash">ssh root@yourIpAddr # ssh 登录到服务器wget http://dss.macosforge.org/downloads/DarwinStreamingSrvr5.5.5-Linux.tar.gztar -zxvf DarwinStreamingSrvr5.5.5-Linux.tar.gzcd DarwinStreamingSrvrlinux-Linux./Install</code></pre><h4 id="浏览器访问Darwin-Streaming-Server-WEB"><a href="#浏览器访问Darwin-Streaming-Server-WEB" class="headerlink" title="浏览器访问Darwin Streaming Server WEB"></a>浏览器访问Darwin Streaming Server WEB</h4><p>访问 <a href="http://yourIpAddr:1220" target="_blank" rel="noopener">http://yourIpAddr:1220</a></p><p>初始设置向导：</p><ol><li>Setup Assistant MP3 Broadcast Password：这里重复输入你的密码，然后点Next下一步</li><li>Setup Assistant Secure Administration：不用勾选，直接点Next下一步</li><li>Setup Assistant Media Folder:默认为/usr/local/movies，不建议修改，直接点Next下一步</li><li>Setup Assistant Streaming on Port 80：不建议改端口，点Finish完成设置向导</li></ol><h4 id="测试RTSP流媒体服务"><a href="#测试RTSP流媒体服务" class="headerlink" title="测试RTSP流媒体服务"></a>测试RTSP流媒体服务</h4><p>打开VLC media player，然后点左上角“媒体”——“打开网络串流”，然后输入网络URL，例如我想播放/usr/local/movies下的sample_h264_1mbit.mp4，则打开下面这个链接：<br>rtsp://192.168.200.77/sample_h264_1mbit.mp4<br>可以看到能够播放视频</p><h4 id="启动及开机自动启动"><a href="#启动及开机自动启动" class="headerlink" title="启动及开机自动启动"></a>启动及开机自动启动</h4><p>1、手动运行：</p><pre class=" language-lang-bash"><code class="language-lang-bash">sudo /usr/local/sbin/DarwinStreamingServersudo /usr/local/sbin/streamingadminserver.pl</code></pre><blockquote><p> 第一个命令为开启DarwinStreamingServer服务，这个服务运行了就可以通过RTSP访问流媒体了.第二个命令为开启WEB服务器（默认端口1220）。</p></blockquote><p>2、如果要开机自动运行，则把上面两条命令（不用sudo）加到/etc/rc.local文件（exit 0之前）中即可。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>在AndroidApp中创建一个VideoView就可以直接播放RTSP视频流了。</p><h4 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h4><p><a href="http://www.yimiju.com/articles/567.html" target="_blank" rel="noopener">http://www.yimiju.com/articles/567.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RTSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Android][Framework]Activity启动流程</title>
      <link href="/2018/06/03/%5BAndroid%5D%5BFramework%5Dhow-does-Activity-start/"/>
      <url>/2018/06/03/%5BAndroid%5D%5BFramework%5Dhow-does-Activity-start/</url>
      
        <content type="html"><![CDATA[<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>从Launcher点击一个App图标，会触发如下动作：</p><p><a href="https://source.asrmicro.com:8443/adroid8.1/xref/frameworks/base/core/java/android/app/LauncherActivity.java" target="_blank" rel="noopener">LauncherActivity.java</a></p><pre class=" language-lang-java"><code class="language-lang-java">@Overrideprotected void onListItemClick(ListView l, View v, int position, long id) {  Intent intent = intentForPosition(position);  startActivity(intent);}</code></pre><p>走到了 <a href="https://source.asrmicro.com:8443/adroid8.1/xref/frameworks/base/core/java/android/app/Activity.java" target="_blank" rel="noopener">Activity.java</a> 的startActivity相关方法：</p><pre class=" language-lang-java"><code class="language-lang-java">@Overridepublic void startActivity(Intent intent) {  this.startActivity(intent, null); // 调用下一个方法}@Overridepublic void startActivity(Intent intent, @Nullable Bundle options) {  if (options != null) {    startActivityForResult(intent, -1, options);  } else {    // Note we want to go through this call for compatibility with    // applications that may have overridden the method.    startActivityForResult(intent, -1);  }}public void startActivityForResult(@RequiresPermission Intent intent, int requestCode) {  startActivityForResult(intent, requestCode, null);}public void startActivityForResult(@RequiresPermission Intent intent, int requestCode,                                   @Nullable Bundle options) {  if (mParent == null) {    options = transferSpringboardActivityOptions(options);    // 关键代码    Instrumentation.ActivityResult ar =      mInstrumentation.execStartActivity(      this, mMainThread.getApplicationThread(), mToken, this,      intent, requestCode, options);    //    if (ar != null) {      mMainThread.sendActivityResult(        mToken, mEmbeddedID, requestCode, ar.getResultCode(),        ar.getResultData());    }    if (requestCode >= 0) {      mStartedActivity = true;    }    cancelInputsAndStartExitTransition(options);    // TODO Consider clearing/flushing other event sources and events for child windows.  } else {    if (options != null) {      mParent.startActivityFromChild(this, intent, requestCode, options);    } else {      // Note we want to go through this method for compatibility with      // existing applications that may have overridden it.      mParent.startActivityFromChild(this, intent, requestCode);    }  }}public void startActivityFromChild(@NonNull Activity child, @RequiresPermission Intent intent, int requestCode, @Nullable Bundle options) {  options = transferSpringboardActivityOptions(options);  Instrumentation.ActivityResult ar =    mInstrumentation.execStartActivity(    this, mMainThread.getApplicationThread(), mToken, child,    intent, requestCode, options);  if (ar != null) {    mMainThread.sendActivityResult(      mToken, child.mEmbeddedID, requestCode,      ar.getResultCode(), ar.getResultData());  }  cancelInputsAndStartExitTransition(options);}</code></pre><p>由代码了解到，调用startActivity最终都会走到startActivityForResult方法。startActivityForResult的作用是，如果想在Activity中得到新打开的Activity关闭后返回的数据，就要用这个方法。但因为这里传入的requestCode是-1，所以不会返回结果。</p><p>这个函数首先会判断要启动的Activity是否是子Activity，如果不是，就会调用execStartActivity函数。反之，调用startActivityFromChild函数。不过在startActivityFromChild中依然是执行到execStartActivity方法中去。区别是参数传递的父类对象。</p><h2 id="Instrumentation"><a href="#Instrumentation" class="headerlink" title="Instrumentation"></a>Instrumentation</h2><p><a href="https://source.asrmicro.com:8443/adroid8.1/xref/frameworks/base/core/java/android/app/Instrumentation.java" target="_blank" rel="noopener">Instrumentation.java</a></p><p>Instrumentation之前在 <a href="http://wossoneri.github.io/2018/05/17/[Android][Framework]ActivityThread/#Instrumentation">ActivityThread</a> 有提到过，它和Activity有些类似。它主要作用是连接Activity/Application的中间层，也就是启动Activity，包括生命周期都不是直接调用的，而是通过instrumentation作为中介调用，这样它就具有了监控App的能力。使用Instrumentation框架可以进行对App的自动化测试，精准控制Activity。</p><p>调用execStartActivity方法传入一个mMainThread.getApplicationThread()参数，这个mMainThread是个ActivityThread，在Activity.attach时拿到的。因为此时还在桌面界面启动，所以还处在Launcher进程中，所以是Launcher的主线程。另一个参数是mToken，是IBinder类型的对象。这里由于还是在Launcher进程，所以这个mToken也是在启动Launcer时的attach方法中创建。</p><pre class=" language-lang-java"><code class="language-lang-java">public ActivityResult execStartActivity(  Context who, IBinder contextThread, IBinder token, Activity target,  Intent intent, int requestCode, Bundle options) {  IApplicationThread whoThread = (IApplicationThread) contextThread;  Uri referrer = target != null ? target.onProvideReferrer() : null;  if (referrer != null) {    intent.putExtra(Intent.EXTRA_REFERRER, referrer);  }  if (mActivityMonitors != null) {    synchronized (mSync) {      final int N = mActivityMonitors.size();      for (int i=0; i<N; i++) { // 通过ActivityMonitor对启动的activity进行检查        final ActivityMonitor am = mActivityMonitors.get(i);        ActivityResult result = null;        if (am.ignoreMatchingSpecificIntents()) {          result = am.onStartActivity(intent);        }        if (result != null) {          am.mHits++;          return result;        } else if (am.match(who, null, intent)) {          am.mHits++;          if (am.isBlocking()) {            return requestCode >= 0 ? am.getResult() : null;          }          break;        }      }    }  }  try {    intent.migrateExtraStreamToClipData();    intent.prepareToLeaveProcess(who);    // 通过binder将处理从launcher进程切换到ActivityManagerService    int result = ActivityManager.getService()      .startActivity(whoThread, who.getBasePackageName(), intent,                     intent.resolveTypeIfNeeded(who.getContentResolver()),                     token, target != null ? target.mEmbeddedID : null,                     requestCode, 0, null, options);    checkStartActivityResult(result, intent);  } catch (RemoteException e) {    throw new RuntimeException("Failure from system", e);  }  return null;}</code></pre><p>方法执行过程见注释。下面是时序图：</p><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/AMS00.png?raw=true" alt></p><h2 id="Server代码流程"><a href="#Server代码流程" class="headerlink" title="Server代码流程"></a>Server代码流程</h2><p><a href="https://source.asrmicro.com:8443/adroid8.1/xref/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java" target="_blank" rel="noopener">ActivityManagerService.java</a></p><h3 id="ActivityManagerService-startActivity"><a href="#ActivityManagerService-startActivity" class="headerlink" title="ActivityManagerService.startActivity"></a>ActivityManagerService.startActivity</h3><pre class=" language-lang-java"><code class="language-lang-java">@Overridepublic final int startActivity(IApplicationThread caller, String callingPackage,                               Intent intent, String resolvedType, IBinder resultTo,                                    String resultWho, int requestCode,                               int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) {  return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,                             resultWho, requestCode, startFlags, profilerInfo, bOptions,                             UserHandle.getCallingUserId());}</code></pre><p>为了适配多用户，直接调用startActivityAsUser方法。</p><h3 id="ActivityManagerService-startActivityAsUser"><a href="#ActivityManagerService-startActivityAsUser" class="headerlink" title="ActivityManagerService.startActivityAsUser"></a>ActivityManagerService.startActivityAsUser</h3><pre class=" language-lang-java"><code class="language-lang-java">@Overridepublic final int startActivityAsUser(IApplicationThread caller, String callingPackage,                                     Intent intent, String resolvedType, IBinder resultTo,                                         String resultWho, int requestCode,                                     int startFlags, ProfilerInfo profilerInfo, Bundle                                          bOptions, int userId) {  enforceNotIsolatedCaller("startActivity"); // 验证CallingUid  userId = mUserController.handleIncomingUser(Binder.getCallingPid(),Binder.getCallingUid(),                                              userId, false, ALLOW_FULL_ONLY,                                                             "startActivity", null);  // TODO: Switch to user app stacks here.  return mActivityStarter.startActivityMayWait(caller, -1, callingPackage, intent,                                               resolvedType, null, null, resultTo,                                                        resultWho, requestCode, startFlags,                                               profilerInfo, null, null, bOptions, false,                                                  userId, null, "startActivityAsUser");}</code></pre><p>参数说明</p><p>caller，调用者。这里是Launcher的所在进程。如果是am start启动的，就是为null</p><p>intent，要启动的intent。包含Action，Categories，Component</p><p>resultTo，启动一个应用后负责接收返回结果的binder</p><p>callingPackage，启动当前activity的应用包名，此处是Launcher包名</p><p>这里，通过调用enforceNotIsolatedCaller()判断当前的请求者Binder.getCallingUid()是否允许启动Activity。</p><p>handleIncomingUser()会校验userSerialNumber,用户是否匹配,userSerial检查Number是什么意思?它是配合多用户新引入的引入userSerialNumber来标识用户。</p><p>这个方法中最关键的就是mActivityStarter.startActivityMayWait</p><h3 id="ActivityStarter-startActivityMayWait"><a href="#ActivityStarter-startActivityMayWait" class="headerlink" title="ActivityStarter.startActivityMayWait"></a>ActivityStarter.startActivityMayWait</h3><p>贴一部分代码 <a href="http://androidxref.com/8.0.0_r4/xref/frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java#668" target="_blank" rel="noopener">ActivityStarter.java</a></p><p>这是一个预处理函数，列举一下主要功能：</p><pre class=" language-lang-java"><code class="language-lang-java">// Collect information about the target of the Intent.ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, profilerInfo);</code></pre><p>这个mSupervisor是 <a href="http://androidxref.com/8.0.0_r4/xref/frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java" target="_blank" rel="noopener">ActivityStackSupervisor.java</a> 类。首先从rInfo拿到aInfo（这个方法经过AMS对aInfo做了一些处理）</p><pre class=" language-lang-java"><code class="language-lang-java">ActivityStackSupervisor.ActivityContainer container =                                                     (ActivityStackSupervisor.ActivityContainer)iContainer;final ActivityStack stack;if (container == null || container.mStack.isOnHomeDisplay()) {  stack = mSupervisor.mFocusedStack;} else {  stack = container.mStack;}</code></pre><p>这里使用当前stack，if条件判断当前是不是在主屏幕上显示，是分屏的雏形。因为当前应用没有启动起来，当前焦点stack是Home。下面就是最重要的部分：</p><pre class=" language-lang-java"><code class="language-lang-java">int res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType,                              aInfo, rInfo, voiceSession, voiceInteractor,                              resultTo, resultWho, requestCode, callingPid,                              callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,                              options, ignoreTargetSecurity, componentSpecified, outRecord, container,                              inTask, reason);</code></pre><p>上面拿到的aInfo和一些参数都传入了startActivityLocked方法，而startActivityLocked内部处理部分参数，直接把参数传给startActivity方法。这个startActivity方法是一个重量级的函数，内容很多，下面看一下：</p><h3 id="ActivityStarter-startActivity"><a href="#ActivityStarter-startActivity" class="headerlink" title="ActivityStarter.startActivity"></a>ActivityStarter.startActivity</h3><pre class=" language-lang-java"><code class="language-lang-java">ProcessRecord callerApp = null;if (caller != null) {  callerApp = mService.getRecordForAppLocked(caller);  if (callerApp != null) {    callingPid = callerApp.pid;    callingUid = callerApp.info.uid;</code></pre><p>创建一个空的ProcessRecord对象。然后先判断启动方式（caller不为空正常启动），然后调用getRecordForAppLocked获得一个ProcessRecord对象。</p><blockquote><p>ProcessRecord 注释：Full information about a particular process that is currently running.</p></blockquote><p>这里运行的是Launcher的进程，ProcessRecord记录的也是Launcher进程信息。</p><pre class=" language-lang-java"><code class="language-lang-java">ActivityRecord sourceRecord = null;ActivityRecord resultRecord = null;if (resultTo != null) { // 接收返回结果  sourceRecord = mSupervisor.isInAnyStackLocked(resultTo); // 拿到sourceRecord  if (DEBUG_RESULTS) Slog.v(TAG_RESULTS,                            "Will send result to " + resultTo + " " + sourceRecord);  if (sourceRecord != null) {    if (requestCode >= 0 && !sourceRecord.finishing) { // sourceRecord非结束状态      resultRecord = sourceRecord;    }  }}</code></pre><p>这部分就是对应startActivityForResult和onActivityResult处理逻辑，sourceRecord就是源Activity的Record，另一个是目标Activity的Record。这里得到的sourceRecord就是Launcher的ActivityRecord。</p><p>后面的代码作用是：</p><ol><li>启动标记的获得和检查</li><li>检查是否有启动any activity的权限</li><li>检查是否有启动当前请求的componentName的权限</li><li>检查权限后，然后判断是否要启动Activity</li></ol><pre class=" language-lang-java"><code class="language-lang-java">boolean abort = !mSupervisor.checkStartAnyActivityPermission(intent, aInfo, resultWho, requestCode, callingPid, callingUid, callingPackage, ignoreTargetSecurity, callerApp, resultRecord, resultStack, options);abort |= !mService.mIntentFirewall.checkStartActivity(intent, callingUid, callingPid, resolvedType, aInfo.applicationInfo);</code></pre><p>abort为true时，就会禁止启动某一个Activity。</p><pre class=" language-lang-java"><code class="language-lang-java">ActivityRecord r = new ActivityRecord(mService, callerApp,         callingPid, callingUid, callingPackage, intent,             resolvedType, aInfo, mService.getGlobalConfiguration(),     resultRecord, resultWho, requestCode, componentSpecified,       voiceSession != null, mSupervisor, container, options,         sourceRecord);</code></pre><p>一个Activity启动的关键步骤：</p><ul><li>找到它应该所在的Stack</li><li>建立一个ActivityRecord</li><li>建立TaskRecord</li><li>建立运行的进程ProcessRecord</li></ul><p>当然这里是第一次运行一个Activity。如果是第二次运行，要涉及到task和process的复用。后面看情况讲。</p><p>然后还有一段关键条件检查，检查App是否允许进行切换。就是在使用某个App的时候来了一个电话，就会切换到电话界面：</p><pre class=" language-lang-java"><code class="language-lang-java">if (!mService.checkAppSwitchAllowedLocked(callingPid, callingUid,                    realCallingPid, realCallingUid, "Activity start")) {    PendingActivityLaunch pal =  new PendingActivityLaunch(r,                                   sourceRecord, startFlags, stack, callerApp);    mPendingActivityLaunches.add(pal);    ActivityOptions.abort(options);    return ActivityManager.START_SWITCHES_CANCELED;}</code></pre><p>如果不允许切换，则存储起来，有机会再启动它。将保存到mPendingActivityLaunches中。</p><p>没有权限切换意味着当前显示的应用进行了stopAppSwitches。这个方法会使其他Task 的Activity无法显示在前端，但同一个Task中的Activity则不受制约。取消禁止切换使用 resumeAppSwitches。为了防止使用者不调用resumeAppSwitches，系统设置了一个超 时时间(5s)，超时则自动resume。在resume中不会处理Pending起来的Activity，但超时会触发处理Pending的Activity。</p><p>这个startActivity执行完成之后，又会进入下一个startActivity的重载函数。</p><h3 id="ActivityStarter-startActivityUnchecked"><a href="#ActivityStarter-startActivityUnchecked" class="headerlink" title="ActivityStarter.startActivityUnchecked"></a>ActivityStarter.startActivityUnchecked</h3><p>进入新的startActivity函数后，执行try catch里就会先执行</p><pre class=" language-lang-java"><code class="language-lang-java">result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor,                    startFlags, doResume, options, inTask, outActivity);</code></pre><p>在startActivityUnchecked中会连续执行几个很重要的逻辑函数</p><h4 id="ActivityStarter-setInitialState"><a href="#ActivityStarter-setInitialState" class="headerlink" title="ActivityStarter.setInitialState"></a>ActivityStarter.setInitialState</h4><p>第一个执行setInitialState方法，做初始化。这个初始化有一段比较关键的代码：</p><pre class=" language-lang-java"><code class="language-lang-java">// We'll invoke onUserLeaving before onPause only if the launching// activity did not explicitly state that this is an automated launch.mSupervisor.mUserLeaving = (mLaunchFlags & FLAG_ACTIVITY_NO_USER_ACTION) == 0;</code></pre><p>我把官方注释也放上去了，这个是说，当启动标记未设置Intent.FLAG_ACTIVITY_NO_USER_ACTION时， mUserLeaving为true。关于Intent.FLAG_ACTIVITY_NO_USER_ACTION标记用于判断是否是用户的行为导致的Activity切换，比如当你按home键时，会切换 Activity，此时会回调onUserLeaveHint()，如果是来电导致的Activity切换，就不会调用onUserLeaveHint()，也就是说如何设置了这个标记就表明当前启动的行为是非用户行为。这样切换到后台的Activity便不会回调onUserLeaveHint()这个生命周期函数。 </p><h4 id="ActivityStarter-computeLaunchingTaskFlags"><a href="#ActivityStarter-computeLaunchingTaskFlags" class="headerlink" title="ActivityStarter.computeLaunchingTaskFlags"></a>ActivityStarter.computeLaunchingTaskFlags</h4><p>回到startActivityUnchecked方法，在执行完初始化函数后，接着执行computeLaunchingTaskFlags()方法。这个方法也有一个重要的代码段：</p><pre class=" language-lang-java"><code class="language-lang-java">if (mSourceRecord == null && mInTask != null && mInTask.getStack() != null) {    final Intent baseIntent = mInTask.getBaseIntent();    final ActivityRecord root = mInTask.getRootActivity();</code></pre><p>从最近任务栏启动开机恢复出来的activity时，会走这个逻辑，mInTask这个参数是5.0 上新增的一个参数，主要是处理任务栏相关的内容，当从最近任务栏启动“恢复的 Task”时，mInTask值是不为空的，但这时sourceRecord是为null 。当进入这个逻辑后，从mInTask中获得Intent和ActivityRecord对象，如果当前的获得的ActivityRecord对象为null时，这时候会重新调整启动flag参数、task的复用等一系列调整，这里不在过多分析。 </p><p>一般启动Activity时都会走到这里：</p><pre class=" language-lang-java"><code class="language-lang-java">if (mInTask == null) {    if (mSourceRecord == null) {        // This activity is not being started from another...  in this        // case we -always- start a new task.        if ((mLaunchFlags & FLAG_ACTIVITY_NEW_TASK) == 0 && mInTask == null) {            Slog.w(TAG, "startActivity called from non-Activity context; forcing " +                   "Intent.FLAG_ACTIVITY_NEW_TASK for: " + mIntent);            mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;        }    } else if (mSourceRecord.launchMode == LAUNCH_SINGLE_INSTANCE) {        // The original activity who is starting us is running as a single        // instance...  this new activity it is starting must go on its        // own task.        mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;    } else if (mLaunchSingleInstance || mLaunchSingleTask) {        // The activity being started is a single instance...  it always        // gets launched into its own task.        mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;    }}</code></pre><p>上面这段代码主要是设置启动标识，设置Intent.FLAG_ACTIVITY_NEW_TASK的启动标识。下面几种情况设置这个标识:</p><ol><li>mSourceRecord == null,不是通过home上启动Activity的情况，比如用命令“am start” </li><li>启动目标的Activity的启动模式是singleInstance </li><li>启动目标的Activity的启动模式是 singleTask。我们都知道，当设置了这个flag后，要启动的Activity必须就要在新的Task中了。 继续向下分析，都是象电影一样，一个场景一个场景的。 下面的场景是mSourceRecord != null的状态。 </li></ol><h4 id="ActivityStarter-computeSourceStack"><a href="#ActivityStarter-computeSourceStack" class="headerlink" title="ActivityStarter.computeSourceStack"></a>ActivityStarter.computeSourceStack</h4><p>如果mSourceRecord为null，这里会立刻返回。如果不为空，则往下进行。</p><p>这个场景下，首先判断mSourceRecord 是不是正在 finish的状态，因为这种状态下，我们就不能在把这个mSourceRecord作为源了。</p><p>如果它的flag没有添加 FLAG_ACTIVITY_NEW_TASK这个flag，我们为它手动添加一个，然后将mSourceRecord ，mSourceStack置为null. 如果mSourceRecord不是在finish状态，那么会将源所在Stack指向一个新的Stack。这主要是为后面进行task复用在做准备。 </p><pre class=" language-lang-java"><code class="language-lang-java">private void computeSourceStack() {    if (mSourceRecord == null) {        mSourceStack = null;        return;    }    if (!mSourceRecord.finishing) {        mSourceStack = mSourceRecord.getStack();        return;    }    // If the source is finishing, we can't further count it as our source. This is because the    // task it is associated with may now be empty and on its way out, so we don't want to    // blindly throw it in to that task.  Instead we will take the NEW_TASK flow and try to find    // a task for it. But save the task information so it can be used when creating the new task.    if ((mLaunchFlags & FLAG_ACTIVITY_NEW_TASK) == 0) {        Slog.w(TAG, "startActivity called from finishing " + mSourceRecord               + "; forcing " + "Intent.FLAG_ACTIVITY_NEW_TASK for: " + mIntent);        mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;        mNewTaskInfo = mSourceRecord.info;        // It is not guaranteed that the source record will have a task associated with it. For,        // example, if this method is being called for processing a pending activity launch, it        // is possible that the activity has been removed from the task after the launch was        // enqueued.        final TaskRecord sourceTask = mSourceRecord.getTask();        mNewTaskIntent = sourceTask != null ? sourceTask.intent : null;    }    mSourceRecord = null;    mSourceStack = null;}</code></pre><h4 id="ActivityStarter-getReusableIntentActivity"><a href="#ActivityStarter-getReusableIntentActivity" class="headerlink" title="ActivityStarter.getReusableIntentActivity"></a>ActivityStarter.getReusableIntentActivity</h4><p>上面执行结束会执行下面方法：</p><pre class=" language-lang-java"><code class="language-lang-java">ActivityRecord reusedActivity = getReusableIntentActivity();</code></pre><p>这个方法就要检查是否有可以复用的Task或者Activity了。 </p><pre class=" language-lang-java"><code class="language-lang-java">/**     * Decide whether the new activity should be inserted into an existing task. Returns null     * if not or an ActivityRecord with the task into which the new activity should be added.     */private ActivityRecord getReusableIntentActivity() {    // We may want to try to place the new activity in to an existing task.  We always    // do this if the target activity is singleTask or singleInstance; we will also do    // this if NEW_TASK has been requested, and there is not an additional qualifier telling    // us to still place it in a new task: multi task, always doc mode, or being asked to    // launch this as a new task behind the current one.    boolean putIntoExistingTask = ((mLaunchFlags & FLAG_ACTIVITY_NEW_TASK) != 0 &&                                   (mLaunchFlags & FLAG_ACTIVITY_MULTIPLE_TASK) == 0)        || mLaunchSingleInstance || mLaunchSingleTask;    // If bring to front is requested, and no result is requested and we have not been given    // an explicit task to launch in to, and we can find a task that was started with this    // same component, then instead of launching bring that one to the front.    putIntoExistingTask &= mInTask == null && mStartActivity.resultTo == null;    ActivityRecord intentActivity = null;    if (mOptions != null && mOptions.getLaunchTaskId() != -1) {        final TaskRecord task = mSupervisor.anyTaskForIdLocked(mOptions.getLaunchTaskId());        intentActivity = task != null ? task.getTopActivity() : null;    } else if (putIntoExistingTask) {        if (mLaunchSingleInstance) {            // There can be one and only one instance of single instance activity in the            // history, and it is always in its own unique task, so we do a special search.            intentActivity = mSupervisor.findActivityLocked(mIntent, mStartActivity.info, false);        } else if ((mLaunchFlags & FLAG_ACTIVITY_LAUNCH_ADJACENT) != 0) {            // For the launch adjacent case we only want to put the activity in an existing            // task if the activity already exists in the history.            intentActivity = mSupervisor.findActivityLocked(mIntent, mStartActivity.info,                                                            !mLaunchSingleTask);        } else {            // Otherwise find the best task to put the activity in.            intentActivity = mSupervisor.findTaskLocked(mStartActivity, mSourceDisplayId);        }    }    return intentActivity;}</code></pre><p>代码中可以看到，在不同的LaunchMode中会做findActivityLocked查找可复用Task。关于Task这边内容比较多，暂时先不梳理了。</p><p>TBC</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> ActivityManagerService </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Android][Framework]A/B system update</title>
      <link href="/2018/06/01/%5BAndroid%5D%5BFramework%5DAB-system-update/"/>
      <url>/2018/06/01/%5BAndroid%5D%5BFramework%5DAB-system-update/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>A/B系统就是指手机上有A，B两套可用的系统（userdata只有一份）。这两份系统同一时间只运行一个，另外一个作为备份。这两个系统的版本可能一样，也可能不一样。</p><blockquote><p>这里称为一套（slot）系统，是因为Android系统由多个分区组成。对于A/B，分为system_a，vendor_a，boot_a和system_b，vendor_b，boot_b。所以一套就是一组完整的分区。</p></blockquote><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul><li>由于手机上有两套可以正常工作的系统，升级系统时总是存在一个可以运行的系统，减少手机变砖的可能性</li><li>OTA在系统后台进行，所以更新时用户可以正常使用设备，升级完成后只需要重启一次进入新系统即可</li><li>更新后重启系统的时间不会超过常规重启时间（传统OTA需要在recovery中升级，重启过程比较慢）</li><li>如果更新的系统无法启动，设备将重启回到旧系统，然后尝试再次更新</li><li>任何错误（例如 I/O 错误）都只会影响<strong>未使用</strong>的分区组，并且用户可以进行重试。由于 I/O 负载被特意控制在较低水平，以免影响用户体验，因此发生此类错误的可能性也会降低</li><li>更新包可以流式传输到 A/B 设备，因此在安装之前不需要先下载更新包。流式更新意味着用户没有必要在 <code>/data</code> 或 <code>/cache</code> 上留出足够的可用空间来存储更新包</li><li>cache分区不再用于存储 OTA 更新包，因此无需确保缓存分区的大小要足以应对日后的更新</li><li>dm-verity 可保证设备将使用未损坏的启动映像。如果设备因 OTA 错误或 dm-verity 问题而无法启动，则可以重新启动到旧img</li></ul><h2 id="与传统OTA差别"><a href="#与传统OTA差别" class="headerlink" title="与传统OTA差别"></a>与传统OTA差别</h2><ol><li>系统的分区设置 <ul><li>传统方式只有一套分区</li><li><code>A/B</code>系统有两套分区，称为<code>slot A</code>和<code>slot B</code></li></ul></li><li>跟bootloader沟通的方式 <ul><li>传统方式bootloader通过读取<code>misc</code>分区信息来决定是进入Android主系统还是Recovery系统</li><li><code>A/B</code>系统的bootloader通过特定的分区信息来决定从<code>slot A</code>还是<code>slot B</code>启动</li></ul></li><li>系统的编译过程 <ul><li>传统方式在编译时会生成<code>boot.img</code>和<code>recovery.img</code>分别用于Android主系统和Recovery系统的ramdisk</li><li><code>A/B</code>系统只有<code>boot.img</code>，而不再生成单独的<code>recovery.img</code></li></ul></li><li>OTA更新包的生成方式 <ul><li><code>A/B</code>系统生成OTA包的工具和命令跟传统方式一样，但是生成内容的格式不一样了</li></ul></li></ol><p>分区具体差别：</p><p>传统分区</p><ul><li><p>bootloader</p><p>存放用于引导linux的bootloader</p></li><li><p>boot</p><p>存放Android主系统linux kernel文件和用于挂载system和其他分区的ramdisk</p></li><li><p>system</p><p>Android 主系统分区，包括Android 系统App和库文件</p></li><li><p>vendor</p><p>Android主系统分区，主要是包含开发厂商定制的一些应用和库文件。tremble了解一下</p></li><li><p>userdata</p><p>用户数据分区，存放用户数据，包括用户安装的App和使用时生成的数据</p></li><li><p>cache</p><p>临时数据分区，通常存放OTA升级包</p></li><li><p>recovery</p><p>存放recovery系统的linux kernel文件和ramdisk</p></li><li><p>misc</p><p>存放Android主系统和Recovery系统跟bootloader通信的数据</p></li></ul><p>A/B system分区</p><ul><li><p>bootloader</p><p>存放用于引导linux的bootloader</p></li><li><p>boot_a和boot_b</p><p>分别用于存放两套系统各自的linux kernel文件和用于挂载system和其他分区的ramdisk</p></li><li><p>system_a和system_b</p><p>Android主系统分区，分别用于存放两套系统各自的系统App和库文件</p></li><li><p>vendor_a和vendor_b</p><p>Android主系统分区，分别用于存放两套系统各自开发厂商定制的一些应用和库文件，很多时候开发厂商也直接将这个分区的内容直接放入system分区</p></li><li><p>userdata</p><p>用户数据分区，存放用户数据，包括用户安装的App和使用时生成的数据</p></li><li><p>misc或其他名字分区</p><p>存放Android主系统和Recovery系统跟bootloader通信的数据，由于存放方式和分区名字没有强制要求，所以部分实现上保留了<code>misc</code>分区（代码中可见<code>Brillo</code>和<code>Intel</code>的平台），另外部分实现采用其他分区存放数据（<code>Broadcom</code>机顶盒平台采用名为<code>eio</code>的分区）。</p></li></ul><p>区别：</p><ol><li>boot， system， vendor变成两套分区，slot A和slot B</li><li>不再需要cache和recovery分区</li><li>misc分区不是必须的</li></ol><h2 id="更新流程"><a href="#更新流程" class="headerlink" title="更新流程"></a>更新流程</h2><p>可以参考代码 <a href="https://source.asrmicro.com:8443/adroid8.1/xref/hardware/libhardware/include/hardware/boot_control.h" target="_blank" rel="noopener">boot_control.h</a></p><ol><li>通过 <code>markBootSuccessful()</code> 将当前slot（或“源slot”）标记为成功（如果尚未标记）</li><li>调用函数 <code>setSlotAsUnbootable()</code>，将未使用的slot（或“目标slot”）标记为不可启动。当前slot始终会在更新开始时被标记为成功，以防止引导加载程序回退到未使用的slot（该slot中很快将会有无效数据）。如果系统已做好准备，可以开始应用更新，那么即使其他主要组件出现损坏（例如界面陷入崩溃循环），当前slot也会被标记为成功，因为可以通过推送新软件来解决这些问题<ul><li>元数据。元数据在更新有效负载中所占的比重相对较小，其中包含一系列用于在目标slot上生成和验证新版本的操作。例如，某项操作可能会解压缩特定 Blob 并将其写入到目标分区中的特定块，或者从源分区读取数据、应用二进制补丁程序，然后写入到目标分区中的特定块</li><li>额外数据。与操作相关的额外数据在更新有效负载中占据了大部分比重，其中包含这些示例中的已压缩 Blob 或二进制补丁程序</li></ul></li><li>下载有效负载元数据</li><li>对于元数据中定义的每项操作，都将按顺序发生以下行为：将相关数据（如果有）下载到内存中、应用操作，然后释放关联的内存</li><li>对照预期的哈希重新读取并验证所有分区</li><li>运行安装后步骤（如果有）。如果在执行任何步骤期间出现错误，则更新失败，系统可能会通过其他有效负载重新尝试更新。如果上述所有步骤均已成功完成，则更新成功，系统会执行最后一个步骤</li><li>调用 <code>setActiveBootSlot()</code>，将未使用的槽位标记为活动槽位。将未使用的槽位标记为活动槽位并不意味着它将完成启动。如果引导加载程序（或系统本身）未读取到“成功”状态，则可以将活动槽位切换回来</li><li>安装后步骤（如下所述）包括从“新更新”版本中运行仍在旧版本中运行的程序。如果此步骤已在 OTA 更新包中定义，则为<strong>强制性</strong>步骤，且程序必须返回并显示退出代码 <code>0</code>，否则更新会失败</li><li>在系统足够深入地成功启动到新槽位并完成重新启动后检查之后，系统会调用 <code>markBootSuccessful()</code>，将现在的当前槽位（原“目标槽位”）标记为成功</li></ol><p>用具体的示例介绍流程：</p><p><img src="https://github.com/guyongqiangx/blog/blob/dev/ab-ota/images/ab-system-example-scenarios.png?raw=true" alt></p><p>如图，每一个slot都有3个属性：</p><ul><li><p>active</p><p>系统活动分区标识。同时只有一个slot是active状态，启动时就会启动标识为此的slot</p></li><li><p>bootable</p><p>分区可启动标识。有此标识说明该分区包含一个完整可启动的系统</p></li><li><p>successful</p><p>分区运行成功标识。说明该分区在上次或者当前启动可以正常运行</p></li></ul><p>图中4个场景如下</p><ol><li><p>普通场景（<code>Normal cases</code>）</p><p>最常见的情形，例如设备出厂时，A分区和B分区都可以成功启动并正确运行，所以两个分区都设置为<code>bootable</code>和<code>successful</code>，但由于是从B分区启动，所以只有B分区设置为<code>active</code>。</p></li><li><p>升级中（<code>Update in progress</code>）</p><p>B分区检测到升级数据，在A分区进行升级，此时将A分区标识为<code>unbootable</code>，另外清除<code>successful</code>标识；B分区仍然为<code>active</code>，<code>bootable</code>和<code>successful</code>。</p></li><li><p>更新完成，等待重启（<code>Update applied, reboot pending</code>）</p><p>B分区将A分区成功更新后，将A分区标识为<code>bootable</code>。另外，由于重启后需要从A分区启动，所以也需要将A分区设置为<code>active</code>，但是由于还没有验证过A分区是否能成功运行，所以不设置<code>successful</code>；B分区的状态变为<code>bootable</code>和<code>successful</code>，但没有<code>active</code>。</p></li><li><p>从新系统成功启动（<code>System rebooted into new update</code>）</p><p>设备重启后，<code>bootloader</code>检测到A分区为<code>active</code>，所以加载A分区系统。进入A系统后如果能正确运行，需要将A分区标识为<code>successful</code>。对比第1个普通场景，A和B系统都设置为<code>bootable</code>和<code>successful</code>，但<code>active</code>从B分区切换到A分区。至此，B分区成功更新并切换到A分区，设备重新进入普通场景。</p></li></ol><h2 id="分区烧写"><a href="#分区烧写" class="headerlink" title="分区烧写"></a>分区烧写</h2><p>首先A/B系统和传统OTA系统只能存在一个，在编译时选择。烧写A/B系统也和烧正常系统一样，指定ab分区即可。</p><pre class=" language-lang-bash"><code class="language-lang-bash">target reported max download size of 536870912 byteserasing 'system_a'...OKAY [  0.023s]sending sparse 'system_a' 1/7 (516186 KB)...OKAY [ 17.114s]writing 'system_a' 1/7...target reported max download size of 536870912 bytessending sparse 'system_b' 1/7 (516186 KB)...OKAY [ 16.368s]writing 'system_b' 1/7...</code></pre><h2 id="Java接口使用方法"><a href="#Java接口使用方法" class="headerlink" title="Java接口使用方法"></a>Java接口使用方法</h2><p>Android提供了Java层的接口，<a href="http://androidxref.com/8.0.0_r4/xref/frameworks/base/core/java/android/os/UpdateEngine.java" target="_blank" rel="noopener">UpdateEngine.java</a></p><p>接口很好用</p><ol><li>首先创建一个UpdateEngine的实例</li><li>实现 <a href="http://androidxref.com/8.0.0_r4/xref/frameworks/base/core/java/android/os/UpdateEngineCallback.java" target="_blank" rel="noopener">UpdateEngineCallback</a> 回调接口</li><li>调用bind方法绑定Callback</li><li>调用applyPayload方法执行更新</li></ol><pre class=" language-lang-java"><code class="language-lang-java">@SystemApipublic void applyPayload(String url, long offset, long size, String[] headerKeyValuePairs) {    try {        mUpdateEngine.applyPayload(url, offset, size, headerKeyValuePairs);    } catch (RemoteException e) {        throw e.rethrowFromSystemServer();    }}</code></pre><p>这个方法是@SystemApi，调用它有两个方法：</p><ul><li>把APK放入源码环境，写Makefile进行编译</li><li>独立APK，把系统framework.jar作为lib导入APK。（也可以只把UpdateEngine相关类打包编译）</li></ul><p>关于参数，第一个是差分包（zip包）的路径。第四个是差分包内部的一个文件，这个文件由做包工具生成，一般会保存为一个payload_properties.txt文件，文件大概内容如下：</p><pre class=" language-lang-txt"><code class="language-lang-txt">FILE_HASH=lURPCIkIAjtMOyB/EjQcl8zDzqtD6Ta3tJef6G/+z2k=FILE_SIZE=871903868METADATA_HASH=tBvj43QOB0Jn++JojcpVdbRLz0qdAuL+uTkSy7hokaw=METADATA_SIZE=70604</code></pre><p>我们要做的就是把文件内容读出来，存在数组里作为第四个参数，形式如下。</p><pre class=" language-lang-java"><code class="language-lang-java">String[] pairs = {    "FILE_HASH=lURPCIkIAjtMOyB/EjQcl8zDzqtD6Ta3tJef6G/+z2k=",    "FILE_SIZE=871903868",    "METADATA_HASH=tBvj43QOB0Jn++JojcpVdbRLz0qdAuL+uTkSy7hokaw=",    "METADATA_SIZE=70604"};</code></pre><p>然后贴一个我用的处理方法：</p><pre class=" language-lang-java"><code class="language-lang-java">private String[] readHeaderKeyValuesFromZipFile(String file) {    String[] values = new String[4];    try {        ZipFile zf = new ZipFile(file);        InputStream in = new BufferedInputStream(new FileInputStream(file));        ZipInputStream zin = new ZipInputStream(in);        ZipEntry ze;        while ((ze = zin.getNextEntry()) != null) {            if (ze.isDirectory()) {                //Do nothing            } else {                if (ze.getName().contains("payload_properties.txt")) {                    BufferedReader br = new BufferedReader(                        new InputStreamReader(zf.getInputStream(ze)));                    String line;                    int index = 0;                    while ((line = br.readLine()) != null) {                        values[index] = line;                        index++;                    }                    br.close();                }            }        }        zin.closeEntry();    } catch (IOException e) {        e.printStackTrace();    }    return values;}</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://source.android.com/devices/tech/ota/ab/ab_implement" target="_blank" rel="noopener">https://source.android.com/devices/tech/ota/ab/ab_implement</a></p><p><a href="https://blog.csdn.net/guyongqiangx/article/details/71334889" target="_blank" rel="noopener">https://blog.csdn.net/guyongqiangx/article/details/71334889</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> OTA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Android][Framework]ActivityThread</title>
      <link href="/2018/05/17/%5BAndroid%5D%5BFramework%5DActivityThread/"/>
      <url>/2018/05/17/%5BAndroid%5D%5BFramework%5DActivityThread/</url>
      
        <content type="html"><![CDATA[<p>前面介绍Handler机制的时候，遗留了一个问题：</p><p>创建ActivityThread的时候为主线程加入了Main Looper，那么主线程是怎么创建的呢？</p><h2 id="ActivityThread启动"><a href="#ActivityThread启动" class="headerlink" title="ActivityThread启动"></a>ActivityThread启动</h2><p>之前在介绍SystemServer启动的时候，在<a href="http://wossoneri.github.io/2018/03/25/[Android][Framework]start-of-SystemServer/#SystemServer-createSystemContext">createSystemContext</a>方法内做了如下操作：</p><pre class=" language-lang-java"><code class="language-lang-java">private void createSystemContext() {      // 创建系统上下文并设置主题    ActivityThread activityThread = ActivityThread.systemMain();    mSystemContext = activityThread.getSystemContext();    mSystemContext.setTheme(DEFAULT_SYSTEM_THEME);    final Context systemUiContext = activityThread.getSystemUiContext();    systemUiContext.setTheme(DEFAULT_SYSTEM_THEME);}</code></pre><p>然后跟一下systemMain方法</p><pre class=" language-lang-java"><code class="language-lang-java">    public static ActivityThread systemMain() {        // The system process on low-memory devices do not get to use hardware        // accelerated drawing, since this can add too much overhead to the        // process.        if (!ActivityManager.isHighEndGfx()) {            ThreadedRenderer.disable(true);        } else {            ThreadedRenderer.enableForegroundTrimming();        }        ActivityThread thread = new ActivityThread();        thread.attach(true);        return thread;    }    ActivityThread() {        mResourcesManager = ResourcesManager.getInstance();    }</code></pre><p>所以这里并不是ActivityThread的执行入口。那么哪里才是入口呢？</p><p>回想主线程添加Looper的地方，对， <code>main</code> 方法才是真正的入口。那么 <code>main</code> 方法是怎么调用的呢？</p><p>通过搜索AOSP，发现在ActivityManagerService的<a href="http://androidxref.com/8.0.0_r4/xref/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java#3914" target="_blank" rel="noopener">startProcessLocked</a>方法内出现了相关代码：</p><pre class=" language-lang-java"><code class="language-lang-java">            // Start the process.  It will either succeed and return a result containing            // the PID of the new process, or else throw a RuntimeException.            boolean isActivityProcess = (entryPoint == null);            if (entryPoint == null) entryPoint = "android.app.ActivityThread";            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "Start proc: " +                    app.processName);            checkTime(startTime, "startProcess: asking zygote to start proc");            ProcessStartResult startResult;            if (hostingType.equals("webview_service")) {                startResult = startWebView(entryPoint,                        app.processName, uid, uid, gids, debugFlags, mountExternal,                        app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,                        app.info.dataDir, null, entryPointArgs);            } else {                startResult = Process.start(entryPoint,                        app.processName, uid, uid, gids, debugFlags, mountExternal,                        app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,                        app.info.dataDir, invokeWith, entryPointArgs);            }</code></pre><p>最终调用了 <code>Process.start(android.app.ActivityThread)</code> 方法，而后通过 <code>socket</code> 通信告知 <code>Zygote进程fork子进程</code> ，即app进程。进程创建后将 <code>ActivityThread</code> 加载进去，执行 <code>ActivityThread.main()</code> 方法。</p><h2 id="ActivityThread执行"><a href="#ActivityThread执行" class="headerlink" title="ActivityThread执行"></a>ActivityThread执行</h2><pre class=" language-lang-java"><code class="language-lang-java">public static void main(String[] args) {    ...    Looper.prepareMainLooper();    ActivityThread thread = new ActivityThread();    thread.attach(false);    if (sMainThreadHandler == null) {        sMainThreadHandler = thread.getHandler();    }    ...    Looper.loop();    throw new RuntimeException("Main thread loop unexpectedly exited");}final Handler getHandler() {  return mH;}</code></pre><p>main方法主要创建Handler以及looper，另一件事就是调用attach(false)方法</p><p>这个attach做了什么呢？</p><pre class=" language-lang-java"><code class="language-lang-java">final ApplicationThread mAppThread = new ApplicationThread();private void attach(boolean system) {    sCurrentActivityThread = this; // 对自己的引用    mSystemThread = system; // 传入的bool参数，这里是false    if (!system) {        ViewRootImpl.addFirstDrawHandler(new Runnable() {            @Override            public void run() {                ensureJitEnabled(); // 虚拟机JIT开启            }        });        android.ddm.DdmHandleAppName.setAppName("<pre-initialized>",                                                UserHandle.myUserId());        RuntimeInit.setApplicationObject(mAppThread.asBinder());        // 获取IActivityManager实例        final IActivityManager mgr = ActivityManager.getService();        try {            mgr.attachApplication(mAppThread);        } catch (RemoteException ex) {            throw ex.rethrowFromSystemServer();        }        // Watch for getting close to heap limit.        ...    } else {        ...    }    ...}</code></pre><p>attach里面得到一个IActivityManager实例。</p><p>这个类从命名看就知道是个AIDL接口，通过ActivityManager源码可知</p><pre class=" language-lang-java"><code class="language-lang-java">public static IActivityManager getService() {    return IActivityManagerSingleton.get();}private static final Singleton<IActivityManager> IActivityManagerSingleton =        new Singleton<IActivityManager>() {            @Override            protected IActivityManager create() {                  // 通过activity service拿到IBinder实例                final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);                final IActivityManager am = IActivityManager.Stub.asInterface(b);                return am;            }        };</code></pre><p>这样看</p><pre class=" language-lang-java"><code class="language-lang-java">final IActivityManager mgr = ActivityManager.getService();// 就相当于final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);final IActivityManager mgr = IActivityManager.Stub.asInterface(b);</code></pre><p>IBinder就要负责和AMS通信。</p><p>attach方法的下一步是</p><pre class=" language-lang-java"><code class="language-lang-java">mgr.attachApplication(mAppThread);</code></pre><p>该方法在IActivityManager声明，在ActivityManagerService实现</p><pre class=" language-lang-java"><code class="language-lang-java">    @Override    public final void attachApplication(IApplicationThread thread) {        synchronized (this) {            int callingPid = Binder.getCallingPid();            final long origId = Binder.clearCallingIdentity();            attachApplicationLocked(thread, callingPid);            Binder.restoreCallingIdentity(origId);        }    }private final boolean attachApplicationLocked(IApplicationThread thread,            int pid) {          // Find the application record that is being attached...           ...        // 这里代码很多，关键在这一步        if (app.instr != null) {                thread.bindApplication(processName, appInfo, providers,                        app.instr.mClass,                        profilerInfo, app.instr.mArguments,                        app.instr.mWatcher,                        app.instr.mUiAutomationConnection, testMode,                        mBinderTransactionTrackingEnabled, enableTrackAllocation,                        isRestrictedBackupMode || !normalMode, app.persistent,                        new Configuration(getGlobalConfiguration()), app.compat,                        getCommonServicesLocked(app.isolated),                        mCoreSettingsObserver.getCoreSettingsLocked(),                        buildSerial);            }        ...    }</code></pre><p>这个IApplicationThread是ActivityThread的内部私有类，其bindApplication方法如下：</p><pre class=" language-lang-java"><code class="language-lang-java">private class ApplicationThread extends IApplicationThread.Stub {        public final void bindApplication(String processName, ApplicationInfo appInfo,                List<ProviderInfo> providers, ComponentName instrumentationName,                ProfilerInfo profilerInfo, Bundle instrumentationArgs,                IInstrumentationWatcher instrumentationWatcher,                IUiAutomationConnection instrumentationUiConnection, int debugMode,                boolean enableBinderTracking, boolean trackAllocation,                boolean isRestrictedBackupMode, boolean persistent, Configuration config,                CompatibilityInfo compatInfo, Map services, Bundle coreSettings,                String buildSerial) {            if (services != null) {                // Setup the service cache in the ServiceManager                ServiceManager.initServiceCache(services);            }            setCoreSettings(coreSettings);            AppBindData data = new AppBindData();            data.processName = processName;            ...            sendMessage(H.BIND_APPLICATION, data);        }}</code></pre><p>最后调用sendMessage。这个方法有多个重载方法，最终会调用到一个重载：</p><pre class=" language-lang-java"><code class="language-lang-java">    private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) {        if (DEBUG_MESSAGES) Slog.v(            TAG, "SCHEDULE " + what + " " + mH.codeToString(what)            + ": " + arg1 + " / " + obj);        Message msg = Message.obtain();        msg.what = what;        msg.obj = obj;        msg.arg1 = arg1;        msg.arg2 = arg2;        if (async) {            msg.setAsynchronous(true);        }        mH.sendMessage(msg);    }</code></pre><p>看到熟悉的mH心里就应该会舒口气，因为调用马上结束了。</p><p>在HandleMessage的地方，处理<code>H.BIND_APPLICATION</code>：</p><pre class=" language-lang-java"><code class="language-lang-java">case BIND_APPLICATION:    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "bindApplication");    AppBindData data = (AppBindData)msg.obj;    handleBindApplication(data);    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);    break;private void handleBindApplication(AppBindData data) {    ...            // Continue loading instrumentation.                  // 创建instrumentation对象                final ClassLoader cl = instrContext.getClassLoader();                mInstrumentation = (Instrumentation)                    cl.loadClass(data.instrumentationName.getClassName()).newInstance();            final ComponentName component = new ComponentName(ii.packageName, ii.name);            mInstrumentation.init(this, instrContext, appContext, component,                    data.instrumentationWatcher, data.instrumentationUiAutomationConnection);            }            // If the app is being launched for full backup or restore, bring it up in            // a restricted environment with the base application class.            //在这里创建了上层开发者的代码中所涉及的Applicaiton类的对象            Application app = data.info.makeApplication(data.restrictedBackupMode, null);            mInitialApplication = app;            // Do this after providers, since instrumentation tests generally start their            // test thread at this point, and we don't want that racing.                mInstrumentation.onCreate(data.instrumentationArgs);                  //调Application的生命周期函数 onCreate()                mInstrumentation.callApplicationOnCreate(app);    ...}</code></pre><p>上面处理做了几个比较关键的事情：</p><ol><li>获取instrumentation实例</li><li>获取Application对象</li><li>instrumentation调用onCreate</li></ol><p>下面具体看这几个东西。</p><h3 id="Instrumentation"><a href="#Instrumentation" class="headerlink" title="Instrumentation"></a>Instrumentation</h3><p>Class前的注释为：</p><blockquote><p>用于实现应用程序检测代码的基类。 当开启Instrumentation运行时，该类将在任何应用程序代码之前实例化，从而允许您监视系统与应用程序之间的所有交互。</p></blockquote><p>也就是说，只要开启instrumentation，就可以通过它来监视系统和Application之间的交互调用。</p><p>查看源码方法列表，的确看到很多和Activity相关的方法。详细的不在这里讲了。</p><p>看下实例化方法：</p><pre class=" language-lang-java"><code class="language-lang-java">mInstrumentation = (Instrumentation)                    cl.loadClass(data.instrumentationName.getClassName()).newInstance();</code></pre><p>通过反射，从 <code>data.instrumentationName.getClassName()</code> 拿到instrumentation的name实例化。</p><p>拿到实例，对其进行init初始化：</p><pre class=" language-lang-java"><code class="language-lang-java">mInstrumentation.init(this, instrContext, appContext, component,                    data.instrumentationWatcher, data.instrumentationUiAutomationConnection);    /*package*/ final void init(ActivityThread thread,            Context instrContext, Context appContext, ComponentName component,            IInstrumentationWatcher watcher, IUiAutomationConnection uiAutomationConnection) {        mThread = thread;        mMessageQueue = mThread.getLooper().myQueue();        mInstrContext = instrContext;        mAppContext = appContext;        mComponent = component;        mWatcher = watcher;        mUiAutomationConnection = uiAutomationConnection;    }</code></pre><p>instrumentation内部有一个mThread对象，它由init方法初始化，这里init时就把自身（即主线程）传递给instrumentation。</p><p>下一步是调用onCreate方法</p><pre class=" language-lang-java"><code class="language-lang-java">mInstrumentation.onCreate(data.instrumentationArgs);    /**     * Called when the instrumentation is starting, before any application code     * has been loaded.  Usually this will be implemented to simply call     * {@link #start} to begin the instrumentation thread, which will then     * continue execution in {@link #onStart}.     *     * <p>If you do not need your own thread -- that is you are writing your     * instrumentation to be completely asynchronous (returning to the event     * loop so that the application can run), you can simply begin your     * instrumentation here, for example call {@link Context#startActivity} to     * begin the appropriate first activity of the application.     *     * @param arguments Any additional arguments that were supplied when the     *                  instrumentation was started.     */    public void onCreate(Bundle arguments) {    }</code></pre><p>onCreate其实是个空方法，可以阅读注释了解详情。这之后调用一个最关键的方法：</p><pre class=" language-lang-java"><code class="language-lang-java">mInstrumentation.callApplicationOnCreate(app);    // 执行application.onCreate方法    // 这个方法会在onCreate方法（上面的空方法）后立即调用。instrumentation测试程序会在那个onCreate中创建测试线程，所以要注意可能的风险    public void callApplicationOnCreate(Application app) {        app.onCreate();    }    // Application.java    // application启动时，在任何activity,service,receiver对象创建之前调用，其实现要越快越好，比如使用懒加载。否则会影响在进程内启动第一个Activity，Service或receiver的性能。重写该方法时需要调用super.onCreate()    @CallSuper    public void onCreate() {    }</code></pre><p>所以最后就是调用到了Application的onCreate方法。</p><p>说道这个方法，提个题外话，自己在写App的时候，有时候会想用到一些App全局的变量，比较常用的就是自己继承Application实现一些方法，比如：</p><pre class=" language-lang-java"><code class="language-lang-java">public class MainApplication extends Application {    public static Context sAppContext;    @Override    public void onCreate() {        super.onCreate();        sAppContext = this;    }}// 把manifest的application名称改掉<application        android:name=".MainApplication"          .../>// 使用Context context = MainApplication.sAppContext;</code></pre><p>看了上面的过程就会理解为什么启动App后这个onCreate会最先调用。</p><h3 id="LoadedApk"><a href="#LoadedApk" class="headerlink" title="LoadedApk"></a>LoadedApk</h3><p>下面在了解一下上面调用时传递的app参数是怎么来的。</p><pre class=" language-lang-java"><code class="language-lang-java">// If the app is being launched for full backup or restore, bring it up in// a restricted environment with the base application class.Application app = data.info.makeApplication(data.restrictedBackupMode, null);</code></pre><p>这个data就是封装在message里的数据，其具体数据来自AMS。但是info这个字段并不在AMS的数据中，查看data的类型，发现：</p><pre class=" language-lang-java"><code class="language-lang-java">    static final class AppBindData {        LoadedApk info;        String processName;        ApplicationInfo appInfo;        List<ProviderInfo> providers;        ComponentName instrumentationName;        Bundle instrumentationArgs;        IInstrumentationWatcher instrumentationWatcher;        IUiAutomationConnection instrumentationUiAutomationConnection;        int debugMode;        boolean enableBinderTracking;        boolean trackAllocation;        boolean restrictedBackupMode;        boolean persistent;        Configuration config;        CompatibilityInfo compatInfo;        String buildSerial;        /** Initial values for {@link Profiler}. */        ProfilerInfo initProfilerInfo;        public String toString() {            return "AppBindData{appInfo=" + appInfo + "}";        }    }</code></pre><p>这个AppBindData也是ActivityThread的内部类，info字段是LoadedApk类型。查找info的赋值，就发生在handleBindApplication方法内，在拿到instrumentation实例前完成：</p><pre class=" language-lang-java"><code class="language-lang-java">data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);</code></pre><p>这中间的实现就不分析了，看一下LoadedApk是怎么拿到application对象的</p><pre class=" language-lang-java"><code class="language-lang-java">// frameworks/base/core/java/android/app/LoadedApk.java// Local state maintained about a currently loaded .apk. 如其名，就是当前加载的apk    public Application makeApplication(boolean forceDefaultAppClass,            Instrumentation instrumentation) {        if (mApplication != null) {            return mApplication;        }        Application app = null;        String appClass = mApplicationInfo.className;        if (forceDefaultAppClass || (appClass == null)) {            appClass = "android.app.Application";        }        try {            java.lang.ClassLoader cl = getClassLoader();            if (!mPackageName.equals("android")) {                initializeJavaContextClassLoader();            }            ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);              // application还是从主线程里的instrumentation中得到的            app = mActivityThread.mInstrumentation.newApplication(                    cl, appClass, appContext);            appContext.setOuterContext(app);        } catch (Exception e) {        }        mActivityThread.mAllApplications.add(app);        mApplication = app;        if (instrumentation != null) {            try {                instrumentation.callApplicationOnCreate(app);            } catch (Exception e) {            }        }        // Rewrite the R 'constants' for all library apks.        ...        return app;    }</code></pre><p>emmm….这个Application还是从主线程的instrumentation创造，再由instrumentation做onCreate…</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>再整理一遍ActivityThread的main函数执行：</p><ul><li>初始化main Looper</li><li>实例化ActivityThread</li><li>初始化H Handler</li><li>调用attach(false)方法<ul><li>得到IActivityManager，拿到AMS的binder</li><li>调用AMS的attachApplication方法，拿到相关参数</li><li>通过ApplicationThread实例作为参数，调用bindApplication方法，封装参数到data</li><li>H handler发送H.BIND_APPLICATION消息，把data发送到ActivityThread，从Binder切换到主线程</li><li>H handler在ActivityThread处理data</li><li>从data.info拿到application对象，通过instrumentation调用callApplicationOnCreate(app)调用到onCreate完成application的创建。</li></ul></li><li>Looper进入循环等待消息</li></ul><p>其实，主线程的启动和Activity的启动时息息相关的，后面就在此基础上跟踪一下Application以及App的main Activity是如何启动的。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> ActivityThread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Android] Handler消息传递机制</title>
      <link href="/2018/05/10/%5BAndroid%5Dhandler-message-delivery/"/>
      <url>/2018/05/10/%5BAndroid%5Dhandler-message-delivery/</url>
      
        <content type="html"><![CDATA[<p>今天看文章的时候看到这么一句话：</p><blockquote><p>UI线程是从ActivityThread运行的，在该类的main()方法中已经使用了Looper.prepareMainLooper()为该线程添加了Looper对象，已经为该线程创建了消息队列，是自带秘书光环的。因此，我们才可以在Activity中去定义Handler对象，因为创建Handler对象时其线程必须已经创建了消息队列，装卸工得配运输带要不然没法干活。而普通的Thread则没有默认创建消息队列，所以不能直接在Thread中直接定义Handler，这个就是我们不懂程序运行原理导致的困惑。</p></blockquote><p>其实这块知识我都看过，但是读完这段话有些地方还是让我回想了一小会儿。想完就觉着既然回想了一遍，不如整理一篇博客出来好了。</p><h2 id="经验之谈"><a href="#经验之谈" class="headerlink" title="经验之谈"></a>经验之谈</h2><p>在Android中经常会创建线程做一些耗时的事情，结束后会更新UI线程。一般代码这样写：</p><pre class=" language-lang-java"><code class="language-lang-java">    private Handler uiHandler = new Handler() {        @Override        public void handleMessage(Message msg) {            switch (msg.what) {                case 1:                    break;            }        }    };        new Thread(new Runnable() {            @Override            public void run() {                Message msg = uiHandler.obtainMessage();                msg.what = 1;                uiHandler.sendMessage(msg);            }        }).start();</code></pre><p>即在主线程中创建Handler接收处理消息，在子线程用handler发送消息。</p><p>上面的Handler是在主线程中创建的，当我们在子线程创建一个Handler时，运行程序会报错：</p><pre class=" language-lang-java"><code class="language-lang-java">java.lang.RuntimeException: Can't create handler inside thread that has not called Looper.prepare()  at android.os.Handler.<init>(Handler.java:203)    at android.os.Handler.<init>(Handler.java:117)</code></pre><p>这是因为主线程是自带Looper的，而子线程需要我们自己添加Looper。</p><pre class=" language-lang-java"><code class="language-lang-java">class LooperThread extends Thread {    public Handler mHandler;    public void run() {          Looper.prepare();        mHandler = new Handler() {            public void handleMessage(Message msg) {            // process incoming messages here            }        };        Looper.loop();          // loop就进入死循环，loop之后的代码不会执行，除非loop结束。    }}</code></pre><p>看到这里，虽然说代码会写，功能会实现，但是很多问题却无法准确回答。</p><p>所以后面就跟着源码，把这些关系理清楚。</p><h2 id="android-os-Message"><a href="#android-os-Message" class="headerlink" title="android.os.Message"></a>android.os.Message</h2><p>一个包含描述信息和任意数据的可以发送给Handler的消息对象。它包含两个int域和一个object域供直接使用（省去alloc操作）。</p><p>它虽然有构造函数，但还是推荐使用Message.obtain()获得Message实例，或者使用Handler.obtainMessage()方法从消息回收池获取消息对象。</p><pre class=" language-lang-java"><code class="language-lang-java">public final Message obtainMessage(){        return Message.obtain(this);}</code></pre><p>Handler调用的方法就是Message自己的obtain。Message源码如下：</p><pre class=" language-lang-java"><code class="language-lang-java">public final class Message implements Parcelable {    // 标识一个message。因为每个Handler都有自己的命名空间，故不必担心这个值和其他handler冲突    public int what;   // 如果只要存储int数据，用arg1和arg2即可，不需要构建Bundle对象做setData    public int arg1;    public int arg2;    // 任意的一个对象。当用Messenger在进程间发消息时，如果它包含一个framework类的Parcelable对象，则它是非空的。对于其他数据使用Bundle.SetData即可。    public Object obj;    // 负责回复消息的Messenger，可选。使用取决于发送者和接收者    public Messenger replyTo;    // 消息uid标识，只在被Messenger传递消息时使用，平时是-1    public int sendingUid = -1;    // 表示message正被使用。    // 该标志在消息入队完成后设置，并在传送后包括到回收之后都保持设置状态。 只有在创建或获取新消息时才会清除该标志，因为这是允许应用程序修改消息内容的唯一时间。所以在in use状态下不可以对一个message进行enqueue和recycle操作    /*package*/ static final int FLAG_IN_USE = 1 << 0;    // 标识消息是否是异步的    /*package*/ static final int FLAG_ASYNCHRONOUS = 1 << 1;    // 需要在CopyFrom方法清除的标识，默认是FLAG_IN_USE    /*package*/ static final int FLAGS_TO_CLEAR_ON_COPY_FROM = FLAG_IN_USE;    /*package*/ int flags;    /*package*/ long when;    // 关键数据    /*package*/ Bundle data;      // 发送和处理消息关联的Handler    /*package*/ Handler target;    /*package*/ Runnable callback;    // 有时会用链表关联下一个message    /*package*/ Message next;      // 同步锁使用的对象    private static final Object sPoolSync = new Object();    private static Message sPool;    private static int sPoolSize = 0; //obtain时-1，recycleUnchecked后+1    private static final int MAX_POOL_SIZE = 50;    private static boolean gCheckRecycle = true; // 只在recycle使用    // 从消息回收池返回一个新的message对象    public static Message obtain() {        synchronized (sPoolSync) {            if (sPool != null) {                Message m = sPool;                sPool = m.next;                m.next = null;                m.flags = 0; // clear in-use flag                sPoolSize--;                return m;            }        }        return new Message();    }    // 先obtain一个message，然后从参数message拷贝一份数据    public static Message obtain(Message orig) {        Message m = obtain();         m.what = orig.what;        m.arg1 = orig.arg1;        m.arg2 = orig.arg2;        m.obj = orig.obj;        m.replyTo = orig.replyTo;        m.sendingUid = orig.sendingUid;        if (orig.data != null) {            m.data = new Bundle(orig.data);        }        m.target = orig.target;        m.callback = orig.callback;        return m;    }    // 先obtain一个message，然后设置要传递的handler    public static Message obtain(Handler h) {        Message m = obtain();        m.target = h;        return m;    }    // 下面的不用介绍了，和上面类似。    public static Message obtain(Handler h, Runnable callback) {}    public static Message obtain(Handler h, int what) {}    public static Message obtain(Handler h, int what, Object obj) {}    public static Message obtain(Handler h, int what, int arg1, int arg2) {}    public static Message obtain(Handler h, int what,            int arg1, int arg2, Object obj) {}    /** @hide */    public static void updateCheckRecycle(int targetSdkVersion) {        if (targetSdkVersion < Build.VERSION_CODES.LOLLIPOP) {            gCheckRecycle = false; // 只有版本低于lollipop的在recycle时不会抛出异常信息        }    }    // 返回一个message实例到global pool    // 调用这个方法后就不能再访问该消息了，因为它已经被有效释放。      // 对于正在enqueued或者被delivered到Handler的message是不能调用recycle的。    public void recycle() {        if (isInUse()) {            if (gCheckRecycle) {                throw new IllegalStateException("This message cannot be recycled because it is still in use.");            }            return;        }        recycleUnchecked();    }    // 回收可能正在in-use状态的消息。 在处理队列消息时由MessageQueue和Looper在内部使用。    void recycleUnchecked() {        // 当其保持在recycled object pool时将message标记为in use，并清除其他信息        flags = FLAG_IN_USE;        what = 0;        arg1 = 0;        arg2 = 0;        obj = null;        replyTo = null;        sendingUid = -1;        when = 0;        target = null;        callback = null;        data = null;        synchronized (sPoolSync) {            if (sPoolSize < MAX_POOL_SIZE) {                next = sPool;                sPool = this;                sPoolSize++;            }        }    }    // 浅拷贝    public void copyFrom(Message o) {        this.flags = o.flags & ~FLAGS_TO_CLEAR_ON_COPY_FROM;        // ...省略...    }    // 返回消息目标delivery时间  毫秒    public long getWhen() { return when; }    public void setTarget(Handler target) { this.target = target; }    public Handler getTarget() { return target; }    public Runnable getCallback() { return callback; }    // data为空会创建新的Bundle    public Bundle getData() {        if (data == null) {            data = new Bundle();        }        return data;    }    // data为空就返回空    public Bundle peekData() { return data; }    public void setData(Bundle data) { this.data = data; }    // 把自己发送给目标Handler    public void sendToTarget() { target.sendMessage(this); }    // true则为异步的。意味着他不是Looper synchronization barriers    public boolean isAsynchronous() {        return (flags & FLAG_ASYNCHRONOUS) != 0;    }    // 某些操作（如视图无效）可能会在Looper的消息队列中引入同步障碍，以防止后续消息被传递，直到满足某些条件。    // 在视图无效的情况下，在调用View.invalidate之后发布的消息将通过同步屏障挂起，直到下一帧准备好绘制为止。    // 同步屏障确保在恢复之前完全处理失效请求。    public void setAsynchronous(boolean async) {        if (async) {            flags |= FLAG_ASYNCHRONOUS;        } else {            flags &= ~FLAG_ASYNCHRONOUS;        }    }    /*package*/ boolean isInUse() { return ((flags & FLAG_IN_USE) == FLAG_IN_USE); }    /*package*/ void markInUse() { flags |= FLAG_IN_USE; }  // 剩下的省略</code></pre><blockquote><p> 代码中提到的同步障碍（synchronization barriers）可以参考 <a href="http://wossoneri.github.io/2018/05/08/[Java]CountDownLatch-and-CyclicBarrier/">[Java] CountDownLatch 与 CyclicBarrier</a> 了解一下Barrier。</p></blockquote><p>源码的注释应该很详细了，关键点再整理如下：</p><ul><li>FLAG_IN_USE 标志在消息入队完成后设置，并在消息传送后包括到回收之后都保持设置状态。 </li><li>只有在创建或获取新消息时才会清除FLAG_IN_USE标志，因为这是允许应用程序修改消息内容的唯一时间。</li><li>in use状态下不可以对一个message进行enqueue和recycle操作。</li><li>调用recycle后就不能再访问该消息了，因为它已经被有效释放。</li><li>对于正在enqueued或者被delivered到Handler的message是不能调用recycle的。</li></ul><p>剩下我认为比较重要的是</p><pre class=" language-lang-java"><code class="language-lang-java">    private static int sPoolSize = 0; //obtain时-1，recycleUnchecked后+1</code></pre><p>如同介绍，调用obtain时计数-1，调用recycleUnchecked后计数+1。除此之外，没有其他地方为其赋值。</p><p>所以这两个方法的调用在整个消息机制里起很大的作用。<code>obtain</code> 方法就不说了，获取Message对象用的，<code>recycleUnchecked</code> 方法的调用都在什么地方呢？</p><p>首先在Message自身的<code>recycle</code> 方法内会执行一次。</p><p>然后在源码搜索，找到两个调用的类：MessageQueue和Looper。</p><p>Looper的调用很简单：</p><pre class=" language-lang-java"><code class="language-lang-java">    public static void loop() {        final Looper me = myLooper();        ...        for (;;) {            Message msg = queue.next(); // might block            if (msg == null) {                // No message indicates that the message queue is quitting.                return;            }          ...            msg.recycleUnchecked();        }    }</code></pre><p>就是在loop循环的时候，从消息队列一个个取出Message，处理完的最后调用 msg.recycleUnchecked()。</p><p>所以一个消息在被 Looper 处理时或者移出队列时会被标识为 FLAG_IN_USE，然后会被加入回收的消息链表，这样我们调用 Message.obtain() 方法时就可以从回收的消息池中获取一个旧的消息，从而节约成本。</p><p>MessageQueue的调用可以找到9处，分别在：</p><pre class=" language-lang-java"><code class="language-lang-java">public void removeSyncBarrier(int token){ ... }void removeMessages(Handler h, int what, Object object) { ... }void removeMessages(Handler h, Runnable r, Object object) { ... }void removeCallbacksAndMessages(Handler h, Object object) { ... }private void removeAllMessagesLocked() { ... }private void removeAllFutureMessagesLocked() { ... }</code></pre><p>通过函数名就知道，所有remove消息的操作都会把remove掉的消息recycle。</p><h2 id="android-os-MessageQueue"><a href="#android-os-MessageQueue" class="headerlink" title="android.os.MessageQueue"></a>android.os.MessageQueue</h2><p>MessageQueue是一个低级别的类，它持有一个将由Looper派发的Message列表。Message不是直接添加到MessageQueue的，而是通过与Looper关联的Handler对象的。</p><p>整理下语言就是，MessageQueue存放Message列表，Handler往队列里塞Message，Looper从队列取出Message往外发送。</p><pre class=" language-lang-java"><code class="language-lang-java">public final class MessageQueue {    // 队列是否可以退出    private final boolean mQuitAllowed;    @SuppressWarnings("unused")    private long mPtr; // Native层使用    Message mMessages;    private final ArrayList<IdleHandler> mIdleHandlers = new ArrayList<IdleHandler>();    private SparseArray<FileDescriptorRecord> mFileDescriptorRecords;    private IdleHandler[] mPendingIdleHandlers;    private boolean mQuitting;    // next()阻塞提示    private boolean mBlocked;    // 下一个屏障的token.    // 屏障由具有空目标的消息指定，其arg1字段携带该token。    private int mNextBarrierToken;</code></pre><p>当前线程的MessageQueue对象是通过Looper.myQueue()获取的（这个线程必须启动Looper，才有MessageQueue）：</p><pre class=" language-lang-java"><code class="language-lang-java">    public static @NonNull MessageQueue myQueue() {        return myLooper().mQueue;    }    private Looper(boolean quitAllowed) {        mQueue = new MessageQueue(quitAllowed);        mThread = Thread.currentThread();    }   public static void prepare() {        prepare(true);    }    private static void prepare(boolean quitAllowed) {        if (sThreadLocal.get() != null) {            throw new RuntimeException("Only one Looper may be created per thread");        }        sThreadLocal.set(new Looper(quitAllowed));    }</code></pre><pre class=" language-lang-java"><code class="language-lang-java">    MessageQueue(boolean quitAllowed) {        mQuitAllowed = quitAllowed;        mPtr = nativeInit();    }</code></pre><p>以上是MessageQueue的构造过程。在Looper一开始的prepare阶段创建new Looper（true），然后拿到new MessageQueue（true）。</p><p>队列的功能是按顺序排列消息，实行FIFO原则。所以看一下这个In和Out。</p><p>入队方法：</p><pre class=" language-lang-java"><code class="language-lang-java">boolean enqueueMessage(Message msg, long when) {          // 如开头介绍，消息是通过Handler塞进消息队列的，所以先判断消息的Handler是否为空        if (msg.target == null) {             throw new IllegalArgumentException("Message must have a target.");        }          // 回去再看Message的FLAG_IN_USE注释，明确说明inUse状态下不可以入队        if (msg.isInUse()) {            throw new IllegalStateException(msg + " This message is already in use.");        }        synchronized (this) { // 加锁            if (mQuitting) { // 队列已退出                IllegalStateException e = new IllegalStateException(                        msg.target + " sending message to a Handler on a dead thread");                Log.w(TAG, e.getMessage(), e);                msg.recycle();                return false;            }            msg.markInUse(); // 前面异常判断完，可以入队了，标记消息为in use            msg.when = when;            Message p = mMessages;            boolean needWake;            if (p == null || when == 0 || when < p.when) {                // 原来空的链表阻塞消息读取，新消息进入唤醒                msg.next = p;                mMessages = msg;                needWake = mBlocked;            } else {                // 消息插入到队列。通常只有在队列头有屏障且这个消息是异步消息时需要唤醒队列                needWake = mBlocked && p.target == null && msg.isAsynchronous();                Message prev;                for (;;) {                    prev = p;                    p = p.next;                    if (p == null || when < p.when) {                        break;                    }                    if (needWake && p.isAsynchronous()) {                        needWake = false;                    }                }                msg.next = p; // invariant: p == prev.next                prev.next = msg;            }            // We can assume mPtr != 0 because mQuitting is false.            if (needWake) {                nativeWake(mPtr);            }        }        return true;    }</code></pre><p>可以看到，MessageQueue 虽然叫“消息队列”，持有的其实是一个消息链表的节点。插入消息也是以链表插入。</p><p>下面是出队</p><pre class=" language-lang-java"><code class="language-lang-java">    Message next() {        // 如果Message loop退出，直接return        final long ptr = mPtr;        if (ptr == 0) {            return null;        }        int pendingIdleHandlerCount = -1; // -1 only during first iteration        int nextPollTimeoutMillis = 0;        for (;;) {            // 如果有需要过段时间再处理的消息，先调用 Binder 的方法            if (nextPollTimeoutMillis != 0) {                Binder.flushPendingCommands();            }            nativePollOnce(ptr, nextPollTimeoutMillis);            synchronized (this) {                // 找下一个消息  找到就return 消息                final long now = SystemClock.uptimeMillis();                Message prevMsg = null;                Message msg = mMessages; // 链表头                if (msg != null && msg.target == null) {                    // 如果消息没有 target，那它就是一个屏障，需要一直往后遍历找到第一个异步的消息                    do {                        prevMsg = msg;                        msg = msg.next;                    } while (msg != null && !msg.isAsynchronous());                }                if (msg != null) {                    if (now < msg.when) {                        // 如果这个消息还没到处理时间，就设置个时间过段时间再处理                        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);                    } else {                        // 拿到消息                        mBlocked = false;                        if (prevMsg != null) {                            prevMsg.next = msg.next;                        } else {                            mMessages = msg.next;                        }                        msg.next = null;                        if (DEBUG) Log.v(TAG, "Returning message: " + msg);                        msg.markInUse(); // 标记使用                        return msg;                    }                } else {                    // 队列没有消息了                    nextPollTimeoutMillis = -1;                }                // 所有等待的消息都处理完了，处理退出消息                if (mQuitting) {                    dispose();                    return null;                }                // 如果第一次idle, 获取要运行idlers的数量.                // Idle handles仅在队列为空时或队列中的第一条消息（可能是屏障）将在未来处理时才运行。                if (pendingIdleHandlerCount < 0                        && (mMessages == null || now < mMessages.when)) {                    pendingIdleHandlerCount = mIdleHandlers.size();                }                if (pendingIdleHandlerCount <= 0) {                    // No idle handlers to run.  Loop and wait some more.                    mBlocked = true;                    continue;                }                if (mPendingIdleHandlers == null) {                    mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];                }                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);            }            // Run the idle handlers.            // We only ever reach this code block during the first iteration.            for (int i = 0; i < pendingIdleHandlerCount; i++) {                final IdleHandler idler = mPendingIdleHandlers[i];                mPendingIdleHandlers[i] = null; // release the reference to the handler                boolean keep = false;                try {                    keep = idler.queueIdle();                } catch (Throwable t) {                    Log.wtf(TAG, "IdleHandler threw exception", t);                }                if (!keep) {                    synchronized (this) {                        mIdleHandlers.remove(idler);                    }                }            }            // Reset the idle handler count to 0 so we do not run them again.            pendingIdleHandlerCount = 0;            // While calling an idle handler, a new message could have been delivered            // so go back and look again for a pending message without waiting.            nextPollTimeoutMillis = 0;        }    }</code></pre><p>代码中出现很多IdleHandler，其定义如下：</p><pre class=" language-lang-java"><code class="language-lang-java">    // 当线程block等待更多消息时，获得新消息的回调接口    public static interface IdleHandler {        // 在消息队列没有消息并且等待更多消息时调用。        // 返回true表示保持idle handler活跃，false表示将其移除          // 如果队列有消息等待在未来某时间点执行也会调用这个方法。        boolean queueIdle();    }</code></pre><p>当消息队列阻塞时，就会回调到这里。</p><p>这里大概知道MessageQueue是什么就够了。</p><p>前面介绍Message时，提到Looper在Loop时处理完消息会将消息recycle掉，在prepare的时候会创建MessageQueue。而且必须是在线程中加入Looper这个线程才可以拥有MessageQueue。那么下面就看一下Looper。</p><h2 id="android-os-Looper"><a href="#android-os-Looper" class="headerlink" title="android.os.Looper"></a>android.os.Looper</h2><p>Looper是对一个线程运行消息循环的类。一个线程默认是没有消息循环的，如果要创建一个，需要在线程先调用Looper.prepare，然后调用Looper.loop使其处理消息，知道循环结束。</p><p>基本上是和Handler交互处理消息循环。</p><pre class=" language-lang-java"><code class="language-lang-java">public final class Looper {    // 必须调用先prepare()，否则sThreadLocal.get()返回空    static final ThreadLocal<Looper> sThreadLocal = new ThreadLocal<Looper>();    private static Looper sMainLooper;  // guarded by Looper.class    final MessageQueue mQueue;    final Thread mThread;    private Printer mLogging;    private long mTraceTag;    /* If set, the looper will show a warning log if a message dispatch takes longer than time. */    private long mSlowDispatchThresholdMs;</code></pre><p>Looper声明了其管理的消息队列，以及与之绑定的线程。</p><p>在线程里使用Looper的第一步是Looper.prepare()，看一下源码：</p><pre class=" language-lang-java"><code class="language-lang-java">    public static void prepare() {        prepare(true);    }    private static void prepare(boolean quitAllowed) {        if (sThreadLocal.get() != null) {            throw new RuntimeException("Only one Looper may be created per thread");        }        sThreadLocal.set(new Looper(quitAllowed));    }</code></pre><p>这里就解释了必须调用先prepare()，否则sThreadLocal.get()返回空的原因。在prepare的时候会从sThreadLocal判断这个线程是否有Looper，如果没有则创建。</p><blockquote><p>ThreadLocal用于提供线程内部的局部变量，这些变量与它们的正常对象不同，每个线程访问一个单独属于自己的，独立的变量的初始副本。</p></blockquote><p>通过ThreadLocal控制一个线程只有一个Looper。</p><p>Looper里还有一个和prepare相关的方法：</p><pre class=" language-lang-java"><code class="language-lang-java">    // 初始化当前线程为一个Looper，并标记它为一个应用程序的主Looper。应用程序的主Looper是在Android环境中构建的，所以不要自己去调用这个方法    public static void prepareMainLooper() {        prepare(false);        synchronized (Looper.class) {            if (sMainLooper != null) {                throw new IllegalStateException("The main Looper has already been prepared.");            }            sMainLooper = myLooper();        }    }    // 返回应用程序主线程中的主Looper    public static Looper getMainLooper() {        synchronized (Looper.class) {            return sMainLooper;        }    }</code></pre><p>这个就是主线程创建的Looper，一开始的例子说过，在UI线程创建Handler不需要自己加Looper，因为UI线程已经做过这个工作了。具体的创建在后面介绍。</p><p>Looper在prepare之后，就只剩下一个重要功能，loop：</p><pre class=" language-lang-java"><code class="language-lang-java">    // 在当前线程中运行message queue。确保在结束时调用quit结束loop    public static void loop() {        final Looper me = myLooper();        if (me == null) { // 确保Looper.prepare调用过            throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");        }        final MessageQueue queue = me.mQueue;        // 底层对IPC标识处理        Binder.clearCallingIdentity();        final long ident = Binder.clearCallingIdentity();        for (;;) { // 无限循环            Message msg = queue.next(); // 读Message，可能会阻塞            if (msg == null) {                // 没有消息意味着消息队列正在退出                return;            }            // 打印一些Log Trace            final Printer logging = me.mLogging;            if (logging != null) {                logging.println(">>>>> Dispatching to " + msg.target + " " +                        msg.callback + ": " + msg.what);            }            final long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;            final long traceTag = me.mTraceTag;            if (traceTag != 0 && Trace.isTagEnabled(traceTag)) {                Trace.traceBegin(traceTag, msg.target.getTraceName(msg));            }            final long start = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();            final long end;            try {                msg.target.dispatchMessage(msg); // 调用Handler派发消息                end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();            } finally {                if (traceTag != 0) {                    Trace.traceEnd(traceTag);                }            }            if (slowDispatchThresholdMs > 0) {                final long time = end - start;                if (time > slowDispatchThresholdMs) {                    Slog.w(TAG, "Dispatch took " + time + "ms on "                            + Thread.currentThread().getName() + ", h=" +                            msg.target + " cb=" + msg.callback + " msg=" + msg.what);                }            }            if (logging != null) {                logging.println("<<<<< Finished to " + msg.target + " " + msg.callback);            }            // 确保在调度过程中线程的identity没有被破坏。            final long newIdent = Binder.clearCallingIdentity();            if (ident != newIdent) {                Log.wtf(TAG, "Thread identity changed from 0x"                        + Long.toHexString(ident) + " to 0x"                        + Long.toHexString(newIdent) + " while dispatching to "                        + msg.target.getClass().getName() + " "                        + msg.callback + " what=" + msg.what);            }            msg.recycleUnchecked(); // 在Message提到过        }    }</code></pre><p>Looper.loop就是从MessageQueue取出消息，如果没有消息就阻塞，知道来消息或者MessageQueue退出。拿到消息后，有消息内部绑定的Handler进行处理。</p><p>回想一下，MessageQueue的消息是Handler塞进去的，Looper循环拿消息出来最后还是由Handler处理。</p><p>最后确保在结束时调用quit结束loop即可。</p><p>再往回看一遍，MessageQueue，Looper都有自己明确的辅助工作。而真正完成消息传递的，全靠Handler。</p><h2 id="android-os-Handler"><a href="#android-os-Handler" class="headerlink" title="android.os.Handler"></a>android.os.Handler</h2><p>Handler允许你发送和处理Message和与线程的MessageQueue关联的Runnable对象。</p><p><strong>每个</strong>Handler实例都与<strong>一个</strong>线程和这个线程的<strong>MessageQueue</strong>相关联。当你创建一个新的Handler，它直接与创建它的所在的线程和MessageQueue绑定。这一点上，它会传递消息和runnable到那个MessageQueue，并且在消息从队列取出时执行消息。</p><p>Handler的两个主要用途：</p><ol><li>规划（Scheduling）message和runnable在未来某个时间点执行</li><li>将一个要在其他线程执行的操作入队</li></ol><p>Scheduling Message是由以下方法完成：</p><pre class=" language-lang-java"><code class="language-lang-java">public final boolean post(Runnable r)public final boolean postAtTime(Runnable r, long uptimeMillis)public final boolean postDelayed(Runnable r, long delayMillis)public final boolean sendEmptyMessage(int what)public final boolean sendMessage(Message msg)public boolean sendMessageAtTime(Message msg, long uptimeMillis)public final boolean sendMessageDelayed(Message msg, long delayMillis)</code></pre><p>post方法传递runnable参数，由message queue调用。send方法都是Message参数，由Handler的handleMessage处理。</p><p>回到最开始的例子，Handler的使用步骤如下：</p><ol><li>在线程A内创建Handler，重载handleMessage方法处理消息</li><li>在线程B使用Handler.sendMessage等发送消息</li><li>消息从线程B发到线程A，handleMessage接收到消息并处理</li></ol><p>下面以这三步来跟一下源码。</p><p>Handler最重要的就是线程间消息传递，下面跟源码了解中间发生了什么</p><pre class=" language-lang-java"><code class="language-lang-java">public class Handler {    // 将此标志设置为true以检测扩展此Handler类并且不是静态的匿名，本地或成员类。 这些类可能会造成泄漏。      // 关于Handler内存泄露的隐患，以后在研究。    private static final boolean FIND_POTENTIAL_LEAKS = false;    private static final String TAG = "Handler";    private static Handler MAIN_THREAD_HANDLER = null;    final Looper mLooper;    final MessageQueue mQueue;    final Callback mCallback;    final boolean mAsynchronous;    IMessenger mMessenger;</code></pre><p>Handler的属性并不多，关于Callback：</p><pre class=" language-lang-java"><code class="language-lang-java">    public interface Callback {        public boolean handleMessage(Message msg);    }</code></pre><p>这个接口增加一个handleMessage的回调，根据注释：</p><blockquote><p>Callback interface you can use when instantiating a Handler to avoid having to implement your own subclass of Handler.</p></blockquote><p>说明可以在构造Handler的时候实现这个接口方法，这样就不用重载handleMessage方法了。实现如下：</p><pre class=" language-lang-java"><code class="language-lang-java">Handler mHandler = new Handler(new Handler.Callback() {    @Override    public boolean handleMessage(Message msg) {        return false;    }});</code></pre><blockquote><p><strong>需要注意，这里创建了匿名内部类，还是会持有外部引用，导致内存泄漏</strong>。</p></blockquote><p>通过源码，可以了解到这么做的原理：</p><pre class=" language-lang-java"><code class="language-lang-java">    public void dispatchMessage(Message msg) {        if (msg.callback != null) {            handleCallback(msg);        } else {            if (mCallback != null) {                if (mCallback.handleMessage(msg)) {                    return;                }            }            handleMessage(msg);        }    }    private static void handleCallback(Message message) {        message.callback.run();    }    /**     * Subclasses must implement this to receive messages.     */    public void handleMessage(Message msg) {    }</code></pre><p>源码在调用dispatchMessage的时候（记不记得从MessageQueue读取到Message后就是调用这个方法？），如果有callback，就调用callback的接口并返回，否则就调用自己的handleMessage，进而调用到我们重载的方法。</p><p>前面提到，Handler发送消息有postXXX和sendXXX。</p><p>其实看完postXXX方法后，发现post也是调用sendXXX方法进行下一步处理，就是把runnable存入message的callback中，然后send message。所以选择一个send方法了解过程。</p><pre class=" language-lang-java"><code class="language-lang-java">public final boolean sendMessage(Message msg){    return sendMessageDelayed(msg, 0);}public final boolean sendMessageDelayed(Message msg, long delayMillis){    if (delayMillis < 0) {        delayMillis = 0;    }    return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);}public boolean sendMessageAtTime(Message msg, long uptimeMillis) {    MessageQueue queue = mQueue;    if (queue == null) {        RuntimeException e = new RuntimeException(            this + " sendMessageAtTime() called with no mQueue");        Log.w("Looper", e.getMessage(), e);        return false;    }    return enqueueMessage(queue, msg, uptimeMillis);}private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {    msg.target = this;    if (mAsynchronous) {        msg.setAsynchronous(true);    }    return queue.enqueueMessage(msg, uptimeMillis);}</code></pre><p>Handler 发送消息最后调用到了消息队列的 <code>enqueueMessage()</code> 方法。然后从队列取出message也讲过了，最终是调用Handler.dispatchMessage()派发消息出去。这段代码在上面callback处已经贴出，然后send到调用便结束了。</p><p>另外提一点，如果移除消息，调用的也是消息队列的remove方法。</p><h2 id="几个问题"><a href="#几个问题" class="headerlink" title="几个问题"></a>几个问题</h2><h3 id="这几个概念间的关系"><a href="#这几个概念间的关系" class="headerlink" title="这几个概念间的关系"></a>这几个概念间的关系</h3><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/handler.png?raw=true" alt></p><ul><li>一个Thread只有一个Looper</li><li>Looper内有一个MessageQueue</li><li>一个Thread可以有多个Handler</li><li>Handler内持有一个Looper和MessageQueue的引用</li><li>Handler内的Looper就是当前Thread（sThreadLocal）的Looper，MQ就是这个Looper的MQ</li></ul><p>Handler构造方法：</p><pre class=" language-lang-java"><code class="language-lang-java">    public Handler(Callback callback, boolean async) {        if (FIND_POTENTIAL_LEAKS) {            final Class<? extends Handler> klass = getClass();            if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &&                    (klass.getModifiers() & Modifier.STATIC) == 0) {                Log.w(TAG, "The following Handler class should be static or leaks might occur: " +                    klass.getCanonicalName());            }        }        mLooper = Looper.myLooper();        if (mLooper == null) {            throw new RuntimeException(                "Can't create handler inside thread that has not called Looper.prepare()");        }        mQueue = mLooper.mQueue;        mCallback = callback;        mAsynchronous = async;    }</code></pre><h3 id="跨线程通信"><a href="#跨线程通信" class="headerlink" title="跨线程通信"></a>跨线程通信</h3><p>核心就是，Handler可以在任意线程发送消息。</p><p>回到开头那段代码：</p><pre class=" language-lang-java"><code class="language-lang-java">private Handler uiHandler = new Handler() {    @Override    public void handleMessage(Message msg) {        switch (msg.what) {            case 1:                break;        }    }};    new Thread(new Runnable() {        @Override        public void run() {            Message msg = uiHandler.obtainMessage();            msg.what = 1;            uiHandler.sendMessage(msg);        }    }).start();</code></pre><p>在UI线程创建uiHandler，此时这个Handler属于UIThread，其内部Looper也是UIThread创建的，MQ也在UIThread（Looper内持有）。</p><p>做到跨线程通信，就是在新的Thread内使用uiHandler的引用，用它给MQ发送一个message，这样消息就从Thread发送到了UIThread。</p><h3 id="getMainLooper-amp-prepareMainLooper"><a href="#getMainLooper-amp-prepareMainLooper" class="headerlink" title="getMainLooper&amp;prepareMainLooper"></a>getMainLooper&amp;prepareMainLooper</h3><p>前面的例子，在UIThread创建Handler是不用指定Looper的，因为相关Looper已经创建。</p><p>如果在子线程中想更新UI线程，除了在UI线程创建Handler外，也可以在子线程创建Handler，不过需要给这个Handler指定主线程的Looper：</p><pre class=" language-lang-java"><code class="language-lang-java">    Handler mainHandler = new Handler(Looper.getMainLooper());    mainHandler.post(new Runnable() {        @Override        public void run() {            //已在主线程中，可以更新UI        }    });</code></pre><p>通过上面的信息，了解到这两个方法和主线程息息相关，所以先看看这两个方法的源码：</p><pre class=" language-lang-java"><code class="language-lang-java">    // 将当前线程初始化为一个Looper，并标记其为应用的主looper。这个Looper是由Android环境创建的，所以你不应该主动调用这个方法。    public static void prepareMainLooper() {        prepare(false);        synchronized (Looper.class) {            if (sMainLooper != null) {                throw new IllegalStateException("The main Looper has already been prepared.");            }            sMainLooper = myLooper();        }    }    // 返回应用程序的主looper，其存在于应用的主线程    public static Looper getMainLooper() {        synchronized (Looper.class) {            return sMainLooper;        }    }</code></pre><p>所以要想知道系统的主线程是何时创建Main Looper的，就要跟踪<code>prepareMainLooper</code> 方法。</p><p>搜索AOSP，找到两处调用该方法的地方：</p><ol><li>frameworks/base/services/java/com/android/server/SystemServer.java 的 run 方法</li><li>frameworks/base/core/java/android/app/ActivityThread.java 的 main 方法</li></ol><p>这边直接说结论，ActivityThread就是所谓的主线程，其中的main方法就是主线程的入口：</p><pre class=" language-lang-java"><code class="language-lang-java">public static void main(String[] args) {        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "ActivityThreadMain");        SamplingProfilerIntegration.start();        // CloseGuard defaults to true and can be quite spammy.  We        // disable it here, but selectively enable it later (via        // StrictMode) on debug builds, but using DropBox, not logs.        CloseGuard.setEnabled(false);        Environment.initForCurrentUser();        // Set the reporter for event logging in libcore        EventLogger.setReporter(new EventLoggingReporter());        // Make sure TrustedCertificateStore looks in the right place for CA certificates        final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());        TrustedCertificateStore.setDefaultUserDirectory(configDir);        Process.setArgV0("<pre-initialized>");          // 这里sMainLooper赋值        Looper.prepareMainLooper();        ActivityThread thread = new ActivityThread();        thread.attach(false);        if (sMainThreadHandler == null) {            sMainThreadHandler = thread.getHandler();        }        if (false) {            Looper.myLooper().setMessageLogging(new                    LogPrinter(Log.DEBUG, "ActivityThread"));        }        // End of event ActivityThreadMain.        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);        Looper.loop();    // Looper进入循环        throw new RuntimeException("Main thread loop unexpectedly exited");    }</code></pre><p>主线程的Handler从thread.getHandler();拿到的：</p><pre class=" language-lang-java"><code class="language-lang-java">final H mH = new H();    final Handler getHandler() {    return mH;}</code></pre><p>H这个Handler基本处理了所有与应用有关的操作。具体的自己可以看看源码：<a href="http://androidxref.com/8.0.0_r4/xref/frameworks/base/core/java/android/app/ActivityThread.java#1462" target="_blank" rel="noopener">H源码</a> </p><p>至此，Android的Handler消息传递机制大概总结完了。不过又引出一个新的问题，ActivityThread的启动流程以及Application的启动过程和Activity的启动过程。这几天会抽时间整理一下。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Handler </tag>
            
            <tag> Looper </tag>
            
            <tag> Message </tag>
            
            <tag> MessageQueue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Java] CountDownLatch 与 CyclicBarrier</title>
      <link href="/2018/05/08/%5BJava%5DCountDownLatch-and-CyclicBarrier/"/>
      <url>/2018/05/08/%5BJava%5DCountDownLatch-and-CyclicBarrier/</url>
      
        <content type="html"><![CDATA[<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><h3 id="CountDownLatch是什么"><a href="#CountDownLatch是什么" class="headerlink" title="CountDownLatch是什么"></a>CountDownLatch是什么</h3><p>源码注释描述如下：</p><p>A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.</p><p>它是一个同步工具类，允许一个或多个线程一直等待，直到其他线程运行完成后再执行。</p><p>看下我遇到的代码：</p><pre class=" language-lang-java"><code class="language-lang-java">final class DecodeThread extends Thread {    private final MainActivity mActivity;    private final CountDownLatch mHandlerInitLatch;    private Handler mHandler;    DecodeThread(MainActivity activity) {        this.mActivity = activity;        mHandlerInitLatch = new CountDownLatch(1);    }    Handler getHandler() {        try {            mHandlerInitLatch.await();        } catch (InterruptedException ie) {            // continue?        }        return mHandler;    }    @Override    public void run() {        Looper.prepare();        mHandler = new DecodeHandler(mActivity);        mHandlerInitLatch.countDown();        Looper.loop();    }}</code></pre><h3 id="CountDownLatch-工作原理"><a href="#CountDownLatch-工作原理" class="headerlink" title="CountDownLatch 工作原理"></a>CountDownLatch 工作原理</h3><p>CountDownLatch是通过一个计数器来实现的，计数器的初始值为线程的数量（上面代码构造线程数为1）。每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。</p><p>CountDownLatch的构造函数中的count就是闭锁需要等待的线程数量。这个值只能被设置一次，而且不能重新设置。</p><p>主线程必须在启动其他线程后立即调用CountDownLatch.await方法，这样主线程就会在这个方法上阻塞，知道其他线程完成各自任务。</p><p>其他线程完成任务后必须各自通知CountDownLatch对象，使其调用countDown方法。当count值为0时，主线程就能通过await方法恢复自己的任务。</p><p>简述其执行流程：</p><ol><li>运行主线程</li><li>创建N个线程的CountDownLatch</li><li>创建启动N个线程</li><li>主线程运行CountDownLatch.await()，等待latch</li><li>N个线程运行完毕，latch计数减到0</li><li>主线程恢复运行</li></ol><p>再看上面的代码，主线程在getHandler处等待latch，在run处创建handler后执行latch.countDown，就是为了在get的时候能拿到非空的handler。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li><strong>实现最大的并行性</strong>：有时我们想同时启动多个线程，实现最大程度的并行性。例如，我们想测试一个单例类。如果我们创建一个初始计数为1的CountDownLatch，并让所有线程都在这个锁上等待，那么我们可以很轻松地完成测试。我们只需调用 一次countDown()方法就可以让所有的等待线程同时恢复执行。</li><li><strong>开始执行前等待n个线程完成各自任务</strong>：例如应用程序启动类要确保在处理用户请求前，所有N个外部系统已经启动和运行了。</li><li><strong>死锁检测：</strong>一个非常方便的使用场景是，你可以使用n个线程访问共享资源，在每次测试阶段的线程数目是不同的，并尝试产生死锁。</li></ol><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>网上看的一个例子</p><pre class=" language-lang-java"><code class="language-lang-java">// 基础checker类import java.util.concurrent.CountDownLatch;public abstract class BaseHealthChecker implements Runnable {    private CountDownLatch _latch;    private String _serviceName;    private boolean _serviceUp;    // Get latch object in constructor so that after completing the task, thread    // can countDown() the latch    public BaseHealthChecker(String serviceName, CountDownLatch latch) {        // TODO Auto-generated constructor stub        super();        this._latch = latch;        this._serviceName = serviceName;        this._serviceUp = false;    }    @Override    public void run() {        // TODO Auto-generated method stub        try {            verifyService();            _serviceUp = true;        } catch (Throwable t) {            // TODO: handle exception            t.printStackTrace(System.err);            _serviceUp = false;        } finally {            if (_latch != null) {                _latch.countDown();            }        }    }    public String getServiceName() {        return _serviceName;    }    public boolean isServiceUp() {        return _serviceUp;    }    // This methos needs to be implemented by all specific service checker    public abstract void verifyService();}</code></pre><p>然后创建三个checker，分别是CacheChecker,DatabaseChecker和NetworkChecker</p><pre class=" language-lang-java"><code class="language-lang-java">import java.util.concurrent.CountDownLatch;public class CacheHealthChecker extends BaseHealthChecker {    public CacheHealthChecker (CountDownLatch latch)  {        super("Cache Service", latch);    }    @Override    public void verifyService()    {        System.out.println("Checking " + this.getServiceName());        try        {            Thread.sleep(6000);        }        catch (InterruptedException e)        {            e.printStackTrace();        }        System.out.println(this.getServiceName() + " is UP");    }}</code></pre><p>创建一个启动类，处理checker的检测</p><pre class=" language-lang-java"><code class="language-lang-java">import java.util.ArrayList;import java.util.List;import java.util.concurrent.CountDownLatch;import java.util.concurrent.Executor;import java.util.concurrent.Executors;public class ApplicationStartupUtil {    //List of service checkers    private static List<BaseHealthChecker> _services;    //This latch will be used to wait on    private static CountDownLatch _latch;    private ApplicationStartupUtil()    {    }    private final static ApplicationStartupUtil INSTANCE = new ApplicationStartupUtil();    public static ApplicationStartupUtil getInstance()    {        return INSTANCE;    }    public static boolean checkExternalServices() throws Exception    {        //Initialize the latch with number of service checkers        _latch = new CountDownLatch(3);        //All add checker in lists        _services = new ArrayList<BaseHealthChecker>();        _services.add(new NetworkHealthChecker(_latch));        _services.add(new CacheHealthChecker(_latch));        _services.add(new DatabaseHealthChecker(_latch));        //Start service checkers using executor framework        Executor executor = Executors.newFixedThreadPool(_services.size());        for(final BaseHealthChecker v : _services)        {            executor.execute(v);        }        //Now wait till all services are checked        _latch.await();        //Services are file and now proceed startup        for(final BaseHealthChecker v : _services)        {            if( ! v.isServiceUp())            {                return false;            }        }        return true;    }}</code></pre><p>在主程序中运行检测</p><pre class=" language-lang-java"><code class="language-lang-java">public class main {    public static void main(String[] args) {        // TODO Auto-generated method stub        boolean result = false;        try {            result = ApplicationStartupUtil.checkExternalServices();        } catch (Exception e) {            e.printStackTrace();        }        System.out.println("External services validation completed !! Result was :: "+ result);    }}</code></pre><p>运行结果：</p><blockquote><p>Checking Network Service<br>Checking Cache Service<br>Checking Database Service<br>Database Service is UP<br>Cache Service is UP<br>Network Service is UP<br>External services validation completed !! Result was :: true</p></blockquote><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><h3 id="CyclicBarrier-定义"><a href="#CyclicBarrier-定义" class="headerlink" title="CyclicBarrier 定义"></a>CyclicBarrier 定义</h3><p>A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point.</p><p>也是一个同步工具类，它是让一组线程相互等待进入barrier状态，然后这组线程再执行。</p><p>初看定义可能有些懵，看个示例代码就清楚了。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre class=" language-lang-java"><code class="language-lang-java">public class Test {    public static void main(String[] args) {        int N = 4;        CyclicBarrier barrier  = new CyclicBarrier(N);        for(int i=0;i<N;i++)            new Writer(barrier).start();    }    static class Writer extends Thread{        private CyclicBarrier cyclicBarrier;        public Writer(CyclicBarrier cyclicBarrier) {            this.cyclicBarrier = cyclicBarrier;        }        @Override        public void run() {            System.out.println("线程"+Thread.currentThread().getName()+"正在写入数据...");            try {                Thread.sleep(5000);      //以睡眠来模拟写入数据操作                System.out.println("线程"+Thread.currentThread().getName()+"写入数据完毕，等待其他线程写入完毕");                cyclicBarrier.await();            } catch (InterruptedException e) {                e.printStackTrace();            }catch(BrokenBarrierException e){                e.printStackTrace();            }            System.out.println("所有线程写入完毕，继续处理其他任务...");        }    }}</code></pre><p>示例中创建了监控4个线程的CyclicBarrier(4)，然后启动4个线程，每个线程都持有cyclicBarrier对象。</p><p>在每个线程执行一半时，运行cyclicBarrier.await()，此时CyclicBarrier就会进行+1计数，当前线程被阻塞。当计数达到4时，解除阻塞，所有线程都继续执行。</p><p>所以运行结果是：</p><blockquote><p>线程Thread-0正在写入数据…<br>线程Thread-3正在写入数据…<br>线程Thread-2正在写入数据…<br>线程Thread-1正在写入数据…<br>线程Thread-2写入数据完毕，等待其他线程写入完毕<br>线程Thread-0写入数据完毕，等待其他线程写入完毕<br>线程Thread-3写入数据完毕，等待其他线程写入完毕<br>线程Thread-1写入数据完毕，等待其他线程写入完毕<br>所有线程写入完毕，继续处理其他任务…<br>所有线程写入完毕，继续处理其他任务…<br>所有线程写入完毕，继续处理其他任务…<br>所有线程写入完毕，继续处理其他任务…</p></blockquote><h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><ul><li>构造方法有两种</li></ul><p>CyclicBarrier(int parties)<br>默认构造方法，参数表示拦截的线程数量。</p><p>CyclicBarrier(int parties, Runnable barrierAction)<br>由于线程之前的调度是由CPU决定的，所以默认的构造方法无法设置线程执行优先级，CyclicBarrier提供一个更高级的构造函数<code>CyclicBarrier(int parties, Runnable barrierAction)</code>，用于在线程到达同步点时，优先执行线程barrierAction，这样可以更加方便的处理一些负责的业务场景。</p><ul><li>await实现</li></ul><p>CyclicBarrier同样提供带超时时间的await和不带超时时间的await。如果指定了时间，在时间内某个线程还未await，就抛出异常，所有线程继续执行后续任务。</p><ul><li>reset功能</li></ul><p>reset可以使其不断地复用</p><h2 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h2><div class="table-container"><table><thead><tr><th>CountDownLatch</th><th>CyclicBarrier</th></tr></thead><tbody><tr><td>减计数方式</td><td>加计数方式</td></tr><tr><td>计算为0时释放所有等待的线程</td><td>计数达到指定值时释放所有等待线程</td></tr><tr><td>计数为0时，无法重置</td><td>计数达到指定值时，计数置为0重新开始</td></tr><tr><td>调用countDown()方法计数减一，调用await()方法只进行阻塞，对计数没任何影响</td><td>调用await()方法计数加1，若加1后的值不等于构造方法的值，则线程阻塞</td></tr><tr><td>不可重复利用</td><td>可重复利用</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> Syntax </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Multithread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[MachineLearning]tesseract使用</title>
      <link href="/2018/05/04/%5BMachineLearning%5Dtesseract-tutorial/"/>
      <url>/2018/05/04/%5BMachineLearning%5Dtesseract-tutorial/</url>
      
        <content type="html"><![CDATA[<h3 id="tesseract-项目"><a href="#tesseract-项目" class="headerlink" title="tesseract 项目"></a>tesseract 项目</h3><p>google的一个开源OCR项目，详情读项目README吧。</p><p><a href="https://github.com/tesseract-ocr/tesseract" target="_blank" rel="noopener">https://github.com/tesseract-ocr/tesseract</a></p><h3 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h3><p><a href="https://github.com/tesseract-ocr/tesseract/wiki/Compiling-%E2%80%93-GitInstallation" target="_blank" rel="noopener">https://github.com/tesseract-ocr/tesseract/wiki/Compiling-%E2%80%93-GitInstallation</a></p><p>首先安装相关库</p><pre><code>apt-get install autoconf-archive automake g++ libtool libleptonica-dev make pkg-config</code></pre><p>然后运行</p><pre><code>cd tesseract-ocr./autogen.sh./configuremakesudo make installsudo ldconfig</code></pre><p>在configure过程会报错：</p><p>configure: error: Leptonica 1.74 or higher is required. Try to install libleptonica-dev package.</p><p>查看本地安装的Leptonica发现是1.73版本。查资料发现如下解释，1.74需要下载源码编译。</p><blockquote><p>Tesseract versions and the minimum version of Leptonica required:<br>Tesseract Leptonica Ubuntu<br>4.00 1.74.2 Must build from source<br>3.05 1.74.0 Must build from source<br>3.04 1.71 Ubuntu 16.04 <a href="&lt;http://packages.ubuntu.com/xenial/libtesseract3">&lt;http://packages.ubuntu.com/xenial/libtesseract3</a>&gt;<br>3.03 1.70 Ubuntu 14.04 <a href="&lt;http://packages.ubuntu.com/trusty/libtesseract3">&lt;http://packages.ubuntu.com/trusty/libtesseract3</a>&gt;<br>3.02 1.69 Ubuntu 12.04 <a href="&lt;http://packages.ubuntu.com/precise/libtesseract3">&lt;http://packages.ubuntu.com/precise/libtesseract3</a>&gt;<br>3.01 1.67</p></blockquote><h3 id="安装leptonica-1-74"><a href="#安装leptonica-1-74" class="headerlink" title="安装leptonica 1.74"></a>安装leptonica 1.74</h3><pre><code>wget http://www.leptonica.com/source/leptonica-1.74.4.tar.gztar xvf leptonica-1.74.tar.gzcd leptonica-1.74./configuremakesudo make install</code></pre><p>成功后继续执行tesseract的安装。</p><h3 id="运行tesseract"><a href="#运行tesseract" class="headerlink" title="运行tesseract"></a>运行tesseract</h3><pre><code>tesseract digits1.png result -l chi_sim</code></pre><p>命令参数:</p><ul><li>digits1.png 要识别的图片文件</li><li>result 保存识别结果的文件</li><li>-l chi_sim 选择识别的文字类别，chi是中文</li></ul><p>报错：</p><pre><code>Error opening data file /usr/local/share//tessdata/chi_sim.traineddataPlease make sure the TESSDATA_PREFIX environment variable is set to your &quot;tessdata&quot; directory.Failed loading language &#39;chi_sim&#39;Tesseract couldn&#39;t load any languages!Could not initialize tesseract.</code></pre><p>需要设置data路径</p><pre><code>export TESSDATA_PREFIX=/usr/local/share/tessdata/</code></pre><p>然后从<code>git@github.com:tesseract-ocr/tessdata.git</code> 下载需要语言的data，中文就下载chi开头的文件。把data拷贝到TESSDATA_PREFIX路径下，再执行检测命令即可。</p><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/tesseract1.png?raw=true" alt></p><pre><code>0电 话 18663778972</code></pre><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/tesseract2.jpg?raw=true" alt></p><pre><code>全 国 朝 号 2012127</code></pre><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/tesseract3.jpg?raw=true" alt></p><pre><code>&amp;) H: 02 04 12 13 16 26标 | 标标 _</code></pre>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OCR </tag>
            
            <tag> tesseract </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Android][Framework] Gallery幻灯片流程以及一个Bitmap的bug</title>
      <link href="/2018/04/25/%5BAndroid%5D%5BFramework%5DGallery-slideshow/"/>
      <url>/2018/04/25/%5BAndroid%5D%5BFramework%5DGallery-slideshow/</url>
      
        <content type="html"><![CDATA[<h3 id="一个奇怪的Bug"><a href="#一个奇怪的Bug" class="headerlink" title="一个奇怪的Bug"></a>一个奇怪的Bug</h3><p>用Camera录制任意长度视频。进入Gallery，打开包含刚拍好的视频的相册，然后右上角选择展示“幻灯片”，发现，刚才的视频的Thumbnail出现倾斜，被分割成三段展示。当第一遍循环展示结束，再次展示这张图时，图片就正常了。<br>如图：<br><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/slideshow_Screenshot.png?raw=true" alt></p><h3 id="Slideshow流程"><a href="#Slideshow流程" class="headerlink" title="Slideshow流程"></a>Slideshow流程</h3><p>简单看一下Slideshow的流程<br><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/SlideShow.png?raw=true" alt></p><p>幻灯片展示的数据是经过<code>SlideshowPage</code>处理，由<code>SlideshowView</code>进行动画展示。展示的Bitmap来自<code>ImageCacheRequest</code>。图中最后的<code>DecodeUtils</code>是静态工具类，其中<code>decodeUsingPool</code>和<code>ensureGLCompatibleBitmap</code>对Bitmap做了处理。</p><p>从代码简单跟一遍这个流程</p><p>首先在AlbumPage或者PhotoPage界面的菜单选择<code>Slideshow</code></p><pre class=" language-lang-java"><code class="language-lang-java">    @Override    protected boolean onItemSelected(MenuItem item) {        switch (item.getItemId()) {            case R.id.action_slideshow: {                mInCameraAndWantQuitOnPause = false;                Bundle data = new Bundle();                data.putString(SlideshowPage.KEY_SET_PATH,                        mMediaSetPath.toString());                data.putBoolean(SlideshowPage.KEY_REPEAT, true);                mActivity.getStateManager().startStateForResult(                        SlideshowPage.class, REQUEST_SLIDESHOW, data);                return true;            }        }    }</code></pre><p>上面代码是从AlbumPage里的代码，看到传入的data有两个内容：相册path和数据可以重复repeat。</p><p>然后通过<code>StateManager</code>启动SlideshowPage。这里没如果不了解Gallery代码可能会奇怪这个<code>StateManager</code>是什么。这里简单介绍一下：AlbumPage和SlideshowPage都是继承自<code>ActivityState</code>这个类。这个<code>ActivityState</code>是Gallery自创的一个状态管理类，类似于<code>Activity</code>。<code>StateManager</code>通过一个栈管理着这些Page的声明周期。后面会单独介绍这个东西。</p><p>启动SlideshowPage后，就会按照onCreate,onResume的顺序初始化这个类。在onResume的时候进行调用loadNextBitmap()方法加载下一张要显示的幻灯片，然后这个方法会给handler发信息，循环调用showPendingBitmap()-&gt;loadNextBitmap()来实现幻灯片循环播放。</p><pre class=" language-lang-java"><code class="language-lang-java">        mHandler = new SynchronizedHandler(mActivity.getGLRoot()) {            @Override            public void handleMessage(Message message) {                switch (message.what) {                    case MSG_SHOW_PENDING_BITMAP:                        showPendingBitmap();                        break;                    case MSG_LOAD_NEXT_BITMAP:                        loadNextBitmap();                        break;                    default: throw new AssertionError();                }            }        };</code></pre><p>在onResume的时候它还做了一件重要的事，初始化SlideshowDataAdapter并且调用其resume方法。</p><pre class=" language-lang-java"><code class="language-lang-java">mModel.resume();</code></pre><p>看一下这个resume做了什么：</p><pre class=" language-lang-java"><code class="language-lang-java">public class SlideshowDataAdapter implements SlideshowPage.Model {        @Override    public synchronized void resume() {        mIsActive = true;        mSource.addContentListener(mSourceListener);        mNeedReload.set(true);        mDataReady = true;        mReloadTask = mThreadPool.submit(new ReloadTask());    }}</code></pre><p>主要是开启异步加载图片的ReloadTask。</p><pre class=" language-lang-java"><code class="language-lang-java">    private class ReloadTask implements Job<Void> {        @Override        public Void run(JobContext jc) {            while (true) {                synchronized (SlideshowDataAdapter.this) {                    while (mIsActive && (!mDataReady                            || mImageQueue.size() >= IMAGE_QUEUE_CAPACITY)) {                        try {                            SlideshowDataAdapter.this.wait();                        } catch (InterruptedException ex) {                            // ignored.                        }                        continue;                    }                }                if (!mIsActive) return null;                mNeedReset = false;                MediaItem item = loadItem();                if (mNeedReset) {                    synchronized (SlideshowDataAdapter.this) {                        mImageQueue.clear();                        mLoadIndex = mNextOutput;                    }                    continue;                }                if (item == null) {                    synchronized (SlideshowDataAdapter.this) {                        if (!mNeedReload.get()) mDataReady = false;                        SlideshowDataAdapter.this.notifyAll();                    }                    continue;                }                Bitmap bitmap = item                        .requestImage(MediaItem.TYPE_THUMBNAIL)                        .run(jc);                if (bitmap != null) {                    synchronized (SlideshowDataAdapter.this) {                        mImageQueue.addLast(                                new Slide(item, mLoadIndex, bitmap));                        if (mImageQueue.size() == 1) {                            SlideshowDataAdapter.this.notifyAll();                        }                    }                }                ++mLoadIndex;            }        }    }</code></pre><p>这个Task里面，异步获取的Bitmap全部保存在mImageQueue里面。</p><p>而Bitmap的获取又是一个任务Job。这个Job是MediaItem定义的一个抽象方法，LocalVideo作为MediaItem的一个子类实现了这个方法：（这里因为是Video出现的bug，所以就直接找video流程）</p><pre class=" language-lang-java"><code class="language-lang-java">    @Override    public Job<Bitmap> requestImage(int type) {        return new LocalVideoRequest(mApplication, getPath(), dateModifiedInSec,                type, filePath);    }</code></pre><p>LocalVideoRequest是LocalView的一个内部类</p><pre class=" language-lang-java"><code class="language-lang-java">    public static class LocalVideoRequest extends ImageCacheRequest {        private String mLocalFilePath;        LocalVideoRequest(GalleryApp application, Path path, long timeModified,                int type, String localFilePath) {            super(application, path, timeModified, type,                    MediaItem.getTargetSize(type));            mLocalFilePath = localFilePath;        }        @Override        public Bitmap onDecodeOriginal(JobContext jc, int type) {            Bitmap bitmap = BitmapUtils.createVideoThumbnail(mLocalFilePath);            if (bitmap == null || jc.isCancelled()) return null;            return bitmap;        }    }</code></pre><p>然后从super进入ImageCacheRequest</p><pre class=" language-lang-java"><code class="language-lang-java">abstract class ImageCacheRequest implements Job<Bitmap> {      @Override    public Bitmap run(JobContext jc) {        ImageCacheService cacheService = mApplication.getImageCacheService();        BytesBuffer buffer = MediaItem.getBytesBufferPool().get();        try {            boolean found = cacheService.getImageData(mPath, mTimeModified, mType, buffer);            if (jc.isCancelled()) return null;            if (found) {                BitmapFactory.Options options = new BitmapFactory.Options();                options.inPreferredConfig = Bitmap.Config.ARGB_8888;                Bitmap bitmap;                if (mType == MediaItem.TYPE_MICROTHUMBNAIL) {                    bitmap = DecodeUtils.decodeUsingPool(jc,                            buffer.data, buffer.offset, buffer.length, options);                } else {                    bitmap = DecodeUtils.decodeUsingPool(jc,                            buffer.data, buffer.offset, buffer.length, options);                }                if (bitmap == null && !jc.isCancelled()) {                    Log.w(TAG, "decode cached failed " + debugTag());                }                return bitmap;            }        } finally {            MediaItem.getBytesBufferPool().recycle(buffer);        }        Bitmap bitmap = onDecodeOriginal(jc, mType);        if (jc.isCancelled()) return null;        if (bitmap == null) {            return null;        }        if (mType == MediaItem.TYPE_MICROTHUMBNAIL) {            bitmap = BitmapUtils.resizeAndCropCenter(bitmap, mTargetSize, true);        } else {            bitmap = BitmapUtils.resizeDownBySideLength(bitmap, mTargetSize, true);        }        if (jc.isCancelled()) return null;        byte[] array = BitmapUtils.compressToBytes(bitmap);        if (jc.isCancelled()) return null;        cacheService.putImageData(mPath, mTimeModified, mType, array);        return bitmap;    }}</code></pre><p>这里就从不同的地方对Bitmap进行处理。然后返回Bitmap，最后经过next()方法展示幻灯片：</p><pre class=" language-lang-java"><code class="language-lang-java">public class SlideshowView extends GLView {  ...    public void next(Bitmap bitmap, int rotation) {        mTransitionAnimation.start();        if (mPrevTexture != null) {            mPrevTexture.getBitmap().recycle();            mPrevTexture.recycle();        }        mPrevTexture = mCurrentTexture;        mPrevAnimation = mCurrentAnimation;        mPrevRotation = mCurrentRotation;        mCurrentRotation = rotation;        mCurrentTexture = new BitmapTexture(bitmap);        if (((rotation / 90) & 0x01) == 0) {            mCurrentAnimation = new SlideshowAnimation(                    mCurrentTexture.getWidth(), mCurrentTexture.getHeight(),                    mRandom);        } else {            mCurrentAnimation = new SlideshowAnimation(                    mCurrentTexture.getHeight(), mCurrentTexture.getWidth(),                    mRandom);        }        mCurrentAnimation.start();        invalidate();    }      @Override    protected void render(GLCanvas canvas) {        long animTime = AnimationTime.get();        boolean requestRender = mTransitionAnimation.calculate(animTime);        float alpha = mPrevTexture == null ? 1f : mTransitionAnimation.get();        if (mPrevTexture != null && alpha != 1f) {            requestRender |= mPrevAnimation.calculate(animTime);            canvas.save(GLCanvas.SAVE_FLAG_ALPHA | GLCanvas.SAVE_FLAG_MATRIX);            canvas.setAlpha(1f - alpha);            mPrevAnimation.apply(canvas);            canvas.rotate(mPrevRotation, 0, 0, 1);            mPrevTexture.draw(canvas, -mPrevTexture.getWidth() / 2,                    -mPrevTexture.getHeight() / 2);            canvas.restore();        }        if (mCurrentTexture != null) {            requestRender |= mCurrentAnimation.calculate(animTime);            canvas.save(GLCanvas.SAVE_FLAG_ALPHA | GLCanvas.SAVE_FLAG_MATRIX);            canvas.setAlpha(alpha);            mCurrentAnimation.apply(canvas);            canvas.rotate(mCurrentRotation, 0, 0, 1);            mCurrentTexture.draw(canvas, -mCurrentTexture.getWidth() / 2,                    -mCurrentTexture.getHeight() / 2);            canvas.restore();        }        if (requestRender) invalidate();    }}</code></pre><h3 id="Bug的判断处理"><a href="#Bug的判断处理" class="headerlink" title="Bug的判断处理"></a>Bug的判断处理</h3><p>关于开始的问题，首先要调查的就是展示的Bitmap是否是正常的。</p><p>通过把Bitmap保存到本地文件，发现图片是正常的。再尝试读这个文件到Bitmap展示，发现没有再出现图像分割的现象了。</p><p>所以这个问题有一个初步的解决办法：把原始Bitmap压缩到字节流去，然后再从字节流读到Bitmap对象：</p><pre class=" language-lang-java"><code class="language-lang-java">        ByteArrayOutputStream fOut = new ByteArrayOutputStream();        bitmap.compress(Bitmap.CompressFormat.JPEG, 100, fOut);        byte[] bitmapData = fOut.toByteArray();        bitmap = BitmapFactory.decodeByteArray(bitmapData, 0, bitmapData.length);</code></pre><p>然后继续跟代码，发现，在最开始的图片加载是在ImageCacheRequest中的run()方法，见下方注释。</p><pre class=" language-lang-java"><code class="language-lang-java">    @Override    public Bitmap run(JobContext jc) {        ImageCacheService cacheService = mApplication.getImageCacheService();        BytesBuffer buffer = MediaItem.getBytesBufferPool().get();        try {          //一开始这里的found是false，会跳出这里            boolean found = cacheService.getImageData(mPath, mTimeModified, mType, buffer);            if (jc.isCancelled()) return null;            if (found) {                BitmapFactory.Options options = new BitmapFactory.Options();                options.inPreferredConfig = Bitmap.Config.ARGB_8888;                Bitmap bitmap;                if (mType == MediaItem.TYPE_MICROTHUMBNAIL) {                    bitmap = DecodeUtils.decodeUsingPool(jc,                            buffer.data, buffer.offset, buffer.length, options);                } else {                    // 第二次走到这里                    bitmap = DecodeUtils.decodeUsingPool(jc,                            buffer.data, buffer.offset, buffer.length, options);                }                if (bitmap == null && !jc.isCancelled()) {                    Log.w(TAG, "decode cached failed " + debugTag());                }                return bitmap;            }        } finally {            MediaItem.getBytesBufferPool().recycle(buffer);        }      //最开始的Bitmap来自这里        Bitmap bitmap = onDecodeOriginal(jc, mType);        if (jc.isCancelled()) return null;        if (bitmap == null) {            return null;        }        if (mType == MediaItem.TYPE_MICROTHUMBNAIL) {            bitmap = BitmapUtils.resizeAndCropCenter(bitmap, mTargetSize, true);        } else {          //然后进行resize处理            bitmap = BitmapUtils.resizeDownBySideLength(bitmap, mTargetSize, true);        }        if (jc.isCancelled()) return null;        byte[] array = BitmapUtils.compressToBytes(bitmap);        if (jc.isCancelled()) return null;        cacheService.putImageData(mPath, mTimeModified, mType, array);        return bitmap;    }</code></pre><p>先看一下onDecodeOriginal()方法：</p><p>在LocalVideo中</p><pre class=" language-lang-java"><code class="language-lang-java">        @Override        public Bitmap onDecodeOriginal(JobContext jc, int type) {            Bitmap bitmap = BitmapUtils.createVideoThumbnail(mLocalFilePath);            if (bitmap == null || jc.isCancelled()) return null;            return bitmap;        }</code></pre><pre class=" language-lang-java"><code class="language-lang-java">    public static Bitmap createVideoThumbnail(String filePath) {        // MediaMetadataRetriever is available on API Level 8        // but is hidden until API Level 10        Class<?> clazz = null;        Object instance = null;        try {            clazz = Class.forName("android.media.MediaMetadataRetriever");            instance = clazz.newInstance();            Method method = clazz.getMethod("setDataSource", String.class);            method.invoke(instance, filePath);            // The method name changes between API Level 9 and 10.            if (Build.VERSION.SDK_INT <= 9) {                return (Bitmap) clazz.getMethod("captureFrame").invoke(instance);            } else {                byte[] data = (byte[]) clazz.getMethod("getEmbeddedPicture").invoke(instance);                if (data != null) {                    Bitmap bitmap = BitmapFactory.decodeByteArray(data, 0, data.length);                    if (bitmap != null) return bitmap;                }                return (Bitmap) clazz.getMethod("getFrameAtTime").invoke(instance);            }        } catch (IllegalArgumentException ex) {            // Assume this is a corrupt video file        } catch (RuntimeException ex) {            // Assume this is a corrupt video file.        } catch (InstantiationException e) {            Log.e(TAG, "createVideoThumbnail", e);        } catch (InvocationTargetException e) {            Log.e(TAG, "createVideoThumbnail", e);        } catch (ClassNotFoundException e) {            Log.e(TAG, "createVideoThumbnail", e);        } catch (NoSuchMethodException e) {            Log.e(TAG, "createVideoThumbnail", e);        } catch (IllegalAccessException e) {            Log.e(TAG, "createVideoThumbnail", e);        } finally {            try {                if (instance != null) {                    clazz.getMethod("release").invoke(instance);                }            } catch (Exception ignored) {            }        }        return null;    }</code></pre><p>这里用反射拿到Video的缩略图。</p><p>然后对图片缩放</p><pre class=" language-lang-java"><code class="language-lang-java">    public static Bitmap resizeDownBySideLength(            Bitmap bitmap, int maxLength, boolean recycle) {        int srcWidth = bitmap.getWidth();        int srcHeight = bitmap.getHeight();        float scale = Math.min(                (float) maxLength / srcWidth, (float) maxLength / srcHeight);        if (scale >= 1.0f) return bitmap;        return resizeBitmapByScale(bitmap, scale, recycle);    }    public static Bitmap resizeBitmapByScale(            Bitmap bitmap, float scale, boolean recycle) {        int width = Math.round(bitmap.getWidth() * scale);        int height = Math.round(bitmap.getHeight() * scale);        if (width == bitmap.getWidth()                && height == bitmap.getHeight()) return bitmap;      //实际走到这里        Bitmap target = Bitmap.createBitmap(width, height, getConfig(bitmap));        Canvas canvas = new Canvas(target);        canvas.scale(scale, scale);        Paint paint = new Paint(Paint.FILTER_BITMAP_FLAG | Paint.DITHER_FLAG);        canvas.drawBitmap(bitmap, 0, 0, paint);        if (recycle) bitmap.recycle();        return target;    }</code></pre><p>但根据这一步的代码，并没能找到明确的原因。</p><p>但是，通过流程代码，发现一个更好的修改方法，就是在ImageCacheRequest中：</p><pre class=" language-lang-java"><code class="language-lang-java">//最开始的Bitmap来自这里        Bitmap bitmap = onDecodeOriginal(jc, mType);        if (jc.isCancelled()) return null;        if (bitmap == null) {            return null;        }        if (mType == MediaItem.TYPE_MICROTHUMBNAIL) {            bitmap = BitmapUtils.resizeAndCropCenter(bitmap, mTargetSize, true);        } else {          //然后进行resize处理            bitmap = BitmapUtils.resizeDownBySideLength(bitmap, mTargetSize, true);        }        if (jc.isCancelled()) return null;        byte[] array = BitmapUtils.compressToBytes(bitmap);        if (jc.isCancelled()) return null;        cacheService.putImageData(mPath, mTimeModified, mType, array);        return bitmap;</code></pre><p>出问题的Bitmap是经过resizeDownBySideLength处理的，然后做了一步转换成字节流的步骤。所以还是使用前面的修改策略，对这个字节流还原成Bitmap返回。</p><pre class=" language-lang-java"><code class="language-lang-java">        if (jc.isCancelled()) return null;        byte[] array = BitmapUtils.compressToBytes(bitmap);        //只需要这一行代码        bitmap = BitmapFactory.decodeByteArray(array, 0, array.length);        if (jc.isCancelled()) return null;</code></pre><p>这样修改就不会影响其他流程，只处理第一次获取缩略图的过程。</p><p>最后，</p><p>根据现象，由于显示的Bitmap内容是完整的，只是数据错乱了。然后保存到字节流再取出来将数据顺序重新排列了。所以下一步就是探索Bitmap源码寻找真正的原因。<br>TBC</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Gallery </tag>
            
            <tag> Framework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Android][Framework] 从一个小问题了解STK加载内容的方式</title>
      <link href="/2018/04/09/%5BAndroid%5D%5BFramework%5Da-issue-of-SIMToolKit/"/>
      <url>/2018/04/09/%5BAndroid%5D%5BFramework%5Da-issue-of-SIMToolKit/</url>
      
        <content type="html"><![CDATA[<p>STK就是SIMToolKit。</p><p>问题如图，STK一个case的输入框，不应该能输入+：<br><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/STK.png?raw=true" alt></p><p>这个界面从哪来的？<br>实际上，我们插入SIM卡，手机就会显示SimToolKit，打开就能看到一些和运营商相关的菜单。换了不同的卡菜单也会变。所以大概可以猜到，SIM卡里写有一些配置文件，STK会解析这些文件。</p><p>项目原因，正好可以拿到一些配置文件，如图：<br><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/STKfile.png?raw=true" alt><br>通过Smartstation把配置文件写到模拟SIM卡中，然后插卡交给STK读取处理这些信息。</p><p>阅读Java文件，找到出问题的case代码：</p><pre class=" language-lang-java"><code class="language-lang-java">        case 30021:             GetInput getinput21 = new GetInput("Enter 67#*+.digits, SMS default alphabet, Terminal to hide text, packing required, help information available,\"+\" can not input.",4,8);            getinput21.digitsOnly();            getinput21.noEcho();            getinput21.textString().packed();            getinput21.helpInformationAvailable(true);            super.pch.sendCommand(getinput21.toByteArray());            super.state = 0;            break;</code></pre><p>从文件可以知道，输入框是个GetInput对象。<br>输入对象配置了<code>digitsOnly</code>，<code>noEcho</code>，<code>packed</code>等属性。</p><p>怎么处理配置文件？</p><p>有了配置文件，插SIM卡到手机，STK会处理这些数据。</p><p>在OpenGrok上搜索代码，可以找到输入部分，在STK的<code>packages/apps/Stk/src/com/android/stk/StkInputActivity.java</code>文件中。</p><p>下面看一下configInputDisplay方法，配置输入显示。</p><pre class=" language-lang-java"><code class="language-lang-java">    private void configInputDisplay() {        TextView numOfCharsView = (TextView) findViewById(R.id.num_of_chars);        TextView inTypeView = (TextView) findViewById(R.id.input_type);        int inTypeId = R.string.alphabet;        // set the prompt.        mPromptView.setText(mStkInput.text);        // Set input type (alphabet/digit) info close to the InText form.        if (mStkInput.digitOnly) {            mTextIn.setKeyListener(StkDigitsKeyListener.getInstance());            inTypeId = R.string.digits;        }        inTypeView.setText(inTypeId);        if (mStkInput.icon != null) {            setFeatureDrawable(Window.FEATURE_LEFT_ICON, new BitmapDrawable(                    mStkInput.icon));        }        // Handle specific global and text attributes.        switch (mState) {        case STATE_TEXT:            int maxLen = mStkInput.maxLen;            int minLen = mStkInput.minLen;            mTextIn.setFilters(new InputFilter[] {new InputFilter.LengthFilter(                    maxLen)});            // Set number of chars info.            String lengthLimit = String.valueOf(minLen);            if (maxLen != minLen) {                lengthLimit = minLen + " - " + maxLen;            }            numOfCharsView.setText(lengthLimit);            if (!mStkInput.echo) {                mTextIn.setInputType(InputType.TYPE_CLASS_NUMBER                                     | InputType.TYPE_NUMBER_VARIATION_PASSWORD);            }            // Set default text if present.            if (mStkInput.defaultText != null) {                mTextIn.setText(mStkInput.defaultText);            } else {                // make sure the text is cleared                mTextIn.setText("", BufferType.EDITABLE);            }            break;        case STATE_YES_NO:            // Set display mode - normal / yes-no layout            mYesNoLayout.setVisibility(View.VISIBLE);            mNormalLayout.setVisibility(View.GONE);            break;        }    }</code></pre><p>代码中出现<code>mStkInput.digitOnly</code>这样的判断，可以推断<code>mStkInput</code>就是和配置文件里的<code>GetInput</code>对象。</p><p><code>mStkInput</code>来自<code>frameworks/opt/telephony/src/java/com/android/internal/telephony/cat/Input.java</code></p><p>定义如下：</p><pre class=" language-lang-java"><code class="language-lang-java">    Input() {        text = "";        defaultText = null;        icon = null;        minLen = 0;        maxLen = 1;        ucs2 = false;        packed = false;        digitOnly = false;        echo = false;        yesNo = false;        helpAvailable = false;        duration = null;        iconSelfExplanatory = false;    }</code></pre><p>回到前面的class，因为STK file里有说明getinput21.digitsOnly();，所以会进入下面逻辑：</p><pre class=" language-lang-java"><code class="language-lang-java">        // Set input type (alphabet/digit) info close to the InText form.        if (mStkInput.digitOnly) {            mTextIn.setKeyListener(StkDigitsKeyListener.getInstance());            inTypeId = R.string.digits;        }</code></pre><p>这里mTextIn是一个EditText，setKeyListener就是过滤字符的作用。</p><pre class=" language-lang-java"><code class="language-lang-java">/** * For entering dates in a text field. */public class StkDigitsKeyListener extends NumberKeyListener {    @Override    protected char[] getAcceptedChars() {        return CHARACTERS;    }    public int getInputType() {        return EditorInfo.TYPE_CLASS_PHONE;    }    public static StkDigitsKeyListener getInstance() {        if (sInstance != null) {            return sInstance;        }        sInstance = new StkDigitsKeyListener();        return sInstance;    }    /**     * The characters that are used.     *     * @see KeyEvent#getMatch     * @see #getAcceptedChars     */    public static final char[] CHARACTERS = new char[] {            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '*', '#', '+'};    private static StkDigitsKeyListener sInstance;}</code></pre><p>可以看到，<code>CHARACTERS</code>定义了可以输入的字符，其中包含’+’。如果不需要’+’，把这里的声明修改掉就OK</p><p>其实我也不做Tele，但通过这个过程，可以大概了解一些STK相关的原理。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Framework </tag>
            
            <tag> STK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Android][Framework] 无障碍快捷方式相关代码</title>
      <link href="/2018/04/03/%5BAndroid%5D%5BFramework%5DAccessibilityShortcut/"/>
      <url>/2018/04/03/%5BAndroid%5D%5BFramework%5DAccessibilityShortcut/</url>
      
        <content type="html"><![CDATA[<p>问题：无障碍快捷方式（Accessibility Shortcut）打开不生效。<br><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/accessibility.png?raw=true" alt></p><p>如图，打开功能后，长按power键会出现振动，震动后双指放在屏幕上会打开无障碍。</p><p>无障碍的功能从来没有接触过，也不清楚在哪个模块修改，所以下面记录一下如何快速定位这种问题的思路：</p><p>在Opengrok检索<code>&quot;Accessibility Shortcut&quot;</code>找到字串<code>accessibility_global_gesture_preference_title</code>，可以确定两个地方：</p><ul><li>Settings里Accessibility选项的入口 <code>packages/apps/Settings/res/xml/accessibility_settings.xml</code></li><li>Accessibility的控制代码 <code>packages/apps/Settings/src/com/android/settings/accessibility/AccessibilitySettings.java</code></li></ul><h5 id="AccessibilitySettings-java"><a href="#AccessibilitySettings-java" class="headerlink" title="AccessibilitySettings.java"></a>AccessibilitySettings.java</h5><p>通过阅读方法列表，知道这个类完全是用来控制Settings的Accessibility界面按钮的逻辑。</p><p>从控制代码，知道打开上图界面的代码是：</p><pre class=" language-lang-java"><code class="language-lang-java">private void handleToggleEnableAccessibilityGesturePreferenceClick() {    Bundle extras = mGlobalGesturePreferenceScreen.getExtras();    extras.putString(EXTRA_TITLE, getString(        R.string.accessibility_global_gesture_preference_title));    extras.putString(EXTRA_SUMMARY, getString(        R.string.accessibility_global_gesture_preference_description));    extras.putBoolean(EXTRA_CHECKED, Settings.Global.getInt(getContentResolver(),Settings.Global.ENABLE_ACCESSIBILITY_GLOBAL_GESTURE_ENABLED, 0) == 1);    super.onPreferenceTreeClick(mGlobalGesturePreferenceScreen);}</code></pre><p>这一步是设置Title和Summary，和设置SwichBar是否check。所以这个KEY是控制变量的关键。</p><p>搜索<code>Settings.Global.ENABLE_ACCESSIBILITY_GLOBAL_GESTURE_ENABLED</code>，可以了解到几个地方：</p><h5 id="ToggleGlobalGesturePreferenceFragment-java"><a href="#ToggleGlobalGesturePreferenceFragment-java" class="headerlink" title="ToggleGlobalGesturePreferenceFragment.java"></a>ToggleGlobalGesturePreferenceFragment.java</h5><p>这里通过KEY的命名和相关类的命名，可以知道，Accessibility Shortcut打开后，相关的手势被称为<code>Global Gesture</code>，全局手势。了解命名也很重要，这对于分析不熟悉的模块很有帮助。</p><p>这个Fragment是处理SwichBar的回调。每当SwichBar状态变化，就会更新相关的值：</p><pre class=" language-lang-Java"><code class="language-lang-Java">@Overrideprotected void onPreferenceToggled(String preferenceKey, boolean enabled) {    Settings.Global.putInt(getContentResolver(),            Settings.Global.ENABLE_ACCESSIBILITY_GLOBAL_GESTURE_ENABLED, enabled ? 1 : 0);}</code></pre><p>前面两个类似乎并不是关键，后面的两个就不一样了。</p><h5 id="PhoneWindowManager-java"><a href="#PhoneWindowManager-java" class="headerlink" title="PhoneWindowManager.java"></a>PhoneWindowManager.java</h5><p>这是个大类，涉及到非常多的控制逻辑，而且从命名就能知道它的核心功能。但实际上，对于这个问题，只需要看一部分逻辑：</p><p>Accessibility Shortcut功能是长按POWER键启用。在PWM中，有<code>powerLongPress</code>的处理逻辑：</p><pre class=" language-lang-java"><code class="language-lang-java">private void powerLongPress() {    final int behavior = getResolvedLongPressOnPowerBehavior();    switch (behavior) {        case LONG_PRESS_POWER_NOTHING:            break;        case LONG_PRESS_POWER_GLOBAL_ACTIONS:            mPowerKeyHandled = true;            if (!performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false)) {                performAuditoryFeedbackForAccessibilityIfNeed();            }            showGlobalActionsInternal();            break;        case LONG_PRESS_POWER_SHUT_OFF:        case LONG_PRESS_POWER_SHUT_OFF_NO_CONFIRM:            mPowerKeyHandled = true;            performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);            sendCloseSystemWindows(SYSTEM_DIALOG_REASON_GLOBAL_ACTIONS);            mWindowManagerFuncs.shutdown(behavior == LONG_PRESS_POWER_SHUT_OFF);            break;    }}</code></pre><p>首先获取长按POWER键的行为：</p><pre class=" language-lang-java"><code class="language-lang-java">private int getResolvedLongPressOnPowerBehavior() {    if (FactoryTest.isLongPressOnPowerOffEnabled()) {        return LONG_PRESS_POWER_SHUT_OFF_NO_CONFIRM;    }    return mLongPressOnPowerBehavior;}</code></pre><p>正常情况下都会直接返回<code>mLongPressOnPowerBehavior</code>，这个变量初始化如下：</p><pre class=" language-lang-java"><code class="language-lang-java">mLongPressOnPowerBehavior = mContext.getResources().getInteger(                com.android.internal.R.integer.config_longPressOnPowerBehavior);</code></pre><p>这个值在<code>frameworks/base/core/res/res/values/config.xml</code>配置为1。所以在Switch会走到LONG_PRESS_POWER_GLOBAL_ACTIONS这个case。</p><p>在这个case下，首先会调用performHapticFeedbackLW方法，从名称看，是perform触觉反馈LW方法，最终目的是发出振动。</p><pre class=" language-lang-java"><code class="language-lang-java">@Overridepublic boolean performHapticFeedbackLw(WindowState win, int effectId, boolean always) {    if (!mVibrator.hasVibrator()) {        return false;    }    final boolean hapticsDisabled = Settings.System.getIntForUser(mContext.getContentResolver(),    Settings.System.HAPTIC_FEEDBACK_ENABLED, 0, UserHandle.USER_CURRENT) == 0;    if (hapticsDisabled && !always) {        return false;    }    long[] pattern = null;    switch (effectId) {        case HapticFeedbackConstants.LONG_PRESS:            pattern = mLongPressVibePattern;            break;        case HapticFeedbackConstants.VIRTUAL_KEY:            pattern = mVirtualKeyVibePattern;            break;        case HapticFeedbackConstants.KEYBOARD_TAP:            pattern = mKeyboardTapVibePattern;            break;        case HapticFeedbackConstants.CLOCK_TICK:            pattern = mClockTickVibePattern;            break;        case HapticFeedbackConstants.CALENDAR_DATE:            pattern = mCalendarDateVibePattern;            break;        case HapticFeedbackConstants.SAFE_MODE_DISABLED:            pattern = mSafeModeDisabledVibePattern;            break;        case HapticFeedbackConstants.SAFE_MODE_ENABLED:            pattern = mSafeModeEnabledVibePattern;            break;        case HapticFeedbackConstants.CONTEXT_CLICK:            pattern = mContextClickVibePattern;            break;        default:            return false;    }    int owningUid;    String owningPackage;    if (win != null) {        owningUid = win.getOwningUid();        owningPackage = win.getOwningPackage();    } else {        owningUid = android.os.Process.myUid();        owningPackage = mContext.getOpPackageName();    }    if (pattern.length == 1) {        // One-shot vibration        mVibrator.vibrate(owningUid, owningPackage, pattern[0], VIBRATION_ATTRIBUTES);    } else {        // Pattern vibration        mVibrator.vibrate(owningUid, owningPackage, pattern, -1, VIBRATION_ATTRIBUTES);    }    return true;}</code></pre><p>如果上面返回为false，则没有振动，代码会进入<code>performAuditoryFeedbackForAccessibilityIfNeed</code>，即播放声音。</p><pre class=" language-lang-java"><code class="language-lang-java">private void performAuditoryFeedbackForAccessibilityIfNeed() {    if (!isGlobalAccessibilityGestureEnabled()) {        return;    }    AudioManager audioManager = (AudioManager) mContext.getSystemService(        Context.AUDIO_SERVICE);    if (audioManager.isSilentMode()) {        return;    }    Ringtone ringTone = RingtoneManager.getRingtone(mContext, Settings.System.DEFAULT_NOTIFICATION_URI);    ringTone.setStreamType(AudioManager.STREAM_MUSIC);    ringTone.play();}</code></pre><p>播放声音前的判断就是 通过获取标志位判断。</p><pre class=" language-lang-java"><code class="language-lang-java">private boolean isGlobalAccessibilityGestureEnabled() {    return Settings.Global.getInt(mContext.getContentResolver(),        Settings.Global.ENABLE_ACCESSIBILITY_GLOBAL_GESTURE_ENABLED, 0) == 1;}</code></pre><p>最后调用的是showGlobalActionsInternal方法</p><pre class=" language-lang-java"><code class="language-lang-java">void showGlobalActionsInternal() {    sendCloseSystemWindows(SYSTEM_DIALOG_REASON_GLOBAL_ACTIONS);    if (mGlobalActions == null) {        mGlobalActions = new GlobalActions(mContext, mWindowManagerFuncs);    }    final boolean keyguardShowing = isKeyguardShowingAndNotOccluded();    mGlobalActions.showDialog(keyguardShowing, isDeviceProvisioned());    if (keyguardShowing) {        // since it took two seconds of long press to bring this up,        // poke the wake lock so they have some time to see the dialog.        mPowerManager.userActivity(SystemClock.uptimeMillis(), false);    }}</code></pre><p>所以这里看出，PWM只是处理了长按power键的逻辑。那长按之后，双指触摸屏幕的逻辑在哪控制呢？</p><h5 id="GlobalActions-java"><a href="#GlobalActions-java" class="headerlink" title="GlobalActions.java"></a>GlobalActions.java</h5><p>这个类蛮有意思的，通过类名知道他是全局的一个操作，里面出现大量的控制代码，而且很多和手势操作相关。有机会可以深入了解一下。</p><p>在onStart的地方，通过阅读注释，可以知道，这里处理打开Accessibility后的双指触摸，触摸时不销毁弹出的关机选项对话框。</p><p>代码中有一个非常重要的判断，它决定是否进入Accessibility模式。</p><pre class=" language-lang-java"><code class="language-lang-java">@Overrideprotected void onStart() {    // If global accessibility gesture can be performed, we will take care    // of dismissing the dialog on touch outside. This is because the dialog    // is dismissed on the first down while the global gesture is a long press    // with two fingers anywhere on the screen.    if (EnableAccessibilityController.canEnableAccessibilityViaGesture(mContext)) {        mEnableAccessibilityController = new EnableAccessibilityController(mContext,        new Runnable() {            @Override            public void run() {                dismiss();            }        });        super.setCanceledOnTouchOutside(false);    } else {        mEnableAccessibilityController = null;        super.setCanceledOnTouchOutside(true);    }    super.onStart();}</code></pre><h5 id="EnableAccessibilityController-java"><a href="#EnableAccessibilityController-java" class="headerlink" title="EnableAccessibilityController.java"></a>EnableAccessibilityController.java</h5><pre class=" language-lang-java"><code class="language-lang-java">public static boolean canEnableAccessibilityViaGesture(Context context) {    AccessibilityManager accessibilityManager = AccessibilityManager.getInstance(context);    // Accessibility is enabled and there is an enabled speaking    // accessibility service, then we have nothing to do.    if (accessibilityManager.isEnabled()        && !accessibilityManager.getEnabledAccessibilityServiceList(            AccessibilityServiceInfo.FEEDBACK_SPOKEN).isEmpty()) {        return false;    }    // If the global gesture is enabled and there is a speaking service    // installed we are good to go, otherwise there is nothing to do.    return Settings.Global.getInt(context.getContentResolver(),                                  Settings.Global.ENABLE_ACCESSIBILITY_GLOBAL_GESTURE_ENABLED, 0) == 1        && !getInstalledSpeakingAccessibilityServices(context).isEmpty();}</code></pre><p>这里需要判断几层：</p><ul><li>AccessibilityManager enable</li><li>AccessibilityManager 服务不为空。这里服务可以是自定义安装的。如果没有可用服务就无从打开。</li><li>ENABLE_ACCESSIBILITY_GLOBAL_GESTURE_ENABLED标志位打开，即前面界面的switch按钮打开。</li><li>talkbak必须安装。因为他需要语音播放一些内容，所以talkbak是必备的。</li></ul><p>我遇到的问题就是手机没有集成GMS talkbak，导致Accessibility打开没反应。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Framework </tag>
            
            <tag> Accessibility </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Android] 使用MediaProjection截屏</title>
      <link href="/2018/04/02/%5BAndroid%5DMediaProjection-Screenshot/"/>
      <url>/2018/04/02/%5BAndroid%5DMediaProjection-Screenshot/</url>
      
        <content type="html"><![CDATA[<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>Android5.0以上提供了MediaProjection，方便截屏录屏等功能。</p><p>详细代码参阅Github：<a href="https://github.com/wossoneri/ScreenCapture" target="_blank" rel="noopener">https://github.com/wossoneri/ScreenCapture</a></p><p>一个完整的创建MediaProjection到结束的流程如下：</p><pre class=" language-lang-java"><code class="language-lang-java">mProjectionManager = (MediaProjectionManager)getSystemService(Context.MEDIA_PROJECTION_SERVICE);// initstartActivityForResult(mProjectionManager.createScreenCaptureIntent(), REQUEST_CODE);@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) {  super.onActivityResult(requestCode, resultCode, data);  if (RESULT_OK == resultCode && REQUEST_CODE == requestCode) {    sMediaProjection = mProjectionManager.getMediaProjection(resultCode, data);    ......  }}// endsMediaProjection.stop();</code></pre><p>其中，需要使用<code>startActivityForResult</code>的唯一原因是，捕捉屏幕是需要用户确认权限才可以，这个权限对应的对话框就是由<code>createScreenCaptureIntent</code>创建的，在用户点击允许之后，在<code>onActivityResult</code>得到确认码，才可以拿到MediaProjection对象。</p><p>下面详细介绍相关知识点。</p><h2 id="About-MediaProjection"><a href="#About-MediaProjection" class="headerlink" title="About MediaProjection"></a>About MediaProjection</h2><h3 id="MediaProjection"><a href="#MediaProjection" class="headerlink" title="MediaProjection"></a>MediaProjection</h3><p>授予应用程序捕获屏幕内容或记录系统音频的能力。授予的准确能力取决于<code>MediaProjection</code>的类型</p><p>可以通过<code>createScreenCaptureIntent()</code>捕获屏幕会话。它能获取屏幕内容，但无法获取系统音频。</p><p>它有4个公有方法：</p><h4 id="createVirtualDisplay"><a href="#createVirtualDisplay" class="headerlink" title="createVirtualDisplay"></a>createVirtualDisplay</h4><pre class=" language-lang-java"><code class="language-lang-java">VirtualDisplay createVirtualDisplay (String name,                 int width,                 int height,                 int dpi,                 int flags,                 Surface surface,                 VirtualDisplay.Callback callback,                 Handler handler)</code></pre><p>创建一个VirtualDisplay用来捕获屏幕内容。</p><p>参数：</p><ul><li><strong>name:String</strong> 名称，永不为空</li><li><strong>width:int</strong></li><li><strong>height:int</strong></li><li><strong>dpi:int</strong></li><li><strong>flags:int</strong> DisplayManager定义的flag组合</li><li><strong>surface:Surface</strong> virtual display的内容应该被渲染的surface，没有的话为空</li><li><strong>callback:VirtualDisplay.Callback</strong> virtual display状态变化的回调</li><li><strong>handler:Handler</strong> callback调用的Handler。如果回调在calling thread的主looper被调用，则为空？</li></ul><h4 id="registerCallback"><a href="#registerCallback" class="headerlink" title="registerCallback"></a>registerCallback</h4><pre class=" language-lang-java"><code class="language-lang-java">void registerCallback (MediaProjection.Callback callback,                 Handler handler)</code></pre><p>注册一个listener接收<code>MediaProjection</code>变化状态的通知。</p><h4 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h4><pre class=" language-lang-java"><code class="language-lang-java">void stop ()</code></pre><p>停止projection</p><h4 id="unregisterCallback"><a href="#unregisterCallback" class="headerlink" title="unregisterCallback"></a>unregisterCallback</h4><pre class=" language-lang-java"><code class="language-lang-java">void unregisterCallback (MediaProjection.Callback callback)</code></pre><p>取消注册<code>MediaProjection</code>的listener</p><h3 id="MediaProjectionManager"><a href="#MediaProjectionManager" class="headerlink" title="MediaProjectionManager"></a>MediaProjectionManager</h3><p>管理获取到MediaProjection具体类型。</p><p>该类必须使用<code>Context.getSystemService(Class)</code>方法，参数用<code>MediaProjectionManager.class</code>或者<code>Context.getSystemService(String)</code>方法，参数用<code>Context.MEDIA_PROJECTION_SERVICE</code>两种方式实例化。</p><p>公有方法：</p><h4 id="createScreenCaptureIntent"><a href="#createScreenCaptureIntent" class="headerlink" title="createScreenCaptureIntent"></a>createScreenCaptureIntent</h4><pre class=" language-lang-java"><code class="language-lang-java">Intent createScreenCaptureIntent()</code></pre><p>启动screen capture，必须把这个方法返回的Intent传递给<code>startActivityForResult()</code>。这个Activity会提示用户是否允许捕捉屏幕。用户的操作结果需要传递给getMediaProjection。</p><p>所以这里的目的就是提示用户，获取允许再抓屏。我用小米系统，这个提示只会弹一次。后面用nexus试试</p><h4 id="getMediaProjection"><a href="#getMediaProjection" class="headerlink" title="getMediaProjection"></a>getMediaProjection</h4><pre class=" language-lang-java"><code class="language-lang-java">MediaProjection getMediaProjection (int resultCode, Intent resultData)</code></pre><p>成功获得用户允许后获取MediaProjection对象。如果授权失败，则得到空对象。</p><h3 id="MediaProjection-Callback"><a href="#MediaProjection-Callback" class="headerlink" title="MediaProjection.Callback"></a>MediaProjection.Callback</h3><p>projection session的回调<br>主要就一个方法：</p><h4 id="onStop"><a href="#onStop" class="headerlink" title="onStop"></a>onStop</h4><pre class=" language-lang-java"><code class="language-lang-java">void onStop()</code></pre><p>当MediaProjection session不再有效时调用。一旦一个MediaProjection调用<code>stop</code>方法就回调到这里，然后由应用程序决定释放其可能持有的资源。如下示例代码，所有资源释放在这里进行。</p><pre class=" language-lang-java"><code class="language-lang-java">private class MediaProjectionStopCallback extends MediaProjection.Callback {  @Override  public void onStop() {    mHandler.post(new Runnable() {      @Override      public void run() {        if (mVirtualDisplay != null) {          mVirtualDisplay.release();        }        if (mImageReader != null) {          mImageReader.setOnImageAvailableListener(null, null);        }        sMediaProjection.unregisterCallback(MediaProjectionStopCallback.this);      }    });  }}</code></pre><h2 id="Screen-Capture"><a href="#Screen-Capture" class="headerlink" title="Screen Capture"></a>Screen Capture</h2><p>以上就是MediaProjection调用的几个接口。得到MediaProjection实例后怎么截屏呢？下面是截屏的核心步骤。</p><pre class=" language-lang-java"><code class="language-lang-java">        //start capture reader        mImageReader = ImageReader.newInstance(mWidth, mHeight,                PixelFormat.RGBA_8888, 2);        mVirtualDisplay = sMediaProjection.createVirtualDisplay(                "ScreenShot",                mWidth,                mHeight,                mDensity,                DisplayManager.VIRTUAL_DISPLAY_FLAG_OWN_CONTENT_ONLY | DisplayManager.VIRTUAL_DISPLAY_FLAG_PUBLIC,                mImageReader.getSurface(),                null,                mHandler);        mImageReader.setOnImageAvailableListener(new ImageReader.OnImageAvailableListener() {            @Override            public void onImageAvailable(ImageReader reader) {                Image image = null;                FileOutputStream fos = null;                Bitmap bitmap = null;                try {                    image = reader.acquireLatestImage();                    if (image != null) {                        Image.Plane[] planes = image.getPlanes();                        ByteBuffer buffer = planes[0].getBuffer();                        int pixelStride = planes[0].getPixelStride();                        int rowStride = planes[0].getRowStride();                        int rowPadding = rowStride - pixelStride * mWidth;                        bitmap = Bitmap.createBitmap(mWidth + rowPadding / pixelStride,                                mHeight, Bitmap.Config.ARGB_8888);                        bitmap.copyPixelsFromBuffer(buffer);                        Date currentDate = new Date();                        SimpleDateFormat date = new SimpleDateFormat("yyyyMMddhhmmss");                        String fileName = STORE_DIR + "/myScreen_" + date.format(currentDate) + ".png";                        fos = new FileOutputStream(fileName);                        bitmap.compress(Bitmap.CompressFormat.JPEG, 100, fos);                        Log.d("WOW", "End now!!!!!!");                        Toast.makeText(mContext, "Screenshot saved in " + fileName, Toast.LENGTH_LONG);                        stopProjection();                    }                } catch (Exception e) {                    e.printStackTrace();                } finally {                    if (fos != null) {                        try {                            fos.close();                        } catch (IOException e) {                            e.printStackTrace();                        }                    }                    if (bitmap != null) {                        bitmap.recycle();                    }                    if (image != null) {                        image.close();                    }                }            }        }, mHandler);        sMediaProjection.registerCallback(new MediaProjectionStopCallback(), mHandler);}</code></pre><h3 id="ImageReader-amp-Surface"><a href="#ImageReader-amp-Surface" class="headerlink" title="ImageReader &amp; Surface"></a>ImageReader &amp; Surface</h3><p>Surface用来处理由屏幕合成器管理的raw buffer。</p><p>在Andorid的窗口实现里，每一个Window其实都会对应一个Surface，而每个Activity都会持有一个Window。可以理解为所有view的绘制都会绘制到surface上面去。</p><p>而ImageReader允许应用级别的直接访问render到surface上面的图像数据。</p><p>图像数据封装在Image对象中，并且可以同时访问多个此类对象，能够访问的数量由构造参数<code>maxImages</code>决定（稍后会看到这个参数）。通过Surface发送给ImageReader的图像都放在队列中，由<code>acquireLatestImage()</code>或 <code>acquireNextImage()</code> 两个方法取出。限于内存大小，如果ImageReader不能以与生成速率相同的速率获取和释放图像，那么图像源最终会在试图渲染到表面的过程中停止或删除图像。</p><p>相关代码说明：</p><h4 id="newInstance"><a href="#newInstance" class="headerlink" title="newInstance"></a>newInstance</h4><pre class=" language-lang-java"><code class="language-lang-java">ImageReader newInstance (int width,                 int height,                 int format,                 int maxImages)</code></pre><pre class=" language-lang-java"><code class="language-lang-java">mImageReader = ImageReader.newInstance(mWidth, mHeight, PixelFormat.RGBA_8888, 2);</code></pre><p>使用<code>newInstance</code>方法实例化一个ImageReader。</p><p>前两个参数是ImageReader生成图像的尺寸，截屏当然是使用屏幕尺寸。</p><blockquote><p>注意，用Display获取屏幕尺寸要用真实的尺寸，使用<code>getRealMetrics</code>方法。如果使用<code>getMetrics</code>方法，得到的高度是缺少Navigaiton Bar的高度的。</p><p>如果尺寸和屏幕不一致，最终得到的图像会是等比例缩放到屏幕大小的图像，然后空白的地方会显示黑边。</p></blockquote><p>第三个参数是format类型，使用ImageFormat或者PixelFormat的一种。代码使用PixelFormat最高保真的类型。</p><p>第四个参数是maxImages，这个参数决定了可以同时从ImageReader对象获取最大图像对象的数量。所以请求更多的缓冲区要占用更多的内存，所以要根据需求选择最小数量。对截屏来说，要1张图像就够了，但是代码使用的是2，这个理由在后面说。</p><h4 id="getSurface"><a href="#getSurface" class="headerlink" title="getSurface"></a>getSurface</h4><pre class=" language-lang-java"><code class="language-lang-java">Surface getSurface ()</code></pre><pre class=" language-lang-java"><code class="language-lang-java">mImageReader.getSurface()</code></pre><p>获取可以用来为当前ImageReader生产Images的Surface对象。</p><p>在有效的图像数据render到这个Surface之前， <code>acquireNextImage()</code> 方法将会返回空值。</p><h4 id="acquireLatestImage"><a href="#acquireLatestImage" class="headerlink" title="acquireLatestImage"></a>acquireLatestImage</h4><pre><code>Image acquireLatestImage ()</code></pre><pre class=" language-lang-java"><code class="language-lang-java">image = reader.acquireLatestImage();</code></pre><p>从ImageReader的队列获取最新的图像，删除旧的图像。如果没有新图像，返回null</p><p>这个方法将会获得来自ImageReader的所有图像，close()掉所有不是最新的图像。对于大多数用例，建议使用这个方法，而不是<code>acquireNextImage()</code>方法，因为它更加适合实时处理。</p><blockquote><p>注意，对于acquireLatestImage方法来说，maxImages应该至少为2，因为它的机制，要获取最新的图像，同时丢弃旧的图像，因此一次至少需要获取两个图像。</p></blockquote><h4 id="acquireNextImage"><a href="#acquireNextImage" class="headerlink" title="acquireNextImage"></a>acquireNextImage</h4><pre><code>Image acquireNextImage ()</code></pre><p>从ImageReader队列获取下一张图像。还是建议使用<code>acquireNextImage</code>方法，因为它会自动释放旧图片。</p><p>错误的使用这个方法，会导致图像不断增加的延时，最终导致没有新图像产生。</p><h4 id="setOnImageAvailableListener"><a href="#setOnImageAvailableListener" class="headerlink" title="setOnImageAvailableListener"></a>setOnImageAvailableListener</h4><p>注册listener，当ImageReader有新的图像时候会回调到这里。</p><pre class=" language-lang-java"><code class="language-lang-java">mImageReader.setOnImageAvailableListener(new ImageReader.OnImageAvailableListener() {    @Override    public void onImageAvailable(ImageReader reader) {        ...        image = reader.acquireLatestImage();    }}</code></pre><h3 id="DisplayManager-amp-VirtualDisplay"><a href="#DisplayManager-amp-VirtualDisplay" class="headerlink" title="DisplayManager &amp; VirtualDisplay"></a>DisplayManager &amp; VirtualDisplay</h3><p>VirtualDisplay表示一个虚拟显示，显示的内容render到 <code>createVirtualDisplay()</code>参数的Surface。</p><p>因为virtual display内容render到应用程序提供的surface，所以当进程终止时，它将会自动释放，并且所以剩余的窗口都会被强制删除。但是，你仍然需要在使用完后显式地调用<code>release()</code>方法。</p><p>DisplayManager管理加载的display的属性</p><p>实例化方法有两种：</p><ul><li><code>Context.getSystemService(DisplayManager.class)</code></li><li><code>Context.getSYstemService(Context.DISPLAY_SERVICE)</code></li></ul><p>DisplayManager的几个常量：</p><h4 id="DISPLAY-CATEGORY-PRESENTATION"><a href="#DISPLAY-CATEGORY-PRESENTATION" class="headerlink" title="DISPLAY_CATEGORY_PRESENTATION"></a>DISPLAY_CATEGORY_PRESENTATION</h4><p>String类型。</p><p>Display category: Presentation displays. （不知道如何翻译准确）</p><p>这一类别可用于识别适合用于presentation displays的第二级的displays，比如HDMI或者Wireless displays。应用程序可以自动地投射他们的内容到presentation displays以提供更丰富的第二屏体验。</p><blockquote><p>关键字：Android双屏异显</p><p>可以参阅Android <a href="https://developer.android.com/reference/android/app/Presentation.html" target="_blank" rel="noopener">Presentation</a>接口说明，实现双屏异显的功能。</p></blockquote><h4 id="VIRTUAL-DISPLAY-FLAG-AUTO-MIRROR"><a href="#VIRTUAL-DISPLAY-FLAG-AUTO-MIRROR" class="headerlink" title="VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR"></a>VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR</h4><p>int类型（后面皆是）。允许在没有显示内容的情况下在私有display上显示内容。</p><p>这个flag和<code>VIRTUAL_DISPLAY_FLAG_OWN_CONTENT_ONLY</code>互相排斥，如果两者同时指定，后者将被应用。</p><p>当设置<code>VIRTUAL_DISPLAY_FLAG_PUBLIC</code> ，同时没有设置<code>VIRTUAL_DISPLAY_FLAG_OWN_CONTENT_ONLY</code>时，这个flag会被隐含。只有在创建私有display时，才需要使用该flag来覆盖默认行为。</p><p>创建一个自动mirror的virtual display需要 <code>CAPTURE_VIDEO_OUTPUT</code>或者 <code>CAPTURE_SECURE_VIDEO_OUTPUT</code> 权限。这些权限保留为系统组件使用，对第三方应用不可用。或者，可以使用适当的MediaProjection创建一个自动mirror的virtual display。</p><h4 id="VIRTUAL-DISPLAY-FLAG-OWN-CONTENT-ONLY"><a href="#VIRTUAL-DISPLAY-FLAG-OWN-CONTENT-ONLY" class="headerlink" title="VIRTUAL_DISPLAY_FLAG_OWN_CONTENT_ONLY"></a>VIRTUAL_DISPLAY_FLAG_OWN_CONTENT_ONLY</h4><p>只展示这个display自己的内容，不镜像其他display的内容。</p><p>这个flag与<code>VIRTUAL_DISPLAY_FLAG_PUBLIC</code>一起使用。通常，public  virtual display在没有自己的窗口时会自动镜像显示默认display的内容。当设定这个flag后，virtual display只会显示自己的内容，如果自己没有窗口，就会为空白。</p><p>在<code>VIRTUAL_DISPLAY_FLAG_PUBLIC</code>或者 <code>VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR</code> 没有设置时，该flag是隐含的。只有在创建公开display时，才需要使用该标志来覆盖默认行为。</p><h4 id="VIRTUAL-DISPLAY-FLAG-PRESENTATION"><a href="#VIRTUAL-DISPLAY-FLAG-PRESENTATION" class="headerlink" title="VIRTUAL_DISPLAY_FLAG_PRESENTATION"></a>VIRTUAL_DISPLAY_FLAG_PRESENTATION</h4><p>创建一个presentation display</p><p>这个和双屏异显有关。设置成该flag，virtual display就注册为一个Presentation display。</p><h4 id="VIRTUAL-DISPLAY-FLAG-PUBLIC"><a href="#VIRTUAL-DISPLAY-FLAG-PUBLIC" class="headerlink" title="VIRTUAL_DISPLAY_FLAG_PUBLIC"></a>VIRTUAL_DISPLAY_FLAG_PUBLIC</h4><p>创建一个public display</p><p>一个公共virtual display 和其他任何与系统连接的display一样，比如HDMI或Wireless display。应用程序可以在display上打开窗口，系统也可以镜像其他display的内容在其上面。</p><p>Creating a public virtual display that isn’t restricted to own-content only implicitly creates an auto-mirroring display. </p><p>当没有设置这个flag，就是私有的display。私有的virtual display属于创建它的应用程序。只有这个display的拥有者才能往上面放置windows。私有的virtual display也不参与display mirroring，它既不接收其他的镜像，也不会把自己镜像出去。更准确的说，只有相同的UID的应用程序或者已经在display上的activities可以使用私有display</p><h4 id="VIRTUAL-DISPLAY-FLAG-SECURE"><a href="#VIRTUAL-DISPLAY-FLAG-SECURE" class="headerlink" title="VIRTUAL_DISPLAY_FLAG_SECURE"></a>VIRTUAL_DISPLAY_FLAG_SECURE</h4><p>创建一个secure的display</p><p>调用者将采取一些合理的措施，比如无线加密，来防止display的内容被拦截或被持久的媒介记录。</p><p>需要系统级别的 <code>CAPTURE_SECURE_VIDEO_OUTPUT</code>权限。</p><h3 id="Process-with-Image"><a href="#Process-with-Image" class="headerlink" title="Process with Image"></a>Process with Image</h3><pre class=" language-lang-java"><code class="language-lang-java">image = reader.acquireLatestImage();if (image != null) {  Image.Plane[] planes = image.getPlanes();  ByteBuffer buffer = planes[0].getBuffer();  int pixelStride = planes[0].getPixelStride();  int rowStride = planes[0].getRowStride();  int rowPadding = rowStride - pixelStride * mWidth;  bitmap = Bitmap.createBitmap(mWidth + rowPadding / pixelStride,                               mHeight, Bitmap.Config.ARGB_8888);  bitmap.copyPixelsFromBuffer(buffer);}</code></pre><p>这部分将Image对象的字节流写进Bitmap里，但是Bitmap接收的是像素格式的。</p><p>先获取图片的buffer数据，然后要把这一行buffer包含的图片宽高找出来。</p><p>获取pixelStride。因为是RGBA4个通道，所以每个像素的间距是4。</p><p>得到每行的宽度rowStride。</p><p>因为内存对齐的缘故，所以buffer的宽度会有不同。用图片宽度×像素间距得到一个大概的宽度。然后拿获取得到的宽度减去计算出的宽度，找到内存对齐的padding。</p><p>由于计算的padding还是把4通道展开一行的宽度，拿给图像就需要rowPadding / pixelStride统一单位和mWidth相加。</p><h4 id="Image-Plane的几个方法说明"><a href="#Image-Plane的几个方法说明" class="headerlink" title="Image.Plane的几个方法说明"></a>Image.Plane的几个方法说明</h4><h5 id="getBuffer"><a href="#getBuffer" class="headerlink" title="getBuffer"></a>getBuffer</h5><p>获得一个包含帧数据的ByteBuffer</p><p>In particular, the buffer returned will always have isDirect return true, so the underlying data could be mapped as a pointer in JNI without doing any copies with GetDirectBufferAddress.</p><p>For raw formats, each plane is only guaranteed to contain data up to the last pixel in the last row. In other words, the stride after the last row may not be mapped into the buffer. This is a necessary requirement for any interleaved format.</p><h5 id="getPixelStride"><a href="#getPixelStride" class="headerlink" title="getPixelStride"></a>getPixelStride</h5><p>The distance between adjacent pixel samples, in bytes.</p><p>This is the distance between two consecutive pixel values in a row of pixels. It may be larger than the size of a single pixel to account for interleaved image data or padded formats. Note that pixel stride is undefined for some formats such as <code>RAW_PRIVATE</code>, and calling getPixelStride on images of these formats will cause an UnsupportedOperationException being thrown. For formats where pixel stride is well defined, the pixel stride is always greater than 0.</p><h5 id="getRowStride"><a href="#getRowStride" class="headerlink" title="getRowStride"></a>getRowStride</h5><p>The row stride for this color plane, in bytes.</p><p>This is the distance between the start of two consecutive rows of pixels in the image. Note that row stried is undefined for some formats such as <code>RAW_PRIVATE</code>, and calling getRowStride on images of these formats will cause an UnsupportedOperationException being thrown. For formats where row stride is well defined, the row stride is always greater than 0.</p><h2 id="Problems"><a href="#Problems" class="headerlink" title="Problems"></a>Problems</h2><p>使用过程中问题总结。</p><ul><li>截屏有黑边<br>mDisplay.getMetrics(metrics);导致的。这个方法获取到的屏幕是不包含NavigationBar的高度的，所以得到的尺寸比真实的全屏要小。需要使用mDisplay.getRealMetrics(metrics);解决这个问题。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> MediaProjection </tag>
            
            <tag> 截屏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Android][Framework] Android O SystemServer启动流程</title>
      <link href="/2018/03/25/%5BAndroid%5D%5BFramework%5Dstart-of-SystemServer/"/>
      <url>/2018/03/25/%5BAndroid%5D%5BFramework%5Dstart-of-SystemServer/</url>
      
        <content type="html"><![CDATA[<p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/system_server.jpg?raw=true" alt></p><h4 id="SystemServer-main"><a href="#SystemServer-main" class="headerlink" title="SystemServer.main"></a>SystemServer.main</h4><p>SystemServer通过ZygoteInit.java反射启动，首先会进入main方法，main会构造一个新的SystemServer，然后运行run()方法</p><pre class=" language-lang-java"><code class="language-lang-java">/frameworks/base/services/java/com/android/server/SystemServer.javapublic final class SystemServer {    /**     * The main entry point from zygote.     */    public static void main(String[] args) {        new SystemServer().run();    }}</code></pre><h4 id="SystemServer-run"><a href="#SystemServer-run" class="headerlink" title="SystemServer.run"></a>SystemServer.run</h4><pre class=" language-lang-java"><code class="language-lang-java">    private void run() {        try {            traceBeginAndSlog("InitBeforeStartServices");            // 如果一个设备时间在1970年之前，很多API会crash，所以会将时间统一设置为1970年起            if (System.currentTimeMillis() < EARLIEST_SUPPORTED_TIME) {                Slog.w(TAG, "System clock is before 1970; setting to 1970.");                SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME);            }            // Default the timezone property to GMT if not set.            String timezoneProperty =  SystemProperties.get("persist.sys.timezone");            if (timezoneProperty == null || timezoneProperty.isEmpty()) {                Slog.w(TAG, "Timezone not set; setting to GMT.");                SystemProperties.set("persist.sys.timezone", "GMT");            }            // If the system has "persist.sys.language" and friends set, replace them with            // "persist.sys.locale". Note that the default locale at this point is calculated            // using the "-Duser.locale" command line flag. That flag is usually populated by            // AndroidRuntime using the same set of system properties, but only the system_server            // and system apps are allowed to set them.            //            // NOTE: Most changes made here will need an equivalent change to            // core/jni/AndroidRuntime.cpp            if (!SystemProperties.get("persist.sys.language").isEmpty()) {                final String languageTag = Locale.getDefault().toLanguageTag();                SystemProperties.set("persist.sys.locale", languageTag);                SystemProperties.set("persist.sys.language", "");                SystemProperties.set("persist.sys.country", "");                SystemProperties.set("persist.sys.localevar", "");            }            // The system server should never make non-oneway calls            Binder.setWarnOnBlocking(true);            // Here we go! 正式进入system server            Slog.i(TAG, "Entered the Android system server!");            int uptimeMillis = (int) SystemClock.elapsedRealtime();            EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_SYSTEM_RUN, uptimeMillis);            if (!mRuntimeRestart) {                MetricsLogger.histogram(null, "boot_system_server_init", uptimeMillis);            }            // In case the runtime switched since last boot (such as when            // the old runtime was removed in an OTA), set the system            // property so that it is in sync. We can | xq oqi't do this in            // libnativehelper's JniInvocation::Init code where we already            // had to fallback to a different runtime because it is            // running as root and we need to be the system user to set            // the property. http://b/11463182              // 变更虚拟机的库文件            SystemProperties.set("persist.sys.dalvik.vm.lib.2", VMRuntime.getRuntime().vmLibrary());            // Enable the sampling profiler.            if (SamplingProfilerIntegration.isEnabled()) {                SamplingProfilerIntegration.start();                mProfilerSnapshotTimer = new Timer();                mProfilerSnapshotTimer.schedule(new TimerTask() {                        @Override                        public void run() {                            SamplingProfilerIntegration.writeSnapshot("system_server", null);                        }                    }, SNAPSHOT_INTERVAL, SNAPSHOT_INTERVAL);            }            // Mmmmmm... more memory!              // 因为启动过程需要较多的虚拟机内存空间，清除vm内存增长上限            VMRuntime.getRuntime().clearGrowthLimit();            // The system server has to run all of the time, so it needs to be            // as efficient as possible with its memory usage.            // 设置内存利用率0.8            VMRuntime.getRuntime().setTargetHeapUtilization(0.8f);            // Some devices rely on runtime fingerprint generation, so make sure            // we've defined it before booting further.            // 部分机型依赖于运行时就产生指纹信息，因此需要在开机完成前定义            Build.ensureFingerprintProperty();            // Within the system server, it is an error to access Environment paths without            // explicitly specifying a user.              // 指定访问环境变量的用户            Environment.setUserRequired(true);            // Within the system server, any incoming Bundles should be defused            // to avoid throwing BadParcelableException.            BaseBundle.setShouldDefuse(true);            // Ensure binder calls into the system always run at foreground priority.              // 确保进入系统的binder调用运行高优先级            BinderInternal.disableBackgroundScheduling(true);            // Increase the number of binder threads in system_server            BinderInternal.setMaxThreads(sMaxBinderThreads);            // Prepare the main looper thread (this thread).            android.os.Process.setThreadPriority(                android.os.Process.THREAD_PRIORITY_FOREGROUND);            android.os.Process.setCanSelfBackground(false);            Looper.prepareMainLooper();            // Initialize native services.              // 加载native 库            System.loadLibrary("android_servers");            // Check whether we failed to shut down last time we tried.            // This call may not return.            performPendingShutdown();            // Initialize the system context.            createSystemContext();            // Create the system service manager.            mSystemServiceManager = new SystemServiceManager(mSystemContext);            mSystemServiceManager.setRuntimeRestarted(mRuntimeRestart);              // 添加mSystemServiceManager到本地服务成员sLocalServiceObjects 见LocalServices.java            LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);            // Prepare the thread pool for init tasks that can be parallelized            SystemServerInitThreadPool.get();        } finally {            traceEnd();  // InitBeforeStartServices        }        // Start services.        try {            traceBeginAndSlog("StartServices");            startBootstrapServices(); // 启动引导服务            startCoreServices(); // 启动核心服务            startOtherServices(); // 启动其他服务            SystemServerInitThreadPool.shutdown();        } catch (Throwable ex) {            Slog.e("System", "******************************************");            Slog.e("System", "************ Failure starting system services", ex);            throw ex;        } finally {            traceEnd();        }        // For debug builds, log event loop stalls to dropbox for analysis.        if (StrictMode.conditionallyEnableDebugLogging()) {            Slog.i(TAG, "Enabled StrictMode for system server main thread.");        }        if (!mRuntimeRestart && !isFirstBootOrUpgrade()) {            int uptimeMillis = (int) SystemClock.elapsedRealtime();            MetricsLogger.histogram(null, "boot_system_server_ready", uptimeMillis);            final int MAX_UPTIME_MILLIS = 60 * 1000;            if (uptimeMillis > MAX_UPTIME_MILLIS) {                Slog.wtf(SYSTEM_SERVER_TIMING_TAG,                        "SystemServer init took too long. uptimeMillis=" + uptimeMillis);            }        }        // Loop forever.        Looper.loop();        throw new RuntimeException("Main thread loop unexpectedly exited");    }</code></pre><p>下面看一下run函数用到的本地私有方法</p><h4 id="SystemServer-performPendingShutdown"><a href="#SystemServer-performPendingShutdown" class="headerlink" title="SystemServer.performPendingShutdown"></a>SystemServer.performPendingShutdown</h4><pre class=" language-lang-java"><code class="language-lang-java">    private void performPendingShutdown() {          // 通过检查ShutdownThread.SHUTDOWN_ACTION_PROPERTY来判断上次关机是否失败        final String shutdownAction = SystemProperties.get(                ShutdownThread.SHUTDOWN_ACTION_PROPERTY, "");        if (shutdownAction != null && shutdownAction.length() > 0) {            boolean reboot = (shutdownAction.charAt(0) == '1');            final String reason;            if (shutdownAction.length() > 1) {                reason = shutdownAction.substring(1, shutdownAction.length());            } else {                reason = null;            }            // If it's a pending reboot into recovery to apply an update,            // always make sure uncrypt gets executed properly when needed.            // If '/cache/recovery/block.map' hasn't been created, stop the            // reboot which will fail for sure, and get a chance to capture a            // bugreport when that's still feasible. (Bug: 26444951)            if (reason != null && reason.startsWith(PowerManager.REBOOT_RECOVERY_UPDATE)) {                File packageFile = new File(UNCRYPT_PACKAGE_FILE);                if (packageFile.exists()) {                    String filename = null;                    try {                        filename = FileUtils.readTextFile(packageFile, 0, null);                    } catch (IOException e) {                        Slog.e(TAG, "Error reading uncrypt package file", e);                    }                    if (filename != null && filename.startsWith("/data")) {                        if (!new File(BLOCK_MAP_FILE).exists()) {                            Slog.e(TAG, "Can't find block map file, uncrypt failed or " +                                       "unexpected runtime restart?");                            return;                        }                    }                }            }            ShutdownThread.rebootOrShutdown(null, reboot, reason);        }    }</code></pre><h4 id="SystemServer-createSystemContext"><a href="#SystemServer-createSystemContext" class="headerlink" title="SystemServer.createSystemContext"></a>SystemServer.createSystemContext</h4><pre class=" language-lang-java"><code class="language-lang-java">    private void createSystemContext() {          // 创建系统上下文并设置主题        ActivityThread activityThread = ActivityThread.systemMain();        mSystemContext = activityThread.getSystemContext();        mSystemContext.setTheme(DEFAULT_SYSTEM_THEME);        final Context systemUiContext = activityThread.getSystemUiContext();        systemUiContext.setTheme(DEFAULT_SYSTEM_THEME);    }</code></pre><h4 id="SystemServer-startBootstrapServices"><a href="#SystemServer-startBootstrapServices" class="headerlink" title="SystemServer.startBootstrapServices"></a>SystemServer.startBootstrapServices</h4><pre class=" language-lang-java"><code class="language-lang-java">    /**     * Starts the small tangle of critical services that are needed to get     * the system off the ground.  These services have complex mutual dependencies     * which is why we initialize them all in one place here.  Unless your service     * is also entwined in these dependencies, it should be initialized in one of     * the other functions.     * 这里的服务都是有复杂的依赖性，所以放在这里统一初始化。如果有与这些服务不相关的服务需要启动，应该放在其他地方去做     */    private void startBootstrapServices() {        Slog.i(TAG, "Reading configuration...");        final String TAG_SYSTEM_CONFIG = "ReadingSystemConfig";        traceBeginAndSlog(TAG_SYSTEM_CONFIG);        SystemServerInitThreadPool.get().submit(SystemConfig::getInstance, TAG_SYSTEM_CONFIG);        traceEnd();        // Wait for installd to finish starting up so that it has a chance to        // create critical directories such as /data/user with the appropriate        // permissions.  We need this to complete before we initialize other services.        traceBeginAndSlog("StartInstaller");          // 等待installd启动，使其有时间建立正确权限的目录。之后才可以初始化其他服务        Installer installer = mSystemServiceManager.startService(Installer.class);        traceEnd();        // In some cases after launching an app we need to access device identifiers,        // therefore register the device identifier policy before the activity manager.        traceBeginAndSlog("DeviceIdentifiersPolicyService");        mSystemServiceManager.startService(DeviceIdentifiersPolicyService.class);        traceEnd();        // Activity manager runs the show.        traceBeginAndSlog("StartActivityManager");          // 启动ActivityManagerService        mActivityManagerService = mSystemServiceManager.startService(                ActivityManagerService.Lifecycle.class).getService();        mActivityManagerService.setSystemServiceManager(mSystemServiceManager);        mActivityManagerService.setInstaller(installer);        traceEnd();        // Power manager needs to be started early because other services need it.        // Native daemons may be watching for it to be registered so it must be ready        // to handle incoming binder calls immediately (including being able to verify        // the permissions for those calls).          // 启动PowerManagerService，因为其他服务需要使用它，所以需要早期创建        traceBeginAndSlog("StartPowerManager");        mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class);        traceEnd();        // Now that the power manager has been started, let the activity manager        // initialize power management features.        traceBeginAndSlog("InitPowerManagement");        mActivityManagerService.initPowerManagement();        traceEnd();        // Bring up recovery system in case a rescue party needs a reboot          // 如果一个rescure party需要重启，则启动recovery          // rescure party是Android O的新特性，代码位于/services/core/java/com/android/server/RescueParty.java        if (!SystemProperties.getBoolean("config.disable_noncore", false)) {            traceBeginAndSlog("StartRecoverySystemService");            mSystemServiceManager.startService(RecoverySystemService.class);            traceEnd();        }        // Now that we have the bare essentials of the OS up and running, take        // note that we just booted, which might send out a rescue party if        // we're stuck in a runtime restart loop.          // 正常启动系统做一个标记，如果开机重启循环，就会发出一个rescure party        RescueParty.noteBoot(mSystemContext);        // Manages LEDs and display backlight so we need it to bring up the display.          // 点亮display        traceBeginAndSlog("StartLightsService");        mSystemServiceManager.startService(LightsService.class);        traceEnd();        // Display manager is needed to provide display metrics before package manager        // starts up.          // 要在package manager之前启动display manager，这样可以提供display metrics数据下去        traceBeginAndSlog("StartDisplayManager");        mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class);        traceEnd();        // We need the default display before we can initialize the package manager.          // 初始化package manager前需要default display        traceBeginAndSlog("WaitForDisplay");        mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY);        traceEnd();        // Only run "core" apps if we're encrypting the device.          // 设备在加密时，运行核心app        String cryptState = SystemProperties.get("vold.decrypt");        if (ENCRYPTING_STATE.equals(cryptState)) {            Slog.w(TAG, "Detected encryption in progress - only parsing core apps");            mOnlyCore = true;        } else if (ENCRYPTED_STATE.equals(cryptState)) {            Slog.w(TAG, "Device encrypted - only parsing core apps");            mOnlyCore = true;        }        // Start the package manager.          // 开始启动PMS        if (!mRuntimeRestart) {            MetricsLogger.histogram(null, "boot_package_manager_init_start",                    (int) SystemClock.elapsedRealtime());        }        traceBeginAndSlog("StartPackageManagerService");        mPackageManagerService = PackageManagerService.main(mSystemContext, installer,                mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);        mFirstBoot = mPackageManagerService.isFirstBoot();        mPackageManager = mSystemContext.getPackageManager();        traceEnd();        if (!mRuntimeRestart && !isFirstBootOrUpgrade()) {            MetricsLogger.histogram(null, "boot_package_manager_init_ready",                    (int) SystemClock.elapsedRealtime());        }        // Manages A/B OTA dexopting. This is a bootstrap service as we need it to rename        // A/B artifacts after boot, before anything else might touch/need them.        // Note: this isn't needed during decryption (we don't have /data anyways).        if (!mOnlyCore) {            boolean disableOtaDexopt = SystemProperties.getBoolean("config.disable_otadexopt",                    false);            if (!disableOtaDexopt) {                traceBeginAndSlog("StartOtaDexOptService");                try {                    OtaDexoptService.main(mSystemContext, mPackageManagerService);                } catch (Throwable e) {                    reportWtf("starting OtaDexOptService", e);                } finally {                    traceEnd();                }            }        }        traceBeginAndSlog("StartUserManagerService");          // UserManagerService 新建目录/data/user/        mSystemServiceManager.startService(UserManagerService.LifeCycle.class);        traceEnd();        // Initialize attribute cache used to cache resources from packages.        traceBeginAndSlog("InitAttributerCache");        AttributeCache.init(mSystemContext);        traceEnd();        // Set up the Application instance for the system process and get started.          // 设置AMS        traceBeginAndSlog("SetSystemProcess");        mActivityManagerService.setSystemProcess();        traceEnd();        // DisplayManagerService needs to setup android.display scheduling related policies        // since setSystemProcess() would have overridden policies due to setProcessGroup          // 配置displayManagerService        mDisplayManagerService.setupSchedulerPolicies();        // Manages Overlay packages          // 启动OverlayManagerService        traceBeginAndSlog("StartOverlayManagerService");        mSystemServiceManager.startService(new OverlayManagerService(mSystemContext, installer));        traceEnd();        // The sensor service needs access to package manager service, app ops        // service, and permissions service, therefore we start it after them.        // Start sensor service in a separate thread. Completion should be checked        // before using it.          // sensor service需要访问PMS,app ops service和permission service。所以基本上在最后启动。          // sensor在线程启动，访问前需要检查是否启动完成        mSensorServiceStart = SystemServerInitThreadPool.get().submit(() -> {            BootTimingsTraceLog traceLog = new BootTimingsTraceLog(                    SYSTEM_SERVER_TIMING_ASYNC_TAG, Trace.TRACE_TAG_SYSTEM_SERVER);            traceLog.traceBegin(START_SENSOR_SERVICE);            startSensorService();            traceLog.traceEnd();        }, START_SENSOR_SERVICE);    }</code></pre><p>BootstrapService整理：</p><ol><li><p><strong>Installer</strong>.class</p><p>等待installd启动，使其有时间建立正确权限的目录。之后才可以初始化其他服务。</p></li><li><p><strong>DeviceIdentifiersPolicyService</strong>.class</p><p>在activity manager之前启动该服务，提供app访问设备identifier。</p></li><li><p><strong>ActivityManagerService</strong>.Lifecycle.class</p><p>启动AMS</p></li><li><p><strong>PowerManagerService</strong>.class</p><p>启动PowerManagerService，因为其他服务需要使用它，所以需要早期创建。</p></li><li><p>mActivityManagerService.initPowerManagement();</p><p>由AMS初始化PowerManagerService</p></li><li><p><strong>RecoverySystemService</strong>.class</p><p>准备rescue party相关</p></li><li><p><strong>LightsService</strong>.class</p><p>点亮display</p></li><li><p><strong>DisplayManagerService</strong>.class</p><p>上一步点亮屏幕后，启动displayManagerService，准备display metrics数据</p></li><li><p>mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY);</p><p>systemServiceManager等待display</p></li><li><p><strong>PackageManagerService</strong>.main</p><p>启动PMS</p></li><li><p><strong>UserManagerService</strong>.LifeCycle.class</p><p>启动UserManagerService，管理多用户，创建/data/user目录</p></li><li><p>AttributeCache.init(mSystemContext);</p><p>初始化attribute cache，用来缓存从packages拿到的资源</p></li><li><p>mActivityManagerService.setSystemProcess();</p><p>设置AMS</p></li><li><p>mDisplayManagerService.setupSchedulerPolicies();</p><p>设置DisplayManagerService的schedule</p></li><li><p>new <strong>OverlayManagerService</strong></p><p>启动OverlayManagerService</p></li><li><p>start<strong>SensorService</strong>();</p><p>启动sensor服务，最后启动它，而且是在线程中启动，所以使用时需要检查完整性</p></li></ol><h4 id="SystemServer-startCoreServices"><a href="#SystemServer-startCoreServices" class="headerlink" title="SystemServer.startCoreServices"></a>SystemServer.startCoreServices</h4><p>来了解一下核心服务，核心的也就是最基本的。这些服务不会和启动阶段的进程产生影响。</p><pre class=" language-lang-java"><code class="language-lang-java">    /**     * Starts some essential services that are not tangled up in the bootstrap process.     */    private void startCoreServices() {        // Records errors and logs, for example wtf()          // 记录error和log的服务，经典的wtf的log...        traceBeginAndSlog("StartDropBoxManager");        mSystemServiceManager.startService(DropBoxManagerService.class);        traceEnd();        traceBeginAndSlog("StartBatteryService");        // Tracks the battery level.  Requires LightService.          // 统计电池的服务，需要LightService        mSystemServiceManager.startService(BatteryService.class);        traceEnd();        // Tracks application usage stats.          // 统计应用使用情况的服务        traceBeginAndSlog("StartUsageService");        mSystemServiceManager.startService(UsageStatsService.class);        mActivityManagerService.setUsageStatsManager(                LocalServices.getService(UsageStatsManagerInternal.class));        traceEnd();        // Tracks whether the updatable WebView is in a ready state and watches for update installs.        traceBeginAndSlog("StartWebViewUpdateService");        mWebViewUpdateService = mSystemServiceManager.startService(WebViewUpdateService.class);        traceEnd();    }</code></pre><ol><li><p><strong>DropBoxManagerService</strong>.class</p><p>记录error和log的服务</p></li><li><p><strong>BatteryService</strong>.class</p><p>记录电池使用的服务</p></li><li><p><strong>UsageStatsService</strong>.class</p><p>应用使用情况的服务</p></li><li><p><strong>WebViewUpdateService</strong>.class</p><p>WebView更新的服务</p></li></ol><h4 id="SystemServer-startOtherServices"><a href="#SystemServer-startOtherServices" class="headerlink" title="SystemServer.startOtherServices"></a>SystemServer.startOtherServices</h4><p>启动一些没有被重构和管理的杂项。</p><p>这个代码很长，有一千多行就不贴了。基本上如果遇到一些前面过程没提到的服务，就可以到这里面找。</p><p>这个方法内最后的代码是：</p><pre class=" language-lang-java"><code class="language-lang-java">        // We now tell the activity manager it is okay to run third party        // code.  It will call back into us once it has gotten to the state        // where third party code can really run (but before it has actually        // started launching the initial applications), for us to complete our        // initialization.        mActivityManagerService.systemReady(() -> {          ...        }</code></pre><p>这时候AMS已经启动完成，可以运行三方代码了。</p><p>参考</p><p><a href="http://gityuan.com/2016/02/20/android-system-server-2/" target="_blank" rel="noopener">http://gityuan.com/2016/02/20/android-system-server-2/</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Framework </tag>
            
            <tag> SystemServer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[MachineLearning][转载]LSTM</title>
      <link href="/2018/03/14/%5BMachingLearning%5D%5BRepost%5DUnderstanding-LSTM/"/>
      <url>/2018/03/14/%5BMachingLearning%5D%5BRepost%5DUnderstanding-LSTM/</url>
      
        <content type="html"><![CDATA[<p>转载自<a href="http://blog.csdn.net/jerr__y/article/details/58598296" target="_blank" rel="noopener">http://blog.csdn.net/jerr__y/article/details/58598296</a></p><p>@翻译：huangyongye</p><p>原文链接： <a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/" target="_blank" rel="noopener">Understanding LSTM Networks</a></p><h1 id="1-循环神经网络（RNNs"><a href="#1-循环神经网络（RNNs" class="headerlink" title="1. 循环神经网络（RNNs)"></a><strong>1. 循环神经网络（RNNs)</strong></h1><p>人们思考问题往往不是从零开始的。就好像你现在阅读这篇文章一样，你对每个词的理解都会依赖于你前面看到的一些词，而不是把你前面看的内容全部抛弃了，忘记了，再去理解这个单词。也就是说，人们的思维总是会有延续性的。</p><p>传统的神经网络是做不到这样的延续性（它们没办法保留对前文的理解），这似乎成了它们一个巨大的缺陷。举个例子，在观看影片中，你想办法去对每一帧画面上正在发生的事情做一个分类理解。目前还没有明确的办法利用传统的网络把对影片中前面发生的事件添加进来帮助理解后面的画面。</p><p>但是，循环神经网络可以做到。在RNNs的网络中，有一个循环的操作，使得它们能够保留之前学习到的内容。</p><p> <img src="http://img.blog.csdn.net/20170228153727815?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSmVycl9feQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"><br>Fig1.  RNNs 网络结构 </p><p>在上图网络结构中，对于矩形块 A 的那部分，通过输入$x_t$（t时刻特征向量），它会输出一个结果 $h_t$ （t 时刻的状态或者输出）。网络中的循环结构使得某个时刻的状态能够传到下一个时刻。（译者注：因为当前时刻的状态会作为下一时刻输入的一部分）</p><p>这些循环的结构让 RNNs 看起来有些难以理解。但是，你稍微想一下就会发现，这似乎和普通的神经网络有不少相似之处呀。我们可以把 RNNs 看成是一个普通的网络做了多次复制后叠加在一起组成的。每一网络会把它的输出传递到下一个网络中。我们可以把 RNNs 在时间步上进行展开，就得到下图这样：</p><p> <img src="http://img.blog.csdn.net/20170228155156825?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSmVycl9feQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img">  fig2. RNNs 展开网络结构</p><p>从 RNNs 链状的结构很容易理解到它是和序列信息相关的。这种结构似乎生来就是为了解决序列相关问题的。</p><p>而且，它们的的确确非常管用！在最近的几年中，人们利用 RNNs 不可思议地解决了各种各样的问题：语音识别，语言模型，翻译，图像（添加）字幕，等等。关于RNNs在这些方面取得的惊人成功，我们可以看 Andrej Karpathy 的博客： <a href="http://karpathy.github.io/2015/05/21/rnn-effectiveness/" target="_blank" rel="noopener">The Unreasonable Effectiveness of Recurrent Neural Networks.</a></p><p>RNNs 能够取得这样的成功，主要还是 LSTMs 的使用。这是一种比较特殊的 RNNs，而且对于很多任务，它比普通的 RNNs 效果要好很多很多！基本上现在所使用的循环神经网络用的都是 LSTMs，这也正是本文后面所要解释的网络。</p><h1 id="2-长时期依赖存在的问题"><a href="#2-长时期依赖存在的问题" class="headerlink" title="2. 长时期依赖存在的问题"></a><strong>2. 长时期依赖存在的问题</strong></h1><p>RNNs 的出现，主要是因为它们能够把以前的信息联系到现在，从而解决现在的问题。比如，利用前面的画面，能够帮助我们理解当前画面的内容。如果 RNNs 真的可以做到这个，那么它肯定是对我们的任务有帮助的。但是它真的可以做到吗，恐怕还得看实际情况呀！</p><p>有时候，我们在处理当前任务的时候，只需要看一下比较近的一些信息。比如在一个语言模型中，我们要通过上文来预测一下个词可能会是什么，那么当我们看到<code>the clouds are in the ?</code>时，不需要更多的信息，我们就能够自然而然的想到下一个词应该是<code>sky</code>。在这样的情况下，我们所要预测的内容和相关信息之间的间隔很小，这种情况下 RNNs 就能够利用过去的信息， 很容易的实现。</p><p> <img src="http://img.blog.csdn.net/20170228162312289?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSmVycl9feQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"><br>fig2. 短期依赖</p><p>但是，有些情况是需要更多的上下文信息。比如我们要预测<code>I grew up in France … … I speak ?</code>这个预测的词应该是 <code>Franch</code>，但是我们是要通过很长很长之前提到的信息，才能做出这个正确的预测的呀，普通的 RNNs 很难做到这个。</p><p>随着预测信息和相关信息间的间隔增大， RNNs 很难去把它们关联起来了。</p><p> <img src="http://img.blog.csdn.net/20170228163055254?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSmVycl9feQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img">  fig3. 长期依赖</p><p>从理论上来讲，通过选择合适的参数，RNNs 确实是可以把这种长时期的依赖关系（“long-term dependencies”） 联系起来，并解决这类问题的。但遗憾的是在实际中， RNNs 无法解决这个问题。 <a href="http://people.idsia.ch/~juergen/SeppHochreiter1991ThesisAdvisorSchmidhuber.pdf" target="_blank" rel="noopener">Hochreiter (1991) [German]</a> 和 <a href="http://www-dsi.ing.unifi.it/~paolo/ps/tnn-94-gradient.pdf" target="_blank" rel="noopener">Bengio, et al. (1994)</a> 曾经对这个问题进行过深入的研究，发现 RNNs 的确很难解决这个问题。</p><p>但是非常幸运，LSTMs 能够帮我们解决这个问题。</p><h1 id="3-LSTM-网络"><a href="#3-LSTM-网络" class="headerlink" title="3. LSTM 网络"></a><strong>3. LSTM 网络</strong></h1><p>长短期记忆网络（Long Short Term Memory networks） - 通常叫做 “LSTMs” —— 是 RNN 中一个特殊的类型。由Hochreiter &amp; Schmidhuber (1997)提出，广受欢迎，之后也得到了很多人们的改进调整。LSTMs 被广泛地用于解决各类问题，并都取得了非常棒的效果。</p><p>明确来说，设计 LSTMs 主要是为了避免前面提到的 长时期依赖 （long-term dependency ）的问题。它们的本质就是能够记住很长时期内的信息，而且非常轻松就能做到。</p><p>所有循环神经网络结构都是由完全相同结构的（神经网络）模块进行复制而成的。在普通的RNNs 中，这个模块结构非常简单，比如仅是一个单一的 tanh 层。</p><p> <img src="http://img.blog.csdn.net/20170228165058708?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSmVycl9feQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img">  fig4. 普通 RNNs 内部结构</p><p>LSTMs 也有类似的结构（译者注：唯一的区别就是中间部分）。但是它们不再只是用一个单一的 tanh 层，而是用了四个相互作用的层。 </p><p> <img src="http://img.blog.csdn.net/20170228165331300?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSmVycl9feQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img">  fig5. LSTM 内部结构</p><p>别担心，别让这个结构给吓着了，下面根据这个结构，我们把它解剖开，一步一步地来理解它（耐心看下去，你一定可以理解的）。现在，我们先来定义一下用到的符号： </p><p> <img src="http://img.blog.csdn.net/20170228165554195?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSmVycl9feQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img">  fig6. 符号说明</p><p>在网络结构图中，每条线都传递着一个向量，从一个节点中输出，然后输入到另一个节点中。粉红色的圆圈表示逐点操作，比如向量相加；黄色的矩形框表示的是一个神经网络层（就是很多个神经节点）；合并的线表示把两条线上所携带的向量进行合并（比如一个带 $h_t−1$ 另一个带 $x_t$ ，那么合并后的输出就是 $[h_t−1, x_t]$ ）; 分开的线表示将线上传递的向量复制一份，传给两个地方。</p><h2 id="3-1-LSTMs-的核心思想"><a href="#3-1-LSTMs-的核心思想" class="headerlink" title="3.1 LSTMs 的核心思想"></a><strong>3.1 LSTMs 的核心思想</strong></h2><p>LSTMs 最关键的地方在于 cell（整个绿色的框就是一个 cell） 的状态 和 结构图上面的那条横穿的水平线。</p><p>cell 状态的传输就像一条传送带，向量从整个 cell 中穿过，只是做了少量的线性操作。这种结构能够很轻松地实现信息从整个 cell 中穿过而不做改变。（译者注：这样我们就可以实现了长时期的记忆保留了） </p><p> <img src="http://img.blog.csdn.net/20170301105024068?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSmVycl9feQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img">  fig7.  传送带结构</p><p>若只有上面的那条水平线是没办法实现添加或者删除信息的。而是通过一种叫做 <strong>门（gates）</strong> 的结构来实现的。</p><p><strong>门</strong> 可以实现选择性地让信息通过，主要是通过一个 sigmoid 的神经层 和一个逐点相乘的操作来实现的。 </p><p> <img src="http://img.blog.csdn.net/20170301110242058?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSmVycl9feQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img">  </p><p>fig8.  门结构（sigmoid 层）</p><p>sigmoid 层输出（是一个向量）的每个元素都是一个在 0 和 1 之间的实数，表示让对应信息通过的权重（或者占比）。比如， 0 表示“不让任何信息通过”， 1 表示“让所有信息通过”。</p><p>每个 LSTM 有三个这样的门结构，来实现保护和控制信息。（译者注：分别是 “forget gate layer”, 遗忘门； “input gate layer”，传入门； “output gate layer”, 输出门）</p><h2 id="3-2-逐步理解-LSTM"><a href="#3-2-逐步理解-LSTM" class="headerlink" title="3.2 逐步理解 LSTM"></a><strong>3.2 逐步理解 LSTM</strong></h2><p>（好了，终于来到最激动的时刻了）</p><h3 id="3-2-1-遗忘门"><a href="#3-2-1-遗忘门" class="headerlink" title="3.2.1 遗忘门"></a><strong>3.2.1 遗忘门</strong></h3><p>首先是 LSTM 要决定让那些信息继续通过这个 cell，这是通过一个叫做“forget gate layer ”的sigmoid 神经层来实现的。它的输入是 $h_t−1$ 和 $x_t$,，输出是一个数值都在 0，1 之间的向量（向量长度和 cell 的状态 $C_t−1$ 一样），表示让 $C_t−1$ 的各部分信息通过的比重。 0 表示“不让任何信息通过”， 1 表示“让所有信息通过”。</p><p>回到我们上面提到的语言模型中，我们要根据<strong>所有</strong>的上文信息来预测下一个词。这种情况下，每个 cell 的状态中都应该包含了当前主语的性别信息（保留信息），这样接下来我们才能够正确地使用代词。但是当我们又开始描述一个新的主语时，就应该把上文中的主语性别给忘了才对(忘记信息)。 </p><p> <img src="http://img.blog.csdn.net/20170301112027436?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSmVycl9feQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img">  fig9.  遗忘门 (forget gates)</p><h3 id="3-2-2-传入门"><a href="#3-2-2-传入门" class="headerlink" title="3.2.2 传入门"></a><strong>3.2.2 传入门</strong></h3><p>下一步是决定让多少新的信息加入到 cell 状态 中来。实现这个需要包括两个 步骤：首先，一个叫做“input gate layer ”的 sigmoid 层决定哪些信息需要更新；一个 tanh 层生成一个向量，也就是备选的用来更新的内容，$\tilde{C_t}$ 。在下一步，我们把这两部分联合起来，对 cell 的状态进行一个更新。</p><p> <img src="http://img.blog.csdn.net/20170301115512234?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSmVycl9feQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"><br>fig10.  传入门 (input gates)</p><p>在我们的语言模型的例子中，我们想把新的主语性别信息添加到 cell 状态中，来替换掉老的状态信息。<br>有了上述的结构，我们就能够更新 cell 状态了， 即把 $C_t−1$ 更新为 $C_t$ 。从结构图中应该能一目了然， 首先我们把旧的状态 $C_t−1$ 和 $f_t$ 相乘， 把一些不想保留的信息忘掉。然后加上 $i_t * \tilde{C_t}$ 。这部分信息就是我们要添加的新内容。</p><p> <img src="http://img.blog.csdn.net/20170301120227745?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSmVycl9feQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img">  fig11.  更新 cell 状态 </p><h3 id="3-2-3-输出门"><a href="#3-2-3-输出门" class="headerlink" title="3.2.3 输出门"></a><strong>3.2.3 输出门</strong></h3><p>最后，我们需要来决定输出什么值了。这个输出主要是依赖于 cell 的状态 $C_t$，但是又不仅仅依赖于 $C_t$，而是需要经过一个过滤的处理。首先，我们还是使用一个 sigmoid 层来（计算出）决定 $C_t$ 中的哪部分信息会被输出。接着，我们把 $C_t$ 通过一个 tanh 层（把数值都归到 -1 和 1 之间），然后把 tanh  层的输出和 sigmoid 层计算出来的权重相乘，这样就得到了最后输出的结果。</p><p>在语言模型例子中，假设我们的模型刚刚接触了一个代词，接下来可能要输出一个动词，这个输出可能就和代词的信息相关了。比如说，这个动词应该采用单数形式还是复数的形式，那么我们就得把刚学到的和代词相关的信息都加入到 cell 状态中来，才能够进行正确的预测。</p><p> <img src="http://img.blog.csdn.net/20170301121358058?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSmVycl9feQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img">  fig12.  cell 输出</p><h1 id="4-LSTM-的变种-GRU"><a href="#4-LSTM-的变种-GRU" class="headerlink" title="4. LSTM 的变种 GRU"></a><strong>4. LSTM 的变种 GRU</strong></h1><p>原文这部分介绍了 LSTM 的几个变种，还有这些变形的作用。在这里我就不再写了。有兴趣的可以直接阅读原文。</p><p>下面主要讲一下其中比较著名的变种 GRU（Gated Recurrent Unit ），这是由 <a href="https://arxiv.org/pdf/1406.1078v3.pdf" target="_blank" rel="noopener">Cho, et al. (2014)</a> 提出。在 GRU 中，如 fig.13 所示，只有两个门：重置门（reset gate）和更新门（update gate）。同时在这个结构中，把细胞状态和隐藏状态进行了合并。最后模型比标准的 LSTM 结构要简单，而且这个结构后来也非常流行。 </p><p> <img src="http://img.blog.csdn.net/20170509215601173?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSmVycl9feQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img">  fig13.  GRU结构 </p><p>其中， $r_t$ 表示重置门，$z_t$ 表示更新门。<strong>重置门决定是否将之前的状态忘记。（作用相当于合并了 LSTM 中的遗忘门和传入门）</strong>当 $r_t$ 趋于 0 的时候，前一个时刻的状态信息 $h_t−1$ 会被忘掉，隐藏状态 $\tilde{h_t}$ 会被重置为当前输入的信息。<strong>更新门决定是否要将隐藏状态更新为新的状态</strong> $\tilde{h_t}$ <strong>（作用相当于 LSTM 中的输出门）</strong> 。</p><p>和 LSTM 比较一下：</p><ol><li>GRU 少一个门，同时少了细胞状态 $C_t$</li><li>在 LSTM 中，通过遗忘门和传入门控制信息的保留和传入；GRU 则通过重置门来控制是否要保留原来隐藏状态的信息，但是不再限制当前信息的传入。</li><li>在 LSTM 中，虽然得到了新的细胞状态 $C_t$，但是还不能直接输出，而是需要经过一个过滤的处理： $h_t=o_t <em> tanh(C_t)$ ； 同样，在 GRU 中, 虽然 (2) 中我们也得到了新的隐藏状态 $\tilde{h_t}$， 但是还不能直接输出，而是通过更新门来控制最后的输出： $h_t=(1−z_t) </em> h_t−1+z_t * \tilde{h_t}$</li></ol>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> LSTM </tag>
            
            <tag> RNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[MachineLearning] 激活函数Activation Function</title>
      <link href="/2018/03/14/%5BMachineLearning%5DActivation-Function/"/>
      <url>/2018/03/14/%5BMachineLearning%5DActivation-Function/</url>
      
        <content type="html"><![CDATA[<p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/activation00.png?raw=true" alt></p><h4 id="为什么需要激活函数"><a href="#为什么需要激活函数" class="headerlink" title="为什么需要激活函数"></a>为什么需要激活函数</h4><p>神经网络中激活函数的主要作用是提供网络的非线性建模能力，如不特别说明，激活函数一般而言是非线性函数。假设一个示例神经网络中仅包含线性卷积和全连接运算，那么该网络仅能够表达线性映射，即便增加网络的深度也依旧还是线性映射，难以有效建模实际环境中非线性分布的数据。加入（非线性）激活函数之后，深度神经网络才具备了分层的非线性映射学习能力。因此，激活函数是深度神经网络中不可或缺的部分。</p><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/activation01.png?raw=true" alt></p><p>理想的激活函数是阶跃函数，把输入数据映射为激活（1）和抑制（0）。但阶跃函数的问题是不连续不光滑。这个问题主要反映在计算梯度（求偏导）的过程中。</p><p>激活函数常用上图右边的<strong>Sigmoid</strong>函数。它可以把输入值挤压到（0,1）的范围中。</p><p>从Sigmoid能看出一些激活函数的特点，同时还有一些其他特点：</p><ul><li><strong>非线性：</strong>当激活函数是线性的时候，一个两层的神经网络就可以逼近基本上所有的函数了。但是，如果激活函数是恒等激活函数的时候（即$f(x) = x$ ），就不满足这个性质了，而且如果MLP使用的是恒等激活函数，那么其实整个网络跟单层神经网络是等价的。</li><li><strong>可微性：</strong>当优化方法是基于梯度的时候，这个性质是必须的。</li><li><strong>单调性：</strong> 当激活函数是单调的时候，单层网络能够保证是凸函数。</li><li><strong>$f(x) \approx x$：</strong>当激活函数满足这个性质的时候，如果参数的初始化是random的很小的值，那么神经网络的训练将会很高效；如果不满足这个性质，那么就需要很用心的去设置初始值。</li><li><strong>输出值的范围：</strong> 当激活函数输出值是 <strong>有限</strong> 的时候，基于梯度的优化方法会更加 <strong>稳定</strong>，因为特征的表示受有限权值的影响更显著；当激活函数的输出是 <strong>无限</strong> 的时候，模型的训练会更加高效，不过在这种情况小，一般需要更小的learning rate.</li></ul><h4 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h4><h5 id="Sigmoid"><a href="#Sigmoid" class="headerlink" title="Sigmoid"></a>Sigmoid</h5><p>最常见的激活函数。</p><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/activation_sigmoid.jpg?raw=true" alt></p><p>Sigmoid在定义域内处处可导，两侧的倒数逐渐趋近于0，即：$\displaystyle \lim_{x \to \infty}f’(x)=0$.（也称作软饱和激活函数）</p><p>Sigmoid导数：</p><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/activation_sigmoid_0.jpg?raw=true" alt></p><p><strong>优点：</strong></p><ul><li>物理意义上最接近神经元</li><li>(0,1)的输出可以表示作概率</li><li>用于输入的归一化</li></ul><p><strong>缺点：</strong></p><ul><li>函数不是0均值，而是以(0, 0.5)为中心。这会导致后一层神经元将得到上一层输出的非0均值的信号作为输入。所以数据进入神经元是正的，w计算出的梯度也始终是正的。用batch去训练可以得到不同信号，可以缓解。</li></ul><ul><li>在后向传播过程中，sigmoid向下传导的梯度包含了 $f’(x)$ 因子，因此一旦输入落入饱和区，$f’(x)$ 就接近于0，导致向底层传递的梯度变得非常小。这就是所谓的<strong>梯度消失</strong>。（在反向传播中，会计算每一层的梯度，链式法则相乘。）</li></ul><blockquote><p>一般来说，sigmoid网络在5层之内就产生<strong>梯度消失</strong>。（sigmoid导数的最大值是0.25，意味着导数每一层至少压缩到原来的1/4，经过5层就非常小了。）</p><p>优化办法：<a href>后续会发出来介绍</a></p><ul><li>DBN的预训练</li><li>Batch Normalization逐层归一化</li><li>Xavier和MSRA权重初始化</li></ul></blockquote><p><strong>代表：</strong>sigmoid交叉熵损失函数</p><h5 id="tanh"><a href="#tanh" class="headerlink" title="tanh"></a>tanh</h5><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/activation_tanh.jpg?raw=true" alt></p><p>tanh实际上是sigmoid的变形：</p><script type="math/tex; mode=display">tanh(x) = 2sigmoid(2x) - 1</script><p>tanh也有软饱和性，所以也有梯度消失的问题。</p><p>由于tanh的输出均值比sigmoid更接近0，SGD会更接近natural gradient，从而降低所需的迭代次数，所以tanh收敛速度比sigmoid更快。</p><h5 id="ReLU"><a href="#ReLU" class="headerlink" title="ReLU"></a>ReLU</h5><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/activation_relu.jpg?raw=true" alt></p><p>ReLU的导数：</p><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/activation_relu_0.jpg?raw=true" alt></p><blockquote><p>虽然2006年Hinton教授提出通过分层无监督预训练解决深层网络训练困难的问题(比如DBN？)，但是深度网络的直接监督式训练的最终突破，最主要的原因是采用了新型激活函数ReLU</p></blockquote><p><strong>优点：</strong></p><ul><li>ReLU函数其实就是<code>max(x, 0)</code>函数，所以计算量比前两者小，计算速度也快。</li><li>ReLU 在x\<0 时硬饱和。由于 x\>0时导数为 1，所以，ReLU 能够在x>0时保持梯度不衰减，从而缓解梯度消失问题。</0></li><li>在x&lt;0时结果取0，提供神经网络的稀疏表达能力。（类似dropout缓解过拟合？不过实验验证，ReLU的稀疏性与网络性能之间并不存在绝对正负比关系。）</li><li>Relu激活函数可以极大地加快收敛速度，相比tanh函数，收敛速度可以加快6倍</li></ul><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/activation_relu_improve.png?raw=true" alt></p><p><strong>缺点：</strong></p><ul><li>随着训练推进，部分输入会落入硬饱和区，导致对应权重无法更新。这种现象被称为<strong>神经元死亡</strong>。</li><li>输出具有偏移现象，即输出均值恒大于0</li></ul><blockquote><p>本文作者公开在arxiv的文章中的实验表明，如果不采用Batch Normalization，即使用 MSRA 初始化30层以上的ReLU网络，最终也难以收敛。</p><p>关于<strong>神经元死亡</strong>：</p><p>比如计算出一个很大的梯度 $\nabla w $，反向传播后  $w - \nabla w$ 使得优化后的 $w$ 变成负数，接着正向传播这个神经元就不会对任何数据有激活现象了。实际操作中，如果你的learning rate 很大，那么很有可能你网络中的40%的神经元都”dead”了。  当然，如果你设置了一个合适的较小的learning rate，这个问题发生的情况其实也不会太频繁。</p></blockquote><h4 id="激活函数的选择"><a href="#激活函数的选择" class="headerlink" title="激活函数的选择"></a>激活函数的选择</h4><p>由于sigmoid可以看做概率，所以在输出层使用sigmoid比较多。</p><p>隐藏层中，ReLU的优秀的计算速度和收敛速度都让其成为一个首选。</p><p>ReLU还有很多其他变种，可以参考最后的链接阅读学习。</p><h4 id="参考和阅读"><a href="#参考和阅读" class="headerlink" title="参考和阅读:"></a>参考和阅读:</h4><blockquote><p><a href="http://blog.csdn.net/cyh_24/article/details/50593400" target="_blank" rel="noopener">【机器学习】神经网络-激活函数-面面观(Activation Function) </a></p><p><a href="http://www.cnblogs.com/ranjiewen/p/5918457.html" target="_blank" rel="noopener">激活函数导引</a></p><p><a href="https://www.jiqizhixin.com/articles/2017-10-10-3" target="_blank" rel="noopener">26种神经网络激活函数可视化</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> Sigmoid </tag>
            
            <tag> ReLU </tag>
            
            <tag> 激活函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title> [深度学习]Charpter 9:卷积网络</title>
      <link href="/2018/02/14/%5BDeepLearning%5D%5BCharpter%209%5DCNN/"/>
      <url>/2018/02/14/%5BDeepLearning%5D%5BCharpter%209%5DCNN/</url>
      
        <content type="html"><![CDATA[<p><code>卷积网络</code>convolutional network,也叫做<code>卷积神经网络</code>convolutional neural network CNN<br>专门用来处理类似<strong>网格结构</strong>数据的神经网络.<br>比如</p><ul><li>时间序列,轴上的一维网格</li><li>图像数据,二维像素网格<br>我们把至少在网络中一层中使用卷积运算来替代一般的矩阵乘法运算的神经网络 称为 卷积网络</li></ul><h4 id="卷积-convolution"><a href="#卷积-convolution" class="headerlink" title="卷积 convolution"></a>卷积 convolution</h4><p>CNN中用到的卷积和其他领域的定义并不完全一致</p><blockquote><p>关于数学概念,参考这里<a href="https://www.zhihu.com/question/22298352" target="_blank" rel="noopener">如何通俗易懂地解释卷积？</a></p></blockquote><p>卷积公式</p><script type="math/tex; mode=display">s(t) = \int x(a)w(t-a)da</script><p>卷积运算通常用星号表示</p><script type="math/tex; mode=display">s(t)=(x*w)(t)</script><p>在卷积网络的术语中,卷积的第一个参数(函数x)通常叫做<strong>输入(input)</strong>,第二个参数(函数w)叫做<strong>核函数(kernel function)</strong>.输出有时被称作<strong>特征映射(feature map)</strong></p><blockquote><p>在模型检测的文章里经常会提到<strong>feature map</strong>,所以这个要记住</p></blockquote><p>上面求积分是考虑连续的情况,离散的卷积如下:</p><script type="math/tex; mode=display">s(t)=(x*w)(t)=\sum_{a=-\infty}^\infty x(a)w(t-a)</script><p>在机器学习中,输入通常是多维数组(Tensor),而核通常是由学习算法优化得到的多维数组的参数.</p><blockquote><p>因为在输入与核中的每一个元素都必须明确地分开存储,我们通常假设在存储了数值的有限点集以外,这<br>些函数的值都为零。这意味着在实际操作中,我们可以通过对有限个数组元素的求和来实现无限求和。</p></blockquote><p>这句话我的理解是,以图像为例,处理图像边界会扩展图片尺寸,扩展的部分都用0填充.”无限求和”就不太清楚了.</p><p>提到图片,二维输入配上二维核的卷积:</p><script type="math/tex; mode=display">S(i,j) = (I * K)(i,j) = \sum_{m} \sum_{n} I(m, n)K(i-m, j-n)</script><p>卷积是可交换(commutative)的,公式等价为</p><script type="math/tex; mode=display">S(i,j) = (K * I)(i,j) = \sum_{m} \sum_{n} I(i-m, j-n)K(m, n)</script><p><strong>公式怎么理解?</strong></p><p>可交换性是因为将核相对输入进行了翻转,从m增大角度看,输入索引增大,核的索引在减小.这个性质在神经网络并不是重要的性质.</p><p>通常,下面的式子在机器学习库中实现更简单,因为m和n的有效取值范围相对较小,称为<strong>互相关函数(cross-correlation)</strong>,和卷积运算几乎一样但没有对核翻转:</p><script type="math/tex; mode=display">S(i,j) = (I * K)(i,j) = \sum_{m} \sum_{n} I(i+m, j+n)K(m, n)</script><h4 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h4><p>卷积运算通过三个重要思想改进机器学习系统:</p><ul><li>稀疏交互 sparse interactions</li><li>参数共享 parameter sharing</li><li>等变表示 equivariant representations</li></ul><p>传统神经网络使用矩阵乘法建立输入输出的连接关系(也就是全连接),然而卷积网络具有<strong>稀疏交互</strong>的特征.使核的大小远小于输入大小完成.我们用小的核检测那些小的且有意义的特征.</p><p>这样,意味着:</p><ol><li>存储参数更少,减少模型存储需求,提高统计效率</li><li>计算量减少,效率提高</li></ol><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/DL-09-1.png?raw=true" alt></p><p>图中稀疏连接,图中输出单元$g_{3}$只受到$h_{2},h_{3},h_{4}$的影响,它们称为$g_{3}$的<strong>接受域receptive field</strong>也叫做<strong>感受野</strong></p><p>处于卷积更深层网络层的单元,它们的感受野比浅层的更大.这意味着,卷积网络中深层单元可以间接连接到全部或者大部分输入图像.</p><p><strong>参数共享</strong>是指在一个模型的多个函数中使用相同的参数.</p><p>传统神经网络,权重矩阵每个元素只用一次.而用卷积,用于一个输入的权重也会绑定在其他权重上.相当于学会一套权重,应用于所有输入位置上.</p><p>参数共享的形式使得神经网络具有对<strong>平移等变性</strong>.</p><p>如果一个函数满足输入改变,输出也以同样方式改变这一性质,就认为其是等变的.</p><p>公式表示就不展示了,用实际例子说明一下:</p><ul><li>一维情况,比如时间序列,通过卷积可以得到由输入中出现不同特征的时刻组成的时间轴.如果把一个输入事件延后,输出中仍然会有相同表示,只是时间延后了</li><li>二维,卷积产生一个二维映射表明某些特征在输入中出现的位置.如果移动输入中的对象,它的表示也会在输出中移动同样的量.</li></ul><h4 id="池化"><a href="#池化" class="headerlink" title="池化"></a>池化</h4><p>池化函数使用某一位置的相邻输出的总体统计特征来代替网络在该位置的输出.</p><p>常用的有最大池化,相邻矩形区域平均值,L2范数以及基于据中心像素距离加权平均.</p><p>不管哪种池化,当输入发生<strong>少量</strong>平移,池化可以帮助输入表示近似不变,即大多数输出不会发生改变.</p><blockquote><p>局部平移不变性是一个很有用的性质,尤其是当我们关心某个特征是否出现<br>而不关心它出现的具体位置时</p></blockquote><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/DL-09-2.png?raw=true" alt></p><p>如图,最大池化引入不变性.下面一行全部变化,上面一行输出只变了一半.</p><p>使用池化可以看做是增加了一个无限强的先验:这一层学得的函数必须具有对少量平移的不变性.</p><p>因为池化综合了全部邻居的反馈,这使得池化单元少于探测单元成为可能,我们可以通过综合池化区域的 k 个像素的统计特征而不是单个像素来实现。</p><p>在很多任务中,池化对于处理不同大小的输入具有重要作用。例如我们想对不同大小的图像进行分类时,分类层的输入必须是固定的大小,而这通常通过调整池化区域的偏置大小来实现,这样分类层总是能接收到相同数量的统计特征而不管最初的输入大小了。例如,最终的池化层可能会输出四组综合统计特征,每组对应着图像的一个象限,而与图像的大小无关。</p><h4 id="卷积与池化作为一种无限强的先验-纯理论-完全摘抄"><a href="#卷积与池化作为一种无限强的先验-纯理论-完全摘抄" class="headerlink" title="卷积与池化作为一种无限强的先验 (纯理论,完全摘抄)"></a>卷积与池化作为一种无限强的先验 (纯理论,完全摘抄)</h4><p>先验概率分布(prior probability distribution)是一个模型参数的概率分布,它刻画了在我们看到数据之前我们认为什么样的模型是合理的信念。</p><p>先验被认为是强或者弱取决于先验中概率密度的集中程度。</p><p>弱先验具有较高的熵值,例如方差很大的高斯分布。这样的先验允许数据对于参数的改变具有或多或少的自由性</p><p>强先验具有较低的熵值,例如方差很小的高斯分布。这样的先验在决定参数最终取值时起着更加积极的作用。</p><p>一个无限强的先验需要对一些参数的概率置零并且完全禁止对这些参数赋值,无论数据对于这些参数的值给出了多大的支持。</p><p>我们可以把卷积网络类比成全连接网络,但对于这个全连接网络的权重有一个无限强的先验。这个无限强的先验是说一个隐藏单元的权重必须和它邻居的权重相同,但可以在空间上移动。这个先验也要求除了那些处在隐藏单元的小的空间连续的接受域内的权重以外,其余的权重都为零。总之,我们可以把卷积的使用当作是对网络中一层的参数引入了一个无限强的先验概率分布。这个先验说明了该层应该学得的函数只包含局部连接关系并且对平移具有等变性。类似的,使用池化也是一个无限强的先验:每一个单元都具有对少量平移的不变性。</p><p>当然,把卷积神经网络当作一个具有无限强先验的全连接网络来实现会导致极大的计算浪费。但把卷积神经网络想成具有无限强先验的全连接网络可以帮助我们更好地洞察卷积神经网络是如何工作的。</p><p>其中一个关键的洞察是卷积和池化可能导致欠拟合。与任何其他先验类似,卷积和池化只有当先验的假设合理且正确时才有用。如果一项任务依赖于保存精确的空间信息,那么在所有的特征上使用池化将会增大训练误差。一些卷积网络结构 (Szegedy et al., 2014a) 为了既获得具有较高不变性的特征又获得当平移不变性不合理时不会导致欠拟合的特征,被设计成在一些通道上使用池化而在另一些通道上不使用。当一项任务涉及到要对输入中相隔较远的信息进行合并时,那么卷积所利用的先验可能就不正确了。</p><p>另一个关键洞察是当我们比较卷积模型的统计学习表现时,只能以基准中的其他卷积模型作为比较的对象。其他不使用卷积的模型即使我们把图像中的所有像素点都置换后依然有可能进行学习。对于许多图像数据集,还有一些分别的基准,有些是针对那些具有 置换不变性(permutation invariant)并且必须通过学习发现拓扑结构的模型,还有一些是针对模型设计者将空间关系的知识植入了它们的模型。</p><h4 id="基本卷积函数的变体"><a href="#基本卷积函数的变体" class="headerlink" title="基本卷积函数的变体"></a>基本卷积函数的变体</h4><p>首先,当我们提到神经网络中的卷积时,我们通常是指由多个并行卷积组成的运算。这是因为具有单个核的卷积只能提取一种类型的特征,尽管它作用在多个空间位置上。所以可以看到,很多卷积网络每一层都会有256个或者其他数目的卷积核,都是为了尽量多地提取特征.</p><p>另外,输入通常也不仅仅是实值的网格,而是由一系列观测数据的向量构成的网格。比如图像,除了宽高维度,还有颜色通道.</p><p>因为卷积网络通常使用多通道的卷积,所以即使使用了核翻转,也不一定保证网络的线性运算是可交换的。只有当其中的每个运算的输出和输入具有相同的通道数时,这些多通道的运算才是可交换的</p><p>零填充(英文和TF中参数一样,记住对编程有帮助):</p><ul><li><p>有效卷积 valid</p><p>无论怎样都不使用零填充.输出像素更加规范,但导致每一层网络都在减小.</p></li><li><p>相同卷积 same</p><p>用足够的零填充保持输入输出具有相同的大小.但边界像素欠表示</p></li><li><p>全卷积 full (很少用)</p><p>进行足够的零填充,保证每个像素在每个方向上被访问相同次数.导致输出靠近边界部分比中间部分是更少像素的函数,学得一个在所有位置都表现良好的核难度加大.</p></li></ul><p>在一些情况下,我们并不是真的想使用卷积,而是想用一些局部连接的网络层。在这种情况下,我们的多层感知机对应的邻接矩阵是相同的,但每一个连接都有它自己的权重.这有时也被称为 非共享卷积(unshared convolution),因为它和具有一个小核的离散卷积运算很像,但并不横跨位置来共享参数。</p><p>当我们知道每一个特征都是一小块空间的函数并且相同的特征不会出现在所有的空间上时,局部连接层是很有用的。例如,如果我们想要辨别一张图片是否是人脸图像时,我们只需要去寻找嘴是否在图像下半部分即可。</p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Deep Learning </tag>
            
            <tag> CNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Android]相册列表加载过程性能优化</title>
      <link href="/2018/02/10/%5BAndroid%5Doptimize-gallery-album-loader/"/>
      <url>/2018/02/10/%5BAndroid%5Doptimize-gallery-album-loader/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在手机中有多个存有图片的文件夹，在recent界面清掉所有的应用，点击进入图库，切换到相册列表。发现要过几秒钟才能从空白页面开始显示文件夹。同时会引起另一问题，在有大量图片文件夹的情况下删除一个文件夹，这个被删除的文件夹还会在界面上显示一段时间，要过好几秒才会被覆盖掉。</p><h2 id="分析与解决"><a href="#分析与解决" class="headerlink" title="分析与解决"></a>分析与解决</h2><p>优化整体分为几个部分，由于当时第一手截图和log都没有保存，所以整体以记录修改思路为主。</p><h3 id="优化一"><a href="#优化一" class="headerlink" title="优化一"></a>优化一</h3><p>一般面对性能优化问题，首先要定位问题。有两个入手方向:</p><ol><li>从代码逻辑角度分析，在代码流程关键处添加Log，通过复现操作观察哪些Log不符合预期。比如这个问题，就是每次刷新相册列表的时候， 刷新行为表现的很慢，可以很容易找到出问题的代码段。</li><li>从 <code>traceView</code> 分析，适合性能异常不确定的问题。比如 Gallery 的启动速度，启动流程涉及很多流程，没 法从逻辑角度确定出问题的代码段。 </li></ol><p>针对当前问题，可以很明确是刷新相册列表的时候某些地方做了一些耗时的操作。所以就要先看看每次刷新列表的时候程序到底干了些什么。因此，需要打一个完整的 log 看看刷新的流程。<br>通过分析 log (很多 log 并没有保存，所以只做文字描述)，一个感觉到异常的地方是：刷新相册的时候，打印出了数十个重复的相册名称，而且不同相册名重复的次数不一样。 </p><p>所以查找打印相关 Log 的代码，发现是方法 <code>ListAlbumSetDataAdapter.setLayoutInfo()</code>中打印的。这也就意 味着这个方法进行了多次执行。 </p><p>对照 traceView，这个方法的确是出现耗时问题的一个地方。 </p><p>那么这个方法是做什么的呢? 这个方法就是对相册列表的每一项进行封面图像和文字更新的方法。因为涉及到了封面图像的生成显示，所以会比较耗时。而大量调用这个方法会导致这个耗时线性增加。像我手机里有 6 个相册，这个方法却执行了数十次。 </p><p>那么是谁在调用这个方法呢?<br>有两个地方，<code>ListAlbumSetDataAdapter.updateView()</code> 和 <code>ListAlbumSetDataAdapter.getView()</code></p><p>先看 <code>updateView()</code>，这个方法是我们自己定义的:<br> 通过在 <code>updateView()</code>处打印堆栈信息，一层层向上查看方法调用顺序，最终发现在 <code>AlbumSetSlidingWindow.updateAllImageRequests()</code>处调用的时候进行了二级循环，进而导致 <code>updateView()</code>循环多次调用。 </p><pre class=" language-lang-java"><code class="language-lang-java">for (int i = mActiveStart, n = mActiveEnd; i < n; ++i) {     AlbumSetEntry entry = mData[i % mData.length];     for (int j = 0; j < entry.coverLoader.size(); j++) {         if (startLoadBitmap(entry.coverLoader.get(j))) ++mActiveRequestCount;     }     ... }</code></pre><p>外层循环是更新每个相册，内层循环是对当前相册内图片进行更新。但对相册来说只需要更新第一张封面图<br>片即可，所以对这里内层循环可以进行优化。否则遇到很多图片的相册，对每张图片循环一次的开销太大了:</p><pre class=" language-lang-java"><code class="language-lang-java">for (int i = mActiveStart, n = mActiveEnd; i < n; ++i) {     AlbumSetEntry entry = mData[i % mData.length];     if (entry.coverLoader.size > 0) {         startLoadBitmap(entry.coverLoader.get(0));     }     ... } ++mActiveRequestCount;</code></pre><blockquote><p>优化期间和开发的同事讨论中得知有一个地方设置了一个 12 的范围，但不确定对这里执行有什么影响。我 在看 log 的时候，恰好发现了一个包含很多图片的相册打印了 12 次，而其他相册只打印了几次，所以猜想好 像相册图片超过 12 张就会只打印 12 次，于是新建一个相册尝试了一下，发现的确是这样。所以定位到设置 12 的代码，是在 MediaSet.getCoverMediaItem()处。看了一下代码，这里 12 是返回数组最大范围，相册有超过 12 张图片就返回 12 张。然而对返回的这 12 张之后的操作，结合代码并没有发现特别的操作，反而导致 setLayoutInfo()多执行了很多遍。所以这里也进行了优化。把 12 改成 1。对照AOSP源码，源码在这里也是用的 1。 </p></blockquote><p>经过后来一系列分析，发现改动这个 12 的效果和改动上面的循环是一样的。原因如下: 在 <code>AlbumSetDataLoader.reloadTask.run()</code> 中，会进行图片的加载，其中有一句: </p><pre class=" language-lang-java"><code class="language-lang-java">info.cover = info.item.getCoverMediaItem();</code></pre><p>就是获取我们把 list.size 从 12 改为 1 的地方。所以这里 info.cover 保存的 list.size = 1。 </p><p>赋值之后会执行: </p><pre class=" language-lang-java"><code class="language-lang-java">executeAndWait(new UpdateContent(info));</code></pre><p>在 UpdateContent(info)中，会执行这段代码: </p><pre class=" language-lang-java"><code class="language-lang-java">mCoverItem[pos] = info.cover;</code></pre><p>这个 mCoverItem[]是干什么的?他的作用体现在 <code>AlbumSetDataLoader.getCoverItem()</code>中: </p><pre class=" language-lang-java"><code class="language-lang-java">public List<MediaItem> getCoverItem(int index) {    try {        assertIsActive(index);     } catch (Exception e) {        e.printStackTrace();        return null;     }    return mCoverItem[index % mCoverItem.length]; }</code></pre><p>这个 getCoverItem()是被 <code>AlbumSetSlidingWindow.updateAlbumSetEntry()</code>处调用: </p><pre class=" language-lang-java"><code class="language-lang-java">List<MediaItem> cover = mSource.getCoverItem(slotIndex); ...if(cover != null) {     resetEntry(entry, cover.size());     for (int i = cover.size() -1 ; i >= 0 ; i--) {         ...         entry.coverLoader.set(....)         ...     } } ...</code></pre><p>所以这里就看明白了，<code>entry.coverLoader.size</code> 是和 <code>getCoverMediaItem()</code> 相关的。因此这两处改动一处即 可。 </p><h3 id="优化二"><a href="#优化二" class="headerlink" title="优化二"></a>优化二</h3><p>再看 getView()方法:<br>getView() 是 BaseAdapter 的方法，是每次刷新 List 都会调用的方法。<br>从 log 信息可以看到，在我有 <strong>5</strong> 个相册的时候，getView()执行了 <strong>150</strong> 次，也就是每个相册遍历了 <strong>30</strong> 遍。 </p><p>关于 getView()方法的调用，一般是和布局文件的复杂度相关的，尤其是对没有指定 cell 高度的 listView， 系统需要模拟加载这些 view 去进行计算，然后计算得出一个高度，之后再把真正的 cell 加载出来。所以出 现 getView()重复调用的情况，就要关注一下布局情况。 </p><p>找到 list 相关界面布局文件 albumset_fragment.xml </p><pre class=" language-lang-xml"><code class="language-lang-xml"><com.tct.gallery3d.ui.DragListView     android:layout_marginTop="60dp"      android:background="#f8f8f8"      android:dividerHeight="5dp"      android:divider="#f8f8f8"     android:id="@+id/drag_list_view"     android:layout_width="match_parent"     android:layout_height="wrap_content" /></code></pre><p>看到列表的 <code>layout_height</code> 是 <code>wrap_content</code>，这个地方就会有问题，因为是 <code>wrap_content</code>，列表计算高度 的时候就会先试着加载所有 cell，算出真正的高度，然后再去加载一遍 cell，算出界面需要显示的 cell 的数 量，确定之后再真正加载一遍(大概是这样)。如果相册很多，每次滑动也都会重复这些操作。 所以这里如果把 <code>layout_height</code> 改为 <code>match_parent</code>，那就为系统省去了很多计算。 </p><p>改动后再看 log，发现 <strong>5</strong> 个相册的情况下，getView()只执行了 <strong>30</strong> 次，改之前可是执行了 150 次! </p><p>这时候再从 <code>traceView</code> 查找耗时操作，很明显的看到另一个耗时大户露出了尾巴: <code>LocalMergeAlbum.getTotalMediaItemCount()</code>方法。</p><h3 id="优化三"><a href="#优化三" class="headerlink" title="优化三"></a>优化三</h3><p>回到之前的大尾巴:<code>LocalMergeAlbum.getTotalMediaItemCount()</code>，这个方法会执行到另一处方法 <code>LocalAlbum.getMediaItemCount()</code>。 </p><p>同样的问题：这个方法是干什么的？<code>LocalAlbum.getMediaItemCount()</code>执行了数据库的查询操作，其实是获取当前相册的图片信息。 </p><p>谁在调用它? 在该方法里打印堆栈信息，发现好多地方在调用它，但是某个方法的一次执行，导致了连续重复 3-4 次调用数据库查询，这引起了我的注意。</p><pre class=" language-lang-java"><code class="language-lang-java">public int getTotalMediaItemCount() {    int count = 0;    mVideoCount = 0;     for (MediaSet set : mSources) { ---------------4         if(null == set)             continue;         count += set.getTotalMediaItemCount(); -------- 1         if(GalleryActivity.TV_LINK_DRM_HIDE_FLAG){             count -= set.getDrmCount();        }         if(set.getMediaSetType() == MEDIASET_TYPE_VIDEO){ -------------2             if (set instanceof LocalAlbum) {                 mVideoCount = ((LocalAlbum)set).getTotalMediaItemVideoCount();             } else if (set instanceof FavoriteAlbum) {                 mVideoCount = ((FavoriteAlbum)set).getTotalMediaItemVideoCount(); }             }         Log.i(TAG, "-----combo++sub--count-"+set.getTotalMediaItemCount()); -----------3      }     return count;}</code></pre><p>如代码所示，<code>LocalMergeAlbum.getTotalMediaItemCount()</code>每执行 1 次，<code>LocalAlbum.getMediaItemCount()</code>至少执行 4 次!! </p><p>对代码做个注释:</p><ol><li>不用解释了，直接就调用 1 次了</li><li>在 set.getMediaSetType()里也执行了 1 次</li><li>竟然在 log 里还执行了无关紧要的 1 次，之前从 traceView 发现一个 Log.i 耗时就源于这里。 </li><li>mSources 是 image 和 video 两个类型各循环一次. </li></ol><p>接下来就优化代码。</p><ul><li>对于 3. 直接注释掉…</li><li>对于4.把内部执行逻辑分为image和 Video，先判断再执行流程，减少不必要的流程，也就是在判断类型条件后的代码块中执行代码 1，而不是像当前这样每次都执行代码 1，然后再根据类型执行其他操作。</li><li><p>对于 2. 因为重写该方法的地方比较多，所以只调整 LocalAlbum.getMediaSetType()内部逻辑。 这样，因为实际上 image 和 video 总是不同的文件夹，这个方法在优化后只会执行 1 次的 getTotalMediaItemCount()的方法。</p><p>调整之后，每次执行这个函数就只做一次数据库查询了。</p></li></ul><p>优化到这一步，初次加载相册和删除相册就已经很流畅了。但前面说了，调用 getMediaItemCount()的地方 很多，排查了一下，还有<code>LocalAlbumSet.AlbumsLoader.run()</code>中还有一处 <code>int count = album.getMediaItemCount();</code> 其中 count 并没有使用，所以是一段<strong>无用代码</strong>，可以注释掉。 </p><blockquote><p>所以说，平时在加Log或者删除无用代码的时候，一定要注意把不再使用的耗时的方法都去掉。否则都是定时炸弹。</p></blockquote><h3 id="优化四"><a href="#优化四" class="headerlink" title="优化四"></a>优化四</h3><p>触发刷新相册有几个操作:</p><ol><li><p>第一次打开相册的时候</p></li><li><p>删除相册的时候</p></li><li><p>添加相册的时候</p><p>前三个发生在 ListAlbumSetFragment</p></li><li><p>添加相册后要从其他相册列表选择相片的时候，显示的 ListAlbumPickerFragment 也会刷新 List </p></li></ol><p>前面的优化已经对第 1，2 点优化的很好了。然而对于 3，4 点还是有不流畅。 </p><p>所以进行添加相册操作再看 log，通过堆栈信息，发现这个在操作下，<code>getMediaItemCount()</code>的执行基本全部来自于 <code>AlbumDataLoader.reloadTask.run()</code> </p><p>可以知道这是一个线程。但通过 log 信息，发现这个线程有大量重复执行的情况，而且一个非常明显的现象就是，log 信息很混乱。看到线程重复执行，而且运行不同步，线程ID也有大量重复，每次操作都会创建新的线程。 </p><p>所以特意打印出线程信息以及开关线程的 log: resume 是创建线程， pause 是结束线程，当前 log 中 pause 从未执行 </p><pre><code>09-02 01:08:12.942 25843 25843 D UpdateThread: ======================&gt;resume&lt;==================== 09-02 01:08:12.959 25843 25843 D UpdateThread: ------------------------------------------------------------------&gt;Thread[Thread-359,5,main]   09-02 01:08:13.063 25843 25843 D UpdateThread: ------------------------------------------------------------------&gt;Thread[Thread-359,5,main]   09-02 01:08:13.140 25843 25843 D UpdateThread: ------------------------------------------------------------------&gt;Thread[Thread-359,5,main]   09-02 01:08:13.206 25843 25843 D UpdateThread: ------------------------------------------------------------------&gt;Thread[Thread-359,5,main]   09-02 01:08:20.625 25843 25843 D UpdateThread: ======================&gt;resume&lt;==================== 09-02 01:08:20.692 25843 25843 D UpdateThread: ------------------------------------------------------------------&gt;Thread[Thread-368,5,main]  09-02 01:08:20.824 25843 25843 D UpdateThread: ------------------------------------------------------------------&gt;Thread[Thread-368,5,main]  09-02 01:08:20.828 25843 25843 D UpdateThread: ------------------------------------------------------------------&gt;Thread[Thread-359,5,main]  09-02 01:08:20.893 25843 25843 D UpdateThread: ------------------------------------------------------------------&gt;Thread[Thread-368,5,main]  09-02 01:08:20.899 25843 25843 D UpdateThread: ------------------------------------------------------------------&gt;Thread[Thread-359,5,main]  09-02 01:08:28.437 25843 25843 D UpdateThread: ======================&gt;resume&lt;==================== 09-02 01:08:28.697 25843 25843 D UpdateThread: ------------------------------------------------------------------&gt;Thread[Thread-368,5,main]  09-02 01:08:28.707 25843 25843 D UpdateThread: ------------------------------------------------------------------&gt;Thread[Thread-380,5,main]  09-02 01:08:28.796 25843 25843 D UpdateThread: ------------------------------------------------------------------&gt;Thread[Thread-380,5,main]  09-02 01:08:28.886 25843 25843 D UpdateThread: ------------------------------------------------------------------&gt;Thread[Thread-368,5,main]  09-02 01:08:28.890 25843 25843 D UpdateThread: ------------------------------------------------------------------&gt;Thread[Thread-380,5,main]  09-02 01:08:29.048 25843 25843 D UpdateThread: ------------------------------------------------------------------&gt;Thread[Thread-380,5,main]  09-02 01:08:29.064 25843 25843 D UpdateThread: ------------------------------------------------------------------&gt;Thread[Thread-368,5,main]  09-02 01:08:29.065 25843 25843 D UpdateThread: ------------------------------------------------------------------&gt;Thread[Thread-380,5,main]  09-02 01:08:29.107 25843 25843 D UpdateThread: ------------------------------------------------------------------&gt;Thread[Thread-380,5,main]  09-02 01:08:29.127 25843 25843 D UpdateThread: ------------------------------------------------------------------&gt;Thread[Thread-368,5,main]  09-02 01:08:29.149 25843 25843 D UpdateThread: ------------------------------------------------------------------&gt;Thread[Thread-380,5,main]  09-02 01:08:29.184 25843 25843 D UpdateThread: ------------------------------------------------------------------&gt;Thread[Thread-380,5,main]  09-02 01:08:29.185 25843 25843 D UpdateThread: ------------------------------------------------------------------&gt;Thread[Thread-368,5,main]  09-02 01:08:29.224 25843 25843 D UpdateThread: ------------------------------------------------------------------&gt;Thread[Thread-380,5,main]  09-02 01:08:29.228 25843 25843 D UpdateThread: ------------------------------------------------------------------&gt;Thread[Thread-368,5,main]  09-02 01:08:29.258 25843 25843 D UpdateThread: ------------------------------------------------------------------&gt;Thread[Thread-380,5,main]  09-02 01:08:29.283 25843 25843 D UpdateThread: ------------------------------------------------------------------&gt;Thread[Thread-380,5,main]  09-02 01:08:29.326 25843 25843 D UpdateThread: ------------------------------------------------------------------&gt;Thread[Thread-380,5,main]  09-02 01:08:29.355 25843 25843 D UpdateThread: ------------------------------------------------------------------&gt;Thread[Thread-380,5,main]  09-02 01:08:42.739 25843 25843 D UpdateThread: ======================&gt;resume&lt;==================== 09-02 01:08:46.630 25843 25843 D UpdateThread: ======================&gt;resume&lt;==================== 09-02 01:08:49.243 25843 25843 D UpdateThread: ======================&gt;resume&lt;==================== 09-02 01:08:52.546 25843 25843 D UpdateThread: ------------------------------------------------------------------&gt;Thread[Thread-392,5,main]  09-02 01:08:52.571 25843 25843 D UpdateThread: ------------------------------------------------------------------&gt;Thread[Thread-368,5,main]  09-02 01:08:52.608 25843 25843 D UpdateThread: ------------------------------------------------------------------&gt;Thread[Thread-392,5,main]  09-02 01:08:52.630 25843 25843 D UpdateThread: ------------------------------------------------------------------&gt;Thread[Thread-368,5,main]  09-02 01:08:52.659 25843 25843 D UpdateThread: ------------------------------------------------------------------&gt;Thread[Thread-392,5,main]  09-02 01:08:52.699 25843 25843 D UpdateThread: ------------------------------------------------------------------&gt;Thread[Thread-392,5,main]  09-02 01:09:00.288 25843 25843 D UpdateThread: ------------------------------------------------------------------&gt;Thread[Thread-368,5,main]  09-02 01:09:00.294 25843 25843 D UpdateThread: ------------------------------------------------------------------&gt;Thread[Thread-392,5,main]  09-02 01:09:00.329 25843 25843 D UpdateThread: ------------------------------------------------------------------&gt;Thread[Thread-368,5,main]  09-02 01:09:00.342 25843 25843 D UpdateThread: ------------------------------------------------------------------&gt;Thread[Thread-392,5,main]  09-02 01:09:00.391 25843 25843 D UpdateThread: ------------------------------------------------------------------&gt;Thread[Thread-392,5,main]  09-02 01:09:00.428 25843 25843 D UpdateThread: ------------------------------------------------------------------&gt;Thread[Thread-392,5,main]  09-02 01:09:08.559 25843 25843 D UpdateThread: ======================&gt;resume&lt;==================== 09-02 01:09:13.460 25843 25843 D UpdateThread: ======================&gt;resume&lt;====================</code></pre><p>可以看到，经过一些连续操作后线程越来越多。所以联想到应该有某处是关闭线程的。跟踪代码，发现在对应 Fragment 的生命周期 onPause 里应该是进行线程关闭的操作的，然而这段代码竟然被注释掉了。将注释打开，重新测试，发现这时候同一时间只有一条线程了。这样就避免了多个线程多次执行 <code>getMediaItemCount()</code>的方法了。 最后操作一下程序，现在的相册刷新过程就非常流畅了。和优化前完全是两种体验。 </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>面对这种有固定复现步骤的性能问题，</p><ul><li>首先要定位到操作执行的相关代码段，通过阅读分析，推断可能出现问题的地方。然后，在关键流程处添加Log，然后复现问题，拿到相关Log。</li><li>抓TraceView或者Systrace，结合Log信息，对比CPU耗时的方法和执行次数很多的方法。</li><li>通过前两个信息定位到问题函数。然后添加堆栈信息Log.printStackTrace(new Throwable())，找到调用顺序（也可以用traceView看，但log打印会更直观）进行分析调试</li></ul><p>另外，也从中看到一些不规范的编码习惯造成的严重影响。比如，ListView布局引起的getView多次调用，这个就需要多学习，对相关机制多一些了解。比如Log里打印从数据库读取的数据，这个是需要注意的习惯，建议打Log的时候，直接打印变量，而不要直接调用方法。还有无用代码的删除，耗时间读取数据库，然后读出的数据没有任何作用，这个也是不应该的。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[MachineLearning] 反向传播Back Propagation</title>
      <link href="/2018/02/06/%5BMachineLearning%5DBackPropagation/"/>
      <url>/2018/02/06/%5BMachineLearning%5DBackPropagation/</url>
      
        <content type="html"><![CDATA[<p>反向传播的理解</p><p>知乎看到一个例子,的确有助于理解,摘抄整理下来.</p><p><a href="https://www.zhihu.com/question/27239198/answer/89853077" target="_blank" rel="noopener">如何直观地解释 back propagation 算法？ - 胡逸夫的回答 - 知乎</a></p><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/bp_01.jpg?raw=true" alt></p><p>如图,我们尝试求$e=c<em>d=(a+b)</em>(b+1)$的偏导</p><p>假设现在要求$a=2,b=1$时的梯度,我们用偏导定义求出不同层偏导的关系</p><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/bp_02.jpg?raw=true" alt></p><p>由链式求导法则:</p><script type="math/tex; mode=display">\dfrac {\partial e}{\partial a}=\dfrac {\partial e}{\partial c} \cdot \dfrac {\partial c}{\partial a}</script><script type="math/tex; mode=display">\dfrac{\partial e}{\partial b} = \dfrac{\partial e}{\partial c} \cdot \dfrac{\partial c}{\partial b} + \dfrac{\partial e}{\partial d} \cdot \dfrac{\partial d}{\partial b}</script><p>所以,从正向下层往上层看,</p><p>$\dfrac {\partial e}{\partial a}$ 等于$a\rightarrow c \rightarrow e$路径上偏导数的乘积.</p><p>$\dfrac {\partial e}{\partial b}$ 等于$b \rightarrow c \rightarrow e $ 和 $b \rightarrow d \rightarrow e$路径上偏导乘积的和</p><p>这里面就有一个问题:$c \rightarrow e$路径跑了两遍.如果面对更复杂的网络通路,这种重复的遍历会更多,必然会引起效率的下降.</p><p>所以BP就避免了这个问题,它使每个路径只访问一次就能求得顶点对所有下层节点的偏导值.</p><p>做法是:</p><p>从最上层节点开始,初始值为1,以层为单位处理.第一层$e$为1</p><p>到第二层,用1乘以到达下一层节点路径上的偏导值,结果存在这个节点.所以,$c = 1 <em> 2 = 2, d = 1 </em> 3 = 3$,即e对c的偏导值是2,e对d的偏导值是3.</p><p>第三层,$a = 2 <em> 1 = 2, b = 2 </em> 1 + 3 * 1 = 5$,即e对a的偏导值是2,e对b的偏导值是5</p><p>通过以上就可以对BP的工作原理有了一定了解.</p><p>再到神经网络中去看看BP算法:</p><p><a href="http://galaxy.agh.edu.pl/%7Evlsi/AI/backp_t_en/backprop.html" target="_blank" rel="noopener">Principles of training multi-layer neural network using backpropagation</a></p><p>我们使用有两个输入,一个输出的三层神经网络:</p><blockquote><p>注:从左到右三层分别是输入层,隐藏层和输出层</p></blockquote><p><img src="http://galaxy.agh.edu.pl/~vlsi/AI/backp_t_en/backprop_files/img01.gif" alt></p><p>每一个神经元都包含两个单元:第一个单元负责合并权重系数和输入信号,第二个单元负责实现激活函数.信号e是第一个加法单元的输出信号,非线性函数y=f(e)是第二个单元的输出信号,y也是整个神经元的输出信号.</p><p><img src="http://galaxy.agh.edu.pl/~vlsi/AI/backp_t_en/backprop_files/img01b.gif" alt></p><p>我们需要通过训练数据集去教神经网络.训练数据集包含输入信号(x1和x2),并且关联期望的正确输出z.网络训练是一个迭代过程.每次迭代中,权重都会根据新的训练数据变化.权重变化的算法如下:</p><p>每一次训练都从训练集的输入信号开始.经过这一阶段,我们能算出每一层每个神经元的输出值,如下图,$W_{x_{m}n}$表示第m个输入x到第n个神经元的权重,$y_{n}$表示第n个神经元的输出.</p><p><img src="http://galaxy.agh.edu.pl/~vlsi/AI/backp_t_en/backprop_files/img02.gif" alt></p><p><img src="http://galaxy.agh.edu.pl/~vlsi/AI/backp_t_en/backprop_files/img03.gif" alt></p><p><img src="http://galaxy.agh.edu.pl/~vlsi/AI/backp_t_en/backprop_files/img04.gif" alt></p><p>隐藏层的信号传播,Wmn是第m到第n个神经元的权重</p><p><img src="http://galaxy.agh.edu.pl/~vlsi/AI/backp_t_en/backprop_files/img05.gif" alt></p><p><img src="http://galaxy.agh.edu.pl/~vlsi/AI/backp_t_en/backprop_files/img06.gif" alt></p><p>输出层的计算</p><p><img src="http://galaxy.agh.edu.pl/~vlsi/AI/backp_t_en/backprop_files/img07.gif" alt></p><p>到这里就是前向传播.</p><p>下一步就是拿输出y和期望值z做比较,这个应该都比较熟悉了.比较的差别称为输出层神经元的错误信号d(感觉这个原文有点奇怪,反正我们的目的是降低y和z的差值)</p><p><img src="http://galaxy.agh.edu.pl/~vlsi/AI/backp_t_en/backprop_files/img08.gif" alt></p><p>直接计算内部神经元的错误信号是不可能的,因为这些神经元的输出值是未知的.(知道为什么吗?)这时就要提到反向传播了,想法是,将错误信号d返回给所有神经元,输出信号是被讨论神经元的输入信号.</p><p><img src="http://galaxy.agh.edu.pl/~vlsi/AI/backp_t_en/backprop_files/img09.gif" alt></p><p><img src="http://galaxy.agh.edu.pl/~vlsi/AI/backp_t_en/backprop_files/img10.gif" alt></p><p>用于传播错误的权重系数$W_{mn}$等于在计算输出值期间使用的系数（就是反向计算的时候使用和之前一样的权重）。只是计算方向变了。对所有的网络层都按这个方式进行。</p><p><img src="http://galaxy.agh.edu.pl/~vlsi/AI/backp_t_en/backprop_files/img11.gif" alt></p><p><img src="http://galaxy.agh.edu.pl/~vlsi/AI/backp_t_en/backprop_files/img12.gif" alt></p><p><img src="http://galaxy.agh.edu.pl/~vlsi/AI/backp_t_en/backprop_files/img13.gif" alt></p><p>当所有神经元的错误信号都计算完毕后，每个神经元的计算权重按下图的方式更新。</p><p><img src="http://galaxy.agh.edu.pl/~vlsi/AI/backp_t_en/backprop_files/img14.gif" alt></p><p><img src="http://galaxy.agh.edu.pl/~vlsi/AI/backp_t_en/backprop_files/img15.gif" alt></p><p><img src="http://galaxy.agh.edu.pl/~vlsi/AI/backp_t_en/backprop_files/img16.gif" alt></p><p><img src="http://galaxy.agh.edu.pl/~vlsi/AI/backp_t_en/backprop_files/img17.gif" alt></p><p><img src="http://galaxy.agh.edu.pl/~vlsi/AI/backp_t_en/backprop_files/img18.gif" alt></p><p><img src="http://galaxy.agh.edu.pl/~vlsi/AI/backp_t_en/backprop_files/img19.gif" alt></p><p>在更新W的时候方程右边会乘一个系数，这个系数就是学习率。详细介绍参见<a href="http://wossoneri.github.io/2018/01/24/[MachineLearning]Hyperparameters-learning-rate/">[MachineLearning] 超参数之LearningRate</a></p><p>有一篇通过代码介绍BP的文章也很推荐：</p><p><a href="http://www.cnblogs.com/charlotte77/p/5629865.html" target="_blank" rel="noopener"><a href="http://www.cnblogs.com/charlotte77/p/5629865.html" target="_blank" rel="noopener">一文弄懂神经网络中的反向传播法——BackPropagation</a></a></p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> Back Propagation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[MachineLearning] 超参数之LearningRate</title>
      <link href="/2018/01/24/%5BMachineLearning%5DHyperparameters-learning-rate/"/>
      <url>/2018/01/24/%5BMachineLearning%5DHyperparameters-learning-rate/</url>
      
        <content type="html"><![CDATA[<h3 id="Gardient-Descent"><a href="#Gardient-Descent" class="headerlink" title="Gardient Descent"></a>Gardient Descent</h3><p>关于Gradient descent 算法,不打算细说概念,公式什么的.贴一张Andrew的PPT:</p><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/gradient_descent_algorithm.png?raw=true" alt></p><p>图中有几点说明:</p><ul><li><p><strong>:=</strong> 是赋值操作</p></li><li><p>$J(\theta_{0},\theta_{1})$是代价函数</p></li><li><p>$\alpha$是learning rate,它控制我们以多大的幅度更新这个参数$\theta_{J} $.</p><blockquote><p>当偏导数部分为0时,即已经到达极小值,梯度便不再下降.这也说明$\alpha$保持不变时,梯度下降也可以收敛到局部最低点</p></blockquote></li></ul><ul><li>梯度下降操作是同时更新 $\theta_{0}$和$\theta_{1}$的.</li></ul><p>所以一般在梯度下降算法中,都需要设置一个学习率.</p><blockquote><p><a href="https://www.zhihu.com/question/64134994/answer/216895968" target="_blank" rel="noopener">SGD和minibatch-SGD</a></p><p>Stochastic Gradient Descent是随机梯度下降,每次计算只用一个随机样本</p><p>minibatch-SGD 一次采用batch size的样本做梯度</p></blockquote><h3 id="Learning-rate"><a href="#Learning-rate" class="headerlink" title="Learning rate"></a>Learning rate</h3><p>学习率决定了在一个小批量(mini-batch)中权重在梯度方向要移动多远.</p><p>比如下面Andrew的PPT截图 (图中$ J\left(\theta_{1} \right)$ 是代价函数):</p><ul><li>LR很小时,训练会变得可靠,也就是说梯度会向着最/极小值一步步靠近.算出来的loss会越来越小.但代价是,下降的速度很慢,训练时间会很长.</li><li>LR很大时,训练会越过最/极小值,表现出loss值不断震荡,忽高忽低.最严重的情况,有可能永远不会达到最/极小值,甚至跳出这个范围,进入另一个下降区域.</li></ul><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/hyperparameter_1.jpg?raw=true" alt></p><p>所以选择一个合适的LR是需要不断尝试和调整的.</p><p>Andrew提供一些practice的LR选取方法,比如0.001, 0.003, 0.01, 0.03, 0.1等.</p><p>总结下来,就是:</p><ol><li>小的LR会更精确</li><li>大的LR的loss下降更快</li></ol><p>结合上面两点优点,就会有这样的策略:</p><p>在训练刚开始的时候,由于初始的随机权重远离最优值,所以使用大一些的LR,让loss尽快下降接近局部最小值.然后训练过程中把LR调小,允许细粒度的权重更新,找到局部最小值.</p><p>调整LR的目的是使loss快速收敛.</p><blockquote><p>Andrew:</p><p>在梯度下降法中,当我们接近局部最低点时,梯度下降法会自动采取更小的幅度.</p><p>这是因为当我们接近局部最低点时,很显然在局部最低时导数等于零,所以当我们接近局部最低时,导数值会自动变得越来越小.所以梯度下降将自动采取较小的幅度,这就是梯度下降的做法.</p><p>所以实际上没有必要再另外减小α,这就是梯度下降算法.你可以用它来最小化任何代价函数, 不只是线性回归中的代价函数J </p></blockquote><h3 id="Initialize-Learning-Rate"><a href="#Initialize-Learning-Rate" class="headerlink" title="Initialize Learning Rate"></a>Initialize Learning Rate</h3><p>简单的方法就是尝试不同值,看哪个值能让损失函数最优,且不损失训练速度.</p><p>一个选择学习率的方法是:以一个低LR开始训练网络,在之后每个batch中指数提高LR,记录每批batch的LR和loss.然后绘制Loss和LR的关系图,从图中找取使Loss最低的LR.</p><p>或者</p><p>从0.1开始,指数下降LR,0.01,0.001这样尝试.在前几次迭代中,如果出现loss从某一时刻下降,这个学习率就是可用的最大值,超过他的都不能使loss收敛.所以用最大值训练一段时间,随后根据loss值适当地降低LR,让其以更细粒度的权重更新.</p><h3 id="Decay-Learning-Rate"><a href="#Decay-Learning-Rate" class="headerlink" title="Decay Learning Rate"></a>Decay Learning Rate</h3><p>前面提到,在训练的不同阶段,LR是需要调整的.比如,在loss不下降的时候,把LR缩小10倍往往会有效果.</p><p>但是,手动调整算哪门子程序员,于是,各种自动调整LR的方法变因此而生.下面介绍Tensorflow中LR的衰减策略.</p><p>底部链接里介绍有更多的策略,这里只放Tensorflow文档里常用的5个.</p><h4 id="exponential-decay"><a href="#exponential-decay" class="headerlink" title="exponential_decay"></a>exponential_decay</h4><p>LR指数衰减是最常用的衰减方法.</p><pre class=" language-lang-Python"><code class="language-lang-Python">exponential_decay(learning_rate, global_step, decay_steps, decay_rate, staircase=False, name=None)</code></pre><ul><li>learning rate 传入初始LR值</li><li>global_step 用于计算衰减</li><li>decay_steps 衰减的周期,每过decay_steps步后做一次衰减</li><li>decay_rate 每次衰减倍率,用初始LR * decay_rate</li><li>staircase 阶梯状衰减</li></ul><p>计算原理是</p><pre class=" language-lang-Python"><code class="language-lang-Python">decayed_learning_rate = learning_rate *                        decay_rate ^ (global_step / decay_steps)</code></pre><p>如果参数<code>staircase</code>是<code>True</code>,则<code>global_step / decay_steps</code>是整除,衰减的LR就遵循阶梯函数.</p><p>示例代码</p><pre class=" language-lang-python"><code class="language-lang-python">...global_step = tf.Variable(0, trainable=False)starter_learning_rate = 0.1learning_rate = tf.train.exponential_decay(starter_learning_rate, global_step,                                           100000, 0.96, staircase=True)# Passing global_step to minimize() will increment it at each step.learning_step = (    tf.train.GradientDescentOptimizer(learning_rate)    .minimize(...my loss..., global_step=global_step))</code></pre><p>示例图</p><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/LR_exponential_decay.webp?raw=true" alt></p><h4 id="inverse-time-decay"><a href="#inverse-time-decay" class="headerlink" title="inverse_time_decay"></a>inverse_time_decay</h4><pre class=" language-lang-python"><code class="language-lang-python">tf.train.inverse_time_decay(learning_rate, global_step, decay_steps, decay_rate, staircase=False, name=None)</code></pre><p>倒数衰减.参数同上.</p><p>计算方式:</p><pre class=" language-lang-python"><code class="language-lang-python">decayed_learning_rate = learning_rate / (1 + decay_rate * t)</code></pre><p>示例代码,以0.5的衰减率衰减1 / t:</p><pre class=" language-lang-Python"><code class="language-lang-Python">...global_step = tf.Variable(0, trainable=False)learning_rate = 0.1k = 0.5learning_rate = tf.train.inverse_time_decay(learning_rate, global_step, k)# Passing global_step to minimize() will increment it at each step.learning_step = (    tf.train.GradientDescentOptimizer(learning_rate)    .minimize(...my loss..., global_step=global_step))</code></pre><p>示例图:</p><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/LR_inverse_decay.webp?raw=true" alt></p><h4 id="natural-exp-decay"><a href="#natural-exp-decay" class="headerlink" title="natural_exp_decay"></a>natural_exp_decay</h4><pre class=" language-lang-python"><code class="language-lang-python">tf.train.natural_exp_decay(learning_rate, global_step, decay_steps, decay_rate, staircase=False, name=None)</code></pre><p>自然指数衰减.和指数衰减差不多,不过下降的底数是$1/e$</p><p>计算公式</p><pre class=" language-lang-Python"><code class="language-lang-Python">decayed_learning_rate = learning_rate * exp(-decay_rate * global_step)</code></pre><p>示例代码 decay exponentially with a base of 0.96:</p><pre class=" language-lang-python"><code class="language-lang-python">...global_step = tf.Variable(0, trainable=False)learning_rate = 0.1k = 0.5learning_rate = tf.train.exponential_time_decay(learning_rate, global_step, k)# Passing global_step to minimize() will increment it at each step.learning_step = (    tf.train.GradientDescentOptimizer(learning_rate)    .minimize(...my loss..., global_step=global_step))</code></pre><p>示例图(绿色是exponential_decay):</p><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/LR_natural_decay.webp?raw=true" alt></p><h4 id="piecewise-constant"><a href="#piecewise-constant" class="headerlink" title="piecewise_constant"></a>piecewise_constant</h4><pre class=" language-lang-python"><code class="language-lang-python">tf.train.piecewise_constant(x, boundaries, values, name=None)</code></pre><p>分段常数下降法类似于 exponential_decay 中的阶梯式下降法，不过各阶段的值是自己设定的。</p><p>其中，x 即为 global step，boundaries=[step_1, step_2, …, step_n] 定义了在第几步进行 lr 衰减，values=[val_0, val_1, val_2, …, val_n] 定义了 lr 的初始值和后续衰减时的具体取值。需要注意的是，values 应该比 boundaries 长一个维度。</p><p>示例代码:use a learning rate that’s 1.0 for the first 100000 steps, 0.5<br>  for steps 100001 to 110000, and 0.1 for any additional steps.</p><pre class=" language-lang-python"><code class="language-lang-python">global_step = tf.Variable(0, trainable=False)boundaries = [100000, 110000]values = [1.0, 0.5, 0.1]learning_rate = tf.train.piecewise_constant(global_step, boundaries, values)# Later, whenever we perform an optimization step, we increment global_step.</code></pre><p>示例图:</p><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/LR_piecewise_decay.webp?raw=true" alt></p><h4 id="polynomial-decay"><a href="#polynomial-decay" class="headerlink" title="polynomial_decay"></a>polynomial_decay</h4><pre class=" language-lang-python"><code class="language-lang-python">tf.train.polynomial_decay(learning_rate, global_step, decay_steps, end_learning_rate=0.0001, power=1.0, cycle=False, name=None)</code></pre><p>polynomial_decay 是以多项式的方式衰减学习率的。</p><p>计算方式:</p><p>The function returns the decayed learning rate.  It is computed as:</p><pre class=" language-lang-python"><code class="language-lang-python">global_step = min(global_step, decay_steps)decayed_learning_rate = (learning_rate - end_learning_rate) *                        (1 - global_step / decay_steps) ^ (power) +                        end_learning_rate</code></pre><p>If <code>cycle</code> is True then a multiple of <code>decay_steps</code> is used, the first one<br>that is bigger than <code>global_steps</code>.</p><pre class=" language-lang-python"><code class="language-lang-python">decay_steps = decay_steps * ceil(global_step / decay_steps)decayed_learning_rate = (learning_rate - end_learning_rate) *                        (1 - global_step / decay_steps) ^ (power) +                        end_learning_rate</code></pre><p>示例代码:decay from 0.1 to 0.01 in 10000 steps using sqrt (i.e. power=0.5):</p><pre class=" language-lang-python"><code class="language-lang-python">...global_step = tf.Variable(0, trainable=False)starter_learning_rate = 0.1end_learning_rate = 0.01decay_steps = 10000learning_rate = tf.train.polynomial_decay(starter_learning_rate, global_step,                                          decay_steps, end_learning_rate,                                          power=0.5)# Passing global_step to minimize() will increment it at each step.learning_step = (    tf.train.GradientDescentOptimizer(learning_rate)    .minimize(...my loss..., global_step=global_step))</code></pre><p>示例图:</p><p>cycle=False，其中红色线为 power=1，即线性下降；蓝色线为 power=0.5，即开方下降；绿色线为 power=2，即二次下降</p><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/LR_polynomial_decay.webp?raw=true" alt></p><h3 id="Experience"><a href="#Experience" class="headerlink" title="Experience"></a>Experience</h3><p>在用new Yolo训练自己的训练集时(3个class),的确遇到了loss不下降的情况.大概在不到2000次step的时候loss就已经维持在1.2-1.5之间,随后的几千次step都没有看到loss有下降的趋势.</p><p>于是就下调LR,5倍,10倍这样下调.从最开始的5e-5调整到1e-7时(同时增加了一倍的batch size),loss出现比较明显的下降,整体维持在0.8-0.9左右,偶尔会出现0.5,0.6这样的值,而且随着训练增多,这些小值的比例在增加.</p><p>另外,观察loss需要有耐心,可能到某一个阶段,它整体在下降,但速度很慢而已.</p><p>贴上一段darkflow中的问答:</p><blockquote><p><a href="https://github.com/thtrieu/darkflow/issues/9" target="_blank" rel="noopener">what is the lowest loss value can reach?</a></p><p>Q:</p><p>hi, I have trained a yolo-small model to step 4648, but most of loss<br>values are greater than 1.0,  and the result of test is not very well. I<br> want to know how well can loss value be, and could you please show some<br> key parameters when training,  e.g learning rate, training time, the<br>final loss value, and so on.</p><p>A:</p><p>What batch size are you using? Because without the batch size, step number cannot say anything about how far you’ve gone. According to the author of YOLO, he used pretty powerful machine and the training have two stages with the first stage (training convolution layer with average pool) takes about <strong>a week</strong>. So you should be patient if you’re not that far from the beginning.</p><p>Training deep net is more of an art than science. So my suggestion is you first train your model on a small data size first to see if the model is able to overfit over training set, if not then there’s a problem to solve before proceeding. Notice due to data augmentation built in the code, you can’t really reach 0.0 for the loss.</p><p>I’ve trained a few configs on my code and the loss can shrink down well from &gt; 10.0 to around 0.5 or below (parameters C, B, S are not relevant since the loss is averaged across the output tensor). I usually start with default learning rate 1e-5, and batch size 16 or even 8 to speed up the loss first until it stops decreasing and seem to be unstable.</p><p>Then, learning rate will be decreased down to 1e-6 and batch size increase to 32 and 64 whenever I feel that the loss get stuck (and testing still does not give good result). You can switch to other adaptive learning rate training algorithm (e.g. Adadelta, Adam, etc) if you feel like familiar with them by editing <code>./yolo/train.py/yolo_loss()</code></p><p>You can also look at the learning rate policy the YOLO author used, inside .cfg files.</p><p>Best of luck</p></blockquote><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://www.jiqizhixin.com/articles/2017-11-17-2" target="_blank" rel="noopener">如何估算深度神经网络的最优学习率</a><br><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODU3OTIyOA==&amp;mid=2650669235&amp;idx=2&amp;sn=5d7c3266d2c99722ce696ad8927e6a94&amp;chksm=bec23dc089b5b4d6ff69b8d904546da2d7de826bb4e69f2fbdbed068535c193d99af8ed67e0a&amp;mpshare=1&amp;scene=1&amp;srcid=01182DsY1hPx919Jf4caieo3&amp;pass_ticket=ytueXC6c9lzoMtH0iIymjCax%2FKklKlHa1L8ic4FMY1fv9jP5afdynPKDklX3JMsD#rd" target="_blank" rel="noopener">Tensorflow 中 learning rate decay 的奇技淫巧</a><br><a href="https://www.tensorflow.org/versions/r0.12/api_docs/python/train/decaying_the_learning_rate" target="_blank" rel="noopener">Decaying the learning rate</a></p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Machine Learning </tag>
            
            <tag> Tensorflow </tag>
            
            <tag> Hyperparameter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[MachineLearning] K最邻近算法</title>
      <link href="/2018/01/24/%5BMachineLearning%5DK-Nearest-Neighbor/"/>
      <url>/2018/01/24/%5BMachineLearning%5DK-Nearest-Neighbor/</url>
      
        <content type="html"><![CDATA[<h3 id="What-is-the-KNN"><a href="#What-is-the-KNN" class="headerlink" title="What is the KNN"></a>What is the KNN</h3><p><code>KNN</code>,全称K Nearest Neighbor.</p><p>K最临近算法是机器学习中一个比较经典的算法.主要用来分类.</p><p>用一张Wikipedia的图例展示<code>KNN</code>:</p><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/KNN-1.png?raw=true" alt="knn"></p><p>图中已知两类:红色三角形和蓝色矩形的分布,现在图中心有一个未知的类别,如果要将其归类,它应该是哪一类?(请不要说绿色圆形…)</p><p>使用<code>KNN</code>算法:</p><ul><li><code>k=3</code>,选取离其最近的3个点:两个红色一个蓝色.选取其中出现最多的红色三角,推断中心也是一个红色三角形.</li><li><code>k=5</code>,选取离其最近的5个点:两个红色三个蓝色.根据周围的类别比例,推断中心是蓝色矩形.</li></ul><p>这就是<code>KNN</code>算法,一个基于一种数据统计的方法.这里的K是选取附近的点的个数.通过计算方式可以知道,K必须取奇数,避免平票的情况.</p><blockquote><p>可以理解为,KNN是由待分类数据由其附近的数据投票决定其类别.</p></blockquote><h3 id="How-to-use-KNN"><a href="#How-to-use-KNN" class="headerlink" title="How to use KNN"></a>How to use KNN</h3><p>拿西瓜书上面一些数据举个例子:</p><div class="table-container"><table><thead><tr><th>密度</th><th>含糖率</th><th>好瓜</th></tr></thead><tbody><tr><td>0.774</td><td>0.376</td><td>是</td></tr><tr><td>0.697</td><td>0.460</td><td>是</td></tr><tr><td>0.666</td><td>0.091</td><td>否</td></tr><tr><td>0.243</td><td>0.267</td><td>否</td></tr></tbody></table></div><p>问:如果现在有一个瓜的密度:0.657,含糖率:0.198,那么它是好瓜吗?</p><p>用<code>KNN</code>计算:</p><div class="table-container"><table><thead><tr><th>密度</th><th>含糖率</th><th>距离</th><th>K=1</th><th>K=3</th></tr></thead><tbody><tr><td>0.774</td><td>0.376</td><td>$(0.774-0.657)^{2}$+$(0.376-0.198)^{2}$=0.045373</td><td>不投票</td><td>是</td></tr><tr><td>0.697</td><td>0.460</td><td>$(0.697-0.657)^{2}$+$(0.460-0.198)^{2}$=0.070244</td><td>不投票</td><td>是</td></tr><tr><td>0.666</td><td>0.091</td><td>$(0.666-0.657)^{2}$+$(0.091-0.198)^{2}$=0.01153</td><td>否</td><td>否</td></tr><tr><td>0.243</td><td>0.267</td><td>$(0.243-0.657)^{2}$+$(0.267-0.198)^{2}$=0.176157</td><td>不投票</td><td>不投票</td></tr></tbody></table></div><p>通过计算距离,可以知道:</p><ul><li>K=1,不是好瓜</li><li>K=3,是好瓜</li></ul><p>其实,通过含糖率数据可以知道,预测的这个瓜不是好瓜.</p><p>所以通过这个结果可以看到,最终预测的准确性和K的数量关系不大.比较关键的是选取判断属性,如果选取含糖率计算的话,准确率会变好.</p><p>上面并不是一个严谨的推论,但可以看出,面对线性变化的某些属性,用<code>KNN</code>还是有一些准确性的.也正因此,<code>KNN</code>还可以做一些插值操作,可以平滑曲线.</p><h3 id="L1-amp-L2-distance"><a href="#L1-amp-L2-distance" class="headerlink" title="L1 &amp; L2 distance"></a>L1 &amp; L2 distance</h3><ul><li><p>L1 distance:</p><script type="math/tex; mode=display">d_{1}(I_{1}, I_{2})=\sum_{p}|I_{1}^{p} - I_{2}^{p}|</script></li><li><p>L2 distance:</p><script type="math/tex; mode=display">d_{2}(I_{1}, I_{2}) = \sqrt{\sum_p(I_{1}^{p} - I_{2}^{p})^2}</script></li></ul><p><a href="http://blog.csdn.net/zhangxb35/article/details/55223825" target="_blank" rel="noopener">http://blog.csdn.net/zhangxb35/article/details/55223825</a></p><p><a href="http://blog.csdn.net/kangroger/article/details/52338344" target="_blank" rel="noopener">http://blog.csdn.net/kangroger/article/details/52338344</a></p><p><a href="http://cs231n.github.io/classification/" target="_blank" rel="noopener">http://cs231n.github.io/classification/</a></p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> KNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[JVM] 垃圾收集器与内存分配策略</title>
      <link href="/2018/01/13/%5BJVM%5DNote-of-JVM-Charpter3/"/>
      <url>/2018/01/13/%5BJVM%5DNote-of-JVM-Charpter3/</url>
      
        <content type="html"><![CDATA[<h3 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="　垃圾收集器与内存分配策略"></a>　垃圾收集器与内存分配策略</h3><p>最早人们思考GC需要完成的3件事情:</p><ul><li>哪些内存需要回收</li><li>什么时候回收</li><li>如何回收</li></ul><p>经过发展,内存动态分配和回收技术已经成熟,为什么还要了解GC和内存分配呢?<br>当需要排查各种内存溢出,内存泄露问题时,当垃圾手机成为系统达到更高并发量的瓶颈时,就需要人为对其进行监控和调节.</p><p>前面提到的<code>程序计数器</code>,<code>虚拟机栈</code>,<code>本地方法栈</code>3个区域随线程生和灭,每个栈帧分配内存基本上是在类结构确定后就已知的.因此方法结束或者线程结束时,内存自然就跟着回收了.</p><p>而<code>Java堆</code>和<code>方法区</code>则不一样:</p><ul><li>一个接口中多个实现类需要的内存可能不一样</li><li>一个方法中的多个分支需要的内存也可能不一样</li></ul><p>我们只有在程序运行期间才知道会创建哪些对象,这部分内存分配和回收都是动态的,垃圾收集器所关注的就是这部分内存.</p><h4 id="对象已死吗"><a href="#对象已死吗" class="headerlink" title="对象已死吗"></a>对象已死吗</h4><p><code>堆</code>中存放着Java中几乎所有的对象实例,垃圾收集器对<code>堆</code>回收前,第一件事情是要确定这些对象哪些还活着.</p><h5 id="引用计数法-Reference-Counting"><a href="#引用计数法-Reference-Counting" class="headerlink" title="引用计数法 Reference Counting"></a>引用计数法 Reference Counting</h5><p>给对象一个引用计数器,对它引用时,计数器加1;引用失效,计数器减1.任何时刻,计数为0的对象是不可能再被使用的.</p><p><code>引用计数法</code>实现简单,判定效率高,但很难解决对象之间循环引用问题.所以JVM没有使用这个方法.</p><h5 id="可达性分析算法-Reachability-Analysis"><a href="#可达性分析算法-Reachability-Analysis" class="headerlink" title="可达性分析算法 Reachability Analysis"></a>可达性分析算法 Reachability Analysis</h5><p>基本思路是,通过一系列称为<code>GC Roots</code>的对象作为起始点,从节点向下搜索.搜索走过的路径称为<code>引用链 Reference Chain</code>,当一个对象到<code>GC Roots</code>没有任何引用链相连时,证明此对象不可用.</p><p>下图白色对象就是可回收的对象.</p><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/3-1.png?raw=true" alt></p><p>可作为GC Roots的对象包括:</p><ul><li>虚拟机栈(栈帧中本地变量表)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI(Native方法)引用的对象</li></ul><h5 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h5><p>JDK1.2以后,对引用概念进行扩充,将引用分为:</p><ul><li><p><strong>强引用 Strong Reference</strong></p><p>类似<code>A obj = new A()</code>这类普遍存在的引用.只要<code>强引用</code>还在,垃圾收集器永远不会回收掉被引用的对象.</p></li><li><p><strong>软引用 Soft Reference</strong></p><p>用<code>SoftReference</code>类实现.表示一些有用但并非必需的对象.</p><p>对于<code>软引用</code>关联的对象,在系统将要发生内存溢出异常之前,将会把这些对象列入回收范围中进行二次回收.如果这次回收还没有足够内存,抛出OOM.</p></li><li><p><strong>弱引用 Weak Reference</strong></p><p>用<code>WeakReference</code>类实现.表示非必需的对象,但强度比<code>软引用</code>弱.</p><p>被<code>弱引用</code>关联的对象只能生存到下一次垃圾收集发生之前.收集器一旦工作,就会回收掉只被<code>弱引用</code>关联的对象.无关内存情况.</p></li><li><p><strong>虚引用 Phantom Reference</strong></p><p>用<code>PhantomReference</code>类实现<code>虚引用</code>.它是最弱的引用关系.</p><p>一个对象是否有<code>虚引用</code>不对其生存时间产生影响,无法通过虚引用取得一个对象实例.</p><p>其存在的唯一目的,<strong>是对象被回收时收到一个系统通知</strong>.</p></li></ul><h5 id="生存or死亡"><a href="#生存or死亡" class="headerlink" title="生存or死亡"></a>生存or死亡</h5><p>在<code>可达性分析算法</code>中找到的可回收的对象,会被第一次标记并进行一次筛选.条件是此对象是否有必要执行<code>finalize()</code>方法.</p><p>当对象没有覆盖<code>finalize()</code>方法,或者<code>finalize()</code>方法已经被虚拟机调用过,虚拟机将认为没有必要触发该方法.(<code>finalize()</code>方法最多只被自动调用一次)</p><p>如果这个对象被判定为有必要执行<code>finalize()</code>方法,对象就被放入<code>F-Queue</code>队列,等待<code>Finalizer</code>线程执行.</p><p><code>finalize()</code>方法中GC将对<code>F-Queue</code>中对象进行第二次标记,这个阶段对象只要重新与引用链上任何一个对象建立关联即可不被标记,从而”活”下来.</p><p>下面用代码演示<code>finalize()</code>过程:</p><pre class=" language-lang-java"><code class="language-lang-java">public class FinalizeEscapeGC {    public static FinalizeEscapeGC SAVE_HOOK = null;    public void isAlive() {        System.out.println("I am alive!");    }    @Override    protected void finalize() throws Throwable {        super.finalize();        System.out.println("finalize method executed!");        FinalizeEscapeGC.SAVE_HOOK = this;    }    public static void main(String[] args) throws Throwable {        SAVE_HOOK = new FinalizeEscapeGC();        //first time save itself        SAVE_HOOK = null;        System.gc();        // finalize priority is low, so wait it        Thread.sleep(500);        if (SAVE_HOOK != null) {            SAVE_HOOK.isAlive();        } else {            System.out.println("I am dead ...");        }        //second time. same code but save failed        SAVE_HOOK = null;        System.gc();        // finalize priority is low, so wait it        Thread.sleep(500);        if (SAVE_HOOK != null) {            SAVE_HOOK.isAlive();        } else {            System.out.println("I am dead ...");        }    }}</code></pre><p>运行结果:</p><pre class=" language-lang-bash"><code class="language-lang-bash">finalize method executed!I am alive!I am dead ...</code></pre><p>代码能看到,<code>finalize()</code>方法有被触发过.至于第二次自救失败,是因为任何对象的<code>finalize()</code>方法只被系统自动调用一次.对象面临下一次回收,此方法不会被再次执行.</p><p><code>finalize()</code>方法不建议使用,因为运行代价高,不确定性强,无法保证各对象的调用顺序.</p><h5 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h5><p>之前提到过,<code>方法区</code>可以不实现垃圾回收,而且这里的回收”性价比”非常低(对比<code>堆</code>).</p><p><code>方法区</code>回收主要是两部分内容:</p><ul><li>废弃常量</li><li>无用的类</li></ul><p>回收常量和回收Java<code>堆</code>类似,没有对这个常量有引用的情况就可以回收.</p><p>回收无用的类就要判断以下:</p><ul><li>Java堆中该类的所有实例都已经被回收</li><li>加载该类的ClassLoader已经回收</li><li>该类对应的java.lang.Class对象没有被引用,无法通过反射访问该类的方法</li></ul><h4 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h4><p>仅做原理介绍.</p><h5 id="标记-清除-Mark-Sweep"><a href="#标记-清除-Mark-Sweep" class="headerlink" title="标记-清除 Mark-Sweep"></a>标记-清除 Mark-Sweep</h5><p>先标记所有需要回收的对象,然后统一回收.</p><p>不足:</p><ul><li>效率过低.标记和清除都不高效</li><li>空间碎片过多.清除标记后产生大量不连续内存碎片.如果以后要再分配大对象时,无法找到足够的连续内存会导致再次触发垃圾回收.</li></ul><h5 id="复制-Copying"><a href="#复制-Copying" class="headerlink" title="复制 Copying"></a>复制 Copying</h5><p>将内存按容量分为相等的两块A和B.每次只使用一块,比如A,这一块内存用完了,就对A进行回收,把存活的对象复制到B上,然后把A一次清理掉.</p><p>这样没有内存碎片,按顺序移动堆指针,很高效.</p><p>不足:</p><ul><li>但内存缩小了一半.所以一些优化是把1:1改成9:1或者8:1这样分配.</li><li>对象存活率高时,复制操作效率低.</li></ul><h5 id="标记整理-Mark-Compact"><a href="#标记整理-Mark-Compact" class="headerlink" title="标记整理 Mark-Compact"></a>标记整理 Mark-Compact</h5><p>标记还是和之前一样,但清除前,先将存活对象移到同一端,然后清理掉边界外的内存.</p><h5 id="分代收集-Generational-Collection"><a href="#分代收集-Generational-Collection" class="headerlink" title="分代收集 Generational Collection"></a>分代收集 Generational Collection</h5><p>根据对象存活周期将内存分为几块,根据特点选算法.一般分为新生代,老年代:</p><ul><li>新生代采用<code>复制算法</code></li><li>老年代使用<code>标记清理</code>或<code>标记整理</code></li></ul><h4 id="HotSpot-虚拟机算法实现"><a href="#HotSpot-虚拟机算法实现" class="headerlink" title="HotSpot 虚拟机算法实现"></a>HotSpot 虚拟机算法实现</h4><p>从可达性分析入手,我们首先需要找到<code>GC Roots</code>.这个<code>GC Roots</code>主要存在于全局性引用与执行上下文中.但现在很多应用在方法区都有数百兆,直接检查很耗时.</p><p>另外,这项工作在分析期间,系统需要暂停,即分析时保证状态不会变化.</p><p>在系统暂停期间,虚拟机从<code>OopMap</code>直接获得对象引用,不需要一个不漏地检查完所有执行上下文和全局的引用位置.</p><p>能引起<code>OopMap</code>内容变化的指令很多,但HotSpot并没有为每条指令都生成<code>OopMap</code>,只是在特定位置记录这些信息,这个位置称为<code>安全点Safepoint</code>.</p><p><code>安全点</code>不能太多也不能太少,权衡标准就是:是否具有让程序长时间执行的特征.所以长指令流的指令才会产生<code>安全点</code>.</p><p><code>安全点</code>保证程序执行时,可以进入GC的<code>安全点</code>,但是程序不执行的时候,即线程处于Sleep或者Blocked时,线程无法响应JVM中断请求.这就需要<code>安全区Safe Region</code>解决.</p><p>线程进入<code>安全区</code>中,就会标识自己,JVM发起GC就会忽略有标记的线程.</p><p>线程离开<code>安全区</code>,先检查系统是否完成根节点枚举或整个GC,如果完成,线程就继续执行,否则等待直到收到可以离开的信号.</p><h4 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><p>垃圾收集器的实现没有统一的规定,所以有很多种不同实现.</p><p>这里仅列举常见的收集器.</p><ul><li>Serial</li><li>ParNew</li><li>Parallel Scavenge</li><li>Serial Old</li><li>Parallel Old</li><li>CMS</li><li>G1</li></ul><h5 id="理解GC日志"><a href="#理解GC日志" class="headerlink" title="理解GC日志"></a>理解GC日志</h5><pre class=" language-lang-bash"><code class="language-lang-bash">33.125: [GC [DefNew: 3324K->152K(3712K), 0.0025925 secs] 3324K->152K(11904K), 0.0031680 secs]100.667: [Full GC [Tenured: OK->210K(10240K), 0.0149142 secs] 4603K->210K(19456K), [Perm : 2999K->2999K(21248K)], 0.0150007 secs] [Times: user=0.01 sys=0.00, real=0.02 secs]</code></pre><ul><li><p><strong>33.125</strong>,<strong>100.667</strong></p><p>代表从JVM启动开始,GC发生的时间点.</p></li><li><p><strong>[GC</strong> 和 <strong>[Full GC</strong> </p><p>说明垃圾收集的停顿类型.如果有Full,说明这次GC发生Stop-The-World(系统暂停).</p><p>如果调用<code>System.gc()</code>,则log显示<strong>[Full GC(System)</strong></p></li><li><p><strong>[DefNew</strong>,<strong>[Tenured</strong>,<strong>[Perm</strong></p><p>表示GC发生的区域.</p><p>Serial收集器新生代名为<code>Default New Generation</code>,所以显示<strong>[DefNew</strong></p></li><li><p>内存区域括号内的 <strong>3324K-&gt;152K(3712K)</strong></p><p>GC前该内存区已使用容量-&gt;GC后该内存区域已使用容量(该内存区域总容量)</p></li><li><p>GC括号内的 <strong>3324K-&gt;152K(11904K)</strong></p><p>GC前Java堆已使用容量-&gt;GC后Java堆已使用容量(Java堆总容量)</p></li><li><p><strong>0.0025925 secs</strong></p><p>该区域GC所用时间</p></li><li><p><strong>[Times: user=0.01 sys=0.00, real=0.02 secs]</strong></p><p>和linux时间含义一致,用户消耗CPU时间,内核消耗CPU时间和操作从开始到结束经过墙钟时间</p></li></ul><h4 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h4><p>对象的内存分配,往大方面讲,是在堆上面分配.对象主要分配在新生代的Eden区上.</p><p>普遍的分配规则:</p><ul><li><p>对象优先在Eden分配</p><p>比如,20MB内存,新生代10MB,老年代10MB.新生代又分为8MBEden区和1MBSurvivor区.</p><p>新建6M对象,存在Eden区,再存入4MB对象,这时Eden区空间不足,遂计划将6MB移入Survivor区,但Survivor区内存也不够,于是这6MB就移入老年代.</p></li><li><p>大对象直接进入老年代</p><p>大对象就是需要连续内存空间的Java对象.比如超长的字符串或数组.平时需要避免大对象,因为系统会为了腾出足够的连续空间而提前GC.</p><p>大对象进入老年代就是因为新生代GC很频繁,降低负担.</p></li><li><p>长期存活的对象将进入老年代</p><p>这个好理解吧?每一次经过GC存活的对象,年龄都加1.默认阈值是15,到15岁就进入老年代.</p></li><li><p>动态对象年龄判定</p><p>15岁的阈值规定也不是永远强制的.如果Survivor中相同年龄所有对象大小总和大于Survivor空间的一半,年龄大于或等于该年龄的对象就可直接进入老年代.</p></li><li><p>空间分配担保</p><blockquote><p>发生Minor GC(新生代GC)之前,虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间.</p><blockquote><p>如果成立,则Minor GC是安全的.</p><p>否则,查看HandlePromotionFailure设置值是否允许担保失败.</p><blockquote><p>如果允许,继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小.</p><blockquote><p>如果大于,尝试一次Minor GC</p><p>如果小于,改为进行一次Full GC</p></blockquote><p>如果不允许,改为进行一次Full GC</p></blockquote></blockquote></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[JVM] Java内存区域与内存溢出异常</title>
      <link href="/2018/01/12/%5BJVM%5DNote-of-JVM-Charpter2/"/>
      <url>/2018/01/12/%5BJVM%5DNote-of-JVM-Charpter2/</url>
      
        <content type="html"><![CDATA[<h3 id="Java内存区域与内存溢出异常"><a href="#Java内存区域与内存溢出异常" class="headerlink" title="Java内存区域与内存溢出异常"></a>Java内存区域与内存溢出异常</h3><h4 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h4><p>运行时数据区有:</p><ul><li>方法区 Method Area</li><li>堆 Heap</li><li>虚拟机栈 VM Stack</li><li>本地方法栈 Native Method Stack</li><li>程序计数器 Program Counter Register</li></ul><p>前两个区域是由所有线程共享的区域,后三个是线程隔离的数据区.</p><p>下面分别介绍这些区域.</p><h5 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h5><p><strong>定义:</strong></p><p><code>程序计数器</code>是一块较小的内存空间,它可以看做是当前线程所执行的字节码的行号指示器.(简单地理解,就是解释器工作是通过行号指示器去找需要执行的指令.)</p><p><strong>特点:</strong></p><p>它是<strong>线程私有</strong>的.因为JVM的多线程是通过线程轮流切换分配处理器执行时间实现的.为了保证线程切换都能恢复到正确位置,所以每个线程都有自己的计数器.</p><p>如果线程执行的是Java方法,该计数器记录正在执行的虚拟机字节码指令地址.</p><p>如果执行的是Native方法,该计数器值则为空(Undefined)</p><p><strong>异常:</strong></p><p>此区域是唯一一个在JVM规范中没有规定<code>OutOfMemoryError</code>的区域</p><h5 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h5><p><strong>定义:</strong></p><p><code>虚拟机栈</code>描述的是Java方法执行的内存模型:每个方法执行的同时会创建一个栈帧,用于存储局部变量表,操作数栈,动态链接,方法出口等信息.每个方法从调用到执行完成的过程,就对应着一个栈帧在虚拟机栈中入栈到出栈的过程.</p><p><strong>特点:</strong></p><p>它也是<strong>线程私有</strong>的,它的生命周期与线程相同.</p><p>广泛流传的(并不准确)堆内存,栈内存中栈内存就是<code>虚拟机栈</code>,或者说是<code>虚拟机栈</code>中<code>局部变量表</code>部分.</p><p><code>局部变量表</code>所需内存空间在编译期间完成分配,当进入一个方法时,这个方法需要在帧中分配的局部变量空间是完全确定的,在方法运行期间不会改变局部变量表的大小.</p><p><strong>异常:</strong></p><p>JVM规范中,对这个区域规定两种异常状况</p><ul><li>如果线程请求的栈深度大于虚拟机允许的深度,抛出<code>StackOverflowError</code></li><li>如果虚拟机栈可以动态扩展,如果扩展是无法申请到足够内存,抛出<code>OutOfMemoryError</code></li></ul><h5 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h5><p><strong>定义:</strong></p><p>类似于<code>虚拟机栈</code>,只是<code>本地方法栈</code>为虚拟机使用到的Native方法服务.</p><p><strong>特点:</strong></p><p>在虚拟机规范中对本地方法栈中方法使用的语言,使用方式与数据结构并没有强制规定.因此具体的虚拟机可以自由实现它.</p><p>同<code>虚拟机栈</code>,是<strong>线程私有</strong>的.</p><p><strong>异常:</strong></p><ul><li>StackOverflowError</li><li>OutOfMemoryError</li></ul><h5 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h5><p><strong>定义:</strong></p><p>Java堆是JVM管理的内存最大的一块.唯一目的是存放对象实例.</p><blockquote><p>JVM规范:所有的对象实例以及数组都要在堆上分配.但随着技术发展,要求也没有那么绝对了</p></blockquote><p><strong>特点:</strong></p><p>Java堆是被所有<strong>线程共享</strong>的内存区域,虚拟机启动时创建.</p><p>Java堆是垃圾收集器管理的主要区域,也称GC堆.</p><p>Java堆划分出很多缓冲区,后面单独讨论.</p><p>Java堆可处于物理上不连续的内存空间,只要保证逻辑连续.实现时,可固定,可拓展(-Xms/-Xmx)</p><p><strong>异常:</strong></p><ul><li>OutOfMemoryError</li></ul><h5 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h5><p><strong>定义:</strong></p><p>用于存储已被虚拟机加载的类信息,常量,静态变量,即时编译器编译后的代码等数据.</p><blockquote><p>JVM规范描述方法区为堆的一个<strong>逻辑部分</strong>,但却有一个Non-Heap的别名</p></blockquote><p><strong>特点:</strong></p><p>是<strong>线程共享</strong>的内存区域</p><p>不需要连续的物理内存,可以选择固定大小或者可拓展.</p><p>可以选择不实现垃圾收集.</p><p>该区域的内存回收针对常量池的回收和对类型的卸载.</p><p><strong>异常:</strong></p><ul><li>OutOfMemoryError</li></ul><h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><p><strong>定义:</strong></p><p><code>运行时常量池Runtime COnstant Pool</code>是方法区的一部分.Class文件有一项信息是常量池,用于存放编译期生成的各种字面量和符号引用,这部分内容将在类加载后进入方法区的运行时常量池中存放.</p><p><strong>特点:</strong></p><p>JVM对Class文件每一部分格式都有严格规定,但对<code>运行时常量池</code>没有细节要求.</p><p>具备动态性,运行期间也可以把新的常量放入池中.</p><p><strong>异常:</strong></p><ul><li>OutOfMemoryError</li></ul><h5 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h5><p><strong>定义:</strong></p><p>Java NIO(New Input/Output)可以使用Native函数库直接分配堆外内存,然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作.</p><p><strong>异常:</strong></p><ul><li>OutOfMemoryError</li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Tensorflow] Faster R-CNN 和自定义 VOC 数据集</title>
      <link href="/2017/12/16/%5BTensorflow%5DFasterRCNN_and_VOC_dataset/"/>
      <url>/2017/12/16/%5BTensorflow%5DFasterRCNN_and_VOC_dataset/</url>
      
        <content type="html"><![CDATA[<h3 id="Faster-R-CNN-和自定义-VOC-数据集"><a href="#Faster-R-CNN-和自定义-VOC-数据集" class="headerlink" title="Faster R-CNN 和自定义 VOC 数据集"></a>Faster R-CNN 和自定义 VOC 数据集</h3><h4 id="制作VOC数据"><a href="#制作VOC数据" class="headerlink" title="制作VOC数据"></a>制作VOC数据</h4><h5 id="修改文件名"><a href="#修改文件名" class="headerlink" title="修改文件名"></a>修改文件名</h5><p>因为VOC文件名都是使用6位数字,为了适应代码,所以需要格式化文件名</p><p>文件改名脚本:</p><pre class=" language-lang-bash"><code class="language-lang-bash">#!/bin/bashindex=1000000;for f in *.png;do    mv "$f" ${index#1}.png    ((index++))done</code></pre><p>VOC代码处理的是<code>jpg</code>格式的文件,所以还需要把<code>png</code>转换成<code>jpg</code>:</p><pre class=" language-lang-bash"><code class="language-lang-bash">bash -c 'for image in *.png; do convert "$image" "${image%.png}.jpg"; echo “image $image converted to ${image%.png}.jpg ”; done'</code></pre><p>看了pascal_voc.py代码,可以把代码的<code>jpg</code>拼接改成<code>png</code>,这样可以不做上一步.</p><h5 id="标记图片"><a href="#标记图片" class="headerlink" title="标记图片:"></a>标记图片:</h5><p>依然使用<code>labelImg</code>工具,生成对应的<code>xml</code>文件.</p><p>然后把</p><ol><li>所有图片放到<strong>/tf-faster-rcnn/data/VOCdevkit2007/VOC2007/JPEGImages</strong>中</li><li>所有<code>xml</code>文件放到<strong>/tf-faster-rcnn/data/VOCdevkit2007/VOC2007/Annotations</strong>中</li><li>修改<strong>tf-faster-rcnn/data/VOCdevkit2007/VOC2007/ImageSets/Main</strong>下的4个文件:<ul><li>test.txt    测试图片名称,数量占总图片数量的50%</li><li>trainval.txt    训练/验证图片名称,数量占总图片数量的50%</li><li>train.txt    训练图片名称,数量占 训练/验证(上一条) 总数的50%</li><li>val.txt    验证图片名称,数量占 训练/验证总数的50%</li></ul></li></ol><p>最后修改<strong>tf-faster-rcnn/lib/datasets/pascal_voc.py</strong>,把<code>self._classes</code>定义的类别填入我们自己要识别的类别.</p><p>到此,自己的VOC数据集就可以使用了.</p><h4 id="Faster-RCNN使用"><a href="#Faster-RCNN使用" class="headerlink" title="Faster RCNN使用"></a>Faster RCNN使用</h4><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><pre class=" language-lang-bash"><code class="language-lang-bash">git clone https://github.com/endernewton/tf-faster-rcnn.git</code></pre><h5 id="修改配置-使支持CPU选项"><a href="#修改配置-使支持CPU选项" class="headerlink" title="修改配置,使支持CPU选项"></a>修改配置,使支持CPU选项</h5><ul><li><p>tf-faster-rcnn/lib/model/nms_wrapper.py 修改/注释以下行:</p><pre class=" language-lang-python"><code class="language-lang-python">#from nms.gpu_nms import gpu_nmsdef nms(dets, thresh, force_cpu=False):   #Dispatch to either CPU or GPU NMS implementations.    if dets.shape[0] == 0:        return []    if cfg.USE_GPU_NMS and not force_cpu:        #return gpu_nms(dets, thresh, device_id=cfg.GPU_ID)        return cpu_nms(dets, thresh)    else:        return cpu_nms(dets, thresh)</code></pre></li><li><p>tf-faster-rcnn/lib/model/config.py 修改代码为:</p><pre class=" language-lang-python"><code class="language-lang-python">__C.USE_GPU_NMS = False</code></pre></li><li><p>tf-faster-rcnn/lib/setup.py 注释下面代码:</p><pre class=" language-lang-python"><code class="language-lang-python">CUDA = locate_cuda()self.src_extensions.append('.cu')Extension('nms.gpu_nms',        ['nms/nms_kernel.cu', 'nms/gpu_nms.pyx'],        library_dirs=[CUDA['lib64']],        libraries=['cudart'],        language='c++',        runtime_library_dirs=[CUDA['lib64']],        # this syntax is specific to this build system        # we're only going to use certain compiler args with nvcc and not with gcc        # the implementation of this trick is in customize_compiler() below        extra_compile_args={'gcc': ["-Wno-unused-function"],                            'nvcc': ['-arch=sm_52',                                     '--ptxas-options=-v',                                     '-c',                                     '--compiler-options',                                     "'-fPIC'"]},        include_dirs = [numpy_include, CUDA['include']]</code></pre></li></ul><h5 id="编译Cython"><a href="#编译Cython" class="headerlink" title="编译Cython"></a>编译Cython</h5><pre class=" language-lang-bash"><code class="language-lang-bash">cd libmake cleanmakecd ..</code></pre><h5 id="安装python-coco-API"><a href="#安装python-coco-API" class="headerlink" title="安装python coco API"></a>安装python coco API</h5><pre class=" language-lang-bash"><code class="language-lang-bash">cd datagit clone https://github.com/pdollar/coco.gitcd coco/PythonAPImakecd ../../..</code></pre><h5 id="下载预训练模型"><a href="#下载预训练模型" class="headerlink" title="下载预训练模型"></a>下载预训练模型</h5><pre class=" language-lang-bash"><code class="language-lang-bash">./data/scripts/fetch_faster_rcnn_models.sh</code></pre><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><pre class=" language-lang-bash"><code class="language-lang-bash">./tools/demo.py</code></pre><p>会对<strong>/data/demo/</strong>目录下的图片进行识别.如果需要识别其他图片,修改demo.py里的im_names列表.</p><h5 id="训练自己的数据"><a href="#训练自己的数据" class="headerlink" title="训练自己的数据"></a>训练自己的数据</h5><p>下载预训练的模型,目前支持<code>VGG16</code>和<code>Resnet V1</code></p><pre class=" language-lang-bash"><code class="language-lang-bash">mkdir -p data/imagenet_weightscd data/imagenet_weightswget -v http://download.tensorflow.org/models/vgg_16_2016_08_28.tar.gztar -xzvf vgg_16_2016_08_28.tar.gzmv vgg_16.ckpt vgg16.ckptcd ../..mkdir -p data/imagenet_weightscd data/imagenet_weightswget -v http://download.tensorflow.org/models/resnet_v1_101_2016_08_28.tar.gztar -xzvf resnet_v1_101_2016_08_28.tar.gzmv resnet_v1_101.ckpt res101.ckptcd ../..</code></pre><p>训练/验证</p><pre class=" language-lang-bash"><code class="language-lang-bash">./experiments/scripts/train_faster_rcnn.sh [GPU_ID] [DATASET] [NET]# GPU_ID is the GPU you want to test on# NET in {vgg16, res50, res101, res152} is the network arch to use# DATASET {pascal_voc, pascal_voc_0712, coco} is defined in train_faster_rcnn.sh# Examples:./experiments/scripts/train_faster_rcnn.sh 0 pascal_voc vgg16./experiments/scripts/train_faster_rcnn.sh 1 coco res101./experiments/scripts/test_faster_rcnn.sh [GPU_ID] [DATASET] [NET]# GPU_ID is the GPU you want to test on# NET in {vgg16, res50, res101, res152} is the network arch to use# DATASET {pascal_voc, pascal_voc_0712, coco} is defined in test_faster_rcnn.sh# Examples:./experiments/scripts/test_faster_rcnn.sh 0 pascal_voc vgg16./experiments/scripts/test_faster_rcnn.sh 1 coco res101</code></pre><p>每次训练前需要把</p><p>output和data/cache目录删掉</p><p>训练次数需要在训练脚本中修改.它的训练不像SSD可以随时中断,然后接着之前的训练.需要一次训练好才会生成文件.后续需要添加</p><p>训练次数在</p><p>train_faster_rcnn.sh 和test_faster_rcnn.sh 里修改</p><h5 id="错误解决"><a href="#错误解决" class="headerlink" title="错误解决:"></a>错误解决:</h5><p>运行test的时候:</p><pre class=" language-lang-bash"><code class="language-lang-bash">Loading model check point from output/vgg16/voc_2007_trainval/default/vgg16_faster_rcnn_iter_300.ckptLoaded.im_detect: 1/35 3.285s 0.001sim_detect: 2/35 3.619s 0.001sim_detect: 3/35 4.309s 0.001sim_detect: 4/35 4.635s 0.001sim_detect: 5/35 4.665s 0.001sim_detect: 6/35 4.506s 0.001sim_detect: 7/35 4.561s 0.001sim_detect: 8/35 4.713s 0.001sim_detect: 9/35 4.776s 0.001sim_detect: 10/35 4.750s 0.001sim_detect: 11/35 4.787s 0.001sim_detect: 12/35 4.761s 0.001sim_detect: 13/35 4.721s 0.001sim_detect: 14/35 4.788s 0.001sim_detect: 15/35 4.861s 0.001sim_detect: 16/35 4.831s 0.001sim_detect: 17/35 4.848s 0.001sim_detect: 18/35 4.793s 0.001sim_detect: 19/35 4.791s 0.001sim_detect: 20/35 4.755s 0.001sim_detect: 21/35 4.795s 0.001sim_detect: 22/35 4.829s 0.001sim_detect: 23/35 4.873s 0.001sim_detect: 24/35 4.822s 0.001sim_detect: 25/35 4.801s 0.001sim_detect: 26/35 4.787s 0.001sim_detect: 27/35 4.758s 0.001sim_detect: 28/35 4.747s 0.001sim_detect: 29/35 4.717s 0.001sim_detect: 30/35 4.725s 0.001sim_detect: 31/35 4.754s 0.001sim_detect: 32/35 4.759s 0.001sim_detect: 33/35 4.775s 0.001sim_detect: 34/35 4.786s 0.001sim_detect: 35/35 4.796s 0.001sEvaluating detectionsWriting knife VOC results fileTraceback (most recent call last):  File "./tools/test_net.py", line 120, in <module>    test_net(sess, net, imdb, filename, max_per_image=args.max_per_image)  File "/home/wow/Github/tf-faster-rcnn/tools/../lib/model/test.py", line 192, in test_net    imdb.evaluate_detections(all_boxes, output_dir)  File "/home/wow/Github/tf-faster-rcnn/tools/../lib/datasets/pascal_voc.py", line 278, in evaluate_detections    self._write_voc_results_file(all_boxes)  File "/home/wow/Github/tf-faster-rcnn/tools/../lib/datasets/pascal_voc.py", line 205, in _write_voc_results_file    with open(filename, 'wt') as f:IOError: [Errno 2] No such file or directory: '/home/wow/Github/tf-faster-rcnn/data/VOCdevkit2007/results/VOC2007/Main/comp4_c412401c-8e25-43ab-ba7f-e65b9089897c_det_test_knife.txt'Command exited with non-zero status 1590.78user 10.24system 2:51.10elapsed 351%CPU (0avgtext+0avgdata 2778584maxresident)k</code></pre><p>查看pascal_voc.py代码,发现这里<code>with open(filename, &#39;wt&#39;) as f</code>代码应该会创建文件,只是因为没有results目录,所以手动创建tf-faster-rcnn/data/VOCdevkit2007/results/VOC2007/Main/目录即可.</p><p>测试通过后进行对图片的识别,识别依然使用<code>./tools/demo.py</code>:</p><pre class=" language-lang-bash"><code class="language-lang-bash">./tools/demo.py --net=vgg16 --dataset=pascal_voc</code></pre><p>得到如下错误:</p><pre class=" language-lang-bash"><code class="language-lang-bash">2017-12-26 17:04:58.521558: I tensorflow/core/platform/cpu_feature_guard.cc:137] Your CPU supports instructions that this TensorFlow binary was not compiled to use: SSE4.1 SSE4.2 AVXbegin to restoreTraceback (most recent call last):  File "./tools/demo.py", line 141, in <module>    saver.restore(sess, tfmodel)  File "/home/wow/ML/tensorflow/local/lib/python2.7/site-packages/tensorflow/python/training/saver.py", line 1666, in restore    {self.saver_def.filename_tensor_name: save_path})  File "/home/wow/ML/tensorflow/local/lib/python2.7/site-packages/tensorflow/python/client/session.py", line 889, in run    run_metadata_ptr)  File "/home/wow/ML/tensorflow/local/lib/python2.7/site-packages/tensorflow/python/client/session.py", line 1120, in _run    feed_dict_tensor, options, run_metadata)  File "/home/wow/ML/tensorflow/local/lib/python2.7/site-packages/tensorflow/python/client/session.py", line 1317, in _do_run    options, run_metadata)  File "/home/wow/ML/tensorflow/local/lib/python2.7/site-packages/tensorflow/python/client/session.py", line 1336, in _do_call    raise type(e)(node_def, op, message)tensorflow.python.framework.errors_impl.InvalidArgumentError: Assign requires shapes of both tensors to match. lhs shape= [84] rhs shape= [16]     [[Node: save/Assign = Assign[T=DT_FLOAT, _class=["loc:@vgg_16/bbox_pred/biases"], use_locking=true, validate_shape=true, _device="/job:localhost/replica:0/task:0/device:CPU:0"](vgg_16/bbox_pred/biases, save/RestoreV2)]]Caused by op u'save/Assign', defined at:  File "./tools/demo.py", line 139, in <module>    saver = tf.train.Saver()  File "/home/wow/ML/tensorflow/local/lib/python2.7/site-packages/tensorflow/python/training/saver.py", line 1218, in __init__    self.build()  File "/home/wow/ML/tensorflow/local/lib/python2.7/site-packages/tensorflow/python/training/saver.py", line 1227, in build    self._build(self._filename, build_save=True, build_restore=True)  File "/home/wow/ML/tensorflow/local/lib/python2.7/site-packages/tensorflow/python/training/saver.py", line 1263, in _build    build_save=build_save, build_restore=build_restore)  File "/home/wow/ML/tensorflow/local/lib/python2.7/site-packages/tensorflow/python/training/saver.py", line 751, in _build_internal    restore_sequentially, reshape)  File "/home/wow/ML/tensorflow/local/lib/python2.7/site-packages/tensorflow/python/training/saver.py", line 439, in _AddRestoreOps    assign_ops.append(saveable.restore(tensors, shapes))  File "/home/wow/ML/tensorflow/local/lib/python2.7/site-packages/tensorflow/python/training/saver.py", line 160, in restore    self.op.get_shape().is_fully_defined())  File "/home/wow/ML/tensorflow/local/lib/python2.7/site-packages/tensorflow/python/ops/state_ops.py", line 276, in assign    validate_shape=validate_shape)  File "/home/wow/ML/tensorflow/local/lib/python2.7/site-packages/tensorflow/python/ops/gen_state_ops.py", line 57, in assign    use_locking=use_locking, name=name)  File "/home/wow/ML/tensorflow/local/lib/python2.7/site-packages/tensorflow/python/framework/op_def_library.py", line 787, in _apply_op_helper    op_def=op_def)  File "/home/wow/ML/tensorflow/local/lib/python2.7/site-packages/tensorflow/python/framework/ops.py", line 2956, in create_op    op_def=op_def)  File "/home/wow/ML/tensorflow/local/lib/python2.7/site-packages/tensorflow/python/framework/ops.py", line 1470, in __init__    self._traceback = self._graph._extract_stack()  # pylint: disable=protected-accessInvalidArgumentError (see above for traceback): Assign requires shapes of both tensors to match. lhs shape= [84] rhs shape= [16]     [[Node: save/Assign = Assign[T=DT_FLOAT, _class=["loc:@vgg_16/bbox_pred/biases"], use_locking=true, validate_shape=true, _device="/job:localhost/replica:0/task:0/device:CPU:0"](vgg_16/bbox_pred/biases, save/RestoreV2)]]</code></pre><p>这个错误推测是之前训练的cache没有清空导致模型数据不匹配.删除/data/cache和/output,重新训练.</p><p>又遇到类似的错误:</p><pre class=" language-lang-bash"><code class="language-lang-bash">tensorflow.python.framework.errors_impl.InvalidArgumentError: Assign requires shapes of both tensors to match. lhs shape= [4096,21] rhs shape= [4096,4]</code></pre><p>这次的shape和上一次的不一样.通过阅读demo.py代码,发现这一行定义了21:</p><pre class=" language-lang-python"><code class="language-lang-python">    net.create_architecture("TEST", 21,                          tag='default', anchor_scales=[8, 16, 32])</code></pre><p>把21改成4,成功运行.</p><p>Reference:</p><p><a href="https://github.com/smallcorgi/Faster-RCNN_TF" target="_blank" rel="noopener">https://github.com/smallcorgi/Faster-RCNN_TF</a></p><p><a href="https://github.com/endernewton/tf-faster-rcnn" target="_blank" rel="noopener">https://github.com/endernewton/tf-faster-rcnn</a></p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> Tensorflow </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Tensorflow] Tensorflow卷积理解</title>
      <link href="/2017/12/16/%5BTensorflow%5Dconv-in-tf/"/>
      <url>/2017/12/16/%5BTensorflow%5Dconv-in-tf/</url>
      
        <content type="html"><![CDATA[<h1 id="Tensorflow-convolution"><a href="#Tensorflow-convolution" class="headerlink" title="Tensorflow convolution"></a>Tensorflow convolution</h1><h2 id="CNN"><a href="#CNN" class="headerlink" title="CNN"></a>CNN</h2><p><code>CNN</code>对于学习深度学习的人来说应该是比较耳熟的名词了.但很多人只是听过,但不知道是什么.</p><p><code>CNN</code>全称是<code>convolutional neural network</code>,可以这么说,只要神经网络里有一层卷积层,就可以称其为<code>CNN</code>.</p><p>目前,<code>CNN</code>在物体识别领域使用的非常广泛,比如<code>R-CNN</code>,<code>Faster R-CNN</code>,<code>R-FCN</code>,<code>SSD</code>等很多优秀模型都在使用卷积网络.</p><p>所以作为实践者,肯定希望自己用代码去实现这些模型.这里便是对Tensorflow的conv系列方法使用的尝试.</p><h2 id="conv2d"><a href="#conv2d" class="headerlink" title="conv2d"></a>conv2d</h2><p>因为图像识别应用更加广泛,而且二维更好理解,所以从conv2d方法开始.</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><pre class=" language-lang-python"><code class="language-lang-python">conv2d(    input,    filter,    strides,    padding,    use_cudnn_on_gpu=True,    data_format='NHWC',    name=None)</code></pre><p>计算一个二维的卷积.传入四维的<code>input</code>,该Tensor的形状为<code>[batch, in_height, in_width, in_channels]</code>.还要传入一个形状为<code>[filter_height, filter_width, in_channels, out_channels]</code>的四维卷积核.<br>这个方法做了如下操作:</p><ol><li>将卷积核压成形状为<code>[filter_height * filter_width * in_channels, output_channels]</code>的二维矩阵</li><li>从输入Tensor提取图像patches(其实就是把每个channel提出来),生成一个虚拟的Tensor<code>[batch, out_height, out_width, filter_height * filter_width * in_channels]</code></li><li>对每个patch,把每个图像patch向量右乘卷积核矩阵</li></ol><p>整体来讲,在默认的<code>NHWC</code>格式下,</p><pre class=" language-lang-python"><code class="language-lang-python">output[b, i, j, k] = sum_{di, dj, q} input[b, strides[1] * i + di, strides[2] * j + dj, q] * filter[di, dj, q, k]</code></pre><p>这里<code>strides[0] = strides[3] = 1</code>.对于常见的纵横方向上等量步长,有<code>strides = [1, stride, stride, 1]</code></p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li><code>input</code>:是一个四维<code>Tensor</code>,数据类型必须是<code>half</code>或<code>float32</code>.每层维度解释是通过<code>data_format</code>决定的.</li><li><code>filter</code>:也是一个四维<code>Tensor</code>,数据类型要和<code>input</code>一致,形状为<code>[filter_height, filter_width, in_channels, out_channels]</code></li><li><code>strides</code>:是一个<code>ints</code>列表.长度为4的一维tensor.是在<code>input</code>每个维度上滑动窗口时每次滑动的步长.其维度顺序也是由<code>data_format</code>决定</li><li><code>padding</code>: 有两个<code>string</code>类型值,”SAME”, “VALID”.涉及到卷积核移动范围.</li><li><code>use_cudnn_on_gpu</code>: <code>bool</code>值,默认<code>True</code>.使用GPU计算的选项.</li><li><code>data_format</code>: 两种<code>string</code>类型的值: <code>NHWC</code>, <code>NCHW</code>. 默认<code>NHWC</code>. 指定输入输出数据维度的意义. <code>NHWC</code>的数据顺序为: <code>[batch, height, width, channels]</code>.<code>NCHW</code>数据顺序为: <code>[batch, channels, height, width]</code>.</li><li><code>name</code>: 该方法的名字,可选参数,<code>TensorBoard</code>会用到.</li></ul><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>和<code>input</code>一样形状的<code>Tensor</code></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre class=" language-lang-python"><code class="language-lang-python">import tensorflow as tf</code></pre><p>二维卷积比较多的用在图像数据处理上.我们假设有一个3x3,1通道的图片:</p><pre class=" language-lang-python"><code class="language-lang-python">input_img = tf.constant([[[[1], [2], [3]],                          [[4], [5], [6]],                          [[7], [8], [9]]]], tf.float32, [1, 3, 3, 1])</code></pre><p>然后再设计一个1x1的卷积核,按照步长为1的长度在图像上滑动,计算卷积.</p><pre class=" language-lang-python"><code class="language-lang-python">conv_filter1 = tf.constant([[[[2]]]], tf.float32, [1, 1, 1, 1])op1 = tf.nn.conv2d(input_img, conv_filter1, strides=[1, 1, 1, 1], padding='VALID')with tf.Session() as sess:    sess.run(tf.global_variables_initializer())    print sess.run(op1)</code></pre><p>运行结果：</p><pre class=" language-lang-bash"><code class="language-lang-bash">[[[[  2.]   [  4.]   [  6.]]  [[  8.]   [ 10.]   [ 12.]]  [[ 14.]   [ 16.]   [ 18.]]]]</code></pre><p>看到结果,是图像每个像素和卷积核相乘. 我们再看看多通道的图像,把原来的图片变成5个通道.</p><pre class=" language-lang-python"><code class="language-lang-python">input_img2 = tf.constant([[[[1, 1, 1, 1, 1],                            [2, 2, 2, 2, 2],                            [3, 3, 3, 3, 3]],                           [[4, 4, 4, 4, 4],                            [5, 5, 5, 5, 5],                            [6, 6, 6, 6, 6]],                           [[7, 7, 7, 7, 7],                            [8, 8, 8, 8, 8],                            [9, 9, 9, 9, 9]]]], tf.float32, [1, 3, 3, 5])</code></pre><p>因为图像通道变为5,卷积核的输入通道也要填为5.卷积核的输出通道我们先用1通道:</p><pre class=" language-lang-python"><code class="language-lang-python">conv_filter2 = tf.constant([[[[2]]]], tf.float32, [1, 1, 5, 1])op2 = tf.nn.conv2d(input_img2, conv_filter2, strides=[1, 1, 1, 1], padding='VALID')with tf.Session() as sess:    sess.run(tf.global_variables_initializer())    print sess.run(op2)</code></pre><p>运行结果：</p><pre class=" language-lang-bash"><code class="language-lang-bash">[[[[ 10.]   [ 20.]   [ 30.]]  [[ 40.]   [ 50.]   [ 60.]]  [[ 70.]   [ 80.]   [ 90.]]]]</code></pre><p>通过运行结果,不难猜出,卷积核对5个通道都进行了计算,然后因为输出为1通道,所以把这5层叠加起来输出.</p><p>自然地,我们也可以推测卷积核输出5通道的话,应该是分5个通道的结果.尝试一下:</p><pre class=" language-lang-python"><code class="language-lang-python">conv_filter3 = tf.constant([[[[2]]]], tf.float32, [1, 1, 5, 5])op3 = tf.nn.conv2d(input_img2, conv_filter3, strides=[1, 1, 1, 1], padding='VALID')with tf.Session() as sess:    sess.run(tf.global_variables_initializer())    print sess.run(op3)</code></pre><p>运行结果：</p><pre class=" language-lang-bash"><code class="language-lang-bash">[[[[ 10.  10.  10.  10.  10.]   [ 20.  20.  20.  20.  20.]   [ 30.  30.  30.  30.  30.]]  [[ 40.  40.  40.  40.  40.]   [ 50.  50.  50.  50.  50.]   [ 60.  60.  60.  60.  60.]]  [[ 70.  70.  70.  70.  70.]   [ 80.  80.  80.  80.  80.]   [ 90.  90.  90.  90.  90.]]]]</code></pre><p>结果的确如我们所料.</p><p>现在我们放大卷积核,1x1的卷积核看不出计算方式,我们换2x2的试试看.运行代码前可以先想想结果,2x2的核在3x3的图像上滑动,滑动步长为1,那么结果应该也是2x2的.</p><pre class=" language-lang-python"><code class="language-lang-python">conv_filter4 = tf.constant([[[[2]], [[4]]], [[[3]], [[1]]]], tf.float32, [2, 2, 1, 1])op4 = tf.nn.conv2d(input_img, conv_filter4, strides=[1, 1, 1, 1], padding='VALID')with tf.Session() as sess:    sess.run(tf.global_variables_initializer())    print sess.run(op4)</code></pre><p>运行结果：</p><pre class=" language-lang-bash"><code class="language-lang-bash">[[[[ 27.]   [ 37.]]  [[ 57.]   [ 67.]]]]</code></pre><p>上面我们使用了</p><pre><code>2 4 3 1</code></pre><p>的卷积核在原图</p><pre><code>1 2 34 5 6 7 8 9</code></pre><p>上滑动</p><p>第一个值的计算是1x2+2x4+4x3+5x1=27. </p><p>然后卷积核向右移动一格,继续计算: 2x2+3x4+5x3+6x1=37.</p><p>前两行遍历完卷积核从第2行开始,继续向右遍历.得到最后的结果.</p><p>这里有个卷积工作的参考图:<img src="https://pic4.zhimg.com/50/v2-15fea61b768f7561648dbea164fcb75f_hd.gif" alt="conv_gif"></p><blockquote><p>图片出处<a href="https://mlnotebook.github.io/post/CNN1/" target="_blank" rel="noopener">https://mlnotebook.github.io/post/CNN1/</a></p></blockquote><p>有了前面的了解,可以聊一聊<code>padding</code>参数了.前面的例子,我们的卷积核都是在图片范围内移动的,永远不会超出图像的边缘.</p><p>这样有一个问题就是如果卷积核size很大,比如用3x3的,那么我们3x3的图像就只能输出一个1x1的值.这个值可能代表了图片中心的一个特征,而图像边缘的信息就被弱化了.再假如我们这个图像就是个空心圆,特征都在边缘,那这个卷积核就不能够很好地体现出图片的特征.</p><p>所以为了解决边缘问题,我们会适当地拓展图像,让卷积核可以在原始尺寸外移动.</p><p>但卷积核终究是要计算的,移动到外面和谁去相乘呢?一般做法就是填0,就好像上面的gif图,图片本身是4x4的,但在左侧和底侧都填满了0,让卷积核可以多一些输出.实际中,往哪个方向拓展图片,填0还是其他数字都是根据情况选择的.</p><p>上面是我个人的理解.我们用Tensorflow看看他们是怎么做的.我们把<code>padding</code>参数改成<code>SAME</code>:</p><pre class=" language-lang-python"><code class="language-lang-python">conv_filter5 = tf.constant([[[[2]], [[4]]], [[[3]], [[1]]]], tf.float32, [2, 2, 1, 1])op5 = tf.nn.conv2d(input_img, conv_filter5, strides=[1, 1, 1, 1], padding='SAME')with tf.Session() as sess:    sess.run(tf.global_variables_initializer())    print sess.run(op5)</code></pre><p>运行结果：</p><pre class=" language-lang-Bash"><code class="language-lang-Bash">[[[[ 27.]   [ 37.]   [ 24.]]  [[ 57.]   [ 67.]   [ 39.]]  [[ 46.]   [ 52.]   [ 18.]]]]</code></pre><p>从结果上看,原本是</p><pre><code>27 3757 67</code></pre><p>的结果变成了</p><pre><code>27 37 2457 67 3946 52 18</code></pre><p>实际上Tensorflow对<code>padding</code>有一套自己的计算方式:</p><p>为了方便理解,我们分水平方向和垂直方向.(源码是直接使用Size)</p><p>我们的情况是:input是3x3, filter是2x2, Stride是1, output是WxH</p><p>output_size = (input_size + stride -1) / stride &gt;&gt; W=(3+1-1)/1=3</p><p>需要添加的padding大小为 </p><p>pad_need = max(0, (output_size - 1) * stride + filter_size - input_size) = max(0, (3-1)x1+2-3)=1</p><p>往图片左边添加的pad_left = pad_need / 2 = 1 / 2 = 0</p><p>往图片右边添加的pad_right = pad_need - pad_left = 1 - 0 = 1</p><p>纵向同样计算方式.所以最后的图像变成</p><pre><code>1 2 3 04 5 6 07 8 9 00 0 0 0</code></pre><p>最后再计算卷积,得到的结果就是上面运行的结果.</p><blockquote><p>源码在/tensorflow/tensorflow/core/framework/common_shape_fns.cc</p></blockquote><p>最后再看看步长<code>stride</code></p><p>默认<code>NHWC</code>格式下,<code>stride</code>是<code>[batch, height, width, channels]</code>,在二维情况下,<code>height</code>对应纵向移动步长,<code>width</code>对应水平移动步长.一般情况,二维<code>stride</code>写成<code>[1, stride, stride,1]</code>的形式.</p><p>我们使用1x1的卷积核对3x3的图片以步长为2处理:</p><pre class=" language-lang-python"><code class="language-lang-python">conv_filter6 = tf.constant([[[[2]]]], tf.float32, [1, 1, 1, 1])op6 = tf.nn.conv2d(input_img, conv_filter6, strides=[1, 2, 2, 1], padding='VALID')with tf.Session() as sess:    sess.run(tf.global_variables_initializer())    print sess.run(op6)</code></pre><p>运行结果：</p><pre><code>[[[[  2.]   [  6.]]  [[ 14.]   [ 18.]]]]</code></pre><p>结果是原来3x3的四个角.很容易理解.再试试不同方向不同的<code>stride</code></p><pre class=" language-lang-python"><code class="language-lang-python">op7 = tf.nn.conv2d(input_img, conv_filter6, strides=[1, 2, 1, 1], padding='SAME')with tf.Session() as sess:    sess.run(tf.global_variables_initializer())    print sess.run(op7)</code></pre><p>运行结果：</p><pre class=" language-lang-Bash"><code class="language-lang-Bash">[[[[  2.]   [  4.]   [  6.]]  [[ 14.]   [ 16.]   [ 18.]]]]</code></pre><p>横向移动为1,纵向为2,结果就是2x3.</p><p>至此,Tensorflow二维的卷积应该就比较清楚了.</p><h2 id="conv1d"><a href="#conv1d" class="headerlink" title="conv1d"></a>conv1d</h2><p>有了2d卷积的理解,看1d应该更容易.对一维来讲,卷积就是对一条线一小段一小段地叠加.这个我会结合<strong>DeepLearning</strong>这本书上的卷积章节做一些整理.</p><h3 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h3><pre class=" language-lang-python"><code class="language-lang-python">conv1d(    value,    filters,    stride,    padding,    use_cudnn_on_gpu=None,    data_format=None,    name=None)</code></pre><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><p>从二维卷积降到一维,我们的数据自然也从四维降到三维.</p><p>所以</p><ul><li><code>input</code>的形状就变成<code>[batch, in_width, in_channels]</code></li><li><code>filter</code>的形状变为<code>[filter_width, in_channels, out_channels]</code></li><li><code>stride</code>变成一个整形数字</li></ul><p>实际上,一维的卷积方法在运行时,会把数据增加一维,然后使用<code>conv2d</code>方法计算.</p><p>变换过程是:</p><ul><li><code>[batch, in_width, in_channels]</code>-&gt;<code>[batch, 1, in_width, in_channels]</code></li><li><code>[filter_width, in_channels, out_channels]</code>-&gt;<code>[1, filter_width, in_channels, out_channels]</code></li></ul><h3 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h3><p>当然,计算结果是升维的结果,返回时需要做一次降维.最终返回结果是<code>[batch, out_width, out_channels]</code></p><h2 id="conv3d"><a href="#conv3d" class="headerlink" title="conv3d"></a>conv3d</h2><h3 id="函数-2"><a href="#函数-2" class="headerlink" title="函数"></a>函数</h3><pre class=" language-lang-python"><code class="language-lang-python">conv3d(    input,    filter,    strides,    padding,    data_format='NDHWC',    name=None)</code></pre><blockquote><p>In signal processing, cross-correlation is a measure of similarity of two waveforms as a function of a time-lag applied to one of them. This is also known as a sliding dot product or sliding inner-product.</p><p>Our Conv3D implements a form of cross-correlation.</p></blockquote><h3 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h3><p>主要是增加一个维度</p><ul><li><code>input</code>:<code>[batch, in_depth, in_height, in_width, in_channels]</code></li><li><code>filter</code>:<code>[filter_depth, filter_height, filter_width, in_channels, out_channels]</code></li></ul><h3 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h3><p>同<code>input</code></p><h2 id="conv2d-backprop-filter"><a href="#conv2d-backprop-filter" class="headerlink" title="conv2d_backprop_filter"></a>conv2d_backprop_filter</h2><p>根据<code>filter</code>计算卷积的梯度</p><h2 id="conv2d-backprop-input"><a href="#conv2d-backprop-input" class="headerlink" title="conv2d_backprop_input"></a>conv2d_backprop_input</h2><p>根据<code>input</code>计算卷积的梯度</p><h2 id="conv2d-transpose"><a href="#conv2d-transpose" class="headerlink" title="conv2d_transpose"></a>conv2d_transpose</h2><p>这个方法有时被成为反卷积,实际上更准确的是对<code>conv2d</code>的转置.</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="http://www.jianshu.com/p/05c4f1621c7e" target="_blank" rel="noopener">Tensorflow中卷积的padding操作</a></p><p><a href="https://www.tensorflow.org/api_docs/python/tf/nn/conv2d" target="_blank" rel="noopener">tf.nn.conv2d</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> Tensorflow </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CS]聊聊字符编码</title>
      <link href="/2017/12/15/%5BCS%5DTalk-about-char-encode/"/>
      <url>/2017/12/15/%5BCS%5DTalk-about-char-encode/</url>
      
        <content type="html"><![CDATA[<h4 id="源起一个Bug"><a href="#源起一个Bug" class="headerlink" title="源起一个Bug"></a>源起一个Bug</h4><p>用爬虫在百度爬图片的时候,发现部分查询关键字的时候,出现爬不出图片的情况.比如在爬<code>鱼</code>的时候,就没有结果.爬<code>鱼 图片</code>就会有结果.</p><p>经过异常捕获,发现,在对<code>URL</code>转码的时候出现了转码错误:</p><pre class=" language-lang-python"><code class="language-lang-python">html = requests.get(url, timeout=10).content.decode('utf-8')error:    html = requests.get(url, timeout=10).content.decode('utf-8')UnicodeDecodeError: 'utf-8' codec can't decode byte 0xe7 in position 63897: invalid continuation byte</code></pre><p>Log的意思是,<code>UTF-8</code>的解码器无法处理字符<code>0xe7</code></p><p>最后的解决方案是使用<code>latin-1</code>编码:</p><pre class=" language-lang-python"><code class="language-lang-python">html = requests.get(url, timeout=10).content.decode('latin-1')</code></pre><p>不过这里遗留了几个问题:</p><ul><li><code>0xe7</code>是什么?</li><li><code>latin-1</code>是什么编码?</li></ul><p>下面就要聊一聊这些问题.</p><h4 id="计算机编码"><a href="#计算机编码" class="headerlink" title="计算机编码"></a>计算机编码</h4><p>在计算机中,所有数据在存储和运算时都要使用二进制表示(这个不理解可以问问冯诺依曼),也就是说,所有字母,符号在计算机中都是由<code>0</code>和<code>1</code>组成的一串数字表示.但是,就像我们需要给所有事物起名一样,所有现实中的字母,符号都需要一个对应的<code>0</code> <code>1</code>字串表示,即编码.为了方便大家编码互通,就需要制定统一的编码规则,<code>ASCII</code>码就这么产生了.</p><h4 id="ASCII编码"><a href="#ASCII编码" class="headerlink" title="ASCII编码"></a>ASCII编码</h4><p>学编程的时候,<code>ASCII</code>是最早介绍的字符编码.<br>标准<code>ASCII</code>使用7位二进制数,因为一个字节占8位,所以在第一位补0形成8位.</p><p>举个栗子:<br>在<code>ASCII</code>编码中,字母<code>A</code>的表示为:</p><ul><li>二进制: 0100 0001</li><li>十进制: 65</li><li>十六进制: 0x41</li></ul><p>所以看前面的问题:<code>0xe7</code>是什么?<br><code>0x</code>是16进制,用二进制表示就是<code>1110 0111</code>,十进制是<code>231</code>.</p><p>对照<code>ASCII</code>码,7位一共128个字符,231明显超过了128,所以对于<code>ASCII</code>编码来说,它并不认识<code>0xe7</code>.<br>这也说明了一个问题,由于<code>ASCII</code>编码长度很短,可以表示的字符有限,遇到中文或者其他字符,就需要其他编码来表示.</p><p>比如中文,上万个汉子需要表示,仅用1个字节表示$2^8$个字符是不够的.所以像<code>GB2312</code>就是使用两字节表示一个汉字,一共$2^8$ * $2^8$ = 65536个</p><h4 id="Unicode编码"><a href="#Unicode编码" class="headerlink" title="Unicode编码"></a>Unicode编码</h4><p>因为存在不同的编码,所以打开文件前就需要指定正确的编码格式,不然解码出来的都是乱码.<br>那么能不能出一种编码,能够涵盖所有的字符呢?<code>Unicode</code>就是这么样的一个符号集.</p><p>但是<code>Unicode</code>只是一个符号集,只规定符号二进制代码,没有规定二进制如何存储.</p><p>举个栗子:<br>汉字<code>鱼</code>,用<code>Unicode</code>表示为十六进制的<code>9c7c</code>:</p><pre class=" language-lang-python"><code class="language-lang-python">>>> u'鱼'u'\u9c7c'</code></pre><p>用二进制表示为<code>1001 1100 0111 1100</code>,一共16位,所以至少需要两个字节表示它.</p><p>所以问题来了</p><ul><li>怎么确定它是<code>Unicode</code>而不是两个字符组成的<code>ASCII</code>?</li><li>为了解决上面的问题,如果所有字符都用两字节表示,那么只用到7位的字符<code>A</code>就会浪费掉将近一个字节的空间.这怎么解决?</li></ul><h4 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h4><p>为了解决空间浪费的问题，出现了一些中间格式的字符集，他们被称为通用转换格式，即UTF（Unicode Transformation Format）。常见的UTF格式有：UTF-7, UTF-7.5, UTF-8,UTF-16, 以及 UTF-32。</p><p>主要聊聊常见的<code>UTF-8</code><br><code>UTF-8</code>规则:</p><ul><li>如果字符只有一个字节则其最高二进制位为0,后7位是字符的<code>Unicode</code>码.单字节的编码和<code>ASCII</code>一致</li><li>对于N字节(N&gt;1),第一个字节前N位设为1,第N+1位为0，其余各字节均以10开头<pre class=" language-lang-bash"><code class="language-lang-bash">2字节: 110xxxxx 10xxxxxx3字节: 1110xxxx 10xxxxxx 10xxxxxx4字节: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</code></pre></li></ul><p>试着把前面的<code>鱼</code>字转成<code>UTF-8</code>,<code>鱼</code>的二进制16位,正好可以填入3字节的<code>UTF-8</code>:<code>11101001 10110001 10111100</code>,将其转成16进制就是<code>e9b1bc</code>.</p><blockquote><p>填入顺序是从低字节开始填,到高字节填不满的补0</p></blockquote><p>用代码验证一下:</p><pre class=" language-lang-python"><code class="language-lang-python">>>> u'鱼'.encode('utf-8')'\xe9\xb1\xbc'</code></pre><p>了解了<code>UTF-8</code>,再回看之前的Bug:<code>0xe7</code>的二进制是<code>1110 0111</code>,占2字节,对比<code>UTF-8</code>的2字节,第三位就不一样,所以<code>0xe7</code>不属于<code>UTF-8</code>的格式,因此无法解码.</p><h4 id="ISO-IEC-8859-1"><a href="#ISO-IEC-8859-1" class="headerlink" title="ISO/IEC 8859-1"></a>ISO/IEC 8859-1</h4><p>看到这个编码名字是否是一脸懵逼?不过提起别称就清楚了,它就是<code>Latin-1</code>编码.</p><p><code>Latin-1</code>属于单字节编码,最多能表示0-255的范围,即$2^8$,所以<code>0xe7</code>就在它的表示范围内,因此可以解码.</p><p>单字节编码的问题是能够表示的字符很少,但是单字节和计算机最基础的表示单位一致,所以面对其他编码的中文表示,可以拆成一个一个的单字节,用<code>Latin-1</code>进行保存.所以就像上面<code>UTF-8</code>对<code>鱼</code>的表示一样,用<code>Latin-1</code>解码后,单个字节拼起来就是<code>UTF-8</code>编码了:</p><pre class=" language-lang-python"><code class="language-lang-python">>>> b'鱼'.decode('Latin-1')u'\xe9\xb1\xbc'</code></pre><p>以上,问题解决.</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> decode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Tensorflow] 使用SSD-MobileNet训练模型</title>
      <link href="/2017/12/12/%5BTensorflow%5DTrain-model-with-SSD-MobileNet/"/>
      <url>/2017/12/12/%5BTensorflow%5DTrain-model-with-SSD-MobileNet/</url>
      
        <content type="html"><![CDATA[<h3 id="使用SSD-MobileNet训练模型"><a href="#使用SSD-MobileNet训练模型" class="headerlink" title="使用SSD-MobileNet训练模型"></a>使用SSD-MobileNet训练模型</h3><p>因为Android Demo里的模型是已经训练好的，模型保存的label都是固定的，所以我们在使用的时候会发现还有很多东西它识别不出来。那么我们就需要用它来训练我们自己的数据。下面就是使用SSD-MobileNet训练模型的方法。</p><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><ul><li>到Github上下载/克隆<a href="https://github.com/tensorflow/models" target="_blank" rel="noopener">TensorModels</a>，后面的操作都要在这个目录下执行</li><li>下载数据集(数据集应该是自己制作的，制作数据集需要用到一些工具，另外介绍)，我们使用<a href="http://cvlab.postech.ac.kr/~mooyeol/pascal_voc_2012/VOCtrainval_11-May-2012.tar" target="_blank" rel="noopener">VOC2012</a>数据集</li><li>下载<a href="http://download.tensorflow.org/models/object_detection/ssd_mobilenet_v1_coco_11_06_2017.tar.gz" target="_blank" rel="noopener">SSD-MobileNet</a>，我们做得，相当于在这个基础上进行再次训练(retrain)</li></ul><h4 id="环境设置"><a href="#环境设置" class="headerlink" title="环境设置"></a>环境设置</h4><p>进入下载的Model目录：</p><pre class=" language-lang-bash"><code class="language-lang-bash">cd models/research/# 执行protoc object_detection/protos/*.proto --python_out=.export PYTHONPATH="${PYTHONPATH}:/home/Github/models:/home/Github/models/research/slim/"</code></pre><blockquote><p>这里的<code>PYTHONPATH</code>路径一定要填对，不然会影响到后面运行代码。<br>然后还要注意代码版本不同文件路径有差别，所以要对照自己目录看好。</p></blockquote><p>继续在<code>research/</code>目录下执行：</p><pre class=" language-lang-bash"><code class="language-lang-bash"># 如果找不到setup.py， 用find命令找对应的路径python setup.py buildpython setup.py install</code></pre><h4 id="配置及训练"><a href="#配置及训练" class="headerlink" title="配置及训练"></a>配置及训练</h4><p>在<code>object_detection/</code>目录下创建目录<code>ssd_model</code></p><pre class=" language-lang-bash"><code class="language-lang-bash">mkdir object_detection/ssd_model</code></pre><p>把下载好的数据集解压进去，数据集路径为</p><pre class=" language-lang-bash"><code class="language-lang-bash">./object_detection/ssd_model/VOCdevkit/</code></pre><p>执行配置文件</p><pre class=" language-lang-bash"><code class="language-lang-bash">python ./object_detection/dataset_tools/create_pascal_tf_record.py --label_map_path=object_detection/data/pascal_label_map.pbtxt --data_dir=object_detection/ssd_model/VOCdevkit/ --year=VOC2012 --set=train --output_path=object_detection/ssd_model/pascal_train.recordpython ./object_detection/dataset_tools/create_pascal_tf_record.py --label_map_path=object_detection/data/pascal_label_map.pbtxt --data_dir=object_detection/ssd_model/VOCdevkit/ --year=VOC2012 --set=val --output_path=object_detection/ssd_model/pascal_val.record</code></pre><p>然后会在<code>ssd_model/</code>目录下生成<code>pascal_train.record</code>和<code>pascal_val.record</code>两个文件，分别有600M左右。<br>下一步复制训练<code>pet</code>数据用到的文件，我们在这个基础上修改配置，训练我们的数据</p><pre class=" language-lang-python"><code class="language-lang-python">cp object_detection/data/pascal_label_map.pbtxt object_detection/ssd_model/cp object_detection/samples/configs/ssd_mobilenet_v1_pets.config object_detection/ssd_model/</code></pre><p>我们打开pascal_label_map.pbtxt看一下，这个文件里面是类似Json格式的label集，列出了数据集里有哪些<code>label</code>。Pascal这个数据集<code>label</code>共有20个。</p><p>然后打开配置文件ssd_mobilenet_v1_pets.config，把<code>num_classes</code>改为<code>20</code><br>配置默认训练次数<code>num_steps: 200000</code>，我们根据自己需要改，注意这个训练是很慢的，差不多以天为单位，所以可以适当改小点。</p><p>然后改一些文件路径：</p><pre class=" language-lang-bash"><code class="language-lang-bash">train_input_reader: {  tf_record_input_reader {    input_path: "/home/wow/Github/models/research/object_detection/ssd_model/pascal_train.record"  }  label_map_path: "/home/wow/Github/models/research/object_detection/ssd_model/pascal_label_map.pbtxt"}eval_input_reader: {  tf_record_input_reader {    input_path: "/home/wow/Github/models/research/object_detection/ssd_model/pascal_val.record"  }  label_map_path: "/home/wow/Github/models/research/object_detection/ssd_model/pascal_label_map.pbtxt"  shuffle: false  num_readers: 1}</code></pre><p>把之前下载的<code>ssd_mobilenet</code>解压到<code>/object_detection/ssd_model/ssd_mobilenet</code>下</p><p>把路径填进配置文件</p><pre class=" language-lang-bash"><code class="language-lang-bash">fine_tune_checkpoint: "/home/wow/Github/models/research/object_detection/ssd_model/ssd_mobilenet/model.ckpt"</code></pre><p>完成之后，就可以训练模型了</p><pre class=" language-lang-bash"><code class="language-lang-bash">python object_detection/train.py --train_dir object_detection/train --pipeline_config_path object_detection/ssd_model/ssd_mobilenet_v1_pets.config</code></pre><p>经过漫长的等待，可以看到在<code>/object_detection/train</code>目录下生成了模型。然后创建文件夹<code>ssd_model/model</code></p><pre class=" language-lang-bash"><code class="language-lang-bash">python object_detection/export_inference_graph.py --input_type image_tensor --pipeline_config_path object_detection/ssd_model/ssd_mobilenet_v1_pets.config --trained_checkpoint_prefix object_detection/train/model.ckpt-30000 --output_directory object_detection/ssd_model/model/</code></pre><p>生成pb文件，再把pascal_label_map.pbtxt的内容改成<code>.txt</code>作为label文件，这个模型就可以使用了。</p><h4 id="错误解决"><a href="#错误解决" class="headerlink" title="错误解决"></a>错误解决</h4><p>错误1：</p><pre class=" language-lang-bash"><code class="language-lang-bash">TypeError: x and y must have the same dtype, got tf.float32 != tf.int32</code></pre><p>修改<code>./object_detection/builders/post_processing_builder.py</code></p><pre class=" language-lang-python"><code class="language-lang-python">def _score_converter_fn_with_logit_scale(tf_score_converter_fn, logit_scale):  """Create a function to scale logits then apply a Tensorflow function."""  def score_converter_fn(logits):    cr = logit_scale    cr = tf.constant([[cr]],tf.float32)    print(logit_scale)    print(logits)    scaled_logits = tf.divide(logits, cr, name='scale_logits') #change logit_scale    return tf_score_converter_fn(scaled_logits, name='convert_scores')  score_converter_fn.__name__ = '%s_with_logit_scale' % (      tf_score_converter_fn.__name__)  return score_converter_fn</code></pre><p>修改之后，需要再执行：</p><pre class=" language-lang-bash"><code class="language-lang-bash">python setup.py buildpython setup.py install</code></pre><p>错误2：</p><pre class=" language-lang-bash"><code class="language-lang-bash">ImportError: cannot import name rewriter_config_pb2# 或者AttributeError: 'module' object has no attribute 'mark_flag_as_required'</code></pre><p>修改：</p><pre class=" language-lang-bash"><code class="language-lang-bash"># 前一个错pip install --upgrade tensorflow==1.2.0# 后一个错pip install --upgrade tensorflow==1.4.0</code></pre><h4 id="测试模型"><a href="#测试模型" class="headerlink" title="测试模型"></a>测试模型</h4><pre class=" language-lang-python"><code class="language-lang-python">import cv2import numpy as npimport tensorflow as tffrom object_detection.utils import label_map_utilfrom object_detection.utils import visualization_utils as vis_utilclass TOD(object):    def __init__(self):        self.PATH_TO_CKPT = '/home/wow/Github/models/research/object_detection/ssd_model/model/frozen_inference_graph.pb'        self.PATH_TO_LABELS = '/home/wow/Github/models/research/object_detection/ssd_model/pascal_label_map.pbtxt'        self.NUM_CLASSES = 1        self.detection_graph = self._load_model()        self.category_index = self._load_label_map()    def _load_model(self):        detection_graph = tf.Graph()        with detection_graph.as_default():            od_graph_def = tf.GraphDef()            with tf.gfile.GFile(self.PATH_TO_CKPT, 'rb') as fid:                serialized_graph = fid.read()                od_graph_def.ParseFromString(serialized_graph)                tf.import_graph_def(od_graph_def, name='')        return detection_graph    def _load_label_map(self):        label_map = label_map_util.load_labelmap(self.PATH_TO_LABELS)        categories = label_map_util.convert_label_map_to_categories(label_map,                                                                    max_num_classes=self.NUM_CLASSES,                                                                    use_display_name=True)        category_index = label_map_util.create_category_index(categories)        return category_index    def detect(self, image):        with self.detection_graph.as_default():            with tf.Session(graph=self.detection_graph) as sess:                # Expand dimensions since the model expects images to have shape: [1, None, None, 3]                image_np_expanded = np.expand_dims(image, axis=0)                image_tensor = self.detection_graph.get_tensor_by_name('image_tensor:0')                boxes = self.detection_graph.get_tensor_by_name('detection_boxes:0')                scores = self.detection_graph.get_tensor_by_name('detection_scores:0')                classes = self.detection_graph.get_tensor_by_name('detection_classes:0')                num_detections = self.detection_graph.get_tensor_by_name('num_detections:0')                # Actual detection.                (boxes, scores, classes, num_detections) = sess.run(                    [boxes, scores, classes, num_detections],                    feed_dict={image_tensor: image_np_expanded})                # Visualization of the results of a detection.                vis_util.visualize_boxes_and_labels_on_image_array(                    image,                    np.squeeze(boxes),                    np.squeeze(classes).astype(np.int32),                    np.squeeze(scores),                    self.category_index,                    use_normalized_coordinates=True,                    line_thickness=8)        cv2.namedWindow("detection", cv2.WINDOW_NORMAL)        cv2.imshow("detection", image)        cv2.waitKey(0)if __name__ == '__main__':    image = cv2.imread('/home/wow/Github/models/research/object_detection/ssd_model/img/cow-in-pasture.jpg')    detecotr = TOD()    detecotr.detect(image)</code></pre><p>效果：<br><img src="./img/detection_screenshot_27.11.2017.png" alt></p><h4 id="数据制作"><a href="#数据制作" class="headerlink" title="数据制作"></a>数据制作</h4><p>安装<a href="https://github.com/tzutalin/labelImg" target="_blank" rel="noopener">labelImg</a>工具,进行图片的标注.标注后的是<code>xml</code>格式的文件,将这些文件按照一定比例分到<code>train</code>和<code>test</code>目录.</p><p>下载<a href="https://github.com/datitran/raccoon_dataset" target="_blank" rel="noopener">datitran</a>,作者自己写了一套<code>xml</code>转<code>csv</code>再转为<code>record</code>文件的脚本.比SSD的脚本方便使用.</p><p>首先编辑xml_to_csv.py,修改main函数:</p><pre class=" language-lang-python"><code class="language-lang-python">def main():    #image_path = os.path.join(os.getcwd(), 'annotations')    image_path = os.path.join('/home/Github/models/research/object_detection/ssd_model/MyImgs/labels/test')    xml_df = xml_to_csv(image_path)    #xml_df.to_csv('raccoon_labels.csv', index=None)    xml_df.to_csv('fish_test_labels.csv', index=None)    print('Successfully converted xml to csv.')</code></pre><p>执行</p><pre class=" language-lang-python"><code class="language-lang-python">python xml_to_csv.py</code></pre><p>会生成test的csv,同样,修改代码,生成train的csv.</p><p>然后进行csv到record的转换</p><p>首先修改<code>generate_tfrecord.py</code>,把main函数的<code>path</code>改成我们图片路径,然后把<code>if row_label == &#39;raccoon&#39;:</code>改成我们的label,比如<code>fish</code>.之后执行下面代码:</p><pre class=" language-lang-python"><code class="language-lang-python">python generate_tfrecord.py --csv_input=fish_train_labels.csv --output_path=fish_train.recordpython generate_tfrecord.py --csv_input=fish_test_labels.csv --output_path=fish_test.record</code></pre><p>然后会生成对应的record文件:</p><pre class=" language-lang-bash"><code class="language-lang-bash">Successfully created the TFRecords: /home/Github/raccoon_dataset/fish_train.recordSuccessfully created the TFRecords: /home/Github/raccoon_dataset/fish_test.record</code></pre><p>回到我们之前训练SSD的目录,创建自己的label文件<code>my_label_map.pbtxt</code></p><pre class=" language-lang-bash"><code class="language-lang-bash">item {  id: 1  name: 'fish'}</code></pre><p>修改训练配置文件:</p><pre class=" language-lang-bash"><code class="language-lang-bash">num_classes: 1 #20</code></pre><p>再把所有<code>PATH_TO_BE_CONFIGURED</code>的地方改掉,就可以用前面的命令进行训练.</p><p>训练时会遇到这个错误:</p><pre class=" language-lang-bash"><code class="language-lang-bash">INFO:tensorflow:Restoring parameters from object_detection/train/model.ckpt-5390INFO:tensorflow:Error reported to Coordinator: <class 'tensorflow.python.framework.errors_impl.InvalidArgumentError'>, Assign requires shapes of both tensors to match. lhs shape= [1,1,128,12] rhs shape= [1,1,128,126]</code></pre><p>这是因为之前我有训练过模型,训练到5390次就停了.这里配置写的是200k次,所以它会接着之前的结果继续跑.但我们的数据发生了变化,所以会出现这个错误.解决方法就是把train目录删掉,重新生成即可</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://cloud.tencent.com/community/article/351424" target="_blank" rel="noopener">深度学习入门篇—手把手教你用 TensorFlow 训练模型</a></p><p><a href="http://blog.csdn.net/u010302327/article/details/78248394" target="_blank" rel="noopener">tensorflow ssd mobilenet模型训练</a></p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> Tensorflow </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Tensorflow] 在Android运行TensorFlow模型</title>
      <link href="/2017/12/10/%5BTensorflow%5DRun-TF-model-in-Android/"/>
      <url>/2017/12/10/%5BTensorflow%5DRun-TF-model-in-Android/</url>
      
        <content type="html"><![CDATA[<p>以下代码来自于<a href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/examples/android/src/org/tensorflow/demo/TensorFlowObjectDetectionAPIModel.java" target="_blank" rel="noopener">TensorFlowObjectDetectionAPIModel.java</a></p><p>Android调用Tensorflow模型主要通过一个类：TensorFlowInferenceInterface<br>通过传入assetManager(要从asset读pb文件)，和modelFilename(模型名)实例化这个类</p><pre class=" language-lang-java"><code class="language-lang-java">d.inferenceInterface = new TensorFlowInferenceInterface(assetManager, modelFilename);</code></pre><p>有了这个实例就可以调用TF相关的方法</p><pre class=" language-lang-java"><code class="language-lang-java">    //获取graph实例    final Graph g = d.inferenceInterface.graph();    d.inputName = "image_tensor";    final Operation inputOp = g.operation(d.inputName);    if (inputOp == null) {      throw new RuntimeException("Failed to find input Node '" + d.inputName + "'");    }    ...    final Operation outputOp1 = g.operation("detection_scores");    if (outputOp1 == null) {      throw new RuntimeException("Failed to find output Node 'detection_scores'");    }</code></pre><p>上面是我截取的一部分代码，简单介绍一下：</p><p>Graph是TF中的图，图是由operation和tensor构成，operation可以看做是图里面的节点，tensor就是连接节点的线。所以要进行对operation进行操作就必须有一个Graph对象。</p><pre class=" language-lang-java"><code class="language-lang-java">d.inputName = "image_tensor";final Operation inputOp = g.operation(d.inputName);</code></pre><p>这里给一个inputName赋值image_tensor，这个值我开始以为是operation需要命名所以任意给了一个标识名，方便后面查找，但发现这个值是不能改的，改了会出错。从代码可以看到，对于所有的operation对象都会有一个非空判断，因为这个op是和模型中训练时候生成的图对应的，获取实例的时候接口会去模型中查找这个节点，也就是这个op。所以使用模型的时候，必须要知道这个模型的输入输出节点。</p><p>为什么是输入输出节点，因为训练模型生成的图是很大的，我用代码(我放在Tests目录下了)把ssd_mobilenet_v1_android_export.pb模型所有op打出来，发现一共有5000多个，所以说这个图的中间节点有非常多。而有用的，目前从代码来看，就是一个输入节点（输入图像的tensor），4个输出节点（输出：分类，准确度分数，识别物体在图片中的位置用于画框，和num_detections）。所以单纯地使用模型，我认为知道模型这几个节点就可以了。</p><blockquote><p>这里推荐一篇文章<a href="https://www.ouyangsong.com/2017/05/23/tensorflow-freeze-model-protocolbuffers/" target="_blank" rel="noopener">TensorFlow固定图的权重并储存为Protocol Buffers</a><br>讲的是Tensorflow保存的模型中都由哪些东西组成的。</p></blockquote><p>知道这几个节点的名称，就可以实例化这些节点，然后就对节点操作：</p><pre class=" language-lang-java"><code class="language-lang-java">    bitmap.getPixels(intValues, 0, bitmap.getWidth(), 0, 0, bitmap.getWidth(), bitmap.getHeight());    //????    for (int i = 0; i < intValues.length; ++i) {      byteValues[i * 3 + 2] = (byte) (intValues[i] & 0xFF);      byteValues[i * 3 + 1] = (byte) ((intValues[i] >> 8) & 0xFF);      byteValues[i * 3 + 0] = (byte) ((intValues[i] >> 16) & 0xFF);    }    // Copy the input data into TensorFlow.    //给inputname节点operation的tensor赋值  feed里有一个Tensor.create  创建张量    inferenceInterface.feed(inputName, byteValues, 1, inputSize, inputSize, 3);    // Run the inference call.    // 运行output operations    inferenceInterface.run(outputNames, logStats);    // Copy the output Tensor back into the output array.    Trace.beginSection("fetch");    outputLocations = new float[MAX_RESULTS * 4];    outputScores = new float[MAX_RESULTS];    outputClasses = new float[MAX_RESULTS];    outputNumDetections = new float[1];    // 从tensor的operation中取值    inferenceInterface.fetch(outputNames[0], outputLocations);    inferenceInterface.fetch(outputNames[1], outputScores);    inferenceInterface.fetch(outputNames[2], outputClasses);    inferenceInterface.fetch(outputNames[3], outputNumDetections);</code></pre><p>上面代码有几个方法：<br>首先是通过getPixels把图片转换成数组，其实就是张量，也就是Tensor，Tensor的形式就是这样任意维度的数组，可以看做是矩阵<br>之后它对这个数组做了一次处理，这里对图像数据的处理我没看明白。。</p><p>然后，使用feed方法把tensor传给operation，参数里inputName其实就是用来定位operation的。数据传给input，后面只要对output做一次处理：inferenceInterface.run(outputNames, logStats);这里第一个参数outputNames是一个数组，包含了所有用来output的operation的名称。<br>最最后，通过inferenceInterface.fetch方法获取每个output operation输出的结果。</p><p>这里还有一点，为什么run方法是作用在output operation的？<br>是因为，tensorflow生成graph后，不会直接运行，因为Graph会有很多条通路，只有在对输出的operation进行run之后，graph才会从output operation开始，反向查找运行的前置条件，只到完成通路才会执行。也就是说：Graph的很多通路不一定都会执行。</p><p>最后再提一下label文件，因为label是和图像对应的，资源文件中也有记录着所有训练labels的文件，那么它用在哪？</p><pre class=" language-lang-java"><code class="language-lang-java">// Find the best detections.    final PriorityQueue<Recognition> pq =        new PriorityQueue<Recognition>(            1,            new Comparator<Recognition>() {              @Override              public int compare(final Recognition lhs, final Recognition rhs) {                // Intentionally reversed to put high confidence at the head of the queue.                return Float.compare(rhs.getConfidence(), lhs.getConfidence());              }            });    // Scale them back to the input size.    for (int i = 0; i < outputScores.length; ++i) {      final RectF detection =          new RectF(              outputLocations[4 * i + 1] * inputSize,              outputLocations[4 * i] * inputSize,              outputLocations[4 * i + 3] * inputSize,              outputLocations[4 * i + 2] * inputSize);      pq.add(new Recognition("" + i, labels.get((int) outputClasses[i]), outputScores[i], detection));</code></pre><p>label用在最后一行的 labels.get((int) outputClasses[i])<br>labels就是保存文件中所有label的数组，outputClasses就是上个代码段中output输出的内容。<br>这个代码段只是把输出结果保存成Recognition对象，然后按照outputScore进行排序，最可能的值排最前面输出。所以我是这么理解的：label数据在模型中就已经存在了，因为pb文件不仅存储了graph，还存储了训练过程的信息。labels文件对我们来说就是为了获得结果。</p><p>总结</p><ol><li>使用inferenceInterface = new TensorFlowInferenceInterface(assetManager, modelFilename);实例化TF入口类</li><li>通过TF入口实例化graph,Graph g = d.inferenceInterface.graph();</li><li>用g.operation(name)检查输入输出的operation是否存在</li><li>把输入数据转换成数组(Tensor)形式，比如图片：bitmap.getPixels(intValues…)</li><li>把输入数据喂给输入operation  inferenceInterface.feed()</li><li>run输出operations inferenceInterface.run()</li><li>用fetch获取结果inferenceInterface.fetch()</li></ol>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Machine Learning </tag>
            
            <tag> Tensorflow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Tensorflow] Tensor维度理解</title>
      <link href="/2017/11/15/%5BTensorflow%5DThe-dimension-of-Tensor/"/>
      <url>/2017/11/15/%5BTensorflow%5DThe-dimension-of-Tensor/</url>
      
        <content type="html"><![CDATA[<p><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script></p><h3 id="Tensor维度理解"><a href="#Tensor维度理解" class="headerlink" title="Tensor维度理解"></a>Tensor维度理解</h3><p>Tensor在Tensorflow中是N维矩阵，所以涉及到Tensor的方法，也都是对矩阵的处理。由于是多维，在Tensorflow中Tensor的流动过程就涉及到升维降维，这篇就通过一些接口的使用，来体会Tensor的维度概念。以下是个人体会，有不准确的请指出。</p><h4 id="tf-reduce-mean"><a href="#tf-reduce-mean" class="headerlink" title="tf.reduce_mean"></a>tf.reduce_mean</h4><pre class=" language-lang-python"><code class="language-lang-python">reduce_mean(    input_tensor,    axis=None,    keep_dims=False,    name=None,    reduction_indices=None)</code></pre><p>计算Tensor各个维度元素的均值。这个方法根据输入参数<code>axis</code>的维度上减少输入<code>input_tensor</code>的维度。<br>举个例子：</p><pre class=" language-lang-python"><code class="language-lang-python">x = tf.constant([[1., 1.], [2., 2.]])tf.reduce_mean(x)  # 1.5tf.reduce_mean(x, 0)  # [1.5, 1.5]tf.reduce_mean(x, 1)  # [1.,  2.]</code></pre><p>x是二维数组[[1.0,1.0],[2.0, 2.0]]<br>当<code>axis</code>参数取默认值时，计算整个数组的均值：(1.+1.+2.+2.)/4=1.5<br>当<code>axis</code>取0，意味着对列取均值：[1.5, 1.5]<br>当<code>axis</code>取1，意味着对行取均值：[1.0, 2.0]</p><p>再换一个3*3的矩阵：</p><pre class=" language-lang-python"><code class="language-lang-python">sess = tf.Session()x = tf.constant([[1., 2., 3.], [4., 5., 6.], [7., 8., 9.]])print(sess.run(x))print(sess.run(tf.reduce_mean(x)))print(sess.run(tf.reduce_mean(x, 0)))print(sess.run(tf.reduce_mean(x, 1)))</code></pre><p>输出结果是</p><pre class=" language-lang-bash"><code class="language-lang-bash">[[ 1.  2.  3.] [ 4.  5.  6.] [ 7.  8.  9.]]5.0[ 4.  5.  6.][ 2.  5.  8.]</code></pre><p>如果我再加一维是怎么计算的？</p><pre class=" language-lang-python"><code class="language-lang-python">sess = tf.Session()x = tf.constant([[[1., 1.], [2., 2.]], [[3., 3.], [4., 4.]]])print(sess.run(x))print(sess.run(tf.reduce_mean(x)))print(sess.run(tf.reduce_mean(x, 0)))print(sess.run(tf.reduce_mean(x, 1)))print(sess.run(tf.reduce_mean(x, 2)))</code></pre><p>我给的输入Tensor是三维数组：</p><pre class=" language-lang-bash"><code class="language-lang-bash">[[[ 1.  1.]  [ 2.  2.]] [[ 3.  3.]  [ 4.  4.]]]</code></pre><p>推测一下，前面二维的经过处理都变成一维的，也就是经历了一次降维，那么现在三维的或许应该变成二维。但现在多了一维，应该从哪个放向做计算呢？<br>看下结果：</p><pre class=" language-lang-bash"><code class="language-lang-bash">2.5[[ 2.  2.] [ 3.  3.]][[ 1.5  1.5] [ 3.5  3.5]][[ 1.  2.] [ 3.  4.]]</code></pre><p>发现，<br>当<code>axis</code>参数取默认值时，依然计算整个数组的均值：(float)(1+2+3+4+1+2+3+4)/8=2.5<br>当<code>axis</code>取0，计算方式是：</p><pre class=" language-lang-bash"><code class="language-lang-bash">[[(1+3)/2, (1+3)/2], [(2+4)/2, (2+4)/2]]</code></pre><p>当<code>axis</code>取1，计算方式是：</p><pre class=" language-lang-bash"><code class="language-lang-bash">[[(1+2)/2, (1+2)/2], [(3+4)/2, (3+4)/2]]</code></pre><p>当<code>axis</code>取2，计算方式是：</p><pre class=" language-lang-bash"><code class="language-lang-bash">[[(1+1)/2, (2+2)/2], [(3+3)/2, (4+4)/2]]</code></pre><p>看到这里，能推断出怎么从四维降到三维吗？<br>有人总结了一下：</p><blockquote><p>规律：<br>对于k维的，<br>tf.reduce_xyz(x, axis=k-1)的结果是对最里面一维所有元素进行求和。<br>tf.reduce_xyz(x, axis=k-2)是对倒数第二层里的向量对应的元素进行求和。<br>tf.reduce_xyz(x, axis=k-3)把倒数第三层的每个向量对应元素相加。<br><a href="https://www.zhihu.com/question/51325408/answer/238082462" target="_blank" rel="noopener">链接</a></p></blockquote><p>拿上面的数组验证这个规律：</p><pre class=" language-lang-bash"><code class="language-lang-bash">[[[ 1.  1.]  [ 2.  2.]] [[ 3.  3.]  [ 4.  4.]]]</code></pre><p>我们的k=3。小括号是一层，在一层内进行计算：<br>axis=3-1=2，做最内层计算，我们的最内层就是(1,1),(2,2),(3,3),(4,4)，计算出来的就是</p><pre class=" language-lang-bash"><code class="language-lang-bash">[[ 1.  2.] [ 3.  4.]]</code></pre><p>axis=3-2=1，做倒数第二层计算(参考二维计算)：([1,1],[2,2])和([3, 3],[4, 4])</p><pre class=" language-lang-bash"><code class="language-lang-bash">[[ 1.5  1.5] [ 3.5  3.5]]</code></pre><p>axis=3-3=1，做倒数第三层计算:([[1, 1], [2, 2]])([[3, 3], [4, 4]])</p><pre class=" language-lang-bash"><code class="language-lang-bash">[[ 2.  2.] [ 3.  3.]]</code></pre><p>对于四维的，就贴段结果，自己可以尝试算一下，加深理解。</p><pre class=" language-lang-bash"><code class="language-lang-bash"># input 4-D[[[[ 1.  1.]   [ 2.  2.]]  [[ 3.  3.]   [ 4.  4.]]] [[[ 5.  5.]   [ 6.  6.]]  [[ 7.  7.]   [ 8.  8.]]]]# axis=none4.5# axis=0[[[ 3.  3.]  [ 4.  4.]] [[ 5.  5.]  [ 6.  6.]]]# axis=1[[[ 2.  2.]  [ 3.  3.]] [[ 6.  6.]  [ 7.  7.]]]</code></pre><blockquote><p>在tensorflow 1.0版本中，<code>reduction_indices</code>被改为了<code>axis</code>，在所有reduce_xxx系列操作中，都有reduction_indices这个参数，即沿某个方向，使用xxx方法，对input_tensor进行降维。</p></blockquote><p>对于<code>axis</code>参数的作用，文档的解释是</p><blockquote><p>the rank of the tensor is reduced by 1 for each entry in axis</p></blockquote><p>即Tensor在axis的每一个分量上的秩减少1。<a href="https://www.zhihu.com/question/21605094/answer/167612272" target="_blank" rel="noopener">如何理解矩阵的「秩」？ - 马同学的回答 - 知乎</a></p><p>附一张reduction_indices的图<br><img src="https://pic2.zhimg.com/50/v2-c92ac5c3a50e4bd3d60e29c2ddc4c5e9_hd.jpg" alt></p><p>下面再看下第三个参数<code>keep_dims</code>，该参数缺省值是False，如果设置为True，那么减少的维度将被保留为长度为1。<br>回头看看最开始的例子：</p><pre class=" language-lang-bash"><code class="language-lang-bash"># 2*2[[ 1.  1.] [ 2.  2.]]# keep_dims=False[ 1.5  1.5]    # 1*2[ 1.  2.]    #1*2# keep_dims=True[[ 1.5  1.5]]    #1*2[[ 1.]            #2*1 [ 2.]]</code></pre><p>可以看到差别。关于这个参数，还没看到太多介绍，还需要了解。</p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> Tensorflow </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[LeetCode] Two Sum</title>
      <link href="/2017/07/27/%5BLeetCode%5D001_TwoSum/"/>
      <url>/2017/07/27/%5BLeetCode%5D001_TwoSum/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a>leetcode</h1><h2 id="本系列前面的话"><a href="#本系列前面的话" class="headerlink" title="本系列前面的话"></a>本系列前面的话</h2><p>这段时间经历了一些事情，思考了很多，还有发现博客很久没写了，域名也因为没有续费被回收，想想博客还是要继续下去的，索性域名先不要了，等以后再换个好记的。<br>以前很少刷算法题，因为感觉工作中不会用到太多。其实到后来想想，原来是自己给自己的定位就是不写算法，因而找不到涉及算法的工作。现在趁着当前人工智能领域的浪潮，看看算法，顺便练习下<code>Python</code>，希望可以赶上这波潮流。</p><h2 id="题目：Two-Sum"><a href="#题目：Two-Sum" class="headerlink" title="题目：Two Sum"></a>题目：Two Sum</h2><blockquote><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have exactly one solution, and you may not use the same element twice.<br><strong>Example</strong>:</p><pre><code>Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1].</code></pre></blockquote><h2 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h2><p>问题很好理解，给出一个数组和<code>target</code>，找出数组里相加之和为<code>target</code>的两个数字的位置。</p><blockquote><p>这里一个坑就是要注意<strong>负数</strong></p></blockquote><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h3><p>暴力方法很好想到，就是从数组第一个数字开始，依次循环往下加，直到加和等于<code>target</code>。这是最简单的方法，也是复杂度很高的方法。</p><h4 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码:"></a><code>Java</code>代码:</h4><pre class=" language-lang-java"><code class="language-lang-java">public int[] twoSum(int[] nums, int target) {  for (int i = 0; i < nums.length; i++) {      for (int j = i + 1; j < nums.length; j++) {          if (nums[j] == target - nums[i]) {          return new int[] { i, j };          }      }  }  throw new IllegalArgumentException("No two sum solution");}</code></pre><h4 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a><code>Python</code>代码</h4><pre class=" language-lang-python"><code class="language-lang-python">class Solution:  def twoSum(self, nums, target):  """  :type nums: List[int]  :type target: int  :rtype: List[int]  """  for i in range(len(nums) - 1):  for j in range(i + 1, len(nums)):  if nums[i] + nums[j] == target:  return [i, j]  return []#if __name__ == "__main__":# sol = Solution()# results = sol.twoSum((3, 2, 4), 6)# print("result is ", results)</code></pre><p><code>Python</code>代码很暴力，但在<code>leetcode</code>上运行最后一个丧心病狂的TestCase时花了７秒多，超出了规定时间，所以需要简单优化一下。<br>待续</p><h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><ul><li>时间复杂度：<strong>O(n²)</strong>.对每个元素，我们都要循环查找数组内的剩余元素，这需要O(n)的时间，所以整体运行下来需要O(n²)</li><li>空间复杂度：<strong>O(1)</strong>.</li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Python </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Android][Framework] PlayAutoInstall配置流程总结</title>
      <link href="/2017/06/19/%5BAndroid%5D%5BFramework%5DPlayAutoInstall/"/>
      <url>/2017/06/19/%5BAndroid%5D%5BFramework%5DPlayAutoInstall/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我这里有谷歌给OEM提供的官方文档，需要的可以联系</p></blockquote><h2 id="什么是PAI"><a href="#什么是PAI" class="headerlink" title="什么是PAI"></a>什么是PAI</h2><p>PAI （PlayAutoInstall） 是一个自动下载安装APK到手机，并且摆放在Launcher对应位置的一个机制。</p><p>因为国内没有GMS，所以很多人没接触过这个机制。这个机制其实对于运营商定制来说非常重要，比如美国的运营商，一个运营商有很多地区很多种类的SIM卡，当插上不同地区的SIM卡，运营商定制的手机就会下载不同的APP摆放在界面不同的位置。</p><p>这么说有些抽象，看下面示例图：</p><p>首先是出厂刚开机Launcher的界面：</p><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/PAI01.png?raw=true" alt></p><p>当手机插上SIM卡联网，PlayStore会通过PAI机制下载安装摆放不同的APP：</p><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/PAI02.png?raw=true" alt></p><p>界面一下子就变丰富了。</p><h2 id="PAI-流程"><a href="#PAI-流程" class="headerlink" title="PAI 流程"></a>PAI 流程</h2><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/PAI03.png?raw=true" alt></p><p>本地编译一个PlayAutoInstallConfig.apk，签名上传到APFE服务器，APFE会验证配置信息，并提供给PlayStore。当目标设备第一次开机启动并且联网（现在不必要登录谷歌帐号），这些应用就会加入下载队列，自动下载到手机。 </p><h2 id="配置菜单"><a href="#配置菜单" class="headerlink" title="配置菜单"></a>配置菜单</h2><p>先聊一下APFE会验证的配置信息。</p><p>需要的配置信息包括：</p><ul><li>指纹（必须）</li><li>城市（可选）</li><li>运营商（可选）</li><li>需要下载的App列表</li><li>应用在桌面的位置信息</li></ul><p>后两项是编译在PlayAutoInstallConfig.apk中的，前三项是把apk上传到服务器时需要填写的。</p><p>上传服务器配置页面如下：</p><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/PAI04.png?raw=true" alt></p><p>配置信息的前三项匹配项如果填写，就必须要完全匹配才能应用到手机。我遇到一个问题是配置上传后PlayAutoInstallConfig.apk会在SetupWizard过程中下载到手机，但需要PlayStore下载的应用怎么都不下载。后来发现是在上传apk到服务器时运营商填的不对，导致无法下载。因为尝试填写几种运营商Name都不能正常工作，最后解决方案是只匹配指纹，不匹配城市和运营商（减少过滤项），这样手机就可以和PlayStore信息匹配，然后就可以自动下载了。</p><p>关于其余配置，参考下面表格：</p><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/PAI05.png?raw=true" alt></p><h2 id="Config-APK"><a href="#Config-APK" class="headerlink" title="Config APK"></a>Config APK</h2><p>对上表中出现一个Config APK 做一些解释。</p><p>手机内必须要先预置一个符合下列条件的stub APK：</p><ul><li>为一个系列的设备设置唯一的包名，包名格式为android.autoinstalls.config.<oem-name>.<device-name></device-name></oem-name></li><li>必须配置一个receiver ”android.autoinstalls.config.action.PLAY_AUTO_INSTALL”，并且设置exported为flase</li><li>在预置的App里只能有一个定义这个receiver</li><li>versionCode必须定义成1</li><li>APK必须预置在/system/app （不能定义成privileged，即不能放/priv-app）</li><li>必须用私有Key签名</li><li>不能定义permissions/activities/其他receivers/content provider/services</li></ul><p>这个APK其实就一个Manifest，没有特别的内容。</p><pre class=" language-lang-xml"><code class="language-lang-xml"><?xml version="1.0" encoding="utf-8"?><manifest xmls:android="http://schemas.android.com/apk/res/android"          package="android.autoinstalls.config.OEM-Name.deviceName" >    <application        android:allowBackup="false"        android:icon="@drawable/ic_launcher"        android:label="@string/app_name" >        <receiver            android:name="DummyReceiver"            android:exported="false" >            <intent-filter>                <action android:name="android.autoinstalls.config.action.PLAY_AUTO_INSTALL" />            </intent-filter>        </receiver>          </application></manifest></code></pre><p>相关的MakeFile如下</p><pre class=" language-lang-mk"><code class="language-lang-mk">include $(CLEAR_VARS)apk_variant := stubAPK_VERSION := 1include $(BUILD_APK)</code></pre><h2 id="PlayAutoInstallConfig-apk"><a href="#PlayAutoInstallConfig-apk" class="headerlink" title="PlayAutoInstallConfig.apk"></a>PlayAutoInstallConfig.apk</h2><p>这个APK是我们真正配置的APK。</p><p>它和前面的APK的关系是：包名一致。因为PAI机制需要本地存在一个这个包名的APK，在开机的SetupWizard阶段，（如果联网）它会从服务器下载这个写有对应配置的APK到手机上，替换掉那个Stub APK。</p><p>关于PAIconfig APK的配置：</p><ul><li>上传的APK（也就是我们编出来的APK）包名与指纹要和stub一致</li><li>APK签名要一致</li><li>和stub配置同样的receiver</li><li>versionCode必须大于1000</li><li>APK必须包含launcher布局配置的xml文件（即后面会提到的default_layout），不然上传会失败，因为上传前会检查这个xml文件，然后会把要下载的app显示出来。所以也必须要求至少定义一个需要下载的app。最多50个，建议放10～15个。（文档还要求autoinstall的应用必须在launcher上指定摆放位置，目前看来是不需要的，有可能bb launcher做了修改）</li><li>界面会有文件夹，文件夹名称string在APK本地resource定义，支持国际化。</li><li>需要自动下载的APK对设备来讲必须是在PlayStore发布的，并且对该地区用户可见</li><li>不能定义permissions/activities/其他receivers/content provider/services</li></ul><p>在这个APK里就要写需要下载的APK信息了，基本格式如下：</p><pre class=" language-lang-xml"><code class="language-lang-xml">参数screen是第几屏，x,y是在屏幕的位置，从0开始。<workspace>    autoinstall开头是需要PlayStore下载的，    <autoinstall className="com.watchdox.android.activity.LaunchActivity" packageName="com.watchdox.android" screen="1" x="1" y="2" requiredPreload="true" installByDefault="true" />    appwidget开头是桌面控件。span属性设定控件的宽高    <appwidget screen="0" x="0" y="0" spanX="5" spanY="1" packageName="com.google.android.googlequicksearchbox" className="com.google.android.googlequicksearchbox.SearchWidgetProvider"/>    appicon就是纯粹摆放APP的位置    <appicon screen="0" x="3" y="3" packageName="com.google.android.apps.photos" className="com.google.android.apps.photos.home.HomeActivity" />    folder是文件夹，里面可以放多个app    <folder screen="0" x="1" y="4" title="@string/google_collection_folder">        <appicon packageName="com.google.android.googlequicksearchbox" className="com.google.android.googlequicksearchbox.SearchActivity"/>    </folder>    action是shortcut快捷键，key是LAUNCHER里面定义的    <action screen="2" x="0" y="3" key="CREATE_NOTE" />    <!-- Dock icons -->    （按顺序？或者按照rank属性决定）最后四个是DOCKER的app icon    <appicon rank="0" container="hotseat" packageName="com.android.dialer" className="com.android.dialer.DialtactsActivity" />    <appicon rank="1" container="hotseat" packageName="com.blackberry.hub" className="com.xyz.hub.ui.IntroActivity" />    <appicon rank="3" container="hotseat" packageName="com.android.chrome" className="com.google.android.apps.chrome.Main" />    <appicon rank="4" container="hotseat" packageName="com.blackberry.camera" className="com.xyz.camera.ui.coordination.MainActivity"/></workspace></code></pre><p>代码结构</p><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/PAI06.png?raw=true" alt></p><p>在res-PAI目录中，xml有两个，default_layout中要填写<autoinstall>的应用（需要从PlayStore自动下载的应用），然后再oem_layout填写该应用的位置。如果其他途径也会下载应用，只需要把应用信息写在oem_layout即可。</autoinstall></p><h2 id="验证流程"><a href="#验证流程" class="headerlink" title="验证流程"></a>验证流程</h2><p>烧一个新手机，启动进SetupWizard，在过程中联网，登录谷歌帐号（现在这一步不必要了）。在设置好谷歌帐号之后，就会自动下载PAI apk到手机，替换默认的stub生效。等到进入Launcher界面，Launcher就会加载这个apk，把icon配置到对应位置上。与此同时，PlayStore会下载配置的App。</p><p> 从工作流程看，如果想调试界面，就可以不reset手机，直接把编译好的APK替换默认的stub。这时候因为launcher已经启动过，所以不会主动加载配置的apk，需要从settings清空launcher数据，强制加载，就可以看到修改的界面了。</p><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>Launcher里面有AutoInstallsLayout.java ，可以阅读了解。</p><p>从上面配置可以看出，写配置需要了解应用的包名，主Activity的类名，所以需要用到am和pm命令去查找，所以写了一个脚本方便获取APK的信息。</p><pre class=" language-lang-bash"><code class="language-lang-bash">#!/bin/bashhelp_info(){    echo "-a get current activity"    echo "-p list packages in device, can add a package name"    echo "-m dump apk's AndroidManifest, need add a APK"}if [ $# -eq 0 ]then    help_infoelse    echo "arg count is $#"ficase "$1" in    -a)    adb shell dumpsys activity activities    ;;    -p)    if [ $# -eq 2 ]    then        adb shell pm list packages -f "$2"    elif [ $# -eq 1 ]    then        adb shell pm list packages    else    echo "check the arguement"    fi    ;;    -m)    if [ $# -eq 2 ]    then    aapt dump xmltree "$2" AndroidManifest.xml    else    echo "need file path"    fiesac</code></pre>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Framework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[设计模式]之二十二:工厂方法模式</title>
      <link href="/2017/04/11/%5BDesign-Pattern%5DFactory/"/>
      <url>/2017/04/11/%5BDesign-Pattern%5DFactory/</url>
      
        <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。</p><p>工厂方法和简单工厂的区别就在于：</p><p>简单工厂里的工厂类是全能类，也就是说生产新的产品，都在工厂代码（switch语句）里添加对应的处理。这样违反了开闭原则，不该修改原类的代码。</p><p>所以工厂方法的策略是，把所有产品的工厂单独写成工厂类，这样添加新的产品，只要添加新的工厂类即可。</p><h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/UML-factory.png?raw=true" alt></p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><pre class=" language-lang-java"><code class="language-lang-java">// 产品为交通工具abstract class Transaction {}public class TCar extends Transaction {    public TCar() {        System.out.println("Create a Car");    }}public class TShip extends Transaction {    public TShip() {        System.out.println("Create a Ship");    }}//工厂通用接口interface FactoryTrans {    Transaction createTrans();}//为新产品创建工厂public class FactoryCar implements FactoryTrans {    @Override    public Transaction createTrans() {        // TODO Auto-generated method stub        return new TCar();    }}public class FactoryShip implements FactoryTrans {    @Override    public Transaction createTrans() {        // TODO Auto-generated method stub        return new TShip();    }}//像这样添加新的产品线，不需要修改任何代码，只要添加public static void main(String[] args) {    // TODO Auto-generated method stub    FactoryCar FCar = new FactoryCar();    TCar car = (TCar) FCar.createTrans();    FactoryShip FShip = new FactoryShip();    TShip ship = (TShip) FShip.createTrans();}</code></pre><h3 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h3><p>优缺点</p><p>优点</p><ul><li>在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。</li><li>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。</li><li>使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</li></ul><p>缺点</p><ul><li>在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</li><li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Design pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[设计模式]之二十一:原型模式</title>
      <link href="/2017/04/10/%5BDesign-Pattern%5DPrototype/"/>
      <url>/2017/04/10/%5BDesign-Pattern%5DPrototype/</url>
      
        <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>原型模式就是从一个对象再创建另外一个可定制的对象，而且不需要知道任何创建的细节。</p><h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/UML-Prototype.png?raw=true" alt></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/java-my-life/archive/2012/04/11/2439387.html" target="_blank" rel="noopener">https://www.cnblogs.com/java-my-life/archive/2012/04/11/2439387.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Design pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[设计模式]之十九:装饰模式</title>
      <link href="/2017/04/08/%5BDesign-Pattern%5DDecorator/"/>
      <url>/2017/04/08/%5BDesign-Pattern%5DDecorator/</url>
      
        <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>装饰模式是为已有功能动态地添加更多功能的一种方式。</p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>由定义，给一个类或对象添加功能，为了不破坏类的结构，可以有两种方式：</p><ul><li><p>继承</p><p>使用继承机制是给现有类添加功能的一种有效途径，通过继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法。但是这种方法是静态的，用户不能控制增加行为的方式和时机。</p></li><li><p>关联</p><p>将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为，我们称这个嵌入的对象为装饰器(Decorator)</p></li></ul><h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/UML-decorator.png?raw=true" alt></p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><pre class=" language-lang-java"><code class="language-lang-java">abstract class Component {    public abstract void Operation();}public class ConcreateComponent extends Component {    @Override    public void Operation() {        // TODO Auto-generated method stub        System.out.println("basic operation");    }}public class Decorator extends Component {    protected Component component;    public void SetComponent(Component component) {        this.component = component;    }    @Override    public void Operation() {        // TODO Auto-generated method stub        if (component != null) {            component.Operation();        }    }}public class DecoratorA extends Decorator {    @Override    public void Operation() {        // TODO Auto-generated method stub        super.Operation();        newBehavior();    }    private void newBehavior() {        System.out.println("Add new behavior AAA");    }}public class DecoratorB extends Decorator {    @Override    public void Operation() {        // TODO Auto-generated method stub        super.Operation();        newBehavior();    }    private void newBehavior() {        System.out.println("Add new behavior BBB");    }}public static void main(String[] args) {  // TODO Auto-generated method stub  ConcreateComponent c = new ConcreateComponent();  DecoratorA a = new DecoratorA();  DecoratorB b = new DecoratorB();  a.SetComponent(c);  a.Operation();  b.SetComponent(a);  b.Operation();}//输出basic operationAdd new behavior AAAbasic operationAdd new behavior AAAAdd new behavior BBB</code></pre><p>基本思路是，在ConcreateComponent做一些基本操作，然后创建装饰器，如果需要给对象增加新的特性，就把该对象放入对应的装饰器中。</p><p>尽量保持Component作为一个轻类，不要做太多逻辑。</p><h3 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h3><p>优缺点</p><p>优点</p><ul><li>不会破坏类的封装性，而且耦合性比继承要低，灵活性比继承高。</li><li>可以动态的拓展一个对象的功能。</li><li>可以用多个装饰器按照不同顺序组合出不同的对象。</li><li>具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类。符合开闭原则。</li></ul><p>缺点</p><ul><li>需要创建更多的对象。</li><li>因为装饰器使用灵活，使用的顺序也能不同，可能引起的错误会比较隐蔽。</li></ul><p>使用场景</p><p>当系统需要新功能的时候，如果新功能只是为了满足某个条件下才会执行的行为，则不建议修改原类，而是使用装饰模式，把要装饰的功能放在特定类中，然后用这个类包装它所要装饰的对象。这样，客户代码可以根据情况在运行时选择装饰功能包装对象。</p>]]></content>
      
      
      <categories>
          
          <category> Design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Design pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[设计模式]之十八:代理模式</title>
      <link href="/2017/04/07/%5BDesign-Pattern%5DProxy/"/>
      <url>/2017/04/07/%5BDesign-Pattern%5DProxy/</url>
      
        <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>给某一个对象提供一个代理，并由代理对象控制对原对象的引用。通俗讲就是，我想做一些事情，但我又不允许对这个事情了解太多，所以中间需要一个代理，由代理控制选择我能做的，然后帮我去做。</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在某些情况下，一个客户不想或者不能直接引用一个对 象，此时可以通过一个称之为“代理”的第三者来实现 间接引用。代理对象可以在客户端和目标对象之间起到 中介的作用，并且可以通过代理对象去掉客户不能看到 的内容和服务或者添加客户需要的额外服务。</p><p>通过引入一个新的对象（如小图片和远程代理 对象）来实现对真实对象的操作或者将新的对 象作为真实对象的一个替身，这种实现机制即 为代理模式，通过引入代理对象来间接访问一 个对象，这就是代理模式的模式动机。</p><h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/UML-proxy.png?raw=true" alt></p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><pre class=" language-lang-java"><code class="language-lang-java">abstract class Subject {    public abstract void Request();}public class RealSubject extends Subject {    @Override    public void Request() {        // TODO Auto-generated method stub        System.out.println("Real request");    }}public class Proxy extends Subject {    RealSubject realSubject;    @Override    public void Request() {        // TODO Auto-generated method stub        if (realSubject == null) {            realSubject = new RealSubject();        }        realSubject.Request();    }}public static void main(String[] args) {    // TODO Auto-generated method stub    Proxy proxy = new Proxy();    proxy.Request();}//输出Real request</code></pre><h3 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h3><p>优缺点</p><p>优点：</p><ul><li>能够协调调用者和被调用者，在一定程度上降低了系统的耦合度。</li><li>个人觉得代理可以管理请求者的权限控制。</li></ul><p>缺点</p><ul><li>中间加一个代理对象，可能导致请求的处理速度变慢。</li></ul><p>应用</p><p>常见代理类型如下</p><ul><li>远程(Remote)代理：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在 另一台主机中，远程代理又叫做大使(Ambassador)。</li><li>虚拟(Virtual)代理：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。</li><li>Copy-on-Write代理：它是虚拟代理的一种，把复制（克隆）操作延迟到只有在客户端真正需要时才执行。一般来说，对象的深克隆是一个 开销较大的操作，Copy-on-Write代理可以让这个操作延迟，只有对象被用到的时候才被克隆。</li><li>保护(Protect or Access)代理：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。</li><li>缓冲(Cache)代理：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。</li><li>防火墙(Firewall)代理：保护目标不让恶意用户接近。</li><li>同步化(Synchronization)代理：使几个用户能够同时使用一个对象而没有冲突。</li><li>智能引用(Smart Reference)代理：当一个对象被引用时，提供一些额外的操作，如将此对象被调用的次数记录下来等。</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://design-patterns.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">http://design-patterns.readthedocs.io/zh_CN/latest/</a></p>]]></content>
      
      
      <categories>
          
          <category> Design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Design pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[设计模式]之十七:外观模式</title>
      <link href="/2017/04/06/%5BDesign-Pattern%5DFacade/"/>
      <url>/2017/04/06/%5BDesign-Pattern%5DFacade/</url>
      
        <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p><p>它有一点像代理模式，外观层就类似代理层。假设外界有很多接口，用户不需要了解这些接口调用顺序，用户只需要提出需求，外观层负责组织调用外界接口实现用户的需求，实现后抽出一个直接实现功能的接口交给用户使用。这就是外观模式的作用。</p><p>根据“单一职责原则”，在软件中将一个系统划分为若干个子系统有利于降低整个系统的复杂性，一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小，而达到该目标的途径之一就是引入一个外观对象，它为子系统的访问提供了一个简单而单一的入口。<br>-外观模式也是“迪米特法则”的体现，通过引入一个新的外观类可以降低原有系统的复杂度，同时降低客户类与子系统类的耦合度。</p><p>外观模式要求一个子系统的外部与其内部的通信通过一个统一的外观对象进行，外观类将客户端与子系统的内部复杂性分隔开，使得客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道。<br>-外观模式的目的在于降低系统的复杂程度。<br>-外观模式从很大程度上提高了客户端使用的便捷性，使得客户端无须关心子系统的工作细节，通过外观角色即可调用相关功能。</p><h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/UML-facade.png?raw=true" alt></p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><pre class=" language-lang-java"><code class="language-lang-java">public class SubSystem1 {    public void method() {        System.out.println("SubSystem1 is doing sth.");    }}public class SubSystem2 {    public void method() {        System.out.println("SubSystem2 is doing sth.");    }}public class Facade {    SubSystem1 s1;    SubSystem2 s2;    public Facade() {        s1 = new SubSystem1();        s2 = new SubSystem2();    }    public void Func1() {        s1.method();    }    public void Func2() {        s1.method();        s2.method();    }}public static void main(String[] args) {    // TODO Auto-generated method stub    Facade facade = new Facade();    facade.Func1();    facade.Func2();}//输出SubSystem1 is doing sth.SubSystem1 is doing sth.SubSystem2 is doing sth.</code></pre><h3 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h3><p>优点</p><ul><li>对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易。通过引入外观模式，客户代码将变得很简单，与之关联的对象也很少。</li><li>实现了子系统与客户之间的松耦合关系，这使得子系统的组件变化不会影响到调用它的客户类，只需要调整外观类即可。</li><li>降低了大型软件系统中的编译依赖性，并简化了系统在不同平台之间的移植过程，因为编译一个子系统一般不需要编译所有其他的子系统。一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。</li><li>只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类。</li></ul><p>缺点</p><ul><li>不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。</li><li>在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</li></ul><p>使用</p><p>外观模式应该是使用比较多的模式</p><ol><li>首先，在设计初期，要有意识地将不同两个层分离，在层与层直接建立外观Facade，为复杂的子系统提供一个简单的接口。</li><li>在开发阶段，子系统往往因为不断重构演化变得越来越复杂。增加Facade可以提供一个简单的接口，减少它们间的依赖。</li><li>在维护一个遗留的大型系统时，可能这个系统已经非常难以维护和扩展。可以为新系统开发一个Facade，让新系统与Facade交互，Facade与遗留代码交互。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Design pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[设计模式]之十六:观察者模式</title>
      <link href="/2017/04/05/%5BDesign-Pattern%5DObserver/"/>
      <url>/2017/04/05/%5BDesign-Pattern%5DObserver/</url>
      
        <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>观察者模式又叫发布订阅模式(public/subscribe)，定义一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</p><h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/UML-observer.png?raw=true" alt></p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><pre class=" language-lang-java"><code class="language-lang-java">//抽象出Notifier接口，保持所有被观察者对象的引用，并管理通知 notifyabstract class INotifier {    private List<IObserver> observers = new ArrayList<>();    public void attach(IObserver observer) {        observers.add(observer);    }    public void detach(IObserver observer) {        observers.remove(observer);    }    public void notifyObserver() {        for (int i = 0; i < observers.size(); i++) {            observers.get(i).update();        }    }}// 具体的通知者 管理控制具体的观察者对象  管理自己需要变化的状态public class ConcreteNotifier extends INotifier {    private String state;    public String getState() {        return state;    }    public void setState(String state) {        this.state = state;    }}//抽象观察者。观察者需要在得到通知后更新自己 所以需要更新方法abstract class IObserver {    // 更新接口    public abstract void update();}//具体观察者 它会有一个状态  在update的时候从对应的notifier获取新状态public class ConcreteObserver extends IObserver {    private String name;    private String observerState;    private ConcreteNotifier notifier;    public ConcreteObserver(ConcreteNotifier notifier, String name) {        // TODO Auto-generated constructor stub        this.notifier = notifier;        this.name = name;    }    @Override    public void update() {        // TODO Auto-generated method stub        observerState = notifier.getState();        System.out.println("Observer " + name + "'s new state is " + observerState);    }}//客户代码public void start() {    //创建通知者    ConcreteNotifier notifier = new ConcreteNotifier();    //添加观察者    notifier.attach(new ConcreteObserver(notifier, "X"));    notifier.attach(new ConcreteObserver(notifier, "Y"));    //通知更新状态    notifier.setState("hahaha");    //告诉观察者开始改状态    notifier.notifyObserver();}//输出Observer X's new state is hahahaObserver Y's new state is hahaha</code></pre><h3 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h3><p>一个对象改变需要同时改变其他对象的时候，且它不知道具体有多少对象有待改变时，考虑使用观察者模式。</p><p>观察者模式做的工作其实就是在解耦合，让耦合双方都依赖抽象，而不是依赖具体。从而使得各自变化都不会影响另一边变化。</p><p>但上面代码还有一个小问题，就是INotifier依赖IObserver。如果通知者和观察者互相不知道对方，由客户端来决定，那么就会更灵活。所以还需要一层解耦。</p><p><a href="https://www.kancloud.cn/digest/suski-pattern/160469" target="_blank" rel="noopener">https://www.kancloud.cn/digest/suski-pattern/160469</a></p>]]></content>
      
      
      <categories>
          
          <category> Design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Design pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[设计模式]之十五:建造者模式</title>
      <link href="/2017/04/04/%5BDesign-Pattern%5DBuilder/"/>
      <url>/2017/04/04/%5BDesign-Pattern%5DBuilder/</url>
      
        <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>讲一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</p><p>建造者模式主要用于创建一些复杂的对象，这些对象内部构建的建造顺序一般是稳定的，但对象内部的构建通常面对复杂的变化。</p><h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/UML-Builder.png?raw=true" alt></p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><pre class=" language-lang-java"><code class="language-lang-java">//产品public class Product {    List parts = new List();    public void add(String part) {        parts.add(part);    }    public void show() {        for (int i = 0; i < parts.getItemCount(); i++) {            System.out.println(parts.getItem(i));        }    }}//builder接口interface Builder {    public void buildPartA();    public void buildPartB();    public Product getResult();}//实现builder接口的不同建造者，也就是不同产品线生产不同的东西。实现接口是为了统一生产流程public class ConcreteBuilder1 implements Builder {    private Product product = new Product();    @Override    public void buildPartA() {        // TODO Auto-generated method stub        product.add("PartA");    }    @Override    public void buildPartB() {        // TODO Auto-generated method stub        product.add("PartB");    }    @Override    public Product getResult() {        // TODO Auto-generated method stub        return product;    }}public class ConcreteBuilder2 implements Builder {    private Product product = new Product();     @Override    public void buildPartA() {        // TODO Auto-generated method stub        product.add("PartX");    }    @Override    public void buildPartB() {        // TODO Auto-generated method stub        product.add("PartY");    }    @Override    public Product getResult() {        // TODO Auto-generated method stub        return product;    }}//管理生产顺序public class Director {    public void construct(Builder builder) {        builder.buildPartA();        builder.buildPartB();    }}public static void main(String[] args) {    // TODO Auto-generated method stub    Director director = new Director();    Builder b1 = new ConcreteBuilder1();    Builder b2 = new ConcreteBuilder2();    director.construct(b1);    Product p1 = b1.getResult();    p1.show();}</code></pre><p>Builder接口决定了所有建造必须实现的方法，避免漏掉某些建造步骤。</p><p>ConcreteBuilder是具体建造者，不同建造者用不同的方式实现每一个建造步骤。</p><p>Director是指挥者，指挥建造的顺序。该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。</p><h3 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h3><p>建造者模式主要用于创建一些复杂对象，这些对象内部构建间的建造通常是稳定的，但是对象内部构建通常面临复杂的变化。</p><p>优点</p><ul><li>在建造者模式中， <strong>客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</strong></li><li>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， <strong>用户使用不同的具体建造者即可得到不同的产品对象</strong> 。</li><li><strong>可以更加精细地控制产品的创建过程</strong> 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</li><li><strong>增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”。</strong></li></ul><p>缺点</p><ul><li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</li><li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Design pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[设计模式]之十四:备忘录模式</title>
      <link href="/2017/04/04/%5BDesign-Pattern%5DMemento/"/>
      <url>/2017/04/04/%5BDesign-Pattern%5DMemento/</url>
      
        <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该状态之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。</p><h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/UML-Memento.png?raw=true" alt></p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><pre class=" language-lang-java"><code class="language-lang-java">public class Originator {    private String state; // 需要保存的属性    public String getState() {        return state;    }    public void setState(String state) {        this.state = state;    }    public Memento createMemento() { //创建备忘录，把自己的状态保存进去        return new Memento(state);    }    public void setMemento(Memento memento) { //根据备忘录恢复数据        state = memento.getState();    }    public void show() {        System.out.println("State is " + state);    }}//备忘录public class Memento {    private String state;    public String getState() {        return state;    }    public Memento(String state) {        this.state = state;    }}//管理者public class Caretaker {    private Memento memento;    public Memento getMemento() {        return memento;    }    public void setMemento(Memento memento) {        this.memento = memento;    }}// 客户代码public static void main(String[] args) {    // TODO Auto-generated method stub    Originator originator = new Originator();    originator.setState("On");    originator.show();    Caretaker caretaker = new Caretaker();    caretaker.setMemento(originator.createMemento());    originator.setState("Off");    originator.show();    originator.setMemento(caretaker.getMemento());    originator.show();}//输出State is OnState is OffState is On</code></pre><p>保存的细节封装在Memeto中，客户端并不需要持有Memeto对象。对象由需要保存状态的Originator创建，交给Caretaker保存。Originator恢复的时候也从Caretaker获取Memeto进行数据恢复。</p>]]></content>
      
      
      <categories>
          
          <category> Design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Design pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[设计模式]之十三:抽象工厂模式</title>
      <link href="/2017/04/03/%5BDesign-Pattern%5DAbstractFactory/"/>
      <url>/2017/04/03/%5BDesign-Pattern%5DAbstractFactory/</url>
      
        <content type="html"><![CDATA[<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>抽象工厂模式与工厂方法模式的最大区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则需要面对多个产品等级结构。</p><p>比如组装电脑这个例子，工厂方法可以创建不同CPU工厂，不同主板工厂。但是CPU和主板是有配套关系的，不匹配的是不能组装的。所以需要抽象工厂，一个抽象工厂管理一个产品族，也就是一套配件，这里是组装一组CPU和主板。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p><h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/UML-AbstractFactory.png?raw=true" alt></p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><pre class=" language-lang-java"><code class="language-lang-java">//首先创建两种CPUinterface ICpu {    public void calculate();}public class IntelCpu implements ICpu {    private int pins = 0;    public IntelCpu(int pins) {        this.pins = pins;    }    @Override    public void calculate() {        System.out.println("Inter pins：" + pins);    }}public class AmdCpu implements ICpu {    private int pins = 0;    public AmdCpu(int pins) {        this.pins = pins;    }    @Override    public void calculate() {        System.out.println("AMD CPU pins:" + pins);    }}//再创建两种主板interface IMainboard {    public void installCpu();}public class IntelMainboard implements IMainboard {    private int cpuHoles = 0;    public IntelMainboard(int cpuHoles){        this.cpuHoles = cpuHoles;    }    @Override    public void installCpu() {        System.out.println("Intel mainboard's holes：" + cpuHoles);    }}public class AmdMainboard implements IMainboard {    private int cpuHoles = 0;    public AmdMainboard(int cpuHoles) {        this.cpuHoles = cpuHoles;    }    @Override    public void installCpu() {        System.out.println("AMD mainboard's holes:" + cpuHoles);    }}//创建抽象工厂interface AbstractFactory {    public ICpu createCpu();    public IMainboard createMainboard();}//分别创建管理两种产品族的工厂public class IntelFactory implements AbstractFactory {    @Override    public ICpu createCpu() {        return new IntelCpu(755);    }    @Override    public IMainboard createMainboard() {        return new IntelMainboard(755);    }}public class AmdFactory implements AbstractFactory {    @Override    public ICpu createCpu() {        return new AmdCpu(938);    }    @Override    public IMainboard createMainboard() {        return new AmdMainboard(938);    }}//组装电脑，通过该类，只需要传入抽象工厂对象，不需要知道具体是哪个工厂public class ComputerEngineer {    private ICpu cpu = null;    private IMainboard mainboard = null;    public void makeComputer(AbstractFactory factory) {        prepareHardwares(factory);    }    private void prepareHardwares(AbstractFactory factory) {        cpu = factory.createCpu();        mainboard = factory.createMainboard();        cpu.calculate();        mainboard.installCpu();    }}//客户端调用public static void main(String[] args) {    ComputerEngineer engineer = new ComputerEngineer();    // 创建具体的工厂对象    AbstractFactory factory = new IntelFactory();    // 组装对应产品    engineer.makeComputer(factory);}</code></pre><h3 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h3><p>抽象工厂的功能是为一系列相关对象或相互依赖的对象创建一个接口。一定要注意，这个接口内的方法不是任意堆砌的，而是一系列相关或相互依赖的方法。</p><p>优点</p><ul><li><strong>分离接口和实现</strong></li></ul><p>　　客户端使用抽象工厂来创建需要的对象，而客户端根本就不知道具体的实现是谁，客户端只是面向产品的接口编程而已。也就是说，客户端从具体的产品实现中解耦。</p><ul><li><strong>使切换产品族变得容易</strong></li></ul><p>　　因为一个具体的工厂实现代表的是一个产品族，比如上面例子的从Intel系列到AMD系列只需要切换一下具体工厂。</p><p>缺点</p><ul><li><strong>不太容易扩展新的产品</strong></li></ul><p>　　如果需要给整个产品族添加一个新的产品，那么就需要修改抽象工厂，这样就会导致修改所有的工厂实现类。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.cnblogs.com/java-my-life/archive/2012/03/28/2418836.html" target="_blank" rel="noopener">http://www.cnblogs.com/java-my-life/archive/2012/03/28/2418836.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Design pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[设计模式]之十二:状态模式</title>
      <link href="/2017/04/02/%5BDesign-Pattern%5DState/"/>
      <url>/2017/04/02/%5BDesign-Pattern%5DState/</url>
      
        <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>在很多情况下，一个对象的行为取决于一个或多个动态变化的属性，这样的属性叫做状态，这样的对象叫做有状态的(stateful)对象，这样的对象状态是从事先定义好的一系列值中取出的。当一个这样的对象与外部事件产生互动时，其内部状态就会改变，从而使得系统的行为也随之发生变化。</p><p>简单来说，就是不同状态对应不同的程序行为。我们可以用大量if/else或者switch代码去处理不同状态的逻辑。但这是面向过程的代码，我们可以用面向对象的方式，使用状态模式，轻松地切换不同的状态。</p><h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/UML-state.png?raw=true" alt></p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><pre class=" language-lang-java"><code class="language-lang-java">//声明一个状态接口，统一通过HandleState处理状态interface IState {    public void HandleState(StateManager manager);}//具体状态类 这里不同状态类可以做一些与这些状态相关的简单处理逻辑public class ConcreteStateA implements IState {    @Override    public void HandleState(StateManager manager) {        if (someState) {            ...        } else {            ...        }      // 当前stateA 改变为 stateB        manager.setState(new ConcreteStateB());    }}public class ConcreteStateB implements IState {    @Override    public void HandleState(StateManager manager) {      // 当前stateB 改变为 stateA        manager.setState(new ConcreteStateA());    }}//状态管理类 私有一个 state对象，通过开放外部接口updateState对状态更新public class StateManager {    private IState state;    public IState getState() {        return state;    }    public void setState(IState state) {        System.out.println("Set new state " + state.getClass().getName());        this.state = state;    }    public StateManager(IState state) {        System.out.println("Current state is " + state.getClass().getName());        this.state = state;    }    public void updateState() {        state.HandleState(this);    }}//客户代码public static void main(String[] args) {  //初始化一个状态管理对象，给他一个初始状态，随后的状态切换由各自具体state类处理，上层只需要在某些条件下进行触发更新状态操作即可    StateManager manager = new StateManager(new ConcreteStateA());    manager.updateState();    manager.updateState();    manager.updateState();}//输出Current state is ConcreteStateASet new state ConcreteStateBSet new state ConcreteStateASet new state ConcreteStateB</code></pre><h3 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h3><ul><li>状态模式描述了对象状态的变化以及对象如何在每一种状态下表现出不同的行为。</li><li>状态模式的关键是引入了一个抽象类来专门表示对象的状态，这个类我们叫做抽象状态类，而对象的每一种具体状态类都继承了该类，并在不同具体状态类中实现了不同状态的行为，包括各种状态之间的转换。</li></ul><p>优点</p><ul><li>封装了转换规则。</li><li>枚举可能的状态，在枚举状态之前需要确定状态种类。</li><li>将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。</li><li>允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。</li><li>可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</li></ul><p>缺点</p><ul><li>状态模式的使用必然会增加系统类和对象的个数。</li><li>状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。</li><li>状态模式对“开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Design pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[设计模式]之十一:适配器模式</title>
      <link href="/2017/04/01/%5BDesign-Pattern%5DAdapter/"/>
      <url>/2017/04/01/%5BDesign-Pattern%5DAdapter/</url>
      
        <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。</p><p>java不支持多重继承，故讨论对象适配器</p><h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/UML-Adapter.png?raw=true" alt></p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><pre class=" language-lang-java"><code class="language-lang-java">// 一个美国人，说英语public class American {    public void sendGreetings() {        System.out.println("Hello!");    }}// 中国人说中文public class Chinese {    public void sendGreetings() {        System.out.println("你好");    }}// 需要一个翻译把英文翻译成中文 他就是Adapterpublic class Translator extends American {    private Chinese chinese = new Chinese();    @Override    public void sendGreetings() {        //打印英文        super.sendGreetings();        //中文翻译        chinese.sendGreetings();        }}// 美国人初始化为翻译，说英文翻译成中文public static void main(String[] args) {    // TODO Auto-generated method stub    American target = new Translator();    target.sendGreetings();}//输出Hello!你好</code></pre><h3 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h3><p>优点</p><ul><li>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码。</li><li>增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性。</li><li>灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。</li></ul><p>缺点</p><ul><li><p>类适配器模式的缺点如下：</p><p>对于Java、C#等不支持多重继承的语言，一次最多只能适配一个适配者类，而且目标抽象类只能为抽象类，不能为具体类，其使用有一定的局限性，不能将一个适配者类和它的子类都适配到目标接口。</p></li><li><p>对象适配器模式的缺点如下：</p><p>与类适配器模式相比，要想置换适配者类的方法就不容易。如果一定要置换掉适配者类的一个或多个方法，就只好先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。   </p></li></ul><p>在以下情况下可以使用适配器模式：</p><ul><li>系统需要使用现有的类，而这些类的接口不符合系统的需要。</li><li>想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Design pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[设计模式]之十:组合模式</title>
      <link href="/2017/03/31/%5BDesign-Pattern%5DComposite/"/>
      <url>/2017/03/31/%5BDesign-Pattern%5DComposite/</url>
      
        <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p><h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/UML-composite.png?raw=true" alt></p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><pre class=" language-lang-java"><code class="language-lang-java">// 声明组织具有的功能，所有子组织都要实现这些方法abstract public class Component {    protected String name;    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public abstract void add(Component c);    public abstract void remove(Component c);    public abstract void display(int depth);}// Leaf节点，即实现部门功能。public class Leaf extends Component {    public Leaf(String name) {        this.name = name;    }    @Override    public void add(Component c) {        System.out.println("Leaf cannot add anything");    }    @Override    public void remove(Component c) {        System.out.println("Leaf has nothing to remove");    }    @Override    public void display(int depth) {        String str = "";        for (int i = 0; i < depth; i++) {            str += "-";        }        System.out.println(str + name);    }}// 组织结构，可以添加子组织public class Composite extends Component {    private List<Component> children = new ArrayList<>();    public Composite(String str) {        this.name = str;    }    @Override    public void add(Component c) {        children.add(c);    }    @Override    public void remove(Component c) {        children.remove(c);    }    @Override    public void display(int depth) {        String str = "";        for (int i = 0; i < depth; i++) {            str += "-";        }        System.out.println(str + name);        for(Component c : children) {            c.display(depth + 2);        }    }}//客户代码public static void main(String[] args) {    // TODO Auto-generated method stub    Composite root = new Composite("总公司");    root.add(new Leaf("财务部"));    root.add(new Leaf("组织部"));    Composite comp = new Composite("深圳分公司");    comp.add(new Leaf("财务部"));    comp.add(new Leaf("组织部"));    root.add(comp);    Composite comp2 = new Composite("香港分公司");    comp2.add(new Leaf("财务部"));    comp2.add(new Leaf("组织部"));    root.add(comp2);    root.display(1);}//输出-总公司---财务部---组织部---深圳分公司-----财务部-----组织部---香港分公司-----财务部-----组织部</code></pre><h3 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h3><p>需求是体现部分与整体层次的结构时，如果希望用户可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象时，就该考虑用组合模式。</p><p>组合模式定义了包含子部门的基本对象和分公司这样的组合对象的类层次结构。基本对象可以组合到组合对象中去，组合对象又可以被组合，这样不断递归。</p>]]></content>
      
      
      <categories>
          
          <category> Design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Design pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[设计模式]之九:迭代器模式</title>
      <link href="/2017/03/31/%5BDesign-Pattern%5DIterator/"/>
      <url>/2017/03/31/%5BDesign-Pattern%5DIterator/</url>
      
        <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示</p><p>Java的for(Obj obj : Iterator)就是迭代器模式</p><h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/UML-iterator.png?raw=true" alt></p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><pre class=" language-lang-java"><code class="language-lang-java">//创建聚集类 保存列表 获取列表属性public class ConcreteAggregate {    private List<Object> items = new ArrayList<Object>();    public int getCount() {        return items.size();    }    public Object getItem(int index) {        return items.get(index);    }    public void addItem(Object object) {        items.add(object);    }}//声明迭代器需要实现的接口interface Iterator {    public Object first();    public Object next();    public boolean isDone();    public Object currentItem();}//具体的迭代类public class ConcreteIterator implements Iterator {    private ConcreteAggregate aggregate;    private int current = 0;    //需要聚集类的引用，保存item到列表    public ConcreteIterator(ConcreteAggregate aggregate) {        this.aggregate = aggregate;    }    @Override    public Object first() {        return aggregate.getItem(0);    }    @Override    public Object next() {        Object obj = null;        current++;        if (current < aggregate.getCount()) {            obj = aggregate.getItem(current);        }        return obj;    }    @Override    public boolean isDone() {        return current >= aggregate.getCount() ? true : false;    }    @Override    public Object currentItem() {        return aggregate.getItem(current);    }}//客户代码public static void main(String[] args) {    // TODO Auto-generated method stub    ConcreteAggregate a = new ConcreteAggregate();    a.addItem("Tom");    a.addItem("Jerry");    a.addItem("Jack");    a.addItem("Rose");    Iterator i = new ConcreteIterator(a);    Object item = i.first();    while(!i.isDone()) {        System.out.println("Hello " + i.currentItem());        i.next();    }}//输出Hello TomHello JerryHello JackHello Rose</code></pre><h3 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h3><p>迭代器分离了集合对象的遍历行为，抽象出一个迭代器负责。这既可以不暴露内部结构，也让外部代码透明地访问集合内部数据</p>]]></content>
      
      
      <categories>
          
          <category> Design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Design pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[设计模式]之八:中介者模式</title>
      <link href="/2017/03/30/%5BDesign-Pattern%5DMediator/"/>
      <url>/2017/03/30/%5BDesign-Pattern%5DMediator/</url>
      
        <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p><h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/UML-mediator.png?raw=true" alt></p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><pre class=" language-lang-java"><code class="language-lang-java">// 比如两个同事分别熟悉CTS和SElinux的问题，现在要找他们协助，就需要找PM协调// 同事之间不一定都认识，但PM肯定认识。所以PM作为中介者interface Mediator {    public void send(String msg, Colleague colleague);}// PM认识所有同事，所以会持有同事们的实例，然后管理同事public class ConcreteMediator implements Mediator {    private ConcreteColleague1 tom;    private ConcreteColleague2 jerry;    public void setTom(ConcreteColleague1 tom) {        this.tom = tom;    }    public void setJerry(ConcreteColleague2 jerry) {        this.jerry = jerry;    }    @Override    public void send(String msg, Colleague colleague) {        // TODO Auto-generated method stub        if (colleague.getClass().equals(tom.getClass())) {            jerry.notify(msg);        } else {            tom.notify(msg);        }    }}//同事只认识PM  由PM转发消息abstract class Colleague {    protected Mediator mediator;    public Colleague(Mediator mediator) {        this.mediator = mediator;    }}public class ConcreteColleague1 extends Colleague {    public ConcreteColleague1(Mediator mediator) {        super(mediator);    }    public void send(String msg) {        mediator.send(msg, this);    }    public void notify(String msg) {        System.out.println("Hi Tom: " + msg);    }}public class ConcreteColleague2 extends Colleague {    public ConcreteColleague2(Mediator mediator) {        super(mediator);    }    public void send(String msg) {        mediator.send(msg, this);    }    public void notify(String msg) {        System.out.println("Hi Jerry: " + msg);    }}//客户代码    public static void main(String[] args) {        // TODO Auto-generated method stub        ConcreteMediator mediator = new ConcreteMediator();        ConcreteColleague1 tom = new ConcreteColleague1(mediator);        ConcreteColleague2 jerry = new ConcreteColleague2(mediator);        mediator.setTom(tom);        mediator.setJerry(jerry);        tom.send("Could you do the CTS job?");        jerry.send("Could you do the SElinux job?");    }//输出Hi Jerry: Could you do the CTS job?Hi Tom: Could you do the SElinux job?</code></pre><h3 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h3><p>当系统出现多对多交互复杂的对象群时，不要急着使用中介者模式，而要先反思你的系统在设计上是不是合理。</p><p>优点：<br>减少各个Colleague之间的耦合，使得可以独立地改变和复用各个Colleague类和Mediator<br>缺点：<br>Mediator实现过于复杂</p><p>计算器就是中介者模式的实现，所有按键以及屏幕互相不了解，中介者处理按键结果给屏幕显示</p><p>适用于一组对象用定义良好但是复杂的方式进行通信的场合</p>]]></content>
      
      
      <categories>
          
          <category> Design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Design pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[设计模式]之七:命令模式</title>
      <link href="/2017/03/29/%5BDesign-Pattern%5DCommand/"/>
      <url>/2017/03/29/%5BDesign-Pattern%5DCommand/</url>
      
        <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>将请求封装成一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或者请求日志，以及支持可撤销的操作。</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>去饭馆吃饭，客人作为发起者点菜，厨师作为执行者做菜。但为了提高效率，分开职责，增加服务员的角色，服务员负责和客人与厨师交互，记录点菜，传达信息。</p><h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/UML-command.png?raw=true" alt></p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><pre class=" language-lang-java"><code class="language-lang-java">//厨师接收消息 做菜public class Receiver {    public void execute() {        System.out.println("Execute command");    }}// 服务员管理收到的各类别的命令，通知厨师去做，所以需要维持一个厨师的引用//这里做了简化，其实服务员还可以单独做一个类，创建一个list保存各式各样的commandabstract class Command {    protected Receiver receiver;    public Command(Receiver receiver) {        this.receiver = receiver;    }    abstract public void execute();}public class ConcreteCommand extends Command {    public ConcreteCommand(Receiver receiver) {        super(receiver);    }    @Override    public void execute() {        receiver.execute();    }}//客户去点菜，所以需要服务员的引用public class Invoker {    private Command cmd;    public void setCommand(Command cmd) {        this.cmd = cmd;    }    public void executeCommand() {        cmd.execute();    }}//客户代码public class main {    public static void main(String[] args) {        // TODO Auto-generated method stub        Receiver r = new Receiver();        Command c = new ConcreteCommand(r);        Invoker i = new Invoker();        i.setCommand(c);        i.executeCommand();    }}</code></pre><h3 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h3><p>优点</p><ol><li>能较容易地设计一个命令队列</li><li>容易把命令记入日志</li><li>允许接收请求的一方决定是否要否决请求</li><li>容易实现对请求的撤销和重做</li><li>易于拓展命令类</li><li>把请求一个操作的对象与执行一个操作的对象分割开</li></ol>]]></content>
      
      
      <categories>
          
          <category> Design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Design pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[设计模式]之六:桥接模式</title>
      <link href="/2017/03/28/%5BDesign-Pattern%5DBridge/"/>
      <url>/2017/03/28/%5BDesign-Pattern%5DBridge/</url>
      
        <content type="html"><![CDATA[<h3 id="合成-聚合复用原则CARP"><a href="#合成-聚合复用原则CARP" class="headerlink" title="合成/聚合复用原则CARP"></a>合成/聚合复用原则CARP</h3><p>尽量使用合成/聚合，尽量不要使用类继承</p><ul><li>聚合Aggregation 表示一种弱的’拥有’关系，体现A对象可以包含B对象，但B对象不是A对象的一部分</li><li>合成Composition 表示一种强的’拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样</li></ul><p>比如，大雁和翅膀属于合成，大雁和雁群属于聚合</p><p>这个原则的好处是，优先使用对象的合成/聚合将有助于你保持每个类被封禁，并被集中在单个任务上。这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物。</p><p>比如，A，B，C三种操作系统，X，Y，Z三种软件。每个系统都有这三种软件时，会发现一共有9种情况。</p><p>按照继承，有两种情况：</p><ol><li>设计OS父类，ABC继承OS，ABC下分别有一个XYZ</li><li>设计Software父类，XYZ继承Software，XYZ下各有ABC三种版本</li></ol><p>这时候，增加一种OS或者Software，再或者增加父类的方法，带来的影响就很大，导致最后规模越来越大。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>桥接模式将抽象部分与它实现的部分分离，使它们都可以独立地变化。</p><p>“将抽象部分与它的实现部分分离”指的是，前面的OS和Software有两种实现方式，现在就是要把这些实现分离开，独立出来，让它们各自变化。</p><h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/UML-bridge.png?raw=true" alt></p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><pre class=" language-lang-java"><code class="language-lang-java">// 软件类统一实现ISoftware接口interface ISoftware {    public void run();}public class Software_X implements ISoftware {    @Override    public void run() {        System.out.println("Run software A");    }}public class Software_Y implements ISoftware {    @Override    public void run() {        System.out.println("Run software Y");    }}// OS类统一继承IOS  因为软件和OS属于聚合关系，OS持有一个software的引用abstract class IOS {    protected ISoftware software;    public void setSoftware(ISoftware sw) {        this.software = sw;    }    public abstract void run();}public class OS_A extends IOS {    @Override    public void run() {        System.out.println("OSA");        software.run();    }}public class OS_B extends IOS {    @Override    public void run() {        System.out.println("OSB");        software.run();    }}//客户代码public class main {    public static void main(String[] args) {        IOS os = new OS_A();        os.setSoftware(new Software_X());        os.run();        os.setSoftware(new Software_Y());        os.run();        os = new OS_B();        os.setSoftware(new Software_X());        os.run();        os.setSoftware(new Software_Y());        os.run();    }}//输出OSARun software AOSARun software YOSBRun software AOSBRun software Y</code></pre>]]></content>
      
      
      <categories>
          
          <category> Design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Design pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[设计模式]之五:职责链模式</title>
      <link href="/2017/03/27/%5BDesign-Pattern%5DChain-of-responsibility/"/>
      <url>/2017/03/27/%5BDesign-Pattern%5DChain-of-responsibility/</url>
      
        <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>需要层层审批的，直到某一层可以给出具体结果。<br>比如离职申请，首先发给团队主管，然后团队主管发给部门经理，之后再给总经理这样，一层一层上传，直到信息传给能够给出反馈的人。</p><h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/UML-chainOfResponsibility.png?raw=true" alt></p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><pre class=" language-lang-java"><code class="language-lang-java">//统一处理接口abstract class Handler {    protected Handler handler;    public void setHandler(Handler handler) {        this.handler =  handler;    }    public abstract void HandlerRequest(int req);}//具体实现 处理不同的内容public class ConcreteHandler1 extends Handler {    @Override    public void HandlerRequest(int req) {        // TODO Auto-generated method stub        if (req >= 0 && req < 10) {            System.out.println("Handler1 handle " + req + " now");        } else if (handler != null) {            handler.HandlerRequest(req);        }    }}public class ConcreteHandler2 extends Handler {    @Override    public void HandlerRequest(int req) {        // TODO Auto-generated method stub        if (req >= 10 && req < 20) {            System.out.println("Handler2 handle " + req + " now");        } else if (handler != null) {            handler.HandlerRequest(req);        }    }}public class ConcreteHandler3 extends Handler {    @Override    public void HandlerRequest(int req) {        // TODO Auto-generated method stub        if (req >= 20 && req < 30) {            System.out.println("Handler3 handle " + req + " now");        } else if (handler != null) {            handler.HandlerRequest(req);        }    }}//客户代码    public static void main(String[] args) {        // TODO Auto-generated method stub        Handler h1 = new ConcreteHandler1();        Handler h2 = new ConcreteHandler2();        Handler h3 = new ConcreteHandler3();        h1.setHandler(h2);        h2.setHandler(h3);        List<Integer> list = new ArrayList<Integer>();        list.add(2);        list.add(5);        list.add(14);        list.add(22);        list.add(18);        list.add(3);        list.add(27);        list.add(20);        for(Integer i : list) {            h1.HandlerRequest(i);        }    }//输出Handler1 handle 2 nowHandler1 handle 5 nowHandler2 handle 14 nowHandler3 handle 22 nowHandler2 handle 18 nowHandler1 handle 3 nowHandler3 handle 27 nowHandler3 handle 20 now</code></pre><h3 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h3><p>一个很好的优点是，当客户提交一个请求时，请求是按着链传递，直至有一个ConcreteHandler对象负责处理。也就是请求一定会被处理。</p><p>另外降低了耦合度。因为这个结构，接收者和发送者都不清楚对方的明确信息，且链中对象也不知道链的结构。结果是职责链可简化对象的相互连接，它们仅需要保持一个指向其后继者的引用，而不需保持它所有的候选接收者的引用。</p><p>最后，可以随时增加或修改处理一个请求的结构，增强了给对象指派职责的灵活性。</p>]]></content>
      
      
      <categories>
          
          <category> Design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Design pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[设计模式]之四:再谈单例模式</title>
      <link href="/2017/03/26/%5BDesign-Pattern%5DMore-about-Singleton/"/>
      <url>/2017/03/26/%5BDesign-Pattern%5DMore-about-Singleton/</url>
      
        <content type="html"><![CDATA[<p><strong><a href="http://wossoneri.github.io/categories/Design-pattern/">设计模式系列目录</a></strong></p><p>之前有写过单例模式：<a href="http://wossoneri.github.io/2016/05/23/[Design-Pattern]Singleton/">[设计模式]之三:单例模式</a>，可以通过链接回顾一下。然后这次再多聊聊这个设计模式。</p><h3 id="线程不安全的懒汉式"><a href="#线程不安全的懒汉式" class="headerlink" title="线程不安全的懒汉式"></a>线程不安全的懒汉式</h3><p>可能一提到单例模式，大多数人都会想到这么写：</p><pre class=" language-lang-java"><code class="language-lang-java">public class Singleton {    private static Singleton instance;    private Singleton() {    }    public static Singleton getInstance(){        if (null == instance) {            instance = new Singleton();        }        return instance;    }}</code></pre><p>这个写法也是严格按照概念来的</p><blockquote><p>让类自身负责保存它的唯一实例。这个类保证没有其它实例可以被创建，并且它可以提供一个访问该实例的方法。</p></blockquote><p>但这个写法有一个问题：多线程情况下并行调用<code>Singleton.getInstance()</code>,会导致创建多个实例。</p><p>可以用代码做个简单验证：</p><pre class=" language-lang-java"><code class="language-lang-java">new Thread(new Runnable() {    @Override    public void run() {        // TODO Auto-generated method stub        System.out.println("s1 hashcode:" + Singleton.getInstance().hashCode());     }}).start();new Thread(new Runnable() {  @Override  public void run() {    // TODO Auto-generated method stub    System.out.println("s2 hashcode:" + Singleton.getInstance().hashCode());   }}).start();</code></pre><p>通过<code>hashCode</code>看到有时候获取到的两个实例并不相同。</p><h3 id="线程安全的懒汉式"><a href="#线程安全的懒汉式" class="headerlink" title="线程安全的懒汉式"></a>线程安全的懒汉式</h3><p>对于多线程情况，一个直接的办法就是使用同步锁<code>synchronized</code>。</p><pre class=" language-lang-java"><code class="language-lang-java">public static synchronized Singleton getInstance(){  if (null == instance) {    instance = new Singleton();  }  return instance;}</code></pre><p>再次执行测试程序，现在不论怎么执行，打印的哈希值都是一样的。这样很轻松地解决了同步问题。</p><p>BUG解掉了不代表工作就结束了，我们还没看程序性能呢。处理性能问题，首先要梳理程序逻辑。</p><ul><li><p>同步锁解决的是什么问题？</p><p>是会创建多个<strong>实例</strong>。</p></li><li><p>如果保证了只有一个实例，后面get实例还有问题吗？</p><p>没有</p></li></ul><p>那么问题就出来了，同步锁保证同时只有一个线程访问它，这个功能只在实例未创建的时候需要。其他时间，我们认为它可以随便调用。否则的话多线程运行到这里就成单线程了，一个一个执行，太影响效率了。</p><p>所以就需要先做一个判断，如果实例未创建，加锁！否则就返回实例。这样就形成了双重检验。</p><h3 id="双重检验锁"><a href="#双重检验锁" class="headerlink" title="双重检验锁"></a>双重检验锁</h3><pre class=" language-lang-java"><code class="language-lang-java">public static Singleton getInstance(){  if (null == instance) {    synchronized (Singleton.class) {      if (null == instance) {        instance = new Singleton();      }    }  }  return instance;}</code></pre><p>首先，检查实例是否存在，不存在就进行加锁。但是加锁后，里面为何又要判断实例为空呢？因为可能有多线程一起通过第一层，而到了同步锁这里，几个线程排队执行。这样第一个线程创建实例后，第二个线程就会进来。所以需要再做一次判断，防止多创建实例。</p><p>到此，一个<strong>近乎</strong>完美的单例就写出来了。说是近乎，是因为还有一个很细小问题没有解决：指令顺序优化。</p><pre class=" language-lang-java"><code class="language-lang-java">instance = new Singleton();</code></pre><p>这行代码，在JVM中执行：（描述可能不是很准确，后续再修改）</p><ol><li>为instance分配内存</li><li>调用Singleton构造函数初始化成员变量</li><li>将创建的对象指向分配的内存空间</li></ol><p>执行了1，2，3后，instance才是非空的。但是在JVM编译时，为了提高执行效率，这些指令执行顺序会被调整。如果出现1，3，2的执行顺序，那么程序就会报错。</p><p>解决方案就是使用<code>volatile</code>关键字禁止指令排序优化。</p><pre class=" language-lang-java"><code class="language-lang-java">private volatile static Singleton instance;</code></pre><p>关于<code>volatile</code>关键字，是涉及到JVM书籍里都会讲到的。我会另外去总结，这里不多BB了。</p><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>前面的都是在第一次使用的时候，初始化实例，所以叫做懒汉式。那么饿汉式就是在使用前直接创建实例给你用。</p><pre class=" language-lang-java"><code class="language-lang-java">private static final Singleton instance = new Singleton();public static Singleton getInstance(){  return instance;}</code></pre><p>其实这样更简单呢。</p><p>因为static final在第一次加载到内存就执行了，所以不用担心线程问题。</p><p>但是毕竟这样还是有缺陷的，就是如果涉及到根据参数初始化的情况，这个写法就不奏效了。</p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>这个是<effective java>推荐的写法。</effective></p><pre class=" language-lang-java"><code class="language-lang-java">private static class SingletonHolder {  private static final Singleton INSTANCE = new Singleton();} public static final Singleton getInstance(){  return SingletonHolder.INSTANCE;}</code></pre><p>后面也会再聊聊内部静态类这个东西。</p><h3 id="枚举单例"><a href="#枚举单例" class="headerlink" title="枚举单例"></a>枚举单例</h3><pre class=" language-lang-java"><code class="language-lang-java">private static enum EnumSingleton {  INSTANCE;  private Singleton singleton;  private EnumSingleton() {    singleton = new Singleton();  }  private Singleton getInstance() {    return singleton;  }}private Singleton() {}public static Singleton getInstance(){  return EnumSingleton.INSTANCE.getInstance();}</code></pre><p>目前最为安全的实现单例的方法是通过内部静态enum的方法来实现，因为JVM会保证enum不能被反射并且构造器方法只执行一次。</p><p>枚举类型可以干很多有意思的事情，后面也会拿出来聊一聊。</p>]]></content>
      
      
      <categories>
          
          <category> Design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Design pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[设计模式]之二十:模板方法模式</title>
      <link href="/2017/03/09/%5BDesign-Pattern%5DTemplateMethod/"/>
      <url>/2017/03/09/%5BDesign-Pattern%5DTemplateMethod/</url>
      
        <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>定义一个操作中算法的骨架，将一些步骤延迟到子类中。模板方法使得子类可以不改变算法的结果即可重定义该算法的某些特定步骤。</p><p>简单理解成</p><p>同样一套代码，要有不同输出。</p><h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/UML-TemplateMethod.png?raw=true" alt></p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><pre class=" language-lang-java"><code class="language-lang-java">abstract class Template {    public abstract void OperationA();    public abstract void OperationB();    //定义模板调用顺序    public void TemplateMethod() {        OperationA();        OperationB();    }}public class SubClassA extends Template {    @Override    public void OperationA() {        // TODO Auto-generated method stub        System.out.println("A want a car");    }    @Override    public void OperationB() {        // TODO Auto-generated method stub        System.out.println("A don't need a girfriend");    }}public class SubClassB extends Template {    @Override    public void OperationA() {        // TODO Auto-generated method stub        System.out.println("B don't need a car");    }    @Override    public void OperationB() {        // TODO Auto-generated method stub        System.out.println("B need a girlfriend");    }}public static void main(String[] args) {    // TODO Auto-generated method stub    Template t;    t = new SubClassA();    t.TemplateMethod();    t = new SubClassB();    t.TemplateMethod();}//输出 A和B用一套模板，不同输出A want a carA don't need a girfriendB don't need a carB need a girlfriend</code></pre><p>通过把不变行为搬到超类，去除子类的重复代码体现优势。</p>]]></content>
      
      
      <categories>
          
          <category> Design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Design pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Android][Framework]Provision</title>
      <link href="/2016/10/28/%5BAndroid%5D%5BFramework%5DProvision/"/>
      <url>/2016/10/28/%5BAndroid%5D%5BFramework%5DProvision/</url>
      
        <content type="html"><![CDATA[<h3 id="Provision是什么？"><a href="#Provision是什么？" class="headerlink" title="Provision是什么？"></a>Provision是什么？</h3><p><code>Provision</code>的作用很简单，就是一个系统初始化引导程序，源生的Android里面<code>Provision</code>只做了一件事，就是写入一个<code>DEVICE_PROVISIONED</code>标记。</p><blockquote><p>这个标记作用很大，这个标记只会在系统 全新升级（双清）的时候写入一次，代表了Android系统升级准备完成，可以正常工作。</p></blockquote><h3 id="Provision在哪？"><a href="#Provision在哪？" class="headerlink" title="Provision在哪？"></a>Provision在哪？</h3><p>一般在<code>package</code>目录下:<code>package/apps/Provision</code>。</p><h3 id="Proision代码"><a href="#Proision代码" class="headerlink" title="Proision代码"></a>Proision代码</h3><p><code>Provision</code>下只有一个<code>Activity</code>文件和一个<code>Manifest</code>文件</p><h4 id="Manifest"><a href="#Manifest" class="headerlink" title="Manifest"></a>Manifest</h4><pre class=" language-lang-xml"><code class="language-lang-xml"><application>  <activity android:name="DefaultActivity"          android:excludeFromRecents="true">      <intent-filter android:priority="1">          <action android:name="android.intent.action.MAIN" />          <category android:name="android.intent.category.HOME" />          <category android:name="android.intent.category.DEFAULT" />      </intent-filter>  </activity></application></code></pre><p>配置说明：</p><ul><li><code>android:excludeFromRecents=&quot;true&quot;</code> 不在<code>Recents</code>界面显示。</li><li><code>&lt;intent-filter android:priority=&quot;1&quot;&gt;</code> 优先级高于<code>Launcher</code>，所以会先于<code>Launcher</code>启动(因为系统Launcher没有显式设置priority值，所以默认是0)</li><li><code>category.HOME</code> 桌面程序标记，和<code>Launcher</code>属于一个级别</li></ul><h4 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h4><pre class=" language-lang-java"><code class="language-lang-java">public class DefaultActivity extends Activity{  @Override  protected void onCreate(Bundle icicle)  {      super.onCreate(icicle);      // Add a persistent setting to allow other apps to know the device has been provisioned.      Settings.Secure.putInt(getContentResolver(), Settings.Secure.DEVICE_PROVISIONED, 1);      // remove this activity from the package manager.      PackageManager pm = getPackageManager();      ComponentName name = new ComponentName(this, DefaultActivity.class);      pm.setComponentEnabledSetting(name, PackageManager.COMPONENT_ENABLED_STATE_DISABLED,          PackageManager.DONT_KILL_APP);      // terminate the activity.      finish();  }}</code></pre><p>源生代码很简单<br>做了两件事：</p><ol><li>设置<code>DEVICE_PROVISIONED</code>标记</li><li>禁止<code>Provision</code>自己的<code>Activity</code>组件</li></ol><p>对这个代码做点说明：</p><pre class=" language-lang-java"><code class="language-lang-java">// Add a persistent setting to allow other apps to know the device has been provisioned.Settings.Secure.putInt(getContentResolver(), Settings.Secure.DEVICE_PROVISIONED, 1);</code></pre><p>注释表述很清楚：为设备写入持久的数据，并供其他App了解设备已经provision过。</p><blockquote><p><strong>class Settings</strong></p><p>The Settings provider contains global system-level device preferences.</p><p><strong>class Secure</strong></p><p>Secure system settings, containing system preferences that applications can read but are not allowed to write.  These are for preferences that the user must explicitly modify through the system UI or specialized APIs for those values, not modified directly by applications.</p><p><strong>public static boolean putInt(ContentResolver cr, String name, int value)</strong></p><p>Convenience function for updating a single settings value as an integer. This will either create a new entry in the table if the given name does not exist, or modify the value of the existing row with that name.  Note that internally setting values are always stored as strings, so this function converts the given value to a string before storing it.</p><ul><li>@param cr The ContentResolver to access.</li><li>@param name The name of the setting to modify.</li><li>@param value The new value for the setting.</li><li>@return true if the value was set, false on database errors</li></ul></blockquote><p>禁止组件的功能</p><pre class=" language-lang-java"><code class="language-lang-java">pm.setComponentEnabledSetting(name, PackageManager.COMPONENT_ENABLED_STATE_DISABLED,    PackageManager.DONT_KILL_APP);</code></pre><blockquote><p><strong>public abstract void setComponentEnabledSetting(ComponentName componentName,</strong><br>          <strong>int newState, int flags);</strong></p><p>Set the enabled setting for a package component (activity, receiver, service, provider). This setting will override any enabled state which may have been set by the component in its manifest.</p><ul><li><p>@param componentName The component to enable</p></li><li><p>@param newState The new enabled state for the component.  The legal values for this state are:</p><ul><li><p>COMPONENT_ENABLED_STATE_ENABLED</p></li><li><p>COMPONENT_ENABLED_STATE_DISABLED</p></li><li><p>COMPONENT_ENABLED_STATE_DEFAULT</p><p>The last one removes the setting, thereby restoring the component’s state to whatever was set in it’s manifest (or enabled, by default).</p></li></ul></li><li><p>@param flags Optional behavior flags: DONT_KILL_APP or 0.</p></li></ul></blockquote><p>功能禁止后，系统package信息会记录下来，保存在 <code>/data/system/packages.xml</code></p><pre class=" language-lang-xml"><code class="language-lang-xml"><package name="com.android.provision" codePath="/system/app/Provision.apk" nativeLibraryPath="/data/data/com.android.provision/lib"flags="1" ft="11b7e237e00" it="11b7e237e00"ut="11b7e237e00" version="15" userId="10005"><sigs count="1"><cert index="1" /></sigs><disabled-components><item name="com.android.provision.DefaultActivity" /></disabled-components></package></code></pre><p>这段代码就是记录的禁止<code>DefaultActivity</code>的信息。所以这个组件只会运行一次，之后就被禁止运行了。除非格式化<code>/data/</code>目录。</p><h3 id="5X实现"><a href="#5X实现" class="headerlink" title="5X实现"></a>5X实现</h3><pre class=" language-lang-java"><code class="language-lang-java">/*** Application that sets the provisioned bit, like SetupWizard does.*/public class DefaultActivity extends Activity {  private static final String ORIGINAL_LAUNCHER_PACKAGENAME = "com.android.launcher3";  private static final String ORIGINAL_LAUNCHER_CLASSNAME = "com.android.launcher3.Launcher";  @Override  protected void onCreate(Bundle icicle) {      super.onCreate(icicle);      // Add a persistent setting to allow other apps to know the device has been provisioned.      Settings.Global.putInt(getContentResolver(), Settings.Global.DEVICE_PROVISIONED, 1);      Settings.Secure.putInt(getContentResolver(), Settings.Secure.USER_SETUP_COMPLETE, 1);      // remove this activity from the package manager.      PackageManager pm = getPackageManager();      ComponentName name = new ComponentName(this, DefaultActivity.class);      pm.setComponentEnabledSetting(name, PackageManager.COMPONENT_ENABLED_STATE_DISABLED,              PackageManager.DONT_KILL_APP);      //set Launcher3 as the preferred home activity      setupDefaultLauncher(pm);      // terminate the activity.      finish();  }  private void setupDefaultLauncher(PackageManager pm){      Intent queryIntent = new Intent();      queryIntent.addCategory(Intent.CATEGORY_HOME);      queryIntent.setAction(Intent.ACTION_MAIN);  // 查找符合 Launcher 的 activity      List<ResolveInfo> homeActivities = pm.queryIntentActivities(queryIntent, 0);      if(homeActivities == null) {          return;      }      ComponentName defaultLauncher = new ComponentName(ORIGINAL_LAUNCHER_PACKAGENAME,              ORIGINAL_LAUNCHER_CLASSNAME);      int activityNum = homeActivities.size();      ComponentName[] set = new ComponentName[activityNum];      int defaultMatch = -1;      for(int i = 0; i < activityNum; i++){ //从符合 Launcher 中查找 Launcher3          ResolveInfo info = homeActivities.get(i);          set[i] = new ComponentName(info.activityInfo.packageName, info.activityInfo.name);          if(ORIGINAL_LAUNCHER_CLASSNAME.equals(info.activityInfo.name)                  && ORIGINAL_LAUNCHER_PACKAGENAME.equals(info.activityInfo.packageName)){              defaultMatch = info.match;          }      }      //if Launcher3 is not found, do not set anything      if(defaultMatch == -1){          return;      }      IntentFilter filter = new IntentFilter();      filter.addAction(Intent.ACTION_MAIN);      filter.addCategory(Intent.CATEGORY_HOME);      filter.addCategory(Intent.CATEGORY_DEFAULT);      pm.addPreferredActivity(filter, defaultMatch, set, defaultLauncher);  }}</code></pre><blockquote><p>Reference<br><a href="http://www.cnblogs.com/mythou/p/3425570.html" target="_blank" rel="noopener">Android 初始化Setup Wizard——Provision</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Provision </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Android]多媒体数据库</title>
      <link href="/2016/10/15/%5BAndroid%5DMultimedia-database/"/>
      <url>/2016/10/15/%5BAndroid%5DMultimedia-database/</url>
      
        <content type="html"><![CDATA[<p>多媒体数据库</p><p>以 root 权限进入 adb shell， <strong>/data/data/com.android.providers.media/databases</strong> 目录下就是存放数据库的地方。</p><p>以 external 开头的数据库存储的是 SD 卡媒体信息，一张卡对应一个，所以如果手机使用过多张卡会有多个数据库。以 internal<br>开头的数据库存储手机内部存储器的媒体信息。因为一般用户无法访问手机内部存储器，而且这两个数据库结构是大体上是相同的，所以只需要关注<br>external 数据库即可。</p><h3 id="图片数据库"><a href="#图片数据库" class="headerlink" title="图片数据库"></a>图片数据库</h3><p>由两个表组成，images和thumbnails</p><h4 id="images-图片"><a href="#images-图片" class="headerlink" title="images 图片"></a>images 图片</h4><div class="table-container"><table><thead><tr><th>字段</th><th>解析</th></tr></thead><tbody><tr><td>_id</td><td>主键。图片 id，从 1 开始自增</td></tr><tr><td>_data</td><td>图片绝对路径</td></tr><tr><td>_size</td><td>文件大小，单位为 byte</td></tr><tr><td>_display_name</td><td>文件名</td></tr><tr><td>mime_type</td><td>类似于 image/jpeg 的 MIME 类型</td></tr><tr><td>title</td><td>不带扩展名的文件名（数据库里也存在部分带有扩展名的）</td></tr><tr><td>date_added</td><td>添加到数据库的时间，单位秒</td></tr><tr><td>date_modified</td><td>文件最后修改时间，单位秒</td></tr><tr><td>description</td><td></td></tr><tr><td>picasa_id</td><td>用于 picasa 网络相册</td></tr><tr><td>isprivate</td><td></td></tr><tr><td>latitude</td><td>纬度，需要照片有 GPS 信息</td></tr><tr><td>longitude</td><td>经度，需要照片有 GPS 信息</td></tr><tr><td>datetaken</td><td>取自 EXIF 照片拍摄时间，若为空则等于文件修改时间，单位毫秒</td></tr><tr><td>orientation</td><td>取自 EXIF 旋转角度，在图库旋转图片也会改变此值</td></tr><tr><td>mini_thumb_magic</td><td>取小缩略图时生成的一个随机数，见 MediaThumbRequest</td></tr><tr><td>bucket_id</td><td>相册（文件夹）id。等于 path.toLowerCase.hashCode()，见MediaProvider.computeBucketValues()</td></tr><tr><td>bucket_display_name</td><td>直接包含图片的文件夹就是该图片的 bucket，就是文件夹名</td></tr><tr><td>width</td><td>图片宽度</td></tr><tr><td>height</td><td>图片高度</td></tr></tbody></table></div><h4 id="thumbnails-缩略图"><a href="#thumbnails-缩略图" class="headerlink" title="thumbnails 缩略图"></a>thumbnails 缩略图</h4><div class="table-container"><table><thead><tr><th>字段</th><th>解析</th></tr></thead><tbody><tr><td>_id</td><td>主键。缩略图 id，从 1 开始自增</td></tr><tr><td>_data</td><td>图片绝对路径</td></tr><tr><td>image_id</td><td>缩略图所对应图片的 id，依赖于 images 表 _id 字段，可建立外键</td></tr><tr><td>kind</td><td>缩略图类型，1 是大缩略图，2 基本不用，3 是微型缩略图但其信息不保存在数据库</td></tr><tr><td>width</td><td>缩略图宽度</td></tr><tr><td>height</td><td>缩略图高度</td></tr></tbody></table></div><h3 id="视频数据库"><a href="#视频数据库" class="headerlink" title="视频数据库"></a>视频数据库</h3><h4 id="video"><a href="#video" class="headerlink" title="video"></a>video</h4><div class="table-container"><table><thead><tr><th>字段</th><th>解析</th></tr></thead><tbody><tr><td>_id</td><td>主键。视频 id</td></tr><tr><td>_data</td><td>视频绝对路径</td></tr><tr><td>_display_name</td><td>文件名</td></tr><tr><td>_size</td><td>文件大小，单位为 byte</td></tr><tr><td>mime_type</td><td>类似于 video/avi 的 MIME 类型</td></tr><tr><td>date_added</td><td>添加到数据库的时间，单位秒</td></tr><tr><td>date_modified</td><td>文件最后修改时间，单位秒</td></tr><tr><td>title</td><td>不带扩展名的文件名</td></tr><tr><td>duration</td><td>视频时长，单位毫秒</td></tr><tr><td>artist</td><td>艺术家</td></tr><tr><td>album</td><td>专辑名，一般为文件夹名</td></tr><tr><td>resolution</td><td>分辨率</td></tr><tr><td>description</td><td></td></tr><tr><td>isprivate</td><td></td></tr><tr><td>tags</td><td></td></tr><tr><td>category</td><td></td></tr><tr><td>language</td><td></td></tr><tr><td>mini_thumb_data</td><td></td></tr><tr><td>latitude</td><td>经度</td></tr><tr><td>longitude</td><td>纬度</td></tr><tr><td>datetaken</td><td>录制时间，单位毫秒</td></tr><tr><td>mini_thumb_magic</td><td>取小缩略图时生成的一个随机数，见 MediaThumbRequest</td></tr><tr><td>bucket_id</td><td>等于 path.toLowerCase.hashCode()，见 MediaProvider.computeBucketValues()</td></tr><tr><td>bucket_display_name</td><td>直接包含视频的文件夹就是该图片的 bucket，就是文件夹名</td></tr><tr><td>bookmark</td><td></td></tr><tr><td>width</td><td>视频宽度</td></tr><tr><td>height</td><td>视频高度</td></tr></tbody></table></div><h4 id="videothumbnails"><a href="#videothumbnails" class="headerlink" title="videothumbnails"></a>videothumbnails</h4><div class="table-container"><table><thead><tr><th>字段</th><th>解析</th></tr></thead><tbody><tr><td>_id</td><td>主键。缩略图 id</td></tr><tr><td>_data</td><td>缩略图绝对路径</td></tr><tr><td>video_id</td><td>缩略图所对应视频的 id，依赖于 video 表 _id 字段</td></tr><tr><td>kind</td><td>缩略图类型，1 是大图，视频只能取类型 1</td></tr><tr><td>width</td><td>缩略图宽度</td></tr><tr><td>height</td><td>缩略图高度</td></tr></tbody></table></div><h3 id="音频数据库"><a href="#音频数据库" class="headerlink" title="音频数据库"></a>音频数据库</h3><p>这个比较复杂，由多个表组成</p><h4 id="album-art：专辑封面"><a href="#album-art：专辑封面" class="headerlink" title="album_art：专辑封面"></a>album_art：专辑封面</h4><div class="table-container"><table><thead><tr><th>字段</th><th>解析</th></tr></thead><tbody><tr><td>album_id</td><td>主键。专辑 id</td></tr><tr><td>_data</td><td>专辑封面缓存的路径</td></tr></tbody></table></div><h4 id="albums：专辑"><a href="#albums：专辑" class="headerlink" title="albums：专辑"></a>albums：专辑</h4><div class="table-container"><table><thead><tr><th>字段</th><th>解析</th></tr></thead><tbody><tr><td>album_id</td><td>主键。专辑 id</td></tr><tr><td>album_key</td><td>全大写字母，用于字母索引</td></tr><tr><td>album</td><td>专辑名</td></tr></tbody></table></div><h4 id="album-info：专辑信息"><a href="#album-info：专辑信息" class="headerlink" title="album_info：专辑信息"></a>album_info：专辑信息</h4><div class="table-container"><table><thead><tr><th>字段</th><th>解析</th></tr></thead><tbody><tr><td>_id</td><td>主键</td></tr><tr><td>album</td><td>专辑名</td></tr><tr><td>album_key</td><td>专辑key</td></tr><tr><td>minyear</td><td>年代</td></tr><tr><td>maxyear</td><td></td></tr><tr><td>artist</td><td>艺术家</td></tr><tr><td>artist_id</td><td>艺术家id</td></tr><tr><td>artist_key</td><td>艺术家key</td></tr><tr><td>numsongs</td><td>歌曲数量</td></tr><tr><td>album_art</td></tr></tbody></table></div><h4 id="android-metadata：当前字符编码"><a href="#android-metadata：当前字符编码" class="headerlink" title="android_metadata：当前字符编码"></a>android_metadata：当前字符编码</h4><div class="table-container"><table><thead><tr><th>字段</th><th>解析</th></tr></thead><tbody><tr><td>locale</td><td>默认字符编码，例如 zh_CN</td></tr></tbody></table></div><h4 id="artists：艺术家"><a href="#artists：艺术家" class="headerlink" title="artists：艺术家"></a>artists：艺术家</h4><div class="table-container"><table><thead><tr><th>字段</th><th>解析</th></tr></thead><tbody><tr><td>artist_id</td><td>主键。艺术家 id</td></tr><tr><td>artist_key</td><td>全大写字母，用于字母索引</td></tr><tr><td>artist</td><td>艺术家</td></tr></tbody></table></div><h4 id="artist-info"><a href="#artist-info" class="headerlink" title="artist_info"></a>artist_info</h4><div class="table-container"><table><thead><tr><th>字段</th><th>解析</th></tr></thead><tbody><tr><td>_id</td><td>主键。映射 id</td></tr><tr><td>artist</td><td>艺术家</td></tr><tr><td>artist_key</td><td></td></tr><tr><td>number_of_albums</td><td></td></tr><tr><td>number_of_tracks</td></tr></tbody></table></div><h4 id="artists-albums-map"><a href="#artists-albums-map" class="headerlink" title="artists_albums_map"></a>artists_albums_map</h4><div class="table-container"><table><thead><tr><th>字段</th><th>解析</th></tr></thead><tbody><tr><td>artist_id</td><td></td></tr><tr><td>album_id</td></tr></tbody></table></div><h4 id="audio-genres：流派"><a href="#audio-genres：流派" class="headerlink" title="audio_genres：流派"></a>audio_genres：流派</h4><div class="table-container"><table><thead><tr><th>字段</th><th>解析</th></tr></thead><tbody><tr><td>_id</td><td>主键。流派 id</td></tr><tr><td>name</td><td>流派名称</td></tr></tbody></table></div><h4 id="audio-genres-map：音频流派映射"><a href="#audio-genres-map：音频流派映射" class="headerlink" title="audio_genres_map：音频流派映射"></a>audio_genres_map：音频流派映射</h4><div class="table-container"><table><thead><tr><th>字段</th><th>解析</th></tr></thead><tbody><tr><td>_id</td><td>主键。映射 id</td></tr><tr><td>audio_id</td><td>音频 id</td></tr><tr><td>genre_id</td><td>流派 id</td></tr></tbody></table></div><blockquote><p>为何要建立映射表：为了消除数据冗余。假如有大量音频属于同一流派，如果没有映射表则需要每个音频都需要记录同样的流派数据，有了映射表之后则只有一条记录就够了。这符合数据库设计的<a href="http://en.wikipedia.org/wiki/Third_normal_form" target="_blank" rel="noopener">第三范式（the 3rd normal form）</a></p></blockquote><h4 id="audio-meta：音频信息"><a href="#audio-meta：音频信息" class="headerlink" title="audio_meta：音频信息"></a>audio_meta：音频信息</h4><div class="table-container"><table><thead><tr><th>字段</th><th>解析</th></tr></thead><tbody><tr><td>_id</td><td>主键。音频 id</td></tr><tr><td>_data</td><td>文件绝对路径</td></tr><tr><td>_display_name</td><td>文件名</td></tr><tr><td>_size</td><td>文件大小，单位 byte</td></tr><tr><td>mime_type</td><td>类似于 audio/mpeg 的 MIME 类型</td></tr><tr><td>date_added</td><td>添加到数据库的时间，单位秒</td></tr><tr><td>is_drm</td><td>是否有drm版权</td></tr><tr><td>date_modified</td><td>文件最后修改时间，单位秒</td></tr><tr><td>title</td><td>来自 ID3 信息的标题，无则为不带扩展名的文件名</td></tr><tr><td>title_key</td><td>全大写字母的标题</td></tr><tr><td>duration</td><td>时长</td></tr><tr><td>artist_id</td><td>艺术家 id</td></tr><tr><td>composer</td><td>来自 ID3 信息，作曲家</td></tr><tr><td>album_id</td><td>专辑 id</td></tr><tr><td>track</td><td>来自 ID3 信息，音轨</td></tr><tr><td>year</td><td>来自 ID3 信息，年代</td></tr><tr><td>is_ringtone</td><td>是否铃声，0 或 1</td></tr><tr><td>is_music</td><td>是否音乐，1 才会在音乐播放器显示</td></tr><tr><td>is_alarm</td><td>是否闹钟铃声</td></tr><tr><td>is_notification</td><td>是否通知铃声</td></tr><tr><td>is_podcast</td><td>是否 podcast</td></tr><tr><td>bookmark</td><td></td></tr><tr><td>album_artist</td></tr></tbody></table></div><h4 id="audio-playlists：播放列表"><a href="#audio-playlists：播放列表" class="headerlink" title="audio_playlists：播放列表"></a>audio_playlists：播放列表</h4><div class="table-container"><table><thead><tr><th>字段</th><th>解析</th></tr></thead><tbody><tr><td>_id</td><td>主键。播放列表 id</td></tr><tr><td>_data</td><td></td></tr><tr><td>name</td><td>播放列表名</td></tr><tr><td>date_added</td><td></td></tr><tr><td>date_modified</td></tr></tbody></table></div><h4 id="audio-playlists-map：音频播放列表映射"><a href="#audio-playlists-map：音频播放列表映射" class="headerlink" title="audio_playlists_map：音频播放列表映射"></a>audio_playlists_map：音频播放列表映射</h4><div class="table-container"><table><thead><tr><th>字段</th><th>解析</th></tr></thead><tbody><tr><td>_id</td><td>主键。映射 id</td></tr><tr><td>audio_id</td><td>音频 id</td></tr><tr><td>playlist_id</td><td>播放列表 id</td></tr><tr><td>play_order</td><td>播放顺序</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Objective-C]用Block实现链式编程</title>
      <link href="/2016/06/30/%5BObjective-C%5DChain-programming-using-Block/"/>
      <url>/2016/06/30/%5BObjective-C%5DChain-programming-using-Block/</url>
      
        <content type="html"><![CDATA[<p>看这篇博客时<a href="http://www.jianshu.com/p/87ef6720a096#" target="_blank" rel="noopener">最快让你上手ReactiveCocoa之基础篇</a>看到作者介绍链式编程那一块，发现自己的钻研精神不足。想想自己使用链式编程也有段时间了，对，就是 Masonry 库。自己一直享受点语法带来的效率提升，却没想过自己去照着实现一下，真是惭愧。</p><p>好吧，本着发现问题就要立即解决问题的一贯原则，就看一看链式语法的实现方法。</p><p>现在做一个加减乘除计算。</p><p>在 Masonry 里，我们常用的添加约束的方法就是 <code>mas_makeConstraints:</code></p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">// View+MASAdditions- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *))block {    self.translatesAutoresizingMaskIntoConstraints = NO;    MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:self];    block(constraintMaker);    return [constraintMaker install];}</code></pre><p>在约束里，用到 left, right 等是 constraintMaker 的属性，最后设置参数，比如 offset() 是 MASConstraint 的方法：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">//MASConstraintMaker@property (nonatomic, strong, readonly) MASConstraint *left;- (MASConstraint *)left {    return [self addConstraintWithLayoutAttribute:NSLayoutAttributeLeft];}//MASConstraint- (MASConstraint * (^)(CGFloat offset))offset;- (MASConstraint * (^)(CGFloat))offset {    return ^id(CGFloat offset){        self.offset = offset;        return self;    };}</code></pre><p>所以源码大概的结构是这样。然后就要实现我们的计算器了。</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">//NSObject+Extension@implementation NSObject (Calculator)- (CGFloat)makeCalculators:(void (^)(CalculatorMaker *))block {    CalculatorMaker *mgr = [[CalculatorMaker alloc] init];    block(mgr);    return mgr.result;}@end//CalculatorMaker.h@interface CalculatorMaker : NSObject@property (nonatomic, assign) int result;- (CalculatorMaker *(^)(int)) add;- (CalculatorMaker *(^)(int)) sub;- (CalculatorMaker *(^)(int)) mul;- (CalculatorMaker *(^)(int)) div;@end//CalculatorMaker.m@implementation CalculatorMaker- (CalculatorMaker *(^)(int))add {    return ^CalculatorMaker *(int value) {        _result += value;        return self;    };}- (CalculatorMaker *(^)(int))sub {    return ^CalculatorMaker *(int value) {        _result -= value;        return self;    };}- (CalculatorMaker *(^)(int))mul {    return ^CalculatorMaker *(int value) {        _result *= value;        return self;    };}- (CalculatorMaker *(^)(int))div {    return ^CalculatorMaker *(int value) {        _result /= value;        return self;    };}@end//main.mint result = [NSObject makeCalculators:^(CalculatorMaker *make) {          make.add(1).add(5).mul(2);        }];//output 12</code></pre><p>看 add() 方法，返回类型是自身所在 CalculatorMaker 类型的 Block，而 Block 返回的也是 <code>self</code>，所以可以连续使用链式调用。不过关于为什么可以用点语法，这个我有点晕，按说 make.add 是 OC 语法，后面括号跑到 Block 里去。那对于 OC 语法来说，点语法是针对 getter 方法的，对于没有参数的非 getter 方法也可以调用，但调用时会报 warning ，所以这点不是很懂。</p><p>关于链式调用的写法，有点秀技术的感觉。视情况而用。不过，鉴于 Masonry 作者能写出这么有技巧的代码，我觉得有必要研究一下 Masonry 源码了。</p>]]></content>
      
      
      <categories>
          
          <category> Syntax </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Objective-C </tag>
            
            <tag> block </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[iOS]创建界面方法的讨论</title>
      <link href="/2016/06/29/%5BiOS%5DAbout-Creating-UI/"/>
      <url>/2016/06/29/%5BiOS%5DAbout-Creating-UI/</url>
      
        <content type="html"><![CDATA[<p>以前在入门的时候，找的入门书籍上编写的 demo 都是基于 Storyboards 拖界面的。后来接触公司项目，发现界面都是用纯代码去写复杂的 autoLayout 的。再然后，领导给我发了个 Masonry 库去看，依然是手写代码布局界面，但效率高了不少。工作一段时间，看了很多博客，也看了一些书，发现用纯代码写界面的很少，于是就在 Google 上搜 Storyboards 有什么好处，最后发现了一篇非常好的文章。在此提炼文章的一些观点，同时表达一下自己的观点。</p><p>文章链接：<a href="https://www.toptal.com/ios/ios-user-interfaces-storyboards-vs-nibs-vs-custom-code" target="_blank" rel="noopener">iOS User Interfaces: Storyboards vs. NIBs vs. Custom Code</a><br>文章介绍了三种构建界面的方法，并对不同方法分别讨论了优缺点。</p><p>其实对于这几种方法，没有最好，只有最适合。</p><blockquote><p>总结下来就是 Storyboards 是一个容易观察并且使用简单的 iOS UI 设计工具。它也消除了固定的创建控件的模板代码，但导致了很严重的灵活性的缺失。NIBs 对于 single view 来说提供了很大灵活性，但没有视觉流（个人猜测是 view controller 的切换）。灵活性最大的方案就是纯代码布局，但纯代码并不是那么直观，也没有那么容易。</p></blockquote><p>同样的话题，在唐巧的博客里，也讨论过这个问题：<a href="http://blog.devtang.com/2015/03/22/ios-dev-controversy-2/" target="_blank" rel="noopener">iOS 开发中的争议（二）</a></p><p>其中比较有说服力的一段是他分析了100多个 App 包含 xib 文件的个数，大概推测出很多著名的 App  里大部分界面都是手写来完成的。</p><p>同时他也提出了自己的建议：</p><ul><li>对于复杂的、动态生成的界面，建议使用手工编写界面。</li><li>对于需要统一风格的按钮或UI控件，建议使用手工用代码来构造。方便之后的修改和复用。</li><li>对于需要有继承或组合关系的 UIView 类或 UIViewController 类，建议用代码手工编写界面。</li><li>对于那些简单的、静态的、非核心功能界面，可以考虑使用 xib 或 storyboard 来完成。</li></ul><p>呐最后我个人也是偏好使用纯代码布局的，并不是因为我一直是这么做的，而是有以下原因：</p><ol><li>纯代码布局最让人诟病的就是代码量太大，的确，我之前用 autoLayout 的时候每写一个 constrains 就要好几行代码，一个控件有几个约束关系的话就要写几个 constrains，这个代码量一下就上去了。但现在有开源的 Masonry 库，对于 Swift 也有相应的库，所以对于代码量以及学习难度来讲，纯代码布局这部分的缺陷完全能够被弥补。</li><li>纯代码写的界面容易控制，这个容易控制是说，你每增加一个控件，一个约束在代码上就可以很直观的显示出来，因为每写一行代码你自己就会很清楚。而对于 Storyboards 来讲，控件的属性界面密密麻麻一大片，不管你改不改，那些数据都显示在那里，有时候你忘记改了哪些东西你都会在属性栏里一个一个去找。<strong>比如</strong>我把 view 的背景色从 <code>grayColor</code> 改成了 <code>lightGrayColor</code>，那我从代码上就可以很直观的看到这一句 view.backgroundColor = [UIColor lightGrayColor]，但如果在 Storyboards 里，我就要去找背景色这一栏，还要分辨出灰色和浅灰色。</li><li>最后，就是代码的复用。比如写一个复杂的 tableViewCell ，用 Storyboards 去拖界面的话，就会看到视图上面有一堆控件和布局，如果我想在哪天复用这个 cell 并做一些布局修改的话，便又要重新拖放，如果有响应事件的话，还要重新给新建的类连线，想想这个工作量，不出错都难。而对于手写界面来说，写一个控件就封装在一个类里面，需要复用了，继承一下或者复制粘贴到别的工程即可使用，就算有响应事件，写几个 protocol 做反馈就解决了。</li><li>最最后，我想起来以前上学搞 MFC 的时候，那时候也有关于手写界面还是拖界面的讨论，当时一个很有说服力的评论是，手写界面可以锻炼你对 MFC 程序的理解，可能你还是无法知道 MFC 的实现原理，但你会很熟悉 MFC 的实现过程（大概是这意思）。这一点我觉得在 iOS 上也适用。比如说按钮事件，用 Storyboards 就是鼠标一拖，连一条线出来，系统就生成了一段事件代码，而你只要填代码就可以。我觉得这对于学习 iOS 不是一件好事情，虽然说我现在也不是非常了解 iOS 底层的一些实现原理，但通过手写界面，手动添加事件，我知道这些东西是怎么添加的，添加的东西和其他类之间的关系是什么。所以手写界面对学习 iOS 还是有一些帮助的。</li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Storyboards </tag>
            
            <tag> Masonry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Objective-C]编程艺术 笔记</title>
      <link href="/2016/06/28/%5BObjective-C%5DArt-Of-Code/"/>
      <url>/2016/06/28/%5BObjective-C%5DArt-Of-Code/</url>
      
        <content type="html"><![CDATA[<blockquote><p>完整的介绍看这两个链接<br><a href="http://zh-google-styleguide.readthedocs.io/en/latest/google-objc-styleguide/contents/" target="_blank" rel="noopener">Google开源项目风格指南</a><br><a href="https://github.com/oa414/objc-zen-book-cn" target="_blank" rel="noopener">禅与 Objective-C 编程艺术 （Zen and the Art of the Objective-C Craftsmanship 中文翻译）</a></p></blockquote><p>本文的意义就是找出一些我自己平时不注意的知识点进行总结，同时提出一些自己的观点，然后自己没事看看总结，提高编码质量。</p><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><blockquote><p>条件语句体应该总是被大括号包围。</p></blockquote><p>我经常为了让代码看起来干净一些，所以对于条件语句体内只有一行代码的时候，我就会省去大括号以减少代码行数。<br>像这样：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">if (!error)    return success;//or    if (!error) return success;</code></pre><p>这样写很容易带来隐患，比如增加一行代码时，就容易对这行代码是在语句体内还是外产生误解导致错误。注释一行代码容易使后面一行代码成为语句体内的内容。</p><p>所以老老实实把代码写规范了：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">if (!error) {    return success;}</code></pre><h3 id="尤达表达式"><a href="#尤达表达式" class="headerlink" title="尤达表达式"></a>尤达表达式</h3><blockquote><p>星球大战中尤达大师的讲话方式，总是用倒装的语序</p></blockquote><p>文章不建议使用尤达表达式，即不要使用常量和变量比较的方式。</p><p>比如：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">if (5 == count) { ...//orif ([@42 isEqual:myValue]) { ...</code></pre><p>建议写成：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">if (count == 5) { ...//orif ([myValue isEqual:@42]) { ...</code></pre><p><strong>对于这一点，我有一些异议。</strong>因为对于第一种写法，写成<code>5 == count</code>可以避免把<code>==</code>写成<code>=</code>，如果按照不用尤达的写法，当我把比较写成赋值时<code>count = 5</code>，编译器是无法检测出我的失误的，而且对于这类失误，自己debug的时候也很难发现。而对于第二种写法使用<code>isEqual</code>方法就不存在这种问题。</p><p>所以这一点见仁见智吧。面对<code>if (5 == count)</code>这类条件语句，我还是偏向用尤达表达式的。</p><h3 id="nil-和-BOOL-的检查"><a href="#nil-和-BOOL-的检查" class="headerlink" title="nil 和 BOOL 的检查"></a>nil 和 BOOL 的检查</h3><blockquote><p>因为 <code>nil</code> 是 解释到 <code>NO</code>，所以没必要在条件语句里面把它和其他值比较。同时，不要直接把它和 <code>YES</code> 比较，因为 <code>YES</code> 的定义是 1， 而 <code>BOOL</code> 是 8 bit的，实际上是 <code>char</code> 类型。</p></blockquote><p>这一点很重要，不要在条件语句内出现<code>YES</code>或者<code>NO</code>，多使用非运算符。</p><p>不推荐：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">if (someObject == YES) { ... // Wrongif (myRawValue == YES) { ... // Never do this.if ([someObject boolValue] == NO) { ...</code></pre><p>推荐：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">if (someObject) { ...if (![someObject boolValue]) { ...if (!someObject) { ...</code></pre><h3 id="黄金大道"><a href="#黄金大道" class="headerlink" title="黄金大道"></a>黄金大道</h3><blockquote><p>在使用条件语句编程时，<strong>代码的左边距</strong>应该是一条“黄金”或者“快乐”的大道。</p></blockquote><p>也就是说，不要嵌套 <code>if</code> 语句。使用多个 return 可以避免增加循环的复杂度，并提高代码的可读性。</p><p>这一点我深有感触，在以往编码的时候，我都很耿直的把一些方法写到嵌套分支里。这样写的容易，但改代码逻辑的时候就麻烦了。</p><p>比如：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">- (void)someMethod {  if ([someOther boolValue]) {    //Do something important    // blablabla ...  }}</code></pre><p>这种情况下，一个是代码看起来很复杂，另一个是改逻辑的时候，blablabla的内容都要拷贝出来，放在新修改的逻辑中去。</p><p>所以直到有一次思考优化代码的时候，我才想起来用相反的逻辑去处理它，即使用 return。比如：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">- (void)someMethod {  if (![someOther boolValue]) {      return;  }  //Do something important}</code></pre><p>把逻辑判断单独择出来，处理代码就直接放在函数里。不符合逻辑的 return 掉，符合逻辑的直接就会运行到处理代码处。而且这样写代码层次很清晰。</p><h3 id="Case-语句"><a href="#Case-语句" class="headerlink" title="Case 语句"></a>Case 语句</h3><blockquote><p>除非编译器强制要求，括号在 case 语句里面是不必要的。但是当一个 case 包含了多行语句的时候，需要加上括号。</p></blockquote><p>个人经验，好像在 case 中创建实例的时候，编译器会提醒你要为这个 case 加上括号。</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">switch (condition) {    case 1:        // ...        break;    case 2: {        // ...        // Multi-line example using braces        break;       }    case 3:        // ...        break;    default:        // ...        break;}</code></pre><h3 id="常量使用、枚举和命名规范"><a href="#常量使用、枚举和命名规范" class="headerlink" title="常量使用、枚举和命名规范"></a>常量使用、枚举和命名规范</h3><p>见这篇博客：<a href="http://www.wossoneri.com/2016/05/19/[Objective-C]Create-Constants/" target="_blank" rel="noopener">Objective-C 常量和枚举</a></p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><blockquote><p>方法名与方法类型 (-/+ 符号)之间应该以空格间隔。方法段之间也应该以空格间隔（以符合 Apple 风格）。参数前应该总是有一个描述性的关键词。</p></blockquote><p>这里要注意的一点是尽量少用 and 这个词。我因为入门的时候看的书经常用 and ，感觉这样阅读起来比较连贯，所以也养成了写 and 的习惯。后来感觉加 and 的确不是很好。关于看书命名这一块推荐看一下 <code>Swift</code> 的函数命名，因为 <code>Swift</code> 设计的时候一部分考虑到了 OC 当前的设计思想，同时对旧设计思想有了一些优化。看完你就会有自己的一套理解了。</p><p>不推荐写法：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">- (void)setT:(NSString *)text i:(UIImage *)image;- (void)sendAction:(SEL)aSelector :(id)anObject :(BOOL)flag;- (id)taggedView:(NSInteger)tag;- (instancetype)initWithWidth:(CGFloat)width andHeight:(CGFloat)height;- (instancetype)initWith:(int)width and:(int)height;  // Never do this.</code></pre><p>推荐写法：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">- (void)setExampleText:(NSString *)text image:(UIImage *)image;- (void)sendAction:(SEL)aSelector to:(id)anObject forAllCells:(BOOL)flag;- (id)viewWithTag:(NSInteger)tag;- (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height;</code></pre><h3 id="美化代码"><a href="#美化代码" class="headerlink" title="美化代码"></a>美化代码</h3><h4 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h4><ul><li>缩进使用 4 个空格。 永远不要使用 tab。可以在 Xcode 中设置按 tab 插入 4 个空格。</li><li><strong>方法的大括号和其他的大括号(if/else/switch/while 等) 总是在同一行开始，在新起一行结束。</strong></li></ul><p>第一点就不说了，前段时间看文章说还有人用 3 个空格，8 个空格的。个人还是觉得 4 空格比较舒服。</p><p>第二点是要注意的，可能以前看的初级书都是这样写：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">if (user.isHappy){  //Do something} else {  //Do something else}</code></pre><p>但分开写的话代码层次关系会更明显：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">if (user.isHappy) {    //Do something}else {    //Do something else}</code></pre><ul><li>方法之间应该要有一个空行来帮助代码看起来清晰且有组织。 方法内的空格应该用来分离功能，但是通常不同的功能应该用新的方法来定义。</li><li>优先使用 auto-synthesis。但是如果必要的话， @synthesize and @dynamic</li><li>在实现文件中的声明应该新起一行。</li><li>应该总是让冒号对齐。有一些方法签名可能超过三个冒号，用冒号对齐可以让代码更具有可读性。即使有代码块存在，也应该用冒号对齐方法。</li></ul><p>这几点 Xcode 会帮你做一部分，比如说冒号对齐在 Xcode 里就是自动的。但还是注意一下吧。</p><p>不推荐：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">[UIView animateWithDuration:1.0 animations:^{    // something} completion:^(BOOL finished) {    // something}];</code></pre><p>推荐：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">[UIView animateWithDuration:1.0                 animations:^{                     // something                 }                 completion:^(BOOL finished) {                     // something                 }];</code></pre><h4 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h4><p>之前看过一个建议，就是一行代码保持在 80 个字符。<br>后来在不同的 IDE 下编码，发现不同的 IDE 在这一点上是一致的，就是可以设置一个字符长度的标志线，来提示代码长度。默认长度都是在 80 个字符。这个 Xcode 好像是默认不开启的，可以设置一下让那条线显示出来。</p><p>举例：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">self.productsRequest = [[SKProductsRequest alloc] initWithProductIdentifiers:productIdentifiers];</code></pre><p>一个像上面的长行的代码在第二行以一个间隔（2个空格）延续</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">self.productsRequest = [[SKProductsRequest alloc]  initWithProductIdentifiers:productIdentifiers];</code></pre><h4 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h4><p>在以下的地方使用 <a href="https://en.wikipedia.org/wiki/Indent_style#K.26R_style" target="_blank" rel="noopener">Egyptian风格 括号</a> （译者注：又称 K&amp;R 风格，代码段括号的开始位于一行的末尾，而不是另外起一行的风格。关于为什么叫做 Egyptian Brackets，可以参考 <a href="http://blog.codinghorror.com/new-programming-jargon/" target="_blank" rel="noopener">http://blog.codinghorror.com/new-programming-jargon/</a> )</p><ul><li>控制语句 (if-else, for, switch)</li></ul><p>非 Egyptian 括号可以用在：</p><ul><li>类的实现（如果存在)</li><li>方法的实现</li></ul><p>看完就不要纠结 Java 风格 or C++ 风格了…</p><p>未完…<br>很多内容在整理…</p>]]></content>
      
      
      <categories>
          
          <category> Syntax </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Objective-C] Copy 和 MutableCopy</title>
      <link href="/2016/06/04/%5BObjective-C%5DCopy-and-MutableCopy/"/>
      <url>/2016/06/04/%5BObjective-C%5DCopy-and-MutableCopy/</url>
      
        <content type="html"><![CDATA[<p>看了几篇文章，因为文章很新手向，所以内容很繁琐。故整理一下重点，写了测试程序去了解几个知识点，不讨论基本概念。</p><h3 id="非集合类对象的copy与mutableCopy"><a href="#非集合类对象的copy与mutableCopy" class="headerlink" title="非集合类对象的copy与mutableCopy"></a>非集合类对象的copy与mutableCopy</h3><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">      //NSString & NSMutableString      NSString *strA = @"origin";      NSLog(@"strA        pointer: %p content: %@", strA, strA);      NSString *strACopy = [strA copy];      NSLog(@"strCopy     pointer: %p content: %@", strACopy, strACopy);      NSMutableString *strAMCopy = [strA mutableCopy];      NSLog(@"strMCopy    pointer: %p content: %@", strAMCopy, strAMCopy);      NSMutableString *strB = [NSMutableString stringWithString:@"mutable string"];      NSLog(@"strB        pointer: %p content: %@", strB, strB);      NSMutableString *strBCopy = [strB copy];      NSLog(@"strBCopy    pointer: %p content: %@", strBCopy, strBCopy);      NSMutableString *strBMCopy = [strB mutableCopy];      NSLog(@"strBMCopy   pointer: %p content: %@", strBMCopy, strBMCopy);//输出strA        pointer: 0x100003180 content: originstrCopy     pointer: 0x100003180 content: originstrMCopy    pointer: 0x100102e90 content: originstrB        pointer: 0x100700510 content: mutable stringstrBCopy    pointer: 0x100700570 content: mutable stringstrBMCopy   pointer: 0x1006002c0 content: mutable string</code></pre><p>在非集合类对象中：对<code>immutable</code>对象进行<code>copy</code>操作，是指针复制，<code>mutableCopy</code>操作时内容复制；对<code>mutable</code>对象进行<code>copy</code>和<code>mutableCopy</code>都是内容复制。</p><p>结论</p><ul><li>[immutableObject copy] // 浅复制</li><li>[immutableObject mutableCopy] //深复制</li><li>[mutableObject copy] //深复制</li><li>[mutableObject mutableCopy] //深复制</li></ul><h3 id="集合类对象的copy与mutableCopy"><a href="#集合类对象的copy与mutableCopy" class="headerlink" title="集合类对象的copy与mutableCopy"></a>集合类对象的copy与mutableCopy</h3><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">      NSArray *arrayA = @[@[@"A", @"B"], @[@"C", @"D"]];      NSLog(@"arrayA      pointer:%p  contentA:%p contentB:%p", arrayA, arrayA[0], arrayA[1]);      NSArray *arrCopyA = [arrayA copy];      NSLog(@"arrCopyA    pointer:%p  contentA:%p contentB:%p", arrCopyA, arrCopyA[0], arrCopyA[1]);      NSMutableArray *arrMCopyA = [arrayA mutableCopy];      NSLog(@"arrMCopyA   pointer:%p  contentA:%p contentB:%p", arrMCopyA,arrMCopyA[0], arrMCopyA[1]);      NSMutableArray *arrayB = [NSMutableArray arrayWithObjects:@[@"A", @"B"], @[@"C", @"D"], nil];      NSLog(@"arrayB      pointer:%p  contentA:%p contentB:%p", arrayB, arrayB[0], arrayB[1]);      NSArray *arrCopyB = [arrayB copy];      NSLog(@"arrCopyB    pointer:%p  contentA:%p contentB:%p", arrCopyB, arrCopyB[0], arrCopyB[1]);      NSMutableArray *arrMCopyB = [arrayB mutableCopy];      NSLog(@"arrMCopyB   pointer:%p  contentA:%p contentB:%p", arrMCopyB,arrMCopyB[0], arrMCopyB[1]);//输出arrayA      pointer:0x100700860  contentA:0x100700840 contentB:0x1007007c0arrCopyA    pointer:0x100700860  contentA:0x100700840 contentB:0x1007007c0arrMCopyA   pointer:0x100700990  contentA:0x100700840 contentB:0x1007007c0arrayB      pointer:0x100701970  contentA:0x100700880 contentB:0x100701730arrCopyB    pointer:0x100102080  contentA:0x100700880 contentB:0x100701730arrMCopyB   pointer:0x100701ab0  contentA:0x100700880 contentB:0x100701730</code></pre><blockquote><p>可以看到拷贝过程和非集合类大体相同。注意一点，就是拷贝过程只是针对对象本身，而对象内部的元素还是指针复制，从上面打印的输出就可以看出来。</p></blockquote><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>看如下代码，有一个<code>mutable</code>数组，赋值给<code>immutable</code>数组</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec"> @property (nonatomic, copy) NSArray *array;  NSMutableArray *mArray = [NSMutableArray array];  [mArray addObject:@"AA"];  _array = mArray;  NSLog(@"mArray: %p, _array: %p", mArray, _array);  [mArray addObject:@"BB"];  NSLog(@"mArray = %@, _array = %@", mArray, _array);</code></pre><p><del>其中，直接对<code>array</code>属性赋值，这样，<code>_array</code>和<code>mArray</code>便是指向同一对象的指针，因为<code>NSMutableArray</code>是<code>NSArray</code>的子类，故<code>_array</code>能够接受<code>mArray</code>的值。</del></p><p>应该说是 <code>_array</code> 是一个指针，通过 <code>_array = mArray</code> 使两个指针指向同一个地方。</p><p>输出结果：</p><pre class=" language-lang-bash"><code class="language-lang-bash">mArray: 0x126ec3e00, _array: 0x126ec3e00mArray = (    AA,    BB), _array = (    AA,    BB)</code></pre><p>下面做个修改，把</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">_array = mArray;</code></pre><p>改为</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">_array = [mArray copy];</code></pre><p>想想结果如何？</p><p><code>mArray</code>是<code>mutable</code>对象，拷贝属于（不完全）深拷贝，所以可以想到<code>_array</code>的指针和<code>mArray</code>并不相同，所以后面<code>mArray</code>改变内容也与<code>_array</code>无关。</p><p>输出：</p><pre class=" language-lang-bash"><code class="language-lang-bash">mArray: 0x154dc8070, _array: 0x154dcf4e0mArray = (    AA,    BB), _array = (    AA)</code></pre><blockquote><p>Reference<br><a href="http://ios.jobbole.com/85008/" target="_blank" rel="noopener">小结 iOS 中的 copy</a><br><a href="http://ios.jobbole.com/84859" target="_blank" rel="noopener">iOS 集合的深复制与浅复制</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Syntax </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Objective-C </tag>
            
            <tag> copy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Objective-C]深入理解GCD</title>
      <link href="/2016/05/30/%5BObjective-C%5DGCD-in-depth/"/>
      <url>/2016/05/30/%5BObjective-C%5DGCD-in-depth/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是GCD"><a href="#什么是GCD" class="headerlink" title="什么是GCD"></a>什么是GCD</h3><p><code>GCD</code>(Grand Central Dispatch)是<code>libdispatch</code>的市场名称，而<code>libdispatch</code>作为Apple的一个库，为并发代码在多核硬件（跑 iOS 或 OS X ）上执行提供有力支持。它具有以下优点：</p><ol><li>GCD能通过推迟昂贵计算任务并在后台运行它们来改善你的应用的响应性能。</li><li>GCD提供一个易于使用的并发模型而不仅仅只是锁和线程，以帮助我们避开并发陷阱。</li><li>GCD具有在常见模式（例如单例）上用更高性能的原语优化你的代码的潜在能力。<br>本教程假设你对 <code>Block</code> 和 <code>GCD</code> 有基础了解。如果你对 <code>GCD</code> 完全陌生，先看看 <a href="http://www.raywenderlich.com/4295/multithreading-and-grand-central-dispatch-on-ios-for-beginners-tutorial" target="_blank" rel="noopener">iOS 上的多线程和 GCD 入门教程</a> 或者 <a href="http://www.wossoneri.com/2016/05/30/[iOS]Multithreading-and-GCD/" target="_blank" rel="noopener">iOS多线程和GCD</a>  学习其要领。</li></ol><h3 id="GCD术语"><a href="#GCD术语" class="headerlink" title="GCD术语"></a>GCD术语</h3><p>要理解 <code>GCD</code> ，你要先熟悉与线程和并发相关的几个概念。这两者都可能模糊和微妙，所以在开始 <code>GCD</code> 之前先简要地回顾一下它们。</p><h4 id="Serial串行-vs-Concurrent并发"><a href="#Serial串行-vs-Concurrent并发" class="headerlink" title="Serial串行 vs. Concurrent并发"></a>Serial串行 vs. Concurrent并发</h4><p>这些术语描述当任务相对于其它任务被执行，任务串行执行就是每次只有一个任务被执行，任务并发执行就是在同一时间可以有多个任务被执行。</p><p>虽然这些术语被广泛使用，本教程中你可以将任务设定为一个 <code>Objective-C</code> 的 <code>Block</code> 。不明白什么是 <code>Block</code> ？<a href="http://www.raywenderlich.com/9328/creating-a-diner-app-using-blocks-part-1" target="_blank" rel="noopener">看看 iOS 5 教程中的如何使用 Block</a> 。实际上，你也可以在 <code>GCD</code> 上使用函数指针，但在大多数场景中，这实际上更难于使用。Block 就是更加容易些！</p><h4 id="Synchronous同步-vs-Asynchronous异步"><a href="#Synchronous同步-vs-Asynchronous异步" class="headerlink" title="Synchronous同步 vs. Asynchronous异步"></a>Synchronous同步 vs. Asynchronous异步</h4><p>在 <code>GCD</code> 中，这些术语描述当一个函数相对于另一个任务完成，此任务是该函数要求 <code>GCD</code> 执行的。一个同步函数只在完成了它预定的任务后才返回。</p><p>一个异步函数，刚好相反，会立即返回，预定的任务会完成但不会等它完成。因此，一个异步函数不会阻塞当前线程去执行下一个函数。</p><h4 id="Critical-Section-临界区"><a href="#Critical-Section-临界区" class="headerlink" title="Critical Section 临界区"></a>Critical Section 临界区</h4><p>就是一段代码不能被并发执行，也就是，两个线程不能同时执行这段代码。这很常见，因为代码去操作一个共享资源，例如一个变量若能被并发进程访问，那么它很可能会变质。</p><h4 id="Race-Condition-竞态条件"><a href="#Race-Condition-竞态条件" class="headerlink" title="Race Condition 竞态条件"></a>Race Condition 竞态条件</h4><p>这种状况是指基于特定序列或时机的事件的软件系统以不受控制的方式运行的行为，例如程序的并发任务执行的确切顺序。竞态条件可导致无法预测的行为，而不能通过代码检查立即发现。</p><h4 id="Deadlock-死锁"><a href="#Deadlock-死锁" class="headerlink" title="Deadlock 死锁"></a>Deadlock 死锁</h4><p>两个（有时更多）东西——在大多数情况下，是线程——所谓的死锁是指它们都卡住了，并等待对方完成或执行其它操作。第一个不能完成是因为它在等待第二个的完成。但第二个也不能完成，因为它在等待第一个的完成。</p><h4 id="Thread-Safe-线程安全"><a href="#Thread-Safe-线程安全" class="headerlink" title="Thread Safe 线程安全"></a>Thread Safe 线程安全</h4><p>线程安全的代码能在多线程或并发任务中被安全的调用，而不会导致任何问题（数据损坏，崩溃，等）。线程不安全的代码在某个时刻只能在一个上下文中运行。一个线程安全代码的例子是 <code>NSDictionary</code> 。你可以在同一时间在多个线程中使用它而不会有问题。另一方面，<code>NSMutableDictionary</code> 就不是线程安全的，应该保证一次只能有一个线程访问它。</p><h4 id="Context-Switch-上下文切换"><a href="#Context-Switch-上下文切换" class="headerlink" title="Context Switch 上下文切换"></a>Context Switch 上下文切换</h4><p>一个上下文切换指当你在单个进程里切换执行不同的线程时存储与恢复执行状态的过程。这个过程在编写多任务应用时很普遍，但会带来一些额外的开销。</p><h4 id="Concurrency并发-vs-Parallelism并行"><a href="#Concurrency并发-vs-Parallelism并行" class="headerlink" title="Concurrency并发 vs Parallelism并行"></a>Concurrency并发 vs Parallelism并行</h4><p>并发和并行通常被一起提到，所以值得花些时间解释它们之间的区别。<br>并发代码的不同部分可以“同步”执行。然而，该怎样发生或是否发生都取决于系统。多核设备通过并行来同时执行多个线程；然而，为了使单核设备也能实现这一点，它们必须先运行一个线程，执行一个上下文切换，然后运行另一个线程或进程。这通常发生地足够快以致给我们并发执行地错觉，如下图所示： </p><p><img src="https://cdn3.raywenderlich.com/wp-content/uploads/2014/01/Concurrency_vs_Parallelism.png" alt></p><p>虽然你可以编写代码在 GCD 下并发执行，但 GCD 会决定有多少并行的需求。并行要求并发，但并发并不能保证并行。</p><p>更深入的观点是并发实际上是关于构造。当你在脑海中用 <code>GCD</code> 编写代码，你组织你的代码来暴露能同时运行的多个工作片段，以及不能同时运行的那些。如果你想深入此主题，看看 <a href="http://vimeo.com/49718712" target="_blank" rel="noopener">this excellent talk by Rob Pike</a> 。</p><h4 id="Queues-队列"><a href="#Queues-队列" class="headerlink" title="Queues 队列"></a>Queues 队列</h4><p><code>GCD</code> 提供有 dispatch queues 来处理代码块，这些队列管理你提供给 <code>GCD</code> 的任务并用 <code>FIFO</code> 顺序执行这些任务。这就保证了第一个被添加到队列里的任务会是队列中第一个开始的任务，而第二个被添加的任务将第二个开始，如此直到队列的终点。</p><p>所有的调度队列（dispatch queues）自身都是线程安全的，你能从多个线程并行的访问它们。 <code>GCD</code> 的优点是显而易见的，即当你了解了调度队列如何为你自己代码的不同部分提供线程安全。关于这一点的关键是选择正确类型的调度队列和正确的调度函数来提交你的工作。</p><p>在本节你会看到两种调度队列，都是由 <code>GCD</code> 提供的，然后看一些描述如何用调度函数添加工作到队列的列子。</p><h5 id="Serial-Queues-串行队列"><a href="#Serial-Queues-串行队列" class="headerlink" title="Serial Queues 串行队列"></a>Serial Queues 串行队列</h5><p><img src="https://cdn2.raywenderlich.com/wp-content/uploads/2014/01/Serial-Queue-480x272.png" alt><br>这些任务的执行时机受到 <code>GCD</code> 的控制；唯一能确保的事情是 <code>GCD</code> 一次只执行一个任务，并且按照我们添加到队列的顺序来执行。</p><p>由于在串行队列中不会有两个任务并发运行，因此不会出现同时访问临界区的风险；相对于这些任务来说，这就从竞态条件下保护了临界区。所以如果访问临界区的唯一方式是通过提交到调度队列的任务，那么你就不需要担心临界区的安全问题了。</p><h5 id="Concurrent-Queues-并发队列"><a href="#Concurrent-Queues-并发队列" class="headerlink" title="Concurrent Queues 并发队列"></a>Concurrent Queues 并发队列</h5><p>在并发队列中的任务能得到的保证是它们会按照被添加的顺序开始执行，但这就是全部的保证了。任务可能以任意顺序完成，你不会知道何时开始运行下一个任务，或者任意时刻有多少 <code>Block</code> 在运行。再说一遍，这完全取决于 <code>GCD</code> 。</p><p>下图展示了一个示例任务执行计划，<code>GCD</code> 管理着四个并发任务： </p><p><img src="https://cdn1.raywenderlich.com/wp-content/uploads/2014/01/Concurrent-Queue-480x272.png" alt></p><p>注意 Block 1,2 和 3 都立马开始运行，一个接一个。在 Block 0 开始后，Block 1等待了好一会儿才开始。同样， Block 3 在 Block 2 之后才开始，但它先于 Block 2 完成。</p><p>何时开始一个 <code>Block</code> 完全取决于 <code>GCD</code> 。如果一个 <code>Block</code> 的执行时间与另一个重叠，也是由 <code>GCD</code> 来决定是否将其运行在另一个不同的核心上，如果那个核心可用，否则就用上下文切换的方式来执行不同的 <code>Block</code> 。</p><p>有趣的是， <code>GCD</code> 提供给你至少五个特定的队列，可根据队列类型选择使用。</p><h4 id="Queue-Types-队列类型"><a href="#Queue-Types-队列类型" class="headerlink" title="Queue Types 队列类型"></a>Queue Types 队列类型</h4><p>首先，系统提供给你一个叫做 主队列（main queue） 的特殊队列。和其它串行队列一样，这个队列中的任务一次只能执行一个。然而，它能保证所有的任务都在主线程执行，而主线程是唯一可用于更新 UI 的线程。这个队列就是用于发生消息给 <code>UIView</code> 或发送通知的。</p><p>系统同时提供给你好几个并发队列。它们叫做 全局调度队列（Global Dispatch Queues） 。目前的四个全局队列有着不同的优先级：background、low、default 以及 high。要知道，Apple 的 API 也会使用这些队列，所以你添加的任何任务都不会是这些队列中唯一的任务。</p><p>最后，你也可以创建自己的串行队列或并发队列。这就是说，至少有五个队列任你处置：主队列、四个全局调度队列，再加上任何你自己创建的队列。</p><p>以上是调度队列的大框架！</p><p><code>GCD</code> 的“艺术”归结为选择合适的队列来调度函数以提交你的工作。体验这一点的最好方式是走一遍下边的列子，我们沿途会提供一些一般性的建议。</p><h3 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h3><p>既然本教程的目标是优化且安全的使用 GCD 调用来自不同线程的代码，那么你将从一个近乎完成的叫做 GooglyPuff 的项目入手。</p><p>GooglyPuff 是一个没有优化，线程不安全的应用，它使用 Core Image 的人脸检测 API 来覆盖一对曲棍球眼睛到被检测到的人脸上。对于基本的图像，可以从相机胶卷选择，或用预设好的URL从互联网下载。<br><a href="http://cdn4.raywenderlich.com/wp-content/uploads/2014/01/GooglyPuff_Start_1.zip" target="_blank" rel="noopener">项目地址</a><br>完成项目下载之后，将其解压到某个方便的目录，再用 Xcode 打开它并编译运行。这个应用看起来如下图所示：<br><img src="https://cdn1.raywenderlich.com/wp-content/uploads/2014/01/Workflow1.png" alt><br>注意当你选择 Le Internet 选项下载图片时，一个 UIAlertView 过早地弹出。你将在本系列教程地第二部分修复这个问题。</p><p>这个项目中有四个有趣的类：</p><ol><li>PhotoCollectionViewController：它是应用开始的第一个视图控制器。它用缩略图展示所有选定的照片。</li><li>PhotoDetailViewController：它执行添加曲棍球眼睛到图像上的逻辑，并用一个 UIScrollView 来显示结果图片。</li><li>Photo：这是一个类簇，它根据一个 NSURL 的实例或一个 ALAsset 的实例来实例化照片。这个类提供一个图像、缩略图以及从 URL 下载的状态。</li><li>PhotoManager：它管理所有 Photo 的实例.</li></ol><h3 id="用-dispatch-async-处理后台任务"><a href="#用-dispatch-async-处理后台任务" class="headerlink" title="用 dispatch_async 处理后台任务"></a>用 dispatch_async 处理后台任务</h3><p>回到应用并从你的相机胶卷添加一些照片或使用 Le Internet 选项下载一些。</p><p>注意在按下 PhotoCollectionViewController 中的一个 UICollectionViewCell 到生成一个新的 PhotoDetailViewController 之间花了多久时间；你会注意到一个明显的滞后，特别是在比较慢的设备上查看很大的图。</p><p>在重载 UIViewController 的 viewDidLoad 时容易加入太多杂波（too much clutter），这通常会引起视图控制器出现前更长的等待。如果可能，最好是卸下一些工作放到后台，如果它们不是绝对必须要运行在加载时间里。</p><p>这听起来像是 dispatch_async 能做的事情！</p><p>打开 PhotoDetailViewController 并用下面的实现替换 viewDidLoad ：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">- (void)viewDidLoad {        [super viewDidLoad];     NSAssert(_image, @"Image not set; required to use view controller");     self.photoImageView.image = _image;     //Resize if neccessary to ensure it's not pixelated     if (_image.size.height <= self.photoImageView.bounds.size.height &&         _image.size.width <= self.photoImageView.bounds.size.width) {         [self.photoImageView setContentMode:UIViewContentModeCenter];     }     dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{ // 1         UIImage *overlayImage = [self faceOverlayImageFromImage:_image];         dispatch_async(dispatch_get_main_queue(), ^{ // 2             [self fadeInNewImage:overlayImage]; // 3         });     }); }</code></pre><p>下面来说明上面的新代码所做的事：</p><ol><li>你首先将工作从主线程移到全局线程。因为这是一个 dispatch_async() ，Block 会被异步地提交，意味着调用线程地执行将会继续。这就使得 viewDidLoad 更早地在主线程完成，让加载过程感觉起来更加快速。同时，一个人脸检测过程会启动并将在稍后完成。</li><li>在这里，人脸检测过程完成，并生成了一个新的图像。既然你要使用此新图像更新你的 UIImageView ，那么你就添加一个新的 Block 到主线程。记住——你必须总是在主线程访问 UIKit 的类。</li><li>最后，你用 fadeInNewImage: 更新 UI ，它执行一个淡入过程切换到新的曲棍球眼睛图像。<br>编译并运行你的应用；选择一个图像然后你会注意到视图控制器加载明显变快，曲棍球眼睛稍微在之后就加上了。这给应用带来了不错的效果，和之前的显示差别巨大。</li></ol><p>进一步，如果你试着加载一个超大的图像，应用不会在加载视图控制器上“挂住”，这就使得应用具有很好伸缩性。</p><p>正如之前提到的， dispatch_async 添加一个 Block 都队列就立即返回了。任务会在之后由 GCD 决定执行。当你需要在后台执行一个基于网络或 CPU 紧张的任务时就使用 dispatch_async ，这样就不会阻塞当前线程。</p><p>下面是一个关于在 dispatch_async 上如何以及何时使用不同的队列类型的快速指导：</p><ol><li>自定义串行队列：当你想串行执行后台任务并追踪它时就是一个好选择。这消除了资源争用，因为你知道一次只有一个任务在执行。注意若你需要来自某个方法的数据，你必须内联另一个 Block 来找回它或考虑使用 dispatch_sync。</li><li>主队列（串行）：这是在一个并发队列上完成任务后更新 UI 的共同选择。要这样做，你将在一个 Block 内部编写另一个 Block 。以及，如果你在主队列调用 dispatch_async 到主队列，你能确保这个新任务将在当前方法完成后的某个时间执行。</li><li>并发队列：这是在后台执行非 UI 工作的共同选择。</li></ol><h3 id="使用-dispatch-after-延后工作"><a href="#使用-dispatch-after-延后工作" class="headerlink" title="使用 dispatch_after 延后工作"></a>使用 dispatch_after 延后工作</h3><p>稍微考虑一下应用的 UX 。是否用户第一次打开应用时会困惑于不知道做什么？你是这样吗？ :]</p><p>如果用户的 PhotoManager 里还没有任何照片，那么显示一个提示会是个好主意！然而，你同样要考虑用户的眼睛会如何在主屏幕上浏览：如果你太快的显示一个提示，他们的眼睛还徘徊在视图的其它部分上，他们很可能会错过它。</p><p>显示提示之前延迟一秒钟就足够捕捉到用户的注意，他们此时已经第一次看过了应用。</p><p>添加如下代码到到 PhotoCollectionViewController.m 中 showOrHideNavPrompt 的废止实现里：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">- (void)showOrHideNavPrompt {     NSUInteger count = [[PhotoManager sharedManager] photos].count;     double delayInSeconds = 1.0;     dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC)); // 1      dispatch_after(popTime, dispatch_get_main_queue(), ^(void){ // 2          if (!count) {             [self.navigationItem setPrompt:@"Add photos with faces to Googlyify them!"];         } else {             [self.navigationItem setPrompt:nil];         }     }); }</code></pre><p>showOrHideNavPrompt 在 viewDidLoad 中执行，以及 UICollectionView 被重新加载的任何时候。按照注释数字顺序看看：</p><ol><li>你声明了一个变量指定要延迟的时长。</li><li>然后等待 delayInSeconds 给定的时长，再异步地添加一个 Block 到主线程。</li></ol><p>编译并运行应用。应该有一个轻微地延迟，这有助于抓住用户的注意力并展示所要做的事情。</p><p>dispatch_after 工作起来就像一个延迟版的 dispatch_async 。你依然不能控制实际的执行时间，且一旦 dispatch_after 返回也就不能再取消它。</p><p>不知道何时适合使用 dispatch_after ？</p><ol><li>自定义串行队列：在一个自定义串行队列上使用 dispatch_after 要小心。你最好坚持使用主队列。</li><li>主队列（串行）：是使用 dispatch_after 的好选择；Xcode 提供了一个不错的自动完成模版。</li><li>并发队列：在并发队列上使用 dispatch_after 也要小心；你会这样做就比较罕见。还是在主队列做这些操作吧。</li></ol><h3 id="让你的单例线程安全"><a href="#让你的单例线程安全" class="headerlink" title="让你的单例线程安全"></a>让你的单例线程安全</h3><p>单例，不论喜欢还是讨厌，它们在 iOS 上的流行情况就像网上的猫。 :]</p><p>一个常见的担忧是它们常常不是线程安全的。这个担忧十分合理，基于它们的用途：单例常常被多个控制器同时访问。</p><p>单例的线程担忧范围从初始化开始，到信息的读和写。PhotoManager 类被实现为单例——它在目前的状态下就会被这些问题所困扰。要看看事情如何很快地失去控制，你将在单例实例上创建一个控制好的竞态条件。</p><p>导航到 PhotoManager.m 并找到 sharedManager ；它看起来如下：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">+ (instancetype)sharedManager     {     static PhotoManager *sharedPhotoManager = nil;     if (!sharedPhotoManager) {         sharedPhotoManager = [[PhotoManager alloc] init];         sharedPhotoManager->_photosArray = [NSMutableArray array];     }     return sharedPhotoManager; }</code></pre><p>当前状态下，代码相当简单；你创建了一个单例并初始化一个叫做 photosArray 的 NSMutableArray 属性。</p><p>然而，if 条件分支不是线程安全的；如果你多次调用这个方法，有一个可能性是在某个线程（就叫它线程A）上进入 if 语句块并可能在 sharedPhotoManager 被分配内存前发生一个上下文切换。然后另一个线程（线程B）可能进入 if ，分配单例实例的内存，然后退出。</p><p>当系统上下文切换回线程A，你会分配另外一个单例实例的内存，然后退出。在那个时间点，你有了两个单例的实例——很明显这不是你想要的（译者注：这还能叫单例吗？）！</p><p>要强制这个（竞态）条件发生，替换 PhotoManager.m 中的 sharedManager 为下面的实现：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">+ (instancetype)sharedManager   {     static PhotoManager *sharedPhotoManager = nil;     if (!sharedPhotoManager) {         [NSThread sleepForTimeInterval:2];         sharedPhotoManager = [[PhotoManager alloc] init];         NSLog(@"Singleton has memory address at: %@", sharedPhotoManager);         [NSThread sleepForTimeInterval:2];         sharedPhotoManager->_photosArray = [NSMutableArray array];     }     return sharedPhotoManager; }</code></pre><p>上面的代码中你用 NSThread 的 sleepForTimeInterval: 类方法来强制发生一个上下文切换。</p><p>打开 AppDelegate.m 并添加如下代码到 application:didFinishLaunchingWithOptions: 的最开始处：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{     [PhotoManager sharedManager]; }); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{     [PhotoManager sharedManager]; });</code></pre><p>这里创建了多个异步并发调用来实例化单例，然后引发上面描述的竞态条件。</p><p>编译并运行项目；查看控制台输出，你会看到多个单例被实例化，如下所示：<br><img src="http://www.raywenderlich.com/wp-content/uploads/2014/01/NSLog-Race-Condition.png" alt><br>注意到这里有好几行显示着不同地址的单例实例。这明显违背了单例的目的，对吧？</p><p>这个输出向你展示了临界区被执行多次，而它只应该执行一次。现在，固然是你自己强制这样的状况发生，但你可以想像一下这个状况会怎样在无意间发生。</p><p>注意：基于其它你无法控制的系统事件，NSLog 的数量有时会显示多个。线程问题极其难以调试，因为它们往往难以重现。<br>要纠正这个状况，实例化代码应该只执行一次，并阻塞其它实例在 if 条件的临界区运行。这刚好就是 dispatch_once 能做的事。</p><p>在单例初始化方法中用 dispatch_once 取代 if 条件判断，如下所示：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">+ (instancetype)sharedManager {     static PhotoManager *sharedPhotoManager = nil;     static dispatch_once_t onceToken;     dispatch_once(&onceToken, ^{         [NSThread sleepForTimeInterval:2];         sharedPhotoManager = [[PhotoManager alloc] init];         NSLog(@"Singleton has memory address at: %@", sharedPhotoManager);         [NSThread sleepForTimeInterval:2];         sharedPhotoManager->_photosArray = [NSMutableArray array];     });     return sharedPhotoManager; }</code></pre><p>编译并运行你的应用；查看控制台输出，你会看到有且仅有一个单例的实例——这就是你对单例的期望！:]</p><p>现在你已经明白了防止竞态条件的重要性，从 AppDelegate.m 中移除 dispatch_async 语句，并用下面的实现替换 PhotoManager 单例的初始化：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">+ (instancetype)sharedManager {     static PhotoManager *sharedPhotoManager = nil;     static dispatch_once_t onceToken;     dispatch_once(&onceToken, ^{         sharedPhotoManager = [[PhotoManager alloc] init];         sharedPhotoManager->_photosArray = [NSMutableArray array];     });     return sharedPhotoManager; }</code></pre><p>dispatch_once() 以线程安全的方式执行且仅执行其代码块一次。试图访问临界区（即传递给 dispatch_once 的代码）的不同的线程会在临界区已有一个线程的情况下被阻塞，直到临界区完成为止。<br><img src="https://cdn1.raywenderlich.com/wp-content/uploads/2014/01/Highlander_dispatch_once-480x274.png" alt><br>需要记住的是，这只是让访问共享实例线程安全。它绝对没有让类本身线程安全。类中可能还有其它竞态条件，例如任何操纵内部数据的情况。这些需要用其它方式来保证线程安全，例如同步访问数据，你将在下面几个小节看到。</p><h3 id="处理读者与写者问题"><a href="#处理读者与写者问题" class="headerlink" title="处理读者与写者问题"></a>处理读者与写者问题</h3><p>线程安全实例不是处理单例时的唯一问题。如果单例属性表示一个可变对象，那么你就需要考虑是否那个对象自身线程安全。</p><p>如果问题中的这个对象是一个 Foundation 容器类，那么答案是——“很可能不安全”！Apple 维护一个有用且有些心寒的列表，众多的 Foundation 类都不是线程安全的。 NSMutableArray，已用于你的单例，正在那个列表里休息。</p><p>虽然许多线程可以同时读取 NSMutableArray 的一个实例而不会产生问题，但当一个线程正在读取时让另外一个线程修改数组就是不安全的。你的单例在目前的状况下不能预防这种情况的发生。</p><p>要分析这个问题，看看 PhotoManager.m 中的 addPhoto:，转载如下：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">- (void)addPhoto:(Photo *)photo {     if (photo) {         [_photosArray addObject:photo];         dispatch_async(dispatch_get_main_queue(), ^{             [self postContentAddedNotification];         });     } }</code></pre><p>这是一个写方法，它修改一个私有可变数组对象。<br>现在看看 photos ，转载如下： </p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">- (NSArray *)photos {   return [NSArray arrayWithArray:_photosArray]; }</code></pre><p>这是所谓的读方法，它读取可变数组。它为调用者生成一个不可变的拷贝，防止调用者不当地改变数组，但这不能提供任何保护来对抗当一个线程调用读方法 photos 的同时另一个线程调用写方法 addPhoto: 。</p><p>这就是软件开发中经典的读者写者问题。GCD 通过用 dispatch barriers 创建一个读者写者锁 提供了一个优雅的解决方案。</p><p>Dispatch barriers 是一组函数，在并发队列上工作时扮演一个串行式的瓶颈。使用 GCD 的障碍（barrier）API 确保提交的 Block 在那个特定时间上是指定队列上唯一被执行的条目。这就意味着所有的先于调度障碍提交到队列的条目必能在这个 Block 执行前完成。</p><p>当这个 Block 的时机到达，调度障碍执行这个 Block 并确保在那个时间里队列不会执行任何其它 Block 。一旦完成，队列就返回到它默认的实现状态。 GCD 提供了同步和异步两种障碍函数。</p><p>下图显示了障碍函数对多个异步队列的影响：<br><img src="http://www.raywenderlich.com/wp-content/uploads/2014/01/Dispatch-Barrier.png" alt><br>注意到正常部分的操作就如同一个正常的并发队列。但当障碍执行时，它本质上就如同一个串行队列。也就是，障碍是唯一在执行的事物。在障碍完成后，队列回到一个正常并发队列的样子。</p><p>下面是你何时会——和不会——使用障碍函数的情况：</p><ol><li>自定义串行队列：一个很坏的选择；障碍不会有任何帮助，因为不管怎样，一个串行队列一次都只执行一个操作。</li><li>全局并发队列：要小心；这可能不是最好的主意，因为其它系统可能在使用队列而且你不能垄断它们只为你自己的目的。</li><li>自定义并发队列：这对于原子或临界区代码来说是极佳的选择。任何你在设置或实例化的需要线程安全的事物都是使用障碍的最佳候选。</li></ol><p>由于上面唯一像样的选择是自定义并发队列，你将创建一个你自己的队列去处理你的障碍函数并分开读和写函数。且这个并发队列将允许多个多操作同时进行。</p><p>打开 PhotoManager.m，添加如下私有属性到类扩展中：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">@interface PhotoManager () @property (nonatomic,strong,readonly) NSMutableArray *photosArray; @property (nonatomic, strong) dispatch_queue_t concurrentPhotoQueue; ///< Add this @end</code></pre><p>找到 addPhoto: 并用下面的实现替换它：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">- (void)addPhoto:(Photo *)photo {     if (photo) { // 1         dispatch_barrier_async(self.concurrentPhotoQueue, ^{ // 2              [_photosArray addObject:photo]; // 3             dispatch_async(dispatch_get_main_queue(), ^{ // 4                 [self postContentAddedNotification];              });         });     } }</code></pre><p>你新写的函数是这样工作的：</p><ol><li>在执行下面所有的工作前检查是否有合法的相片。</li><li>添加写操作到你的自定义队列。当临界区在稍后执行时，这将是你队列中唯一执行的条目。</li><li>这是添加对象到数组的实际代码。由于它是一个障碍 Block ，这个 Block 永远不会同时和其它 Block 一起在 concurrentPhotoQueue 中执行。</li><li>最后你发送一个通知说明完成了添加图片。这个通知将在主线程被发送因为它将会做一些 UI 工作，所以在此为了通知，你异步地调度另一个任务到主线程。<br>这就处理了写操作，但你还需要实现 photos 读方法并实例化 concurrentPhotoQueue 。</li></ol><p>在写者打扰的情况下，要确保线程安全，你需要在 concurrentPhotoQueue 队列上执行读操作。既然你需要从函数返回，你就不能异步调度到队列，因为那样在读者函数返回之前不一定运行。</p><p>在这种情况下，dispatch_sync 就是一个绝好的候选。</p><p>dispatch_sync() 同步地提交工作并在返回前等待它完成。使用 dispatch_sync 跟踪你的调度障碍工作，或者当你需要等待操作完成后才能使用 Block 处理过的数据。如果你使用第二种情况做事，你将不时看到一个 __block 变量写在 dispatch_sync 范围之外，以便返回时在 dispatch_sync 使用处理过的对象。</p><p>但你需要很小心。想像如果你调用 dispatch_sync 并放在你已运行着的当前队列。这会导致死锁，因为调用会一直等待直到 Block 完成，但 Block 不能完成（它甚至不会开始！），直到当前已经存在的任务完成，而当前任务无法完成！这将迫使你自觉于你正从哪个队列调用——以及你正在传递进入哪个队列。</p><p>下面是一个快速总览，关于在何时以及何处使用 dispatch_sync ：</p><ol><li>自定义串行队列：在这个状况下要非常小心！如果你正运行在一个队列并调用 dispatch_sync 放在同一个队列，那你就百分百地创建了一个死锁。</li><li>主队列（串行）：同上面的理由一样，必须非常小心！这个状况同样有潜在的导致死锁的情况。</li><li>并发队列：这才是做同步工作的好选择，不论是通过调度障碍，或者需要等待一个任务完成才能执行进一步处理的情况。</li></ol><p>继续在 PhotoManager.m 上工作，用下面的实现替换 photos ：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">- (NSArray *)photos {     __block NSArray *array; // 1     dispatch_sync(self.concurrentPhotoQueue, ^{ // 2         array = [NSArray arrayWithArray:_photosArray]; // 3     });     return array; }</code></pre><p>这就是你的读函数。按顺序看看编过号的注释，有这些：</p><ol><li>__block 关键字允许对象在 Block 内可变。没有它，array 在 Block 内部就只是只读的，你的代码甚至不能通过编译。</li><li>在 concurrentPhotoQueue 上同步调度来执行读操作。</li><li>将相片数组存储在 array 内并返回它。</li></ol><p>最后，你需要实例化你的 concurrentPhotoQueue 属性。修改 sharedManager 以便像下面这样初始化队列：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">+ (instancetype)sharedManager {     static PhotoManager *sharedPhotoManager = nil;     static dispatch_once_t onceToken;     dispatch_once(&onceToken, ^{         sharedPhotoManager = [[PhotoManager alloc] init];         sharedPhotoManager->_photosArray = [NSMutableArray array];         // ADD THIS:         sharedPhotoManager->_concurrentPhotoQueue = dispatch_queue_create("com.selander.GooglyPuff.photoQueue",                                                     DISPATCH_QUEUE_CONCURRENT);      });     return sharedPhotoManager; }</code></pre><p>这里使用 dispatch_queue_create 初始化 concurrentPhotoQueue 为一个并发队列。第一个参数是反向DNS样式命名惯例；确保它是描述性的，将有助于调试。第二个参数指定你的队列是串行还是并发。</p><p>注意：当你在网上搜索例子时，你会经常看人们传递 0 或者 NULL 给 dispatch_queue_create 的第二个参数。这是一个创建串行队列的过时方式；明确你的参数总是更好。<br>恭喜——你的 PhotoManager 单例现在是线程安全的了。不论你在何处或怎样读或写你的照片，你都有这样的自信，即它将以安全的方式完成，不会出现任何惊吓。</p><h3 id="A-Visual-Review-of-Queueing-队列的虚拟回顾"><a href="#A-Visual-Review-of-Queueing-队列的虚拟回顾" class="headerlink" title="A Visual Review of Queueing 队列的虚拟回顾"></a>A Visual Review of Queueing 队列的虚拟回顾</h3><p>依然没有 100% 地掌握 GCD 的要领？确保你可以使用 GCD 函数轻松地创建简单的例子，使用断点和 NSLog 语句保证自己明白当下发生的情况。</p><p>我在下面提供了两个 GIF动画来帮助你巩固对 dispatch_async 和 dispatch_sync 的理解。包含在每个 GIF 中的代码可以提供视觉辅助；仔细注意 GIF 左边显示代码断点的每一步，以及右边相关队列的状态。</p><h4 id="dispatch-sync-回顾"><a href="#dispatch-sync-回顾" class="headerlink" title="dispatch_sync 回顾"></a>dispatch_sync 回顾</h4><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">- (void)viewDidLoad {   [super viewDidLoad];   dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{       NSLog(@"First Log");   });   NSLog(@"Second Log"); }</code></pre><p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/01/dispatch_sync_in_action.gif" alt><br>下面是图中几个步骤的说明：</p><ol><li>主队列一路按顺序执行任务——接着是一个实例化 UIViewController 的任务，其中包含了 viewDidLoad 。</li><li>viewDidLoad 在主线程执行。</li><li>主线程目前在 viewDidLoad 内，正要到达 dispatch_sync 。</li><li>dispatch_sync Block 被添加到一个全局队列中，将在稍后执行。进程将在主线程挂起直到该 Block 完成。同时，全局队列并发处理任务；要记得 Block 在全局队列中将按照 FIFO 顺序出列，但可以并发执行。</li><li>全局队列处理 dispatch_sync Block 加入之前已经出现在队列中的任务。</li><li>终于，轮到 dispatch_sync Block 。</li><li>这个 Block 完成，因此主线程上的任务可以恢复。</li><li>viewDidLoad 方法完成，主队列继续处理其他任务。</li></ol><p>dispatch_sync 添加任务到一个队列并等待直到任务完成。dispatch_async 做类似的事情，但不同之处是它不会等待任务的完成，而是立即继续“调用线程”的其它任务。</p><h4 id="dispatch-async-回顾"><a href="#dispatch-async-回顾" class="headerlink" title="dispatch_async 回顾"></a>dispatch_async 回顾</h4><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">- (void)viewDidLoad {   [super viewDidLoad];   dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{       NSLog(@"First Log");   });   NSLog(@"Second Log"); }</code></pre><p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/01/dispatch_async_in_action.gif" alt></p><ol><li>主队列一路按顺序执行任务——接着是一个实例化 UIViewController 的任务，其中包含了 viewDidLoad 。</li><li>viewDidLoad 在主线程执行。</li><li>主线程目前在 viewDidLoad 内，正要到达 dispatch_async 。</li><li>dispatch_async Block 被添加到一个全局队列中，将在稍后执行。</li><li>viewDidLoad 在添加 dispatch_async 到全局队列后继续进行，主线程把注意力转向剩下的任务。同时，全局队列并发地处理它未完成地任务。记住 Block 在全局队列中将按照 FIFO 顺序出列，但可以并发执行。</li><li>添加到 dispatch_async 的代码块开始执行。</li><li>dispatch_async Block 完成，两个 NSLog 语句将它们的输出放在控制台上。</li></ol><p>在这个特定的实例中，第二个 NSLog 语句执行，跟着是第一个 NSLog 语句。并不总是这样——着取决于给定时刻硬件正在做的事情，而且你无法控制或知晓哪个语句会先执行。“第一个” NSLog 在某些调用情况下会第一个执行。</p><h3 id="准备下一步"><a href="#准备下一步" class="headerlink" title="准备下一步"></a>准备下一步</h3><p>在本教程中，你学习了如何让你的代码线程安全，以及在执行 CPU 密集型任务时如何保持主线程的响应性。</p><p>你可以下载 <a href="http://www.raywenderlich.com/wp-content/uploads/2014/01/GooglyPuff_End_1.zip" target="_blank" rel="noopener">GooglyPuff 项目</a>，它包含了目前所有本教程中编写的实现。在本教程的第二部分，你将继续改进这个项目。</p><p>如果你计划优化你自己的应用，那你应该用 Instruments 中的 Time Profile 模版分析你的工作。对这个工具的使用超出了本教程的范围，你可以看看 <a href="https://www.raywenderlich.com/?p=23037" target="_blank" rel="noopener">如何使用Instruments</a> 来得到一个很好的概述。</p><p>同时请确保在真实设备上分析，而在模拟器上测试会对程序速度产生非常不准确的印象。</p><p>现在你已经学到超过你想像的关于并发、线程以及GCD 如何工作的知识。通过在初始化时利用 dispatch_once，你创建了一个线程安全的 PhotoManager 单例，而且你通过使用 dispatch_barrier_async 和 dispatch_sync 的组合使得对 Photos 数组的读取和写入都变得线程安全了。</p><p>除了上面这些，你还通过利用 dispatch_after 来延迟显示提示信息，以及利用 dispatch_async 将 CPU 密集型任务从 ViewController 的初始化过程中剥离出来异步执行，达到了增强应用的用户体验的目的。</p><p>如果你一直跟着第一部分的教程在写代码，那你可以继续你的工程。但如果你没有完成第一部分的工作，或者不想重用你的工程，你可以下载<a href="http://www.raywenderlich.com/wp-content/uploads/2014/01/GooglyPuff_End_1.zip" target="_blank" rel="noopener">第一部分最终的代码</a>。</p><p>那就让我们来更深入地探索 GCD 吧！</p><h3 id="纠正过早弹出的提示"><a href="#纠正过早弹出的提示" class="headerlink" title="纠正过早弹出的提示"></a>纠正过早弹出的提示</h3><p>你可能已经注意到当你尝试用 Le Internet 选项来添加图片时，一个 UIAlertView 会在图片下载完成之前就弹出，如下如所示： </p><p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-17-at-5.49.51-PM.png" alt></p><p>问题的症结在 PhotoManagers 的 downloadPhotoWithCompletionBlock: 里，它目前的实现如下：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">- (void)downloadPhotosWithCompletionBlock:(BatchPhotoDownloadingCompletionBlock)completionBlock{    __block NSError *error;    for (NSInteger i = 0; i < 3; i++) {        NSURL *url;        switch (i) {            case 0:                url = [NSURL URLWithString:kOverlyAttachedGirlfriendURLString];                break;            case 1:                url = [NSURL URLWithString:kSuccessKidURLString];                break;            case 2:                url = [NSURL URLWithString:kLotsOfFacesURLString];                break;            default:                break;        }        Photo *photo = [[Photo alloc] initwithURL:url                              withCompletionBlock:^(UIImage *image, NSError *_error) {                                  if (_error) {                                      error = _error;                                  }                              }];        [[PhotoManager sharedManager] addPhoto:photo];    }    if (completionBlock) {        completionBlock(error);    }}</code></pre><p>在方法的最后你调用了 completionBlock ——因为此时你假设所有的照片都已下载完成。但很不幸，此时并不能保证所有的下载都已完成。</p><p>Photo 类的实例方法用某个 URL 开始下载某个文件并立即返回，但此时下载并未完成。换句话说，当 downloadPhotoWithCompletionBlock: 在其末尾调用 completionBlock 时，它就假设了它自己所使用的方法全都是同步的，而且每个方法都完成了它们的工作。</p><p>然而，-[Photo initWithURL:withCompletionBlock:] 是异步执行的，会立即返回——所以这种方式行不通。</p><p>因此，只有在所有的图像下载任务都调用了它们自己的 Completion Block 之后，downloadPhotoWithCompletionBlock: 才能调用它自己的 completionBlock 。问题是：你该如何监控并发的异步事件？你不知道它们何时完成，而且它们完成的顺序完全是不确定的。</p><p>或许你可以写一些比较 Hacky 的代码，用多个布尔值来记录每个下载的完成情况，但这样做就缺失了扩展性，而且说实话，代码会很难看。</p><p>幸运的是， 解决这种对多个异步任务的完成进行监控的问题，恰好就是设计 dispatch_group 的目的。</p><h3 id="Dispatch-Groups（调度组）"><a href="#Dispatch-Groups（调度组）" class="headerlink" title="Dispatch Groups（调度组）"></a>Dispatch Groups（调度组）</h3><p>Dispatch Group 会在整个组的任务都完成时通知你。这些任务可以是同步的，也可以是异步的，即便在不同的队列也行。而且在整个组的任务都完成时，Dispatch Group 可以用同步的或者异步的方式通知你。因为要监控的任务在不同队列，那就用一个 dispatch_group_t 的实例来记下这些不同的任务。</p><p>当组中所有的事件都完成时，GCD 的 API 提供了两种通知方式。</p><p>第一种是 dispatch_group_wait ，它会阻塞当前线程，直到组里面所有的任务都完成或者等到某个超时发生。这恰好是你目前所需要的。</p><p>打开 PhotoManager.m，用下列实现替换 downloadPhotosWithCompletionBlock:</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">- (void)downloadPhotosWithCompletionBlock:(BatchPhotoDownloadingCompletionBlock)completionBlock{    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{ // 1        __block NSError *error;        dispatch_group_t downloadGroup = dispatch_group_create(); // 2        for (NSInteger i = 0; i < 3; i++) {            NSURL *url;            switch (i) {                case 0:                    url = [NSURL URLWithString:kOverlyAttachedGirlfriendURLString];                    break;                case 1:                    url = [NSURL URLWithString:kSuccessKidURLString];                    break;                case 2:                    url = [NSURL URLWithString:kLotsOfFacesURLString];                    break;                default:                    break;            }            dispatch_group_enter(downloadGroup); // 3            Photo *photo = [[Photo alloc] initwithURL:url                                  withCompletionBlock:^(UIImage *image, NSError *_error) {                                      if (_error) {                                          error = _error;                                      }                                      dispatch_group_leave(downloadGroup); // 4                                  }];            [[PhotoManager sharedManager] addPhoto:photo];        }        dispatch_group_wait(downloadGroup, DISPATCH_TIME_FOREVER); // 5        dispatch_async(dispatch_get_main_queue(), ^{ // 6            if (completionBlock) { // 7                completionBlock(error);            }        });    });}</code></pre><p>按照注释的顺序，你会看到：</p><ol><li><p>因为你在使用的是同步的 dispatch_group_wait ，它会阻塞当前线程，所以你要用 dispatch_async 将整个方法放入后台队列以避免阻塞主线程。</p></li><li><p>创建一个新的 Dispatch Group，它的作用就像一个用于未完成任务的计数器。</p></li><li><p>dispatch_group_enter 手动通知 Dispatch Group 任务已经开始。你必须保证 dispatch_group_enter 和 dispatch_group_leave 成对出现，否则你可能会遇到诡异的崩溃问题。</p></li><li><p>手动通知 Group 它的工作已经完成。再次说明，你必须要确保进入 Group 的次数和离开 Group 的次数相等。</p></li><li><p>dispatch_group_wait 会一直等待，直到任务全部完成或者超时。如果在所有任务完成前超时了，该函数会返回一个非零值。你可以对此返回值做条件判断以确定是否超出等待周期；然而，你在这里用 DISPATCH_TIME_FOREVER 让它永远等待。它的意思，勿庸置疑就是，永－远－等－待！这样很好，因为图片的创建工作总是会完成的。</p></li><li><p>此时此刻，你已经确保了，要么所有的图片任务都已完成，要么发生了超时。然后，你在主线程上运行 completionBlock 回调。这会将工作放到主线程上，并在稍后执行。</p></li><li><p>最后，检查 completionBlock 是否为 nil，如果不是，那就运行它。</p></li></ol><p>编译并运行你的应用，尝试下载多个图片，观察你的应用是在何时运行 completionBlock 的。</p><blockquote><p>注意：如果你是在真机上运行应用，而且网络活动发生得太快以致难以观察 completionBlock 被调用的时刻，那么你可以在 Settings 应用里的开发者相关部分里打开一些网络设置，以确保代码按照我们所期望的那样工作。只需去往 Network Link Conditioner 区，开启它，再选择一个 Profile，“Very Bad Network” 就不错。<br>如果你是在模拟器里运行应用，你可以使用 来自 GitHub 的 <a href="http://nshipster.com/network-link-conditioner/" target="_blank" rel="noopener">Network Link Conditioner</a> 来改变网络速度。它会成为你工具箱中的一个好工具，因为它强制你研究你的应用在连接速度并非最佳的情况下会变成什么样。</p></blockquote><p>目前为止的解决方案还不错，但是总体来说，如果可能，最好还是要避免阻塞线程。你的下一个任务是重写一些方法，以便当所有下载任务完成时能异步通知你。</p><p>在我们转向另外一种使用 Dispatch Group 的方式之前，先看一个简要的概述，关于何时以及怎样使用有着不同的队列类型的 Dispatch Group ：</p><ol><li><p>自定义串行队列：它很适合当一组任务完成时发出通知。</p></li><li><p>主队列（串行）：它也很适合这样的情况。但如果你要同步地等待所有工作地完成，那你就不应该使用它，因为你不能阻塞主线程。然而，异步模型是一个很有吸引力的能用于在几个较长任务（例如网络调用）完成后更新 UI 的方式。</p></li><li><p>并发队列：它也很适合 Dispatch Group 和完成时通知。</p></li></ol><h3 id="Dispatch-Group，第二种方式"><a href="#Dispatch-Group，第二种方式" class="headerlink" title="Dispatch Group，第二种方式"></a>Dispatch Group，第二种方式</h3><p>上面的一切都很好，但在另一个队列上异步调度然后使用 dispatch_group_wait 来阻塞实在显得有些笨拙。是的，还有另一种方式……</p><p>在 PhotoManager.m 中找到 downloadPhotosWithCompletionBlock: 方法，用下面的实现替换它：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">- (void)downloadPhotosWithCompletionBlock:(BatchPhotoDownloadingCompletionBlock)completionBlock{    // 1    __block NSError *error;    dispatch_group_t downloadGroup = dispatch_group_create();     for (NSInteger i = 0; i < 3; i++) {        NSURL *url;        switch (i) {            case 0:                url = [NSURL URLWithString:kOverlyAttachedGirlfriendURLString];                break;            case 1:                url = [NSURL URLWithString:kSuccessKidURLString];                break;            case 2:                url = [NSURL URLWithString:kLotsOfFacesURLString];                break;            default:                break;        }        dispatch_group_enter(downloadGroup); // 2        Photo *photo = [[Photo alloc] initwithURL:url                              withCompletionBlock:^(UIImage *image, NSError *_error) {                                  if (_error) {                                      error = _error;                                  }                                  dispatch_group_leave(downloadGroup); // 3                              }];        [[PhotoManager sharedManager] addPhoto:photo];    }    dispatch_group_notify(downloadGroup, dispatch_get_main_queue(), ^{ // 4        if (completionBlock) {            completionBlock(error);        }    });}</code></pre><p>下面解释新的异步方法如何工作：</p><ol><li><p>在新的实现里，因为你没有阻塞主线程，所以你并不需要将方法包裹在 async 调用中。</p></li><li><p>同样的 enter 方法，没做任何修改。</p></li><li><p>同样的 leave 方法，也没做任何修改。</p></li><li><p>dispatch_group_notify 以异步的方式工作。当 Dispatch Group 中没有任何任务时，它就会执行其代码，那么 completionBlock 便会运行。你还指定了运行 completionBlock 的队列，此处，主队列就是你所需要的。</p></li></ol><p>对于这个特定的工作，上面的处理明显更清晰，而且也不会阻塞任何线程。</p><h3 id="太多并发带来的风险"><a href="#太多并发带来的风险" class="headerlink" title="太多并发带来的风险"></a>太多并发带来的风险</h3><p>既然你的工具箱里有了这些新工具，你大概做任何事情都想使用它们，对吧？ </p><p>看看 PhotoManager 中的 downloadPhotosWithCompletionBlock 方法。你可能已经注意到这里的 for 循环，它迭代三次，下载三个不同的图片。你的任务是尝试让 for 循环并发运行，以提高其速度。</p><p>dispatch_apply 刚好可用于这个任务。</p><p>dispatch_apply 表现得就像一个 for 循环，但它能并发地执行不同的迭代。这个函数是同步的，所以和普通的 for 循环一样，它只会在所有工作都完成后才会返回。</p><p>当在 Block 内计算任何给定数量的工作的最佳迭代数量时，必须要小心，因为过多的迭代和每个迭代只有少量的工作会导致大量开销以致它能抵消任何因并发带来的收益。而被称为跨越式（striding）的技术可以在此帮到你，即通过在每个迭代里多做几个不同的工作。</p><p>那何时才适合用 dispatch_apply 呢？</p><ol><li><p>自定义串行队列：串行队列会完全抵消 dispatch_apply 的功能；你还不如直接使用普通的 for 循环。</p></li><li><p>主队列（串行）：与上面一样，在串行队列上不适合使用 dispatch_apply 。还是用普通的 for 循环吧。</p></li><li><p>并发队列：对于并发循环来说是很好选择，特别是当你需要追踪任务的进度时。</p></li></ol><p>回到 downloadPhotosWithCompletionBlock: 并用下列实现替换它：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">- (void)downloadPhotosWithCompletionBlock:(BatchPhotoDownloadingCompletionBlock)completionBlock {     __block NSError *error;     dispatch_group_t downloadGroup = dispatch_group_create();     dispatch_apply(3, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^(size_t i) {         NSURL *url;         switch (i) {             case 0:                 url = [NSURL URLWithString:kOverlyAttachedGirlfriendURLString];                 break;             case 1:                 url = [NSURL URLWithString:kSuccessKidURLString];                 break;             case 2:                 url = [NSURL URLWithString:kLotsOfFacesURLString];                 break;             default:                 break;         }         dispatch_group_enter(downloadGroup);         Photo *photo = [[Photo alloc] initwithURL:url                               withCompletionBlock:^(UIImage *image, NSError *_error) {                                   if (_error) {                                       error = _error;                                   }                                   dispatch_group_leave(downloadGroup);                               }];         [[PhotoManager sharedManager] addPhoto:photo];     });     dispatch_group_notify(downloadGroup, dispatch_get_main_queue(), ^{         if (completionBlock) {             completionBlock(error);         }     }); }</code></pre><p>你的循环现在是并行运行的了；在上面的代码中，在调用 dispatch_apply 时，你用第一次参数指明了迭代的次数，用第二个参数指定了任务运行的队列，而第三个参数是一个 Block。</p><p>要知道虽然你有代码保证添加相片时线程安全，但图片的顺序却可能不同，这取决于线程完成的顺序。</p><p>编译并运行，然后从 “Le Internet” 添加一些照片。注意到区别了吗？</p><p>在真机上运行新代码会稍微更快的得到结果。但我们所做的这些提速工作真的值得吗？</p><p>实际上，在这个例子里并不值得。下面是原因：</p><ol><li><p>你创建并行运行线程而付出的开销，很可能比直接使用 for 循环要多。若你要以合适的步长迭代非常大的集合，那才应该考虑使用 dispatch_apply。</p></li><li><p>你用于创建应用的时间是有限的——除非实在太糟糕否则不要浪费时间去提前优化代码。如果你要优化什么，那去优化那些明显值得你付出时间的部分。你可以通过在 Instruments 里分析你的应用，找出最长运行时间的方法。看看 <a href="http://www.raywenderlich.com/23037/how-to-use-instruments-in-xcode" target="_blank" rel="noopener">如何在 Xcode 中使用 Instruments</a> 可以学到更多相关知识。</p></li><li><p>通常情况下，优化代码会让你的代码更加复杂，不利于你自己和其他开发者阅读。请确保添加的复杂性能换来足够多的好处。</p></li></ol><p>记住，不要在优化上太疯狂。你只会让你自己和后来者更难以读懂你的代码。</p><h3 id="GCD-的其他趣味"><a href="#GCD-的其他趣味" class="headerlink" title="GCD 的其他趣味"></a>GCD 的其他趣味</h3><p>等一下！还有更多！有一些额外的函数在不同的道路上走得更远。虽然你不会太频繁地使用这些工具，但在对的情况下，它们可以提供极大的帮助。</p><h4 id="阻塞——正确的方式"><a href="#阻塞——正确的方式" class="headerlink" title="阻塞——正确的方式"></a>阻塞——正确的方式</h4><p>这可能听起来像是个疯狂的想法，但你知道 Xcode 已有了测试功能吗？:] 我知道，虽然有时候我喜欢假装它不存在，但在代码里构建复杂关系时编写和运行测试非常重要。</p><p>Xcode 里的测试在 XCTestCase 的子类上执行，并运行任何方法签名以 test 开头的方法。测试在主线程运行，所以你可以假设所有测试都是串行发生的。</p><p>当一个给定的测试方法运行完成，XCTest 方法将考虑此测试已结束，并进入下一个测试。这意味着任何来自前一个测试的异步代码会在下一个测试运行时继续运行。</p><p>网络代码通常是异步的，因此你不能在执行网络获取时阻塞主线程。也就是说，整个测试会在测试方法完成之后结束，这会让对网络代码的测试变得很困难。也就是，除非你在测试方法内部阻塞主线程直到网络代码完成。</p><blockquote><p>注意：有一些人会说，这种类型的测试不属于集成测试的首选集（Preferred Set）。一些人会赞同，一些人不会。但如果你想做，那就去做。</p></blockquote><p>导航到 GooglyPuffTests.m 并查看 downloadImageURLWithString:，如下：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">- (void)downloadImageURLWithString:(NSString *)URLString {     NSURL *url = [NSURL URLWithString:URLString];     __block BOOL isFinishedDownloading = NO;     __unused Photo *photo = [[Photo alloc]                              initwithURL:url                              withCompletionBlock:^(UIImage *image, NSError *error) {                                  if (error) {                                      XCTFail(@"%@ failed. %@", URLString, error);                                  }                                  isFinishedDownloading = YES;                              }];     while (!isFinishedDownloading) {} }</code></pre><p>这是一种测试异步网络代码的幼稚方式。 While 循环在函数的最后一直等待，直到 isFinishedDownloading 布尔值变成 True，它只会在 Completion Block 里发生。让我们看看这样做有什么影响。</p><p>通过在 Xcode 中点击 Product / Test 运行你的测试，如果你使用默认的键绑定，也可以使用快捷键 ?+U 来运行你的测试。</p><p>在测试运行时，注意 Xcode debug 导航栏里的 CPU 使用率。这个设计不当的实现就是一个基本的 自旋锁 。它很不实用，因为你在 While 循环里浪费了珍贵的 CPU 周期；而且它也几乎没有扩展性。</p><blockquote><p>译者注：所谓自旋锁，就是某个线程一直抢占着 CPU 不断检查以等到它需要的情况出现。因为现代操作系统都是可以并发运行多个线程的，所以它所等待的那个线程也有机会被调度执行，这样它所需要的情况早晚会出现。</p></blockquote><p>你可能需要使用前面提到的 Network Link Conditioner ，已便清楚地看到这个问题。如果你的网络太快，那么自旋只会在很短的时间里发生，难以观察。</p><p>你需要一个更优雅、可扩展的解决方案来阻塞线程直到资源可用。欢迎来到信号量。</p><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>信号量是一种老式的线程概念，由非常谦卑的 Edsger W. Dijkstra 介绍给世界。信号量之所以比较复杂是因为它建立在操作系统的复杂性之上。</p><p>如果你想学到更多关于信号量的知识，看看<a href="http://greenteapress.com/semaphores/" target="_blank" rel="noopener">这个链接</a>它更细致地讨论了信号量理论。如果你是学术型，那可以看一个软件开发中经典的<a href="http://greenteapress.com/semaphores/" target="_blank" rel="noopener">哲学家进餐问题</a>，它需要使用信号量来解决。</p><p>信号量让你控制多个消费者对有限数量资源的访问。举例来说，如果你创建了一个有着两个资源的信号量，那同时最多只能有两个线程可以访问临界区。其他想使用资源的线程必须在一个…你猜到了吗？…FIFO队列里等待。</p><p>让我们来使用信号量吧！</p><p>打开 GooglyPuffTests.m 并用下列实现替换 downloadImageURLWithString:</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">- (void)downloadImageURLWithString:(NSString *)URLString{    // 1    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);    NSURL *url = [NSURL URLWithString:URLString];    __unused Photo *photo = [[Photo alloc]                             initwithURL:url                             withCompletionBlock:^(UIImage *image, NSError *error) {                                 if (error) {                                     XCTFail(@"%@ failed. %@", URLString, error);                                 }                                 // 2                                 dispatch_semaphore_signal(semaphore);                             }];    // 3    dispatch_time_t timeoutTime = dispatch_time(DISPATCH_TIME_NOW, kDefaultTimeoutLengthInNanoSeconds);    if (dispatch_semaphore_wait(semaphore, timeoutTime)) {        XCTFail(@"%@ timed out", URLString);    }}</code></pre><p>下面来说明你代码中的信号量是如何工作的：</p><ol><li><p>创建一个信号量。参数指定信号量的起始值。这个数字是你可以访问的信号量，不需要有人先去增加它的数量。（注意到增加信号量也被叫做发射信号量）。译者注：这里初始化为0，也就是说，有人想使用信号量必然会被阻塞，直到有人增加信号量。</p></li><li><p>在 Completion Block 里你告诉信号量你不再需要资源了。这就会增加信号量的计数并告知其他想使用此资源的线程。</p></li><li><p>这会在超时之前等待信号量。这个调用阻塞了当前线程直到信号量被发射。这个函数的一个非零返回值表示到达超时了。在这个例子里，测试将会失败因为它以为网络请求不会超过 10 秒钟就会返回——一个平衡点！</p></li></ol><p>再次运行测试。只要你有一个正常工作的网络连接，这个测试就会马上成功。请特别注意 CPU 的使用率，与之前使用自旋锁的实现作个对比。</p><p>关闭你的网络链接再运行测试；如果你在真机上运行，就打开飞行模式。如果你的在模拟器里运行，你可以直接断开 Mac 的网络链接。测试会在 10 秒后失败。这很棒，它真的能按照预想的那样工作！</p><p>还有一些琐碎的测试，但如果你与一个服务器组协同工作，那么这些基本的测试能够防止其他人就最新的网络问题对你说三道四。</p><h4 id="使用-Dispatch-Source"><a href="#使用-Dispatch-Source" class="headerlink" title="使用 Dispatch Source"></a>使用 Dispatch Source</h4><p>GCD 的一个特别有趣的特性是 Dispatch Source，它基本上就是一个低级函数的 grab-bag ，能帮助你去响应或监测 Unix 信号、文件描述符、Mach 端口、VFS 节点，以及其它晦涩的东西。所有这些都超出了本教程讨论的范围，但你可以通过实现一个 Dispatch Source 对象并以一个相当奇特的方式来使用它来品尝那些晦涩的东西。</p><p>第一次使用 Dispatch Source 可能会迷失在如何使用一个源，所以你需要知晓的第一件事是 dispatch_source_create 如何工作。下面是创建一个源的函数原型：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">dispatch_source_t dispatch_source_create(   dispatch_source_type_t type,   uintptr_t handle,   unsigned long mask,   dispatch_queue_t queue);</code></pre><p>第一个参数是 dispatch_source_type_t 。这是最重要的参数，因为它决定了 handle 和 mask 参数将会是什么。你可以查看 <a href="https://developer.apple.com/library/mac/documentation/Performance/Reference/GCD_libdispatch_Ref/Reference/reference.html#//apple_ref/doc/constant_group/Dispatch_Source_Type_Constants" target="_blank" rel="noopener">Xcode 文档</a> 得到哪些选项可用于每个 dispatch_source_type_t 参数。</p><p>下面你将监控 DISPATCH_SOURCE_TYPE_SIGNAL 。如<a href="https://developer.apple.com/library/mac/documentation/Performance/Reference/GCD_libdispatch_Ref/Reference/reference.html#//apple_ref/c/macro/DISPATCH_SOURCE_TYPE_SIGNAL%22" target="_blank" rel="noopener">文档所显示的</a>：</p><p>一个监控当前进程信号的 Dispatch Source。 handle 是信号编号，mask 未使用（传 0 即可）。</p><p>这些 Unix 信号组成的列表可在头文件 <a href="http://www.opensource.apple.com/source/xnu/xnu-1456.1.26/bsd/sys/signal.h" target="_blank" rel="noopener">signal.h</a> 中找到。在其顶部有一堆 #define 语句。你将监控此信号列表中的 SIGSTOP 信号。这个信号将会在进程接收到一个无法回避的暂停指令时被发出。在你用 LLDB 调试器调试应用时你使用的也是这个信号。</p><p>去往 PhotoCollectionViewController.m 并添加如下代码到 viewDidLoad 的顶部，就在 [super viewDidLoad] 下面：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">- (void)viewDidLoad{  [super viewDidLoad];  // 1  #if DEBUG      // 2      dispatch_queue_t queue = dispatch_get_main_queue();      // 3      static dispatch_source_t source = nil;      // 4      __typeof(self) __weak weakSelf = self;      // 5      static dispatch_once_t onceToken;      dispatch_once(&onceToken, ^{          // 6          source = dispatch_source_create(DISPATCH_SOURCE_TYPE_SIGNAL, SIGSTOP, 0, queue);          // 7          if (source)          {              // 8              dispatch_source_set_event_handler(source, ^{                  // 9                  NSLog(@"Hi, I am: %@", weakSelf);              });              dispatch_resume(source); // 10          }      });  #endif  // The other stuff</code></pre><p>这些代码有点儿复杂，所以跟着注释一步步走，看看到底发生了什么：</p><ol><li><p>最好是在 DEBUG 模式下编译这些代码，因为这会给“有关方面（Interested Parties）”很多关于你应用的洞察。</p></li><li><p>Just to mix things up，你创建了一个 dispatch_queue_t 实例变量而不是在参数上直接使用函数。当代码变长，分拆有助于可读性。</p></li><li><p>你需要 source 在方法范围之外也可被访问，所以你使用了一个 static 变量。</p></li><li><p>使用 weakSelf 以确保不会出现保留环（Retain Cycle）。这对 PhotoCollectionViewController 来说不是完全必要的，因为它会在应用的整个生命期里保持活跃。然而，如果你有任何其它会消失的类，这就能确保不会出现保留环而造成内存泄漏。</p></li><li><p>使用 dispatch_once 确保只会执行一次 Dispatch Source 的设置。</p></li><li><p>初始化 source 变量。你指明了你对信号监控感兴趣并提供了 SIGSTOP 信号作为第二个参数。进一步，你使用主队列处理接收到的事件——很快你就好发现为何要这样做。</p></li><li><p>如果你提供的参数不合格，那么 Dispatch Source 对象不会被创建。也就是说，在你开始在其上工作之前，你需要确保已有了一个有效的 Dispatch Source 。</p></li><li><p>当你收到你所监控的信号时，dispatch_source_set_event_handler 就会执行。之后你可以在其 Block 里设置合适的逻辑处理器（Logic Handler）。</p></li><li><p>一个基本的 NSLog 语句，它将对象打印到控制台。</p></li><li><p>默认的，所有源都初始为暂停状态。如果你要开始监控事件，你必须告诉源对象恢复活跃状态。</p></li></ol><p>编译并运行应用；在调试器里暂停并立即恢复应用，查看控制台，你会看到这个来自黑暗艺术的函数确实可以工作。你看到的大概如下：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">2014-03-29 17:41:30.610 GooglyPuff[8181:60b] Hi, I am:</code></pre><p>你的应用现在具有调试感知了！这真是超级棒，但在真实世界里该如何使用它呢？</p><p>你可以用它去调试一个对象并在任何你想恢复应用的时候显示数据；你同样能给你的应用加上自定义的安全逻辑以便在恶意攻击者将一个调试器连接到你的应用上时保护它自己（或用户的数据）。</p><p>一个有趣的主意是，使用此方式的作为一个堆栈追踪工具去找到你想在调试器里操纵的对象。 </p><p>稍微想想这个情况。当你意外地停止调试器，你几乎从来都不会在所需的栈帧上。现在你可以在任何时候停止调试器并在你所需的地方执行代码。如果你想在你的应用的某一点执行的代码非常难以从调试器访问的话，这会非常有用。有机会试试吧！ </p><p>将一个断点放在你刚添加在 viewDidLoad 里的事件处理器的 NSLog 语句上。在调试器里暂停，然后再次开始；应用会到达你添加的断点。现在你深入到你的 PhotoCollectionViewController 方法深处。你可以访问 PhotoCollectionViewController 的实例得到你关心的内容。非常方便！</p><blockquote><p>注意：如果你还没有注意到在调试器里的是哪个线程，那现在就看看它们。主线程总是第一个被 libdispatch 跟随，它是 GCD 的坐标，作为第二个线程。之后，线程计数和剩余线程取决于硬件在应用到达断点时正在做的事情。</p></blockquote><p>在调试器里，键入命令：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">po [[weakSelf navigationItem] setPrompt:@"WOOT!"]</code></pre><p>然后恢复应用的执行。你会看到如下内容：</p><p><img src="https://cdn5.raywenderlich.com/wp-content/uploads/2014/01/Dispatch_Sources_Xcode_Breakpoint_Console-650x500.png" alt></p><p><img src="https://cdn1.raywenderlich.com/wp-content/uploads/2014/01/Dispatch_Sources_Debugger_Updating_UI-308x500.png" alt></p><p>使用这个方法，你可以更新 UI、查询类的属性，甚至是执行方法——所有这一切都不需要重启应用并到达某个特定的工作状态。相当优美吧！</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>你可以在此<a href="http://www.raywenderlich.com/wp-content/uploads/2014/01/GooglyPuff-Final.zip" target="_blank" rel="noopener">下载最终的项目</a>。</p><p>我讨厌再次提及此主题，但你真的要看看 <a href="https://www.raywenderlich.com/?p=23037" target="_blank" rel="noopener">如何使用 Instruments</a> 教程。如果你计划优化你的应用，那你一定要学会使用它。请注意 Instruments 擅长于分析相对执行：比较哪些区域的代码相对于其它区域的代码花费了更长的时间。如果你尝试计算出某个方法实际的执行时间，那你可能需要拿出更多的自酿的解决方案（Home-brewed Solution）。</p><p>同样请看看 <a href="http://www.raywenderlich.com/19788/how-to-use-nsoperations-and-nsoperationqueues" target="_blank" rel="noopener">如何使用 NSOperations 和 NSOperationQueues</a> 吧，它们是建立在 GCD 之上的并发技术。大体来说，如果你在写简单的用过就忘的任务，那它们就是使用 GCD 的最佳实践，。NSOperations 提供更好的控制、处理大量并发操作的实现，以及一个以速度为代价的更加面向对象的范例。</p><p>记住，除非你有特别的原因要往下流走（译者的玩笑：即使用低级别 API），否则永远应尝试并坚持使用高级的 API。如果你想学到更多或想做某些非常非常“有趣”的事情，那你就应该冒险进入 Apple 的黑暗艺术。</p><blockquote><p>Reference<br><a href="https://www.raywenderlich.com/60749/grand-central-dispatch-in-depth-part-1" target="_blank" rel="noopener">Grand Central Dispatch In-Depth: Part 1/2</a> <a href="http://www.cocoachina.com/industry/20140428/8248.html" target="_blank" rel="noopener">中文</a><br><a href="https://www.raywenderlich.com/63338/grand-central-dispatch-in-depth-part-2" target="_blank" rel="noopener">Grand Central Dispatch In-Depth: Part 2/2</a> <a href="http://www.cocoachina.com/ios/20140515/8433.html" target="_blank" rel="noopener">中文</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Syntax </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Objective-C </tag>
            
            <tag> GCD </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Objective-C]多线程和GCD</title>
      <link href="/2016/05/30/%5BObjective-C%5DMultithreading-and-GCD/"/>
      <url>/2016/05/30/%5BObjective-C%5DMultithreading-and-GCD/</url>
      
        <content type="html"><![CDATA[<h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>是指在系统中正在运行的一个应用程序。<br>每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内。<br>比如同时打开QQ、Xcode，系统就会分别启动两个进程。</p><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>一个进程要想执行任务，必须得有线程（每一个进程至少要有一条线程）<br>线程是进程的基本执行单元，一个进程（程序）的所有任务都在线程中执行<br>比如使用酷狗播放音乐、使用迅雷下载电影，都需要在线程中执行</p><h4 id="线程的串行"><a href="#线程的串行" class="headerlink" title="线程的串行"></a>线程的串行</h4><p>一个线程中任务的执行是串行的<br>如果要在一个线程中执行多个任务，那么只能一个一个地按顺序执行这些任务<br>也就是说，在同一时间内，一个线程只能执行一个任务<br>比如在一个线程中下载三个文件（分别是文件A、文件B、文件C），下载顺序就是ABC</p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>一个进程中可以开启多条线程，每条线程可以并行（同时）执行不同的任务<br>如果把进程比作车间，那么线程就相当于车间工人<br>多线程技术可以提高程序的执行效率，比如同时开启3条线程分别下载3个文件（分别是文件A、文件B、文件C）</p><p>同一时间，CPU只能处理一条线程，只有一条线程在工作（执行）<br>多线程并发（同时）执行，其实是CPU快速地在多条线程之间调度（切换），如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象。</p><p>所以如果线程非常非常多，CPU会在N多线程之间调度，CPU会累死，消耗大量的CPU资源，每条线程被调度执行的频次会降低（线程的执行效率降低）。</p><p>优点：</p><ul><li>能适当提高程序的执行效率</li><li>能适当提高资源利用率（CPU、内存利用率）</li></ul><p>缺点:</p><ul><li>开启线程需要占用一定的内存空间，如果开启大量的线程，会占用大量的内存空间，降低程序的性能</li><li>线程越多，CPU在调度线程上的开销就越大</li><li>程序设计更加复杂：比如线程之间的通信、多线程的数据共享</li></ul><p>移动APP经常使用多线程，因为对APP来说，界面要保持响应用户操作并给以反馈，也就是要保持流畅。所以很多比较耗时的运算就应该放在其他线程中，保证主线程能够及时处理用户操作。</p><p>对于iOS程序，使用多线程有几类：</p><ul><li>c语言的<code>pthread_t</code></li><li>NSThread</li><li>GCD</li><li>NSOperation</li></ul><p>使用的比较多的应该就是<code>GCD</code>和<code>NSOperation</code>了，对于这两者的讨论可以看看这个<br><a href="http://stackoverflow.com/questions/10373331/nsoperation-vs-grand-central-dispatch" target="_blank" rel="noopener">NSOperation vs Grand Central Dispatch</a></p><p>这里主要介绍<code>GCD</code></p><h3 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h3><p><code>GCD</code>全称是<code>Grand Central Dispatch</code>，纯c语言提供。<br><code>GCD</code>是苹果公司为多核的并行运算提出的解决方案，会自动利用更多的CPU内核（比如双核、四核），会自动管理线程的生命周期（创建线程、调度任务、销毁线程）。程序员只需要告诉<code>GCD</code>想要执行什么任务，不需要编写任何线程管理代码。</p><p><code>GCD</code>中有两个核心概念：</p><ol><li>任务：执行什么操作</li><li>队列：用来存放任务</li></ol><p>将任务添加到队列中，<code>GCD</code>会自动将队列中的任务取出，放到对应的线程中执行。任务的取出遵循队列的FIFO原则：First in first out</p><p><code>GCD</code>路径iOS usr/include/dispatch/下查看头文件说明</p><h3 id="GCD常用方法"><a href="#GCD常用方法" class="headerlink" title="GCD常用方法"></a>GCD常用方法</h3><h4 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h4><ul><li><p>dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);</p><p>  用同步的方式执行任务（当前线程中执行）</p></li><li><p>dispatch_async(dispatch_queue_t queue, dispatch_block_t block);</p><p>  用异步的方式执行任务（另起一条线程中执行）</p></li></ul><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>从上面方法第一个参数<code>dispatch_queue_t</code>就是<code>GCD</code>的队列类型。一般分为两大类型：<strong>并发队列</strong>和<strong>串行队列</strong>。并发功能只有在异步函数下才有用。</p><ul><li><strong>同步</strong>：在当前线程中执行任务，不具备开启新线程的能力</li><li><strong>异步</strong>：在新的线程中执行任务，具备开启新线程的能力</li><li><strong>并发</strong>：多个任务并发（同时）执行</li><li><strong>串行</strong>：一个任务执行完毕后，再执行下一个任务</li></ul><p><strong>获取串行队列：</strong></p><ul><li><p>dispatch_queue_t  dispatch_queue_create(const char *label,  dispatch_queue_attr_t attr);</p><p>  参数为队列名和属性，属性一般用<code>NULL</code></p></li><li><p>dispatch_get_main_queue()</p><p>  获得主队列，主队列是<code>GCD</code>自带的一种特殊的串行队列,放在主队列中的任务，都会放到主线程中执行</p></li></ul><p><strong>获取并发队列：</strong><br><code>GCD</code>默认已经提供了全局的并发队列，供整个应用使用，不需要手动创建</p><ul><li><p>dispatch_queue_t dispatch_get_global_queue(dispatch_queue_priority_t priority,unsigned long flags);</p><p>  第一个参数是优先级，第二个暂用0即可</p></li></ul><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">#define DISPATCH_QUEUE_PRIORITY_HIGH 2#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0#define DISPATCH_QUEUE_PRIORITY_LOW (-2)#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN</code></pre><p>关于不同队列的执行任务的效果：<br><img src="http://images.cnitblog.com/i/450136/201406/242038164084931.png" alt></p><p><strong>示例代码</strong></p><p>一. 异步函数往并发队列添加任务</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">  //获得全局并发队列  执行顺序每次都不一样  dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);  //添加任务到队列执行任务  //异步函数 具备开启新线程能力  dispatch_async(queue, ^{    NSLog(@"下载图片1---%@", [NSThread currentThread]);  });  dispatch_async(queue, ^{    NSLog(@"下载图片2---%@", [NSThread currentThread]);  });  dispatch_async(queue, ^{    NSLog(@"下载图片3---%@", [NSThread currentThread]);  });  NSLog(@"Main Thread: %@", [NSThread mainThread]);//输出Main Thread: <NSThread: 0x12de0c090>{number = 1, name = main}下载图片1---<NSThread: 0x12ddc1140>{number = 6, name = (null)}下载图片2---<NSThread: 0x12dd80ea0>{number = 7, name = (null)}下载图片3---<NSThread: 0x12dee45f0>{number = 8, name = (null)}</code></pre><p>看到开启了三个子线程执行任务</p><p>二. 异步函数往串行队列中添加任务</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">  //创建串行队列  按顺序执行  而且只开启一个线程  dispatch_queue_t queue = dispatch_queue_create("wossoneri", NULL);  //添加任务到队列执行任务  //异步函数 具备开启新线程能力  dispatch_async(queue, ^{    NSLog(@"下载图片1---%@", [NSThread currentThread]);  });  dispatch_async(queue, ^{    NSLog(@"下载图片2---%@", [NSThread currentThread]);  });  dispatch_async(queue, ^{    NSLog(@"下载图片3---%@", [NSThread currentThread]);  });  NSLog(@"Main Thread: %@", [NSThread mainThread]);//输出Main Thread: <NSThread: 0x12c60c0d0>{number = 1, name = main}下载图片1---<NSThread: 0x12c6574f0>{number = 6, name = (null)}下载图片2---<NSThread: 0x12c6574f0>{number = 6, name = (null)}下载图片3---<NSThread: 0x12c6574f0>{number = 6, name = (null)}</code></pre><p>看到只开启了一条线程，串行执行任务</p><p>三. 用同步函数往并发队列中添加任务</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">  //获得全局并发队列  执行顺序每次都不一样  dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);  NSLog(@"Main Thread: %@", [NSThread mainThread]);  //同步  dispatch_sync(queue, ^{    NSLog(@"下载图片1---%@", [NSThread currentThread]);  });  dispatch_sync(queue, ^{    NSLog(@"下载图片2---%@", [NSThread currentThread]);  });  dispatch_sync(queue, ^{    NSLog(@"下载图片3---%@", [NSThread currentThread]);  });//输出Main Thread: <NSThread: 0x136d04ae0>{number = 1, name = main}下载图片1---<NSThread: 0x136d04ae0>{number = 1, name = main}下载图片2---<NSThread: 0x136d04ae0>{number = 1, name = main}下载图片3---<NSThread: 0x136d04ae0>{number = 1, name = main}</code></pre><p>发现根本没有开启新线程，直接在主线程顺序执行，并发队列失去了并发功能。</p><p>四. 用同步函数往串行队列中添加任务</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">  //创建串行队列  按顺序执行  而且只开启一个线程  dispatch_queue_t queue = dispatch_queue_create("wossoneri", NULL);    NSLog(@"Main Thread: %@", [NSThread mainThread]);  //同步  dispatch_sync(queue, ^{    NSLog(@"下载图片1---%@", [NSThread currentThread]);  });  dispatch_sync(queue, ^{    NSLog(@"下载图片2---%@", [NSThread currentThread]);  });  dispatch_sync(queue, ^{    NSLog(@"下载图片3---%@", [NSThread currentThread]);  });//输出Main Thread: <NSThread: 0x135e0c0b0>{number = 1, name = main}下载图片1---<NSThread: 0x135e0c0b0>{number = 1, name = main}下载图片2---<NSThread: 0x135e0c0b0>{number = 1, name = main}下载图片3---<NSThread: 0x135e0c0b0>{number = 1, name = main}</code></pre><p>没有开启新线程，依旧在主线程顺序执行任务。</p><p>小结：</p><ul><li>同步函数（永远）不会开启新线程，不具备开线程的能力</li><li>异步函数具备开启新线程的能力（但不一定总会开线程？）<ul><li>在串行队列只开启一条线程</li><li>在并发队列开启多条线程</li></ul></li></ul><h4 id="主队列"><a href="#主队列" class="headerlink" title="主队列"></a>主队列</h4><p>主队列是和主线程相关联的队列，主队列是<code>GCD</code>自带的一种特殊的<strong>串行</strong>队列，放在主队列中的任务，都会放到主线程中执行。</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">dispatch_queue_t queue = dispatch_get_main_queue();</code></pre><p><strong>使用异步函数执行主队列任务：</strong></p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">  //获取主队列  dispatch_queue_t queue = dispatch_get_main_queue();  //把任务添加到主队列中执行  dispatch_async(queue, ^{    NSLog(@"使用异步函数执行主队列中的任务1--%@",[NSThread currentThread]);  });  dispatch_async(queue, ^{    NSLog(@"使用异步函数执行主队列中的任务2--%@",[NSThread currentThread]);  });  dispatch_async(queue, ^{    NSLog(@"使用异步函数执行主队列中的任务3--%@",[NSThread currentThread]);  });//输出Main Thread: <NSThread: 0x13de0c030>{number = 1, name = main}使用异步函数执行主队列中的任务1--<NSThread: 0x13de0c030>{number = 1, name = main}使用异步函数执行主队列中的任务2--<NSThread: 0x13de0c030>{number = 1, name = main}使用异步函数执行主队列中的任务3--<NSThread: 0x13de0c030>{number = 1, name = main}</code></pre><p>看到任务都在主线程中执行。</p><p><strong>使用同步函数执行主队列任务：</strong></p><p>此时会发生死锁。<br>死锁的原因是：主线程本身是串行队列，串行队列的任务是顺序执行的。<br>比如下面代码段</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">NSLog(@"1");dispatch_sync(dispatch_get_main_queue(), ^{  NSLog(@"2");});NSLog(@"3");</code></pre><p>在主线程中，任务执行的顺序是：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">NSLog(@"1");dispatch_sync()NSLog(@"3");NSLog(@"2");</code></pre><p>其中</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">NSLog(@"2");</code></pre><p>是作为<code>Block</code>的内容放在队列最后执行。</p><p>但<code>dispatch_sync()</code>方法必须返回才能往下执行，其返回的条件是<code>Block</code>的内容执行完毕才行。</p><p>也就是说死锁的条件是因为<code>dispatch_sync()</code>方法在等待<code>Block</code>执行完毕，而<code>Block</code>在等待<code>dispatch_sync()</code>方法往下执行才能轮到它。</p><blockquote><p>所以，如果把任务放到主队列中进行处理，那么不论处理函数是异步的还是同步的都不会开启新的线程。</p></blockquote><h4 id="延时执行"><a href="#延时执行" class="headerlink" title="延时执行"></a>延时执行</h4><p>可以使用<code>NSObject</code>方法，该方法通常在哪个线程调用，就在哪个线程执行，一般是主线程</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">[self performSelector:@selector(run) withObject:nil afterDelay:2.0];</code></pre><p>示例</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">- (void)viewDidLoad {  NSLog(@"打印线程----%@",[NSThread currentThread]);  //延迟执行  [self performSelector:@selector(runA) withObject:nil afterDelay:2.0];}- (void)onBtnClicked {  //在异步函数中执行  dispatch_queue_t queue = dispatch_queue_create("wOw", 0);  dispatch_async(queue, ^{    [self performSelector:@selector(runB) withObject:nil afterDelay:1.0];  });  NSLog(@"异步函数");}- (void)runA {  NSLog(@"延迟执行----%@", [NSThread currentThread]);}- (void)runB {  NSLog(@"异步函数中延迟执行----%@", [NSThread currentThread]);}//输出2016-05-29 23:31:49.194 FunctionTest[4199:1337673] 打印线程----<NSThread: 0x154e04b60>{number = 1, name = main}2016-05-29 23:31:51.197 FunctionTest[4199:1337673] 延迟执行----<NSThread: 0x154e04b60>{number = 1, name = main}2016-05-29 23:31:58.198 FunctionTest[4199:1337673] 异步函数</code></pre><p>这里发现，异步下的runB方法似乎并没有执行。换成同步则会执行。<br>出现这个问题的原因是async开的新线程中的<code>runLoop</code>没有启动，在后面加上</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">[[NSRunLoop currentRunLoop] run];</code></pre><p>即可。好吧..后面再研究一下<code>RunLoop</code>原理…</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">  dispatch_async(queue, ^{        [self performSelector:@selector(runB) withObject:nil afterDelay:1.0];    [[NSRunLoop currentRunLoop] run];  });  //再看输出2016-05-29 23:37:10.877 FunctionTest[4214:1339152] 打印线程----<NSThread: 0x12660a2a0>{number = 1, name = main}2016-05-29 23:37:12.879 FunctionTest[4214:1339152] 延迟执行----<NSThread: 0x12660a2a0>{number = 1, name = main}2016-05-29 23:37:15.150 FunctionTest[4214:1339152] 异步函数2016-05-29 23:37:16.157 FunctionTest[4214:1339199] 异步函数中延迟执行----<NSThread: 0x1266b3f40>{number = 6, name = (null)}</code></pre><p>延时都是正确的。使用异步函数后执行的线程也变为的新线程。</p><p>使用<code>GCD</code>方法</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{});</code></pre><p>示例：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">  NSLog(@"打印线程----%@",[NSThread currentThread]);  //GCD delay  //1 主队列  dispatch_queue_t queue = dispatch_get_main_queue();  dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5.0 * NSEC_PER_SEC)), queue, ^{    NSLog(@"主队列--延迟执行------%@",[NSThread currentThread]);  });  //2 并发队列  dispatch_queue_t queue1 = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);  dispatch_time_t when = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5.0 * NSEC_PER_SEC));  dispatch_after(when, queue1, ^{    NSLog(@"并发队列-延迟执行------%@",[NSThread currentThread]);  });  //输出  2016-05-30 22:14:43.734 FunctionTest[4507:1470176] 打印线程----<NSThread: 0x15ee0bd40>{number = 1, name = main}2016-05-30 22:14:49.234 FunctionTest[4507:1470176] 主队列--延迟执行------<NSThread: 0x15ee0bd40>{number = 1, name = main}2016-05-30 22:14:49.235 FunctionTest[4507:1470304] 并发队列-延迟执行------<NSThread: 0x15ed90390>{number = 6, name = (null)}</code></pre><p>看到并发队列开启一个新线程，在新线程执行。主队列直接在主线程执行。</p><h4 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h4><p>之前说过，程序中遇到耗时操作就要把操作放在另外一个线程中执行。当执行过之后，就需要把耗时操作得到的数据带回到主线程对UI进行刷新操作，这时就可以用如下代码。</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">  dispatch_async( dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{    // 执⾏耗时的异步操作    dispatch_async(dispatch_get_main_queue(), ^{            // 回到主线程,执⾏UI刷新操作    });  });</code></pre><h4 id="一次性代码"><a href="#一次性代码" class="headerlink" title="一次性代码"></a>一次性代码</h4><p>这个概念在之前的<a href="http://www.wossoneri.com/2016/05/23/[Design-Pattern]Singleton/" target="_blank" rel="noopener">单例模式</a>中提到过，就是保证一段代码段在程序执行过程中只执行一次。使用的方法就是<code>dispatch_once</code>。</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">static dispatch_once_t onceToken;dispatch_once(&onceToken, ^{    // 只执行1次的代码(这里面默认是线程安全的)});</code></pre><p><code>Block</code>中的代码在整个程序运行期间只执行一次！</p><h4 id="队列组"><a href="#队列组" class="headerlink" title="队列组"></a>队列组</h4><p>队列组的使用情形是这样：</p><p>现在有多个耗时的操作要做，我当然要考虑开启异步的线程去，把任务放到并发队列去做。但此时我需要这几个操作都完成的时候回到主线程来。</p><p>此时有一个办法，就是把操作统一放在一个线程里做，这样我能知道线程执行结束的时间，但缺点是这些耗时的操作是串行的。</p><p>如果让这些操作并行执行，那效率就更高了，但我该怎么知道全部操作都执行完的时间呢？</p><p>这时就用上队列组了。</p><p>创建一个队列组，把所有异步操作都放在队列组中，这样队列组执行完会发出一个通知回来。</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">//创建队列组dispatch_group_t group =  dispatch_group_create();//异步方法dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{    // 执行一个耗时的异步操作});dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{    // 执行另一个耗时的异步操作});dispatch_group_notify(group, dispatch_get_main_queue(), ^{    // 等前面的异步操作都执行完毕后，回到主线程});</code></pre><p>暂时整理这么多，掌握这些可以应对大多数使用到<code>GCD</code>的相关问题了。</p><blockquote><p>Reference<br><a href="http://www.cnblogs.com/wendingding/tag/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87/" target="_blank" rel="noopener">整理多线程篇</a><br><a href="http://www.cocoachina.com/bbs/read.php?tid=1482884" target="_blank" rel="noopener">GCD中在主线程中用同步函数分派任务到串行队列中会产生死锁是什么原因？</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Syntax </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Objective-C </tag>
            
            <tag> Multithreading </tag>
            
            <tag> GCD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[设计模式]之三:单例模式</title>
      <link href="/2016/05/23/%5BDesign-Pattern%5DSingleton/"/>
      <url>/2016/05/23/%5BDesign-Pattern%5DSingleton/</url>
      
        <content type="html"><![CDATA[<p><strong><a href="http://wossoneri.github.io/categories/Design-pattern/">设计模式系列目录</a></strong></p><p>单例进阶：<a href="http://wossoneri.github.io/2017/12/14/[Design-Pattern]More-about-Singleton/">[设计模式]之四:再谈单例模式</a></p><p>吐槽一下，这两天练车又热又累…</p><h3 id="需求情景"><a href="#需求情景" class="headerlink" title="需求情景"></a>需求情景</h3><p>还是试想一个情景：现在有一个自定义对话框。当主界面上的按钮被点击后，弹出对话框。<br>一般的设计思路是这样的：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">- (void)onBtnClicked {    MyPopupView *popup = [[MyPopupView alloc] init];    [self.view addSubview: popup];    [popup show];}</code></pre><p>假设这个对话框可以保存一些状态，比如上次输入的内容之类的信息，那我们就需要保证这个实例唯一，也就是第一次使用的时候创建一次实例，之后都使用这个实例。</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">MyPopupView *popup;- (void)onBtnClicked {    if (nil == popup) {        popup = [[MyPopupView alloc] init];        [self.view addSubview: popup];    }    [popup show];}</code></pre><p>看到这里，应该就能发现，对于这个自定义的对话框，我每次调用的时候都要去判断我需要的实例是否存在。而且例子中逻辑判断很简单，真正写的时候情况也许会更复杂，这也就意味着我每次用它都要写很多重复的代码，而这些代码仅仅是为了保证这个类只有一个实例。</p><p>所以对于这类情形，最好能有一个办法让类本身去控制自己只有一个实例，而不是让调用者每次都操心它。</p><p>但是类都有一个构造方法，即使不写它也会有一个默认的构造方法供外部调用，像<code>Java</code>的话，可以直接将构造方法改为私有，不给外部new出实例。对于<code>Objective-C</code>似乎并不能阻止你<code>alloc</code>一个实例对象，当然这并不是关键。下面才是。</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><blockquote><p>单例模式，保证一个类仅有一个实例，并提供一个访问它的全局访问点</p></blockquote><p>也就是说让类自身来负责保存它的唯一实例，保证没有其他实例被创建，并且提供一个访问该实例的方法。</p><p>所以关键点就是首先在类中创建一个静态全局变量，用来保存当前类的实例。然后创建一个获取该实例的类方法，在该方法中生成实例并保证其唯一即可。</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">///.h@interface MyManager : NSObject {  NSString *someProperty;}@property (nonatomic, retain) NSString *someProperty;+ (instancetype)sharedManager;@end///.m@implementation MyManager@synthesize someProperty;+ (instancetype)sharedManager {  static MyManager *sharedMyManager = nil;  if (nil == sharedMyManager)    sharedMyManager = [[self alloc] init];  return sharedMyManager;}- (instancetype)init {  if (self = [super init]) {    someProperty = @"Default Property Value";  }  return self;}@end///mainMyManager *manager1 = [[MyManager alloc] init];MyManager *manager2 = [MyManager sharedManager];MyManager *manager3 = [MyManager sharedManager];NSLog(@"manager1 %p", manager1);NSLog(@"manager2 %p", manager2);NSLog(@"manager3 %p", manager3);NSLog(@"Instance property: %@", manager2.someProperty);manager2.someProperty = @"Changed By manager2";NSLog(@"Instance property: %@", manager3.someProperty);</code></pre><p>通过程序，可以看到，创建了</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">static MyManager *sharedMyManager = nil;</code></pre><p>来保存实例，然后使用</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">+ (instancetype)sharedManager</code></pre><p>访问实例。</p><p>主程序输出为</p><pre class=" language-lang-bash"><code class="language-lang-bash">manager1 0x100300080manager2 0x1003000b0manager3 0x1003000b0Instance property: Default Property ValueInstance property: Changed By manager2</code></pre><p>通过指针地址可以看到，当前类是可以通过<code>alloc</code>创建一个不同实例，但通过sharedManager访问获得的实例是相同的，因此属性也是一致的。</p><h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/UML-singleton.png?raw=true" alt="UML"></p><h3 id="多线程时的单例"><a href="#多线程时的单例" class="headerlink" title="多线程时的单例"></a>多线程时的单例</h3><p>在多线程的情况下，上面的程序就无法保证实例的唯一性，多个线程同时访问MyManager类时，调用获取实例的方法就会创建出多个实例。<br>所以就要对代码加锁。这个原理就不讲了，操作系统都学过的。</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">+ (instancetype)sharedManager {  static MyManager *sharedMyManager = nil;  //使用GCD  static dispatch_once_t onceToken;  dispatch_once(&onceToken, ^{    sharedMyManager = [[self alloc] init];  });  //非GCD  @synchronized(self) {    if (nil == sharedMyManager)      sharedMyManager = [[self alloc] init];  }    return sharedMyManager;}</code></pre><p><code>Swift</code>版本</p><pre class=" language-lang-swift"><code class="language-lang-swift">class MyManager {    static private var onceToken: dispatch_once_t = 0    static private var sharedMyManager: MyManager? = nil    static func sharedMyManager() -> MyManager {        dispatch_once(&onceToken) {            sharedMyManager = MyManager()        }        return sharedMyManager!    }    private init() {} //私有化构造方法  外部无法构造}let single1 = MyManager.sharedMyManager()let single2 = MyManager.sharedMyManager()unsafeAddressOf(single1)unsafeAddressOf(single2)</code></pre><h3 id="单例模式的好处"><a href="#单例模式的好处" class="headerlink" title="单例模式的好处"></a>单例模式的好处</h3><ul><li>可以保证唯一的实例</li><li>严格控制他人怎样访问与何时访问</li><li>方便共享状态</li></ul><blockquote><p>参考<br><a href="http://www.galloway.me.uk/tutorials/singleton-classes/" target="_blank" rel="noopener">Singletons in Objective-C</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Design pattern </tag>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Objective-C] 常量和枚举</title>
      <link href="/2016/05/19/%5BObjective-C%5DCreate-Constants/"/>
      <url>/2016/05/19/%5BObjective-C%5DCreate-Constants/</url>
      
        <content type="html"><![CDATA[<p><strong><code>#define</code>宏定义</strong><br><code>#define</code>是一条预编译指令, 编译器在编译阶段前期会将所有使用到宏的地方简单地进行替换.</p><blockquote><p>在预处理器里进行文本替换，没有类型，不做任何类型检查，编译器可以对相同的字符串进行优化。只保存一份到 .rodata 段。甚至有相同后缀的字符串也可以优化，你可以用GCC 编译测试，”Hello world” 与 “world” 两个字符串，只存储前面一个。取的时候只需要给前面和中间的地址，如果是整形、浮点型会有多份拷贝，但这些数写在指令中。占的只是代码段而已，大量用宏会导致二进制文件变大</p></blockquote><p>但<code>#define</code>可以使用类型定义，比如</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">#define MY_INT_CONSTANT ((int)123)</code></pre><p><strong>const</strong><br>const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是象#define一样给出的是立即数，所以，const定义的常量在程序运行过程中只有一份拷贝，而#define定义的常量在内存中有若干个拷贝</p><p>如果在一个指定单一类里声明常量，在.m 文件顶端用 static const 声明</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">static NSString *const MyThingNotificationKey = @"MyThingNotificationKey";</code></pre><p>如果常量属于一个类，但又要其他类可以访问，在头文件将其声明为 extern ，在.m文件定义</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">//.hextern NSString *const MyThingNotificationKey;//.mNSString *const MyThingNotificationKey = @"MyThingNotificationKey";</code></pre><p>如果它们是全局的常量，在头文件声明，并在相应模块里定义。</p><p>只有公有的常量才需要添加命名空间作为前缀。尽管实现文件中私有常量的命名可以遵循另外一种模式，你仍旧可以遵循这个规则。</p><p><strong>enum</strong><br>enum拥有define和const两者的优点，不过enum只能定义整型常量。</p><p><strong>如何选择</strong><br>尽量选择使用const，因为编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率比宏定义要高。</p><p>相反，define占据更多的内存空间，因为它只是文字替换，导致存在过多的拷贝。当然这一点是对于一般类型的常量来说的。对于int型常量，引用const的地方拿到的是内存地址，地址数据和int差不多，所以内存上应该不会有太大区别。</p><p>另外，const对编译器和调试器来说更加友好。这一点可以作为一个很重要的参考。</p><p>记录比较粗略，只是简单整理一下网友讨论，这里用到的具体的语法还是要自己去研究，比如const <em>int 和 int </em>const的区别等。</p><hr><p>update at May 20</p><blockquote><p>关于命名规范<br>常量名（如宏定义、枚举、静态局部变量等）应该以小写字母<code>k</code>开头，使用驼峰格式分隔单词，如：<code>kInvalidHandle</code>,<code>kWritePerm</code>。<a href="http://zh-google-styleguide.readthedocs.io/en/latest/google-objc-styleguide/naming/#id10" target="_blank" rel="noopener">参考</a></p></blockquote><p>苹果官方文档介绍编码规范提到常量部分：<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingIvarsAndTypes.html#//apple_ref/doc/uid/20001284-1001783" target="_blank" rel="noopener">链接</a></p><ul><li>对于一组相关的整型常量，应使用枚举类型</li><li>使用const创建浮点型常量。如果这个常量与其他常量没有关联，也可以使用const创建整型常量，否则使用枚举</li><li>通常来说，不要使用#define创建常量，使用上两条</li></ul><hr><p>update at June 28</p><p>这里提到枚举类型，就在这里补充点内容吧。</p><p>Apple 文档： <a href="https://developer.apple.com/library/ios/releasenotes/ObjectiveC/ModernizationObjC/AdoptingModernObjective-C/AdoptingModernObjective-C.html#//apple_ref/doc/uid/TP40014150-CH1-SW6" target="_blank" rel="noopener">Adopting Modern Objective-C</a></p><p>对于 Objective-C 来说，枚举类型建议使用 <code>NS_ENUM</code> 和 <code>NS_OPTIONS</code> 宏。因为它们有更强大的类型检查和代码补全。此外，这个语法提供枚举的方式也兼容旧编译器，当然新编译器可以更好的解析出其隐含的类型信息。</p><ul><li>使用 <code>NS_ENUM</code> 宏定义枚举数据，其内容的值都是互斥的：</li></ul><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">typedef NS_ENUM(NSInteger, UITableViewCellStyle) {        UITableViewCellStyleDefault,        UITableViewCellStyleValue1,        UITableViewCellStyleValue2,        UITableViewCellStyleSubtitle};</code></pre><p><code>NS_ENUM</code> 宏不仅定义了枚举的名称(UITableViewCellStyle)，还定义了类型(NSInteger)，一般来说枚举的类型是 <code>NSInteger</code>。</p><ul><li><code>NS_OPTIONS</code> 宏定义选项类型，定义一组可以组合的位掩码值：</li></ul><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">typedef NS_OPTIONS(NSUInteger, UIViewAutoresizing) {        UIViewAutoresizingNone                 = 0,        UIViewAutoresizingFlexibleLeftMargin   = 1 << 0,        UIViewAutoresizingFlexibleWidth        = 1 << 1,        UIViewAutoresizingFlexibleRightMargin  = 1 << 2,        UIViewAutoresizingFlexibleTopMargin    = 1 << 3,        UIViewAutoresizingFlexibleHeight       = 1 << 4,        UIViewAutoresizingFlexibleBottomMargin = 1 << 5};</code></pre><p><code>NS_OPTIONS</code>的定义也包含名称和类型。一般来说选项的类型是 <code>NSUInteger</code>。</p><blockquote><p>选项和枚举的差别是枚举只能出现一项，选项可以出现一项或几项，所以选项使用位运算</p></blockquote><p><a href="http://stackoverflow.com/a/11154217/4522227" target="_blank" rel="noopener">#define vs const in Objective-C</a><br><a href="http://stackoverflow.com/a/17228508/4522227" target="_blank" rel="noopener">What is the best way to create constants in Objective-C</a></p>]]></content>
      
      
      <categories>
          
          <category> Syntax </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Objective-C </tag>
            
            <tag> define </tag>
            
            <tag> const </tag>
            
            <tag> enum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[设计模式]之二:策略模式</title>
      <link href="/2016/05/15/%5BDesign-Pattern%5DStrategy/"/>
      <url>/2016/05/15/%5BDesign-Pattern%5DStrategy/</url>
      
        <content type="html"><![CDATA[<p><strong><a href="http://wossoneri.github.io/categories/Design-pattern/">设计模式系列目录</a></strong></p><h3 id="需求情景"><a href="#需求情景" class="headerlink" title="需求情景"></a>需求情景</h3><p>比如现在需要做一个收银软件，要根据用户所买商品的单价和数量进行计算。</p><p>很简单，用“单价 * 数量”即可。</p><p>但如果某天需要打折呢？</p><p>也很简单，同一个方法，把折扣作为一个参数，默认值为1，代码改为“单价 <em> 数量 </em> 折扣”即可。</p><p>恩，看起来都很美好。现在又要加需求，我要满300减100，我还要满200送50…</p><p>OK，现在就得回到面向对象上来了。向上次简单工厂一样，把所有计算价格可能的方法封装成一个个类。比如一个打一折类，一个打两折类…唉等等，这可不对。上次加、减、乘、除分别封装是因为他们属于同一种类型，但是有不同的实现方法。而这次，对于打折来说，不论打几折，打折的计算方式都是一样的，只是形式不同，但本质是一样的。同理，满减和返利也是两种类型，但各自有多种实现。</p><blockquote><p>面向对象的编程，并不是类越多越好，类的划分是为了封装，但分类的基础是抽象，具有相同属性和功能的对象的抽象集合才是类</p></blockquote><p>所以可以开始编码，先抽象一个计算收款的类，抽象一个收钱的方法，然后根据不同打折类型实现不同的收钱方法。</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">@interface Cash : NSObject- (CGFloat)acceptOriginCash: (CGFloat)money;@end@implementation Cash- (CGFloat)acceptOriginCash: (CGFloat)money {    return money;}@end///正常价钱@implementation CashNormal- (CGFloat)acceptOriginCash:(CGFloat)money {    return money;}@end///折扣@interface CashRebate : Cash@property (nonatomic, assign) CGFloat rebate;@end@implementation CashRebate- (instancetype)init {    self = [super init];    if (self) {        _rebate = 1.0; //默认不打折    }    return self;}- (CGFloat)acceptOriginCash:(CGFloat)money {    return money * _rebate;}@end///满返@interface CashReturn : Cash@property (nonatomic, assign) CGFloat moneyCondition;@property (nonatomic, assign) CGFloat moneyReturn;@end@implementation CashReturn- (instancetype)init {    self = [super init];    if (self) {        _moneyReturn = 0;        _moneyCondition = 0;    }    return self;}- (CGFloat)acceptOriginCash:(CGFloat)money {    if (_moneyCondition == 0 || _moneyReturn == 0 || money < _moneyCondition) {        return money; //没有返现    } else {        int returnCount = floorf(money / _moneyCondition);        money -= returnCount * _moneyReturn;        return money;    }}@end</code></pre><p>创建好以上几种收费类型，设想一下，一般打折时都会列出相应的打折商品，也就是说平时不是所有的商品都打折，这时候假设我们专门写好一个折扣日的类，类中包含了打折商品列表，当然也包含了打折的方式等其他信息。继续用面向对象的思想去思考，折扣日应该也分好几种，比如周末，五一，工作日等等，所以折扣日也可以抽象一个基类出来，这个基类就应该包含<strong>返回折扣结果的抽象方法</strong>。</p><p>OK，到这里问题就来了，不同的折扣日都有相同的获取最终价钱的方法，而对于价钱的计算策略却完全不同，也就是每个具体的折扣日实现这个<strong>返回折扣结果的抽象方法</strong>都不一样。那该怎么做？</p><blockquote><p>设计原则：找到系统中变化的部分，将变化的部分同其它稳定的部分隔开。换句话说就是：”找到变化并且把它封装起来，稍后你就可以在不影响其它部分的情况下修改或扩展被封装的变化部分。”尽管这个概念很简单，但是它几乎是所有设计模式的基础，所有模式都提供了使系统里变化的部分独立于其它部分的方法。</p></blockquote><p>可以看出，每个折扣日都要实现基类返回折扣结果的方法，但实现的方法不一样。而计算方法都是经过了封装的，保证计算方法不被改变，也保证改变一个不会影响到其他计算方法。在这种情况下，就可以考虑使用策略模式。</p><hr><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>策略模式定义了算法家族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化不会影响到使用算法的客户。</p><p>以上几种收钱方式都是一些算法，算法本身只是一种策略，最重要的是这些算法是随时都可能且可以互相替换的，这就是变化点，而<strong>封装变化点</strong>是我们面向对象很重要的思维方式。</p><p>所以这里的思路是创建一个上下文类，用策略对象作为构造参数，来维护一个对策略对象的引用。同时这样也不会受到拓展的影响。</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">@interface CashContext : NSObject- (instancetype)initWithCash: (Cash *)cash;- (CGFloat)getResult: (CGFloat)money;@end///@interface CashContext(){    Cash *_cash;}@end@implementation CashContext- (instancetype)initWithCash: (Cash *)cash {    self = [super init];    if (self) {        _cash = cash;    }    return self;}- (CGFloat)getResult: (CGFloat)money {    return [_cash acceptOriginCash:money];}@end</code></pre><p>创建好Context类，就可以通过构造方法选择不同的策略来实现计算：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">CashContext *context = [[CashContext alloc] initWithCash:[[CashRebate alloc] initWithRebate:0.8]];//打8折CGFloat value = [context getResult:400]]//原价400</code></pre><hr><h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/UML-strategy.png?raw=true" alt="UML"></p><hr><h3 id="应用场景和优缺点"><a href="#应用场景和优缺点" class="headerlink" title="应用场景和优缺点"></a>应用场景和优缺点</h3><p>应用</p><ul><li>多个类只区别在表现行为不同，可以使用Strategy模式，在运行时动态选择具体要执行的行为。</li><li>需要在不同情况下使用不同的策略(算法)，或者策略还可能在未来用其它方式来实现。</li><li>对客户隐藏具体策略(算法)的实现细节，彼此完全独立。(你只要知道Context类的接口，不必知道折扣算法内部是怎么实现的)</li></ul><p>实际上，一些平时常见的方法就是用的策略模式，比如说Swift(很多其他语言也是)里的数组的<code>Sort</code>函数</p><pre class=" language-lang-swift"><code class="language-lang-swift">func biggerNumberFirst( a: Int, _ b: Int ) -> Bool {    return a > b}arr.sort(biggerNumberFirst)</code></pre><p><code>Sort</code>函数可以添加参数，上面代码中是我们自己定制一个策略，然后作为参数传给<code>Sort</code>去处理。当然也可以定制其他策略或者使用系统默认的一些策略去进行排序工作。这就是策略模式一个很典型的应用。</p><p>优点</p><ul><li>提供了一种替代继承的方法，而且既保持了继承的优点(代码重用)还比继承更灵活(算法独立，可以任意扩展)。</li><li>避免程序中使用多重条件转移语句，使系统更灵活，并易于扩展。</li><li>遵守大部分GRASP原则和常用设计原则，高内聚、低偶合。</li></ul><p>缺点</p><ul><li>因为每个具体策略类都会产生一个新类，所以会增加系统需要维护的类的数量。</li></ul><blockquote><p>参考<br><a href="http://www.cnblogs.com/justinw/archive/2007/02/06/641414.html" target="_blank" rel="noopener">鸭子-策略模式（Strategy）</a><br>这篇文章更深入形象，推荐阅读</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Design pattern </tag>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[设计模式]之一:简单工厂模式</title>
      <link href="/2016/05/13/%5BDesign-Pattern%5DSimple-Factory/"/>
      <url>/2016/05/13/%5BDesign-Pattern%5DSimple-Factory/</url>
      
        <content type="html"><![CDATA[<p><strong><a href="http://wossoneri.github.io/categories/Design-pattern/">设计模式系列目录</a></strong></p><h3 id="系列前言"><a href="#系列前言" class="headerlink" title="系列前言"></a>系列前言</h3><p>最近思考了一下这两年的工作：做Android的时候一直看Android知识，做iOS的时候一直学iOS的东西。其实看起来感觉这样没什么问题，但仔细想想，我发现自己一直忽略了一大片知识点，那就是软件工程。不同的语言，不同的开发方向的确在代码上有千差万别，但是回到软件架构上来看，所有的编程思想都是相通的，比如说算法，再比如说设计模式。算法这点可能在移动开发中用得较少，但设计模式是必不可少的。我回想了一下，虽说写了不少代码，也考虑过一些关于模块代码结构的设计，但还是缺乏对这一块的系统了解。所以就找了一本众人推荐的书——《大话设计模式》来看。这本书写的的确好，通俗易懂，所以在这里我也推荐一下。这本书看了几个章节我就有一种受人点拨的感觉，明显感觉到如果我把这本书吃透，编码水平肯定能提高一个level。想到我的读书列表还有几本受到程序员追捧的大作要看，突然有种迫不及待就要一本一本读下去的感觉。不过读书可不是读一遍就完事的，关键就在于悟。进步也不能急，一点一点来吧。加油！</p><hr><h3 id="23种设计模式"><a href="#23种设计模式" class="headerlink" title="23种设计模式"></a>23种设计模式</h3><p>关于设计模式最好的书应该是GoF的《设计模式》了，其中列出了23种设计模式，这里先列出来，后面写完对应博客会把这里改为文章链接方便查看。</p><ol><li><a href="http://wossoneri.github.io/2016/05/23/[Design-Pattern]Singleton/">Singleton 单例模式</a></li><li><a href="http://wossoneri.github.io/">Abstract Factory 抽象工厂模式</a></li><li><a href="http://wossoneri.github.io/">Builder 生成器模式</a></li><li><a href="http://wossoneri.github.io/">Factory Method 工厂方法模式</a></li><li><a href="http://wossoneri.github.io/">Prototype 原型模式</a></li><li><a href="http://wossoneri.github.io/">Adapter 适配器模式</a></li><li><a href="http://wossoneri.github.io/">Bridge 桥接模式</a></li><li><a href="http://wossoneri.github.io/">Composite 组合模式</a></li><li><a href="http://wossoneri.github.io/">Decorator 装饰模式</a></li><li><a href="http://wossoneri.github.io/">Facade 外观模式</a></li><li><a href="http://wossoneri.github.io/">Flyweight 享元模式</a></li><li><a href="http://wossoneri.github.io/">Proxy 代理模式</a></li><li><a href="http://wossoneri.github.io/">Template Method模板方法</a></li><li><a href="http://wossoneri.github.io/">Command 命令模式</a></li><li><a href="http://wossoneri.github.io/">Interpreter 解释器模式</a></li><li><a href="http://wossoneri.github.io/">Mediator 中介者模式</a></li><li><a href="http://wossoneri.github.io/">Iterator 迭代器模式</a></li><li><a href="http://wossoneri.github.io/">Observer 观察者模式</a></li><li><a href="http://wossoneri.github.io/">Chain Of Responsibility 职责链模式</a></li><li><a href="http://wossoneri.github.io/">Memento 备忘录模式</a></li><li><a href="http://wossoneri.github.io/">State 状态模式</a></li><li><a href="http://wossoneri.github.io/2016/05/15/[Design-Pattern]Strategy/">Strategy 策略模式</a></li><li><a href="http://wossoneri.github.io/">Visitor 访问者模式</a></li><li><a href="http://wossoneri.github.io/2016/05/16/[Design-Pattern]Principles/">Design Principles 设计原则</a></li></ol><hr><h3 id="实现四则运算"><a href="#实现四则运算" class="headerlink" title="实现四则运算"></a>实现四则运算</h3><p>下面直接先上代码，因为一开始就说太多概念容易让人看不下去。<br>对于四则运算，也就是简单的加减乘除，实现起来并不难，但我们要用面向对象的角度去思考代码。加减乘除属于四种不同且独立的功能，所以应该分别地实现与封装，这样修改代码的时候也会方便一些，不会误改其他功能的代码。<br>另外，对于这四种运算都有一个相同点，那就是运算都需要两个数字来完成，考虑到这一点，就可以设计一个基类，在基类中定义两个用于计算的变量，再声明一个获取计算结果的方法。之后，四则运算分别继承这个基类，各自实现返回结果的方法。</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">///Operation.h@interface Operation : NSObject@property (nonatomic, assign) CGFloat number1;@property (nonatomic, assign) CGFloat number2;- (CGFloat)getResult;@end///Operation.m@interface Operation : NSObject@property (nonatomic, assign) CGFloat number1;@property (nonatomic, assign) CGFloat number2;- (CGFloat)getResult;@end///OpAdd.h@interface OpAdd : Operation@end///OpAdd.m@implementation OpAdd- (CGFloat)getResult {    return self.number1 + self.number2;}@end///OpMns.m@implementation OpMns- (CGFloat)getResult {    return self.number1 - self.number2;}@end///OpMul.m@implementation OpMul- (CGFloat)getResult {    return self.number1 * self.number2;}@end///OpDiv.m@implementation OpDiv- (CGFloat)getResult {    if (self.number2 == 0) {        NSLog(@"除数不能为零");        return 0;    } else {        return self.number1 / self.number2;    }}@end</code></pre><p>好了，功能封装完毕，下面就可以直接用这些写好的功能了，比如我要做加法</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">Operation *operation = [OpAdd new];operation.number1 = 1;operation.number2 = 2;NSLog(@"operation result: %f", [operation getResult]);</code></pre><p>但这样做的话我每次做运算时都需要知道我到底要实例化谁。为了方便起见，可以设计一个工厂类，专门用来做这个实例化的过程，这就是简单工厂模式。</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">typedef NS_ENUM(int, TYPE_OPERATION) {    OPERATION_ADD = 0,    OPERATION_MNS,    OPERATION_MUL,    OPERATION_DIV};@interface OperationSimpleFactory : NSObject+ (Operation *)CreateOperationWithType:(enum TYPE_OPERATION)type;@end@implementation OperationSimpleFactory+ (Operation *)CreateOperationWithType:(enum TYPE_OPERATION)type {    Operation *op = nil;    switch (type) {        case OPERATION_ADD:            op = [OpAdd new];            break;        case OPERATION_MNS:            op = [OpMns new];            break;        case OPERATION_MUL:            op = [OpMul new];            break;        case OPERATION_DIV:            op = [OpDiv new];            break;        default:            break;    }    return op;}@end</code></pre><p>设计好工厂就可以直接使用工厂类实例化合适的对象，通过多态，返回父类的方式实现运算。</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">int main(int argc, const char * argv[]) {    @autoreleasepool {        // insert code here...        Operation *op = [OperationSimpleFactory CreateOperationWithType:OPERATION_ADD];        op.number1 = 10;        op.number2 = 20;        NSLog(@"operation result: %f", [op getResult]);    }    return 0;}</code></pre><p>这里工厂类的<code>CreateOperationWithType:</code>方法是类方法，所以使用的时候不需要实例化工厂类，直接使用该方法传入参数就能够获得对应的运算实例。</p><p>但对于这段代码，如果我想要增加一个新的计算方法，比如用两个数字取log，这样我就需要首先创建一个计算log的功能类，然后修改工厂类的代码，增加一个switch分支。但是修改工厂类并不符合<strong>开放封闭原则</strong>，这里可以使用<strong>反射机制</strong>进行处理。</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">static NSString *kOperationAdd = @"OpAdd";static NSString *kOperationMns = @"OpMns";static NSString *kOperationMul = @"OpMul";static NSString *kOperationDiv = @"OpDiv";@interface OperationSimpleFactory : NSObject+ (Operation *)CreateOperationWithType:(NSString *)type;@end@implementation OperationSimpleFactory+ (Operation *)CreateOperationWithType:(NSString *)type {      return [NSClassFromString(type) new]; }@end</code></pre><p>这里定义几个字符串常量，字符串内容和功能类名保持一致，将字符串作为参数即可。</p><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>简单工厂模式中定义一个抽象类，抽象类中声明公共的特征及属性，抽象子类继承自抽象类，去实现具体的操作。工厂类根据外界需求，在工厂类中创建对应的抽象子类实例并传给外界，而对象的创建是由外界决定的。外界只需要知道抽象子类对应的参数即可，而不需要知道抽象子类的创建过程，在外界使用时甚至不用引入抽象子类。</p><p>简单工厂模式将操作对象的创建，和关于操作对象相关的业务逻辑分离开，降低操作对象的耦合度。由于工厂类只是为外界创建对象，所以并不需要实例化工厂类对象，只需要为外界提供类方法即可。外界需要什么类型的抽象子类，只需要传递对应的参数即可。</p><h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/UML-simple-factory.png?raw=true" alt="UML"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>在简单工厂模式中，一个工厂类负责所有产品对象的创建，这个工厂类的职责大大增加，可能客户端对于某些产品的创建方式会有不同的要求，这样的话，就要不断的修改工厂类，增加相应的逻辑，不利于后期的代码维护。<br>另外，由于简单工厂模式使用静态方法创建，这就导致静态方法无法被继承。<br>所以，简单工厂模式适用于创建的对象比较少或简单的情况。</p><h3 id="Swift代码"><a href="#Swift代码" class="headerlink" title="Swift代码"></a>Swift代码</h3><p>因为最近也在看Swift，所以会用Swift做一些练习练习</p><pre class=" language-lang-swift"><code class="language-lang-swift">class Operation {    var number1: CGFloat = 0.0    var number2: CGFloat = 0.0    func getResult() -> CGFloat {        return 0    }}class OpAdd: Operation {    override func getResult() -> CGFloat {        return self.number1 + self.number2    }}class OpMns: Operation {    override func getResult() -> CGFloat {        return self.number1 - self.number2    }}class OpMul: Operation {    override func getResult() -> CGFloat {        return self.number1 * self.number2    }}class OpDiv: Operation {    override func getResult() -> CGFloat {        if self.number2 == 0 {            print("除数不得为零")            return 0        } else {            return self.number1 / self.number2        }    }}enum OperationType {    case OperationAdd    case OperationMns    case OperationMul    case OperationDiv}class OperationSimpleFactory {    static func CreateOperationWithType(type: OperationType) -> Operation {        var operation: Operation        switch type {        case .OperationAdd:            operation = OpAdd()        case .OperationMns:            operation = OpMns()        case .OperationMul:            operation = OpMul()        case .OperationDiv:            operation = OpDiv()        }        return operation    }}let op: Operation = OperationSimpleFactory.CreateOperationWithType(OperationType.OperationAdd)op.number1 = 10op.number2 = 20print("result by Add is", op.getResult())</code></pre>]]></content>
      
      
      <categories>
          
          <category> Design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Design pattern </tag>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[设计模式]之零：六大设计原则</title>
      <link href="/2016/05/12/%5BDesign-Pattern%5DPrinciples/"/>
      <url>/2016/05/12/%5BDesign-Pattern%5DPrinciples/</url>
      
        <content type="html"><![CDATA[<p><strong><a href="http://wossoneri.github.io/categories/Design-pattern/">设计模式系列目录</a></strong></p><h3 id="单一职责原则-Single-Responsibility-Principle-SRP"><a href="#单一职责原则-Single-Responsibility-Principle-SRP" class="headerlink" title="单一职责原则 Single Responsibility Principle - SRP"></a>单一职责原则 Single Responsibility Principle - SRP</h3><blockquote><p>就一个类而言，应该仅有一个引起它变化的原因。</p></blockquote><p>假设现在要在iPhone上做一个图片编辑工具。功能有裁剪图片，旋转图片，缩放移动照片等等。</p><p>呐，我们可以写一个功能集类，然后把这些所有操作视为功能集的一部分，把代码全部写进这个类里面。</p><p>这么看来似乎可以，因为这是作为一个单独的模块嘛，把相关功能写进一个工具类里，用哪个功能调用哪个函数就好了。但这带来了一个问题就是这个工具类包含过多功能显得非常臃肿，不容易维护。而且在一个类里往往容易出现几个函数共用一个全局变量的情况，功能之间耦合度太大，难以复用。</p><p>举个最直接的例子：如果我想把这个功能移植到Android上去怎么办。这个移植过程麻烦之处并不在于语言语法变化，而是两个系统有着完全不同的手势传递机制，我要用手旋转，缩放图片这段代码完全没法复用，唯一能用的裁剪代码，也可能因为和其他代码耦合过大导致需要重新修改，退一步说，裁剪算法就算没有耦合，代码可以直接用，但关系到手势的代码对我来说都成为冗余代码，这对于代码复用就是灾难。</p><blockquote><p>如果一个类承担的职责过多，就等于把这些职责偶合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。</p></blockquote><p>所以这里在设计的时候，就要考虑一下把这些功能分类。比如裁剪功能需要知道裁剪框大小，位置。那就分离出一个类，专门负责计算裁剪框四个点的坐标变化。旋转缩放图片需要知道图片的大小，缩放率，显示方向等信息，那就再分离出一个类，负责计算图片形态的变化。最后剩下手势再封装一个类，处理手势的逻辑，在不同情况下获取不同的手势数据，作为参数交给上面两个算法类进行计算输出。</p><p>这样一来，每个类的职责就变得单一了，维护就容易多了。后面再移植代码的话，算法类只需要切换语法，手势类只要去重写触发手势的条件，而不必修改逻辑。代码很快就可以改好，并且不会破坏原有的项目结构。</p><blockquote><p>软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。判断是否要分离出类的方法就是，如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责，就应该考虑类的职责分离。</p></blockquote><p><strong>优点</strong></p><ul><li>可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多</li><li>提高类的可读性，提高系统的可维护性</li><li>变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响</li></ul><hr><h3 id="里氏替换原则-Liskov-Substitution-Principle-LSP"><a href="#里氏替换原则-Liskov-Substitution-Principle-LSP" class="headerlink" title="里氏替换原则 Liskov Substitution Principle - LSP"></a>里氏替换原则 Liskov Substitution Principle - LSP</h3><blockquote><p>子类型必须能够替换掉他们的父类型</p></blockquote><p>通俗的讲，一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。即，在软件里，把父类都替换成它的子类，程序的行为没有变化。</p><p>里氏替换原则的重点在不影响原功能，而不是不覆盖原方法。</p><p>所以正常遵从该原则的处理办法是在需要覆盖父类方法时应该首先考虑使用super调用父类的同名方法以保证父类同名方法会被调用。</p><p>如果确实不需要调用父类方法，则不加此语句。</p><p>这个原则很重要，编码时要注意。</p><hr><h3 id="依赖倒置原则-Dependence-Inversion-Principle-DIP"><a href="#依赖倒置原则-Dependence-Inversion-Principle-DIP" class="headerlink" title="依赖倒置原则 Dependence Inversion Principle - DIP"></a>依赖倒置原则 Dependence Inversion Principle - DIP</h3><blockquote><p>抽象不应该依赖细节，细节应该依赖抽象</p></blockquote><p>通俗的说，就是要<strong>针对接口编程，不要对实现编程</strong>。呐，比如说电脑主板，CPU，内存，硬盘这些硬件的设计就是依赖接口设计的。单拿CPU来说，CPU有各种厂家设计的各种型号，这些型号的内部设计实现都不相同，但他们的接口是一样的，这样主板就可以随意更换CPU了。</p><p>关于倒置，比如说我有一个高层模块，模块实现对SQLite读写的功能依赖一个控制访问SQLite的低层模块。一旦我要求把SQLite改为MySQL，那这个低层模块就无法正常工作，进而倒置上层模块也无法正常工作。依赖倒置就是说设计代码不再是上层依赖下层，而是两层都去依赖接口去实现，这样两层的运行状态便不会互相影响。</p><blockquote><p>依赖倒转其实可以说是面向对象设计的标志，用哪种语言来编写程序不重要，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，即程序中所有的依赖关系都是终止于抽象类或者接口，那就是面向对象的设计，反之那就是过程化的设计了。</p></blockquote><p>依赖倒置原则的实现可以参考策略模式：<a href="http://www.wossoneri.com/2016/05/15/[Design-Pattern]Strategy/" target="_blank" rel="noopener">设计模式之二:策略模式</a><br>例子中的收取现金的不同方式可以看做CPU的不同型号。调用收现金的方法可看做主板插上不同型号的CPU。就是这么个思想。</p><blockquote><p>遵循依赖倒置原则可以降低类之间的耦合性，提高系统的稳定性，降低修改程序造成的风险。</p></blockquote><p>根据该原则，编程中要注意</p><ul><li>低层模块尽量都要有抽象类或接口，或者两者都有</li><li>变量的声明类型尽量是抽象类或接口</li><li>使用继承时遵循里氏替换原则</li></ul><hr><h3 id="接口隔离原则-Interface-Segregation-Principle-ISP"><a href="#接口隔离原则-Interface-Segregation-Principle-ISP" class="headerlink" title="接口隔离原则 Interface Segregation Principle - ISP"></a>接口隔离原则 Interface Segregation Principle - ISP</h3><blockquote><p>客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上</p></blockquote><p>看图，图一是未遵循该原则的结构：<br><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/ISP1.jpg?raw=true" alt="未遵循ISP"><br><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/ISP2.jpg?raw=true" alt="遵循ISP"></p><p>接口隔离原则的含义是：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。</p><p>接口是设计时对外部设定的“契约”，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</p><p>注意事项</p><ul><li>接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度</li><li>为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系</li><li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情</li></ul><hr><h3 id="迪米特法则-Law-Of-Demeter-LOD"><a href="#迪米特法则-Law-Of-Demeter-LOD" class="headerlink" title="迪米特法则 Law Of Demeter - LOD"></a>迪米特法则 Law Of Demeter - LOD</h3><blockquote><p>一个对象应该对其他对象保持最少的了解。</p></blockquote><p>如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法，可以通过第三者转发这个调用。</p><p>迪米特法则首先强调的前提是在<strong>类的结构设计上，每一个类应当尽量降低成员的访问权限</strong>，也就是要降低类之间的耦合。类之间的耦合越弱，越有利于复用，修改类相互之间的影响也会降到最低。</p><p>迪米特法则还有一个更简单的定义：只与<strong>直接的朋友</strong>通信。首先来解释一下什么是直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友。也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部。</p><p>迪米特法则的初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系。但是凡事都有度，虽然可以避免与非直接的类通信，但是要通信，必然会通过一个“中介”来发生联系，例如本例中，总公司就是通过分公司这个“中介”来与分公司的员工发生联系的。过分的使用迪米特原则，会产生大量这样的中介和传递类，导致系统复杂度变大。所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。</p><hr><h3 id="开闭原则-Open-Close-Principle-OCP"><a href="#开闭原则-Open-Close-Principle-OCP" class="headerlink" title="开闭原则 Open Close Principle - OCP"></a>开闭原则 Open Close Principle - OCP</h3><blockquote><p>软件实体（类，模块，函数等）应该可以拓展，但是不可修改</p></blockquote><p>这个原则有两点：</p><ul><li>对于拓展是开放的 Open for extension</li><li>对于更改是封闭的 Closed for modification</li></ul><p>在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。所以当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</p><p>但在设计软件的时候，无论模块是多么的封闭，都会存在无法对之封闭的变化，因为你不可能在编码前就考虑到所有情况。所以在设计代码时就必须先猜测出最可能发生变化的种类，然后构造抽象来隔离变化。在编码之后，一旦遇到发生变化的地方，那就应该首先考虑要不要对这里进行结构的修改。也就是<strong>遇到变化发生时要立即采取行动</strong>。</p><p>比如现在在客户端类中写了一个加法程序，后来说要增加减法，那么这时就应该立即抽象出来一个运算类。虽然说直接在客户端增加减法算法很快，但考虑到以后也许会拓展更多的算法，而且代码改得越晚修改代码的范围就越大。立即修改代码结构的代价似乎比以后去改的代价要小很多。</p><blockquote><p>我们希望的是在开发工作展开不久就知道可能发生的变化。查明可能发生的变化所等待的时间越长，要创建正确的抽象就越困难<br>开放-封闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护，可拓展，可复用，灵活性好。开发人员应该对程序中呈现出频繁变化的那些部分作出抽象，然而，对于应用程序中的每个部分都刻意地进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要。</p></blockquote><hr><blockquote><p>参考<br><a href="http://blog.csdn.net/zhengzhb/article/category/926691/" target="_blank" rel="noopener">http://blog.csdn.net/zhengzhb/article/category/926691/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Design pattern </tag>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[iOS] WSHorizontalPickerView 图片水平滚动封装</title>
      <link href="/2016/05/05/%5BiOS%5DWSHorizontalPickerView/"/>
      <url>/2016/05/05/%5BiOS%5DWSHorizontalPickerView/</url>
      
        <content type="html"><![CDATA[<p>之前这篇文章<a href="http://www.wossoneri.com/2016/01/09/[iOS]%20UICollectionView%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E6%B0%B4%E5%B9%B3%E6%BB%9A%E5%8A%A8/" target="_blank" rel="noopener">传送门</a>本来是记录自己练手的demo的，后来很多人来问我要代码。今天就抽时间封装了一下，没有考虑太多情况，等我有空再去仔细考虑吧。</p><p>代码在：<a href="https://github.com/wossoneri/WSHorizontalPickerView" target="_blank" rel="noopener">Github</a></p><p>用法很简单，创建对象，设置数据源，记得使用前updateData()就可以了。</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">    WSHorizontalPickerView *WSHPickerView = [[WSHorizontalPickerView alloc] initWithFrame:CGRectMake(0, 150, self.view.frame.size.width, 150)];    WSHPickerView.itemTitles = itemNames;    WSHPickerView.images = imageNames;    WSHPickerView.delegate = self;    [WSHPickerView updateData];    [self.view addSubview:WSHPickerView];</code></pre><p>里面一些常量我是按照我的demo图片64*64大小去写的，还没改。我这两天会考虑考虑把自定义cell提出来，作为参数重新封装一下。</p><p>反正要代码的就先到这里看吧…<br>我最近真的很忙…闲下来再更新接口，也会对应更新readme文件…和这篇博客…</p>]]></content>
      
      
      <categories>
          
          <category> iOS入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> UICollectionView </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[iOS] 技术文章收藏</title>
      <link href="/2016/05/04/%5BiOS%5DCollection-of-Articles/"/>
      <url>/2016/05/04/%5BiOS%5DCollection-of-Articles/</url>
      
        <content type="html"><![CDATA[<p>现在关注了一些微博，订阅号，博客。每天都能看到不少好文章。现在收藏夹里放了不少文章，我觉得是时候整理一下，把文章分各类，做个目录出来，方便以后查阅。</p><h3 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h3><p><a href="http://zh-google-styleguide.readthedocs.io/en/latest/google-objc-styleguide/" target="_blank" rel="noopener">Google开源项目风格指南—O-C风格指南</a></p><h3 id="MRC-amp-ARC-amp-Run-Loop"><a href="#MRC-amp-ARC-amp-Run-Loop" class="headerlink" title="MRC &amp; ARC &amp; Run Loop"></a>MRC &amp; ARC &amp; Run Loop</h3><p><a href="http://tutuge.me/2015/03/17/what-is-autoreleasepool/" target="_blank" rel="noopener">@autoreleasepool-内存的分配与释放</a><br><a href="http://www.samirchen.com/ios-arc/" target="_blank" rel="noopener">iOS ARC 内存管理要点</a></p><h3 id="Block-amp-Runtime"><a href="#Block-amp-Runtime" class="headerlink" title="Block &amp; Runtime"></a>Block &amp; Runtime</h3><p><a href="http://www.samirchen.com/block-in-objc/" target="_blank" rel="noopener">Block</a><br><a href="http://ios.jobbole.com/84672/" target="_blank" rel="noopener">详解 Objective-C 中的 Runtime</a><br>这篇讲block实现 很详细<a href="https://www.zybuluo.com/MicroCai/note/51116" target="_blank" rel="noopener">block没那么难（一）：block的实现</a></p><h3 id="About-Memory"><a href="#About-Memory" class="headerlink" title="About Memory"></a>About Memory</h3><p><a href="http://ios.jobbole.com/86324/" target="_blank" rel="noopener">alloc、init你弄懂50%了吗？</a></p><h3 id="APNS"><a href="#APNS" class="headerlink" title="APNS"></a>APNS</h3><p><a href="http://my.oschina.net/hejunbinlan/blog/494721#navbar-header" target="_blank" rel="noopener">手把手教你配置苹果APNS推送服务</a>  超详细</p>]]></content>
      
      
      <categories>
          
          <category> iOS入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[闲谈] 有经验的程序员用Google用得多么？</title>
      <link href="/2016/05/04/%5B%E9%97%B2%E8%B0%88%5DDoes-experienced-programmer-use-google-frequently/"/>
      <url>/2016/05/04/%5B%E9%97%B2%E8%B0%88%5DDoes-experienced-programmer-use-google-frequently/</url>
      
        <content type="html"><![CDATA[<p>关于程序员有没有必要记一些API什么的讨论有很多，我个人觉得能Google到的就没必要刻意去记，可以简单的做个笔记，需要用的时候查一下就好了。真正有必要记的东西，用得多了自然也就能记住了。<br>文章不难，不浪费时间翻译了。<a href="http://codeahoy.com/2016/04/30/do-experienced-programmers-use-google-frequently/" target="_blank" rel="noopener">原文链接</a></p><p>Software developers, especially those who are new to the field, often <a href="http://two-wrongs.com/how-much-does-an-experienced-programmer-use-google" target="_blank" rel="noopener">ask</a> this question or at least <a href="http://www.hanselman.com/blog/AmIReallyADeveloperOrJustAGoodGoogler.aspx" target="_blank" rel="noopener">wonder</a> whether they are good developers or just good at googling up solutions.</p><p><strong>“Do experienced programmers use Google frequently?”</strong></p><p>The resounding answer is <strong>YES, experienced (and good) programmers use Google… a lot.</strong> In fact, one might argue they <strong>use it more than the beginners.</strong> （有经验的程序员经常用Google，并且比初级程序员用的多得多） Using Google doesn’t make them bad programmers or imply that they cannot code without Google. In fact, truth is quite the opposite: Google is an essential part of their software development toolkit and they know when and how to use it.</p><p>A big reason to use Google is that it is hard to remember all those minor details and nuances especially when you are programming in multiple languages and using dozens of frameworks. As Einstein said:</p><blockquote><p>“Never memorize something that you can look up.” - Albert Einstein（绝不要去死记硬背那些可随手能查阅到的东西  爱因斯坦）</p></blockquote><p>Aside from that, good programmers also know that they cannot be the first one to have encountered a problem. They use Google to <strong>research</strong> possible solutions, carefully evaluating the results and consciously separating the wheat from the chaff; they <strong>don’t blindly follow or copy-paste</strong> any solution they come across. Expert programmers are also paranoid, living in self-doubt and <a href="http://blog.valbonne-consulting.com/2014/08/16/the-imposter-syndrome-in-software-development/" target="_blank" rel="noopener">questioning their competence</a>. Whenever their spidey senses start tingling, they know they may be going the wrong hole; they rely on Google on validate their logic.<br>（不要盲目的复制粘贴代码，要去思考评估别人的代码，然后提炼出你需要的东西）</p><p>Going by the definition, I would be considered an experienced programmer. Recently, I had to write web server using <a href="http://netty.io/" target="_blank" rel="noopener">Netty</a> in Java to handle persistent sockets from mobile games. I had never used Netty before. Here are my Google searches I did:</p><pre class=" language-lang-bash"><code class="language-lang-bash">1. netty tutorial 2. netty maven dependency 3. netty bytebuf to string 4. netty bytebuf release 5. netty 4 changes 6. setOption("child.bufferFactory") netty 4 7. ByteBuf netty 8. opensource projects using netty framework 9. netty 4 examples 10. netty 4 adding json encoder 11. netty channel pipeline 12. netty 4 messagetomessage encoder 13. netty serverbootstrap childhandler 14. ByteBuf netty 15. lengthfieldbasedframedecoder netty 4 16. netty 4 client examples 17. netty 4 bytebuf to bytebuffer 18. netty 4 endianness 19. netty channelhandlercontext 20. netty channelhandlercontext thread safe 21. netty user authentication 22. netty heartbeat handling 23. load test netty with 10k concurrent sockets</code></pre><p>I wrote 255 lines of code that included a working server and a client. I queried google 23 times mostly landing on StackOverflow, Netty 4 website, GitHub, and JavaDocs. If you do the math, that averages out to <strong>1 query every 10 lines of code</strong>! I had no idea. Let me know in the <strong>comments what your average is</strong>.</p><p>So sit back, relax and remember that <strong>Google is software developer’s best friend</strong>.（记住 谷歌永远是开发者最好的伙伴）</p>]]></content>
      
      
      <categories>
          
          <category> 闲谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲谈 </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Objective-C] KVC 和 KVO</title>
      <link href="/2016/04/29/%5BObjective-C%5DKVC-and-KVO/"/>
      <url>/2016/04/29/%5BObjective-C%5DKVC-and-KVO/</url>
      
        <content type="html"><![CDATA[<h3 id="KVC-Key-Value-Coding"><a href="#KVC-Key-Value-Coding" class="headerlink" title="KVC Key Value Coding"></a>KVC Key Value Coding</h3><p><code>KVC</code>是一种用间接方式访问类的属性的机制。比如你要给一个类中的属性赋值或者取值，可以直接通过类和点运算符实现，当然也可以使用<code>KVC</code>。不过对于私有属性，点运算符就不起作用，因为私有属性不暴露给调用者，不过使用<code>KVC</code>却依然可以实现对私有属性的读写。</p><p>先看一下<code>KVC</code>的一部分源码，当然只能看到头文件：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">// NSKeyValueCoding.h@interface NSObject(NSKeyValueCoding)+ (BOOL)accessInstanceVariablesDirectly;- (nullable id)valueForKey:(NSString *)key;- (void)setValue:(nullable id)value forKey:(NSString *)key;- (BOOL)validateValue:(inout id __nullable * __nonnull)ioValue forKey:(NSString *)inKey error:(out NSError **)outError;- (NSMutableArray *)mutableArrayValueForKey:(NSString *)key;- (NSMutableOrderedSet *)mutableOrderedSetValueForKey:(NSString *)key NS_AVAILABLE(10_7, 5_0);- (NSMutableSet *)mutableSetValueForKey:(NSString *)key;- (nullable id)valueForKeyPath:(NSString *)keyPath;- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;- (BOOL)validateValue:(inout id __nullable * __nonnull)ioValue forKeyPath:(NSString *)inKeyPath error:(out NSError **)outError;- (NSMutableArray *)mutableArrayValueForKeyPath:(NSString *)keyPath;- (NSMutableOrderedSet *)mutableOrderedSetValueForKeyPath:(NSString *)keyPath NS_AVAILABLE(10_7, 5_0);- (NSMutableSet *)mutableSetValueForKeyPath:(NSString *)keyPath;- (nullable id)valueForUndefinedKey:(NSString *)key;- (void)setValue:(nullable id)value forUndefinedKey:(NSString *)key;- (void)setNilValueForKey:(NSString *)key;- (NSDictionary<NSString *, id> *)dictionaryWithValuesForKeys:(NSArray<NSString *> *)keys;- (void)setValuesForKeysWithDictionary:(NSDictionary<NSString *, id> *)keyedValues;@end@interface NSArray<ObjectType>(NSKeyValueCoding)- (id)valueForKey:(NSString *)key;- (void)setValue:(nullable id)value forKey:(NSString *)key;@end@interface NSDictionary<KeyType, ObjectType>(NSKeyValueCoding)- (nullable ObjectType)valueForKey:(NSString *)key;@end@interface NSMutableDictionary<KeyType, ObjectType>(NSKeyValueCoding)- (void)setValue:(nullable ObjectType)value forKey:(NSString *)key;@end@interface NSOrderedSet<ObjectType>(NSKeyValueCoding)- (id)valueForKey:(NSString *)key NS_AVAILABLE(10_7, 5_0);- (void)setValue:(nullable id)value forKey:(NSString *)key NS_AVAILABLE(10_7, 5_0);@end@interface NSSet<ObjectType>(NSKeyValueCoding)- (id)valueForKey:(NSString *)key;- (void)setValue:(nullable id)value forKey:(NSString *)key;@end</code></pre><p>可以看到这个类里面包含了对类<code>NSObject</code>,<code>NSArray</code>,<code>NSDictionary</code>,<code>NSMutableDictionary</code>,<code>NSOrderedSet</code>,<code>NSSet</code>的拓展。拓展的方法基本上为</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">- (id)valueForKey:(NSString *)key;- (void)setValue:(nullable id)value forKey:(NSString *)key;</code></pre><p>也就是说，基本上Objective-C里所有的对象都支持<code>KVC</code>操作，操作包含如上两类方法，动态读取和动态设值。</p><blockquote><p>好多地方说是NSObject实现了NSKeyValueCoding协议。而代码里是类的拓展。这两种说法是相通的嘛？</p></blockquote><p>举个🌰，新建一个Command line程序：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">// Account.h@interface Account : NSObject@property (nonatomic, assign) float balance;@end// Account.m@implementation Account {    float salaryPerDay;}@synthesize balance = _balance;- (void)setBalance:(float)balance {    NSLog(@"set balance invoked");    _balance = balance;}- (float)balance {    NSLog(@"get balance invoked");    return _balance;}@end// Person.h@class Account;@interface Person : NSObject {    @private    int _age;}@property (nonatomic, copy) NSString *name;@property (nonatomic, retain) Account *account;- (void)showMessage;@end// Person.m#import "Person.h"@implementation Person {    NSString *_sex;}- (void)showMessage {    NSLog(@"name = %@, age = %d, sex = %@", _name, _age, _sex);}@end// mainint main(int argc, const char * argv[]) {    @autoreleasepool {        Person *person1 = [[Person alloc] init];        [person1 setValue:@"Wossoneri" forKey:@"name"];        [person1 setValue:@25 forKey:@"age"];       //私有变量也可以访问        [person1 setValue:@"male" forKey:@"sex"];   //私有变量也可以访问        [person1 showMessage];        Account *account1 = [[Account alloc] init];        person1.account = account1;        [person1 setValue:@1000.0 forKeyPath:@"account.balance"];        [person1 setValue:@300.0 forKeyPath:@"account.salaryPerDay"];        NSLog(@"Person1`s balance is : %.2f", [[person1 valueForKeyPath:@"account.balance"] floatValue]);        NSLog(@"Person1`s salary is : %.2f", [[person1 valueForKeyPath:@"account.salaryPerDay"] floatValue]);    }    return 0;}// 输出name = Wossoneri, age = 25, sex = maleset balance invokedget balance invokedPerson1`s balance is : 1000.00Person1`s salary is : 300.00</code></pre><p>代码说明：</p><ul><li>Person类里用旧方法声明私有变量<code>_age</code>以及直接添加的私有成员变量<code>_sex</code>，同时声明一个开放的属性<code>_name</code>。</li><li>对于<code>_name</code>，O-C会直接为其生成对应的<code>setter</code>和<code>getter</code>，所以可以通过点运算符操作属性，比如<pre class=" language-lang-objectivec"><code class="language-lang-objectivec">person1.name = @"Wossoneri";</code></pre></li><li>可以看到<code>KVC</code>可以对私有变量进行操作。对于当前类的直接成员变量，把变量名作为key来访问，否则要写成keyPath来访问。</li><li><code>KVC</code>运行时首先会优先调用属性的<code>getter</code>和<code>setter</code>，这一点可以在代码输出的第二行和第三行看到，如果没有，就会优先搜索<code>_property</code>，不存在则搜索<code>property</code>，如果仍然没有，就会调用<code>setValue:forUndefinedKey:</code>和<code>valueForUndefinedKey:</code>方法</li></ul><h3 id="KVO-Key-Value-Observing"><a href="#KVO-Key-Value-Observing" class="headerlink" title="KVO Key Value Observing"></a>KVO Key Value Observing</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p><code>KVO</code>其实是一种观察者模式，利用它可以很容易实现视图组件和数据模型的分离，当数据模型的属性值改变之后作为监听器的视图组件就会被激发，激发时就会回调监听器自身。</p><p>更通俗的话来说就是<strong>任何对象都允许观察其他对象的属性，并且可以接收其他对象状态变化的通知</strong>。</p><p><code>&lt;NSKeyValueObserving&gt;</code> 或者 <code>KVO</code> 是一个非正式的协议，该协议定义了一个观察和通知对象之间状态变化的通用机制。作为一个非正式的协议，你在使用该协议的类中看不到惯用的写法<code>&lt;NSKeyValueObserving&gt;</code>，实际上，这个协议只是隐式地由<code>NSObject</code>实现，继承<code>NSObject</code>的子类默认能够使用这个协议。</p><p>放一部分NSKeyValueObserving.h对于<code>NSObject</code>的拓展代码</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">@interface NSObject(NSKeyValueObserving)- (void)observeValueForKeyPath:(nullable NSString *)keyPath ofObject:(nullable id)object change:(nullable NSDictionary<NSString*, id> *)change context:(nullable void *)context;@end@interface NSObject(NSKeyValueObserverRegistration)- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context;- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath context:(nullable void *)context NS_AVAILABLE(10_7, 5_0);- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath;@end</code></pre><p>从拓展名称就可以看出，使用<code>KVO</code>需要注册监听器，也需要删除监听器。监听过程需要使用<code>observeValueForKeyPath</code>回调方法。<br>所以使用方法就可以推测出个大概来：</p><ol><li>addObserver方法注册一个监听器</li><li>复写observeValueForKeyPath回调，获得监听到的信息，做对应操作。</li><li>使用结束removeObserver，这很重要。</li></ol><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>最后对上面代码做一些改动，我需要对Account对象的balance做监听，当balance内容改变，我要做输出处理。</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">#pragma mark - For KVO- (void)setAccount:(Account *)account {    _account = account;    //add observer    [_account addObserver:self               forKeyPath:@"balance"                  options:NSKeyValueObservingOptionNew                  context:nil];}//override- (void)observeValueForKeyPath:(NSString *)keyPath                      ofObject:(id)object                        change:(NSDictionary<NSString *,id> *)change                       context:(void *)context {    if ([keyPath isEqualToString:@"balance"]) {        NSLog(@"keyPath = %@, object = %@, newValue = %.2f, context = %@", keyPath, object, [[change objectForKey:@"new"] floatValue], context);    }}- (void)dealloc {    [_account removeObserver:self forKeyPath:@"balance"];}//mainint main(int argc, const char * argv[]) {    @autoreleasepool {        Person *person1 = [[Person alloc] init];        [person1 setValue:@"Wossoneri" forKey:@"name"];        [person1 setValue:@25 forKey:@"age"];       //私有变量也可以访问        [person1 setValue:@"male" forKey:@"sex"];   //私有变量也可以访问        [person1 showMessage];        Account *account1 = [[Account alloc] init];        person1.account = account1;        [person1 setValue:@1000.0 forKeyPath:@"account.balance"];        [person1 setValue:@300.0 forKeyPath:@"account.salaryPerDay"];        //KVO        account1.balance = 4000.0;        NSLog(@"Person1`s balance is : %.2f", [[person1 valueForKeyPath:@"account.balance"] floatValue]);        NSLog(@"Person1`s salary is : %.2f", [[person1 valueForKeyPath:@"account.salaryPerDay"] floatValue]);}// 输出name = Wossoneri, age = 25, sex = maleset balance invokedget balance invokedkeyPath = balance, object = <Account: 0x1003001d0>, newValue = 1000.00, context = (null)set balance invokedget balance invokedkeyPath = balance, object = <Account: 0x1003001d0>, newValue = 4000.00, context = (null)get balance invokedPerson1`s balance is : 4000.00Person1`s salary is : 300.00</code></pre><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>当有属性改变，<code>KVO</code>会提供自动的消息通知。这样的架构有很多好处。首先，开发人员不需要自己去实现这样的方案：每次属性改变了就发送消息通知。这是<code>KVO</code>机制提供的最大的优点。因为这个方案已经被明确定义，获得框架级支持，可以方便地采用。开发人员不需要添加任何代码，不需要设计自己的观察者模型，直接可以在工程里使用。其次，<code>KVO</code>的架构非常的强大，可以很容易的支持多个观察者观察同一个属性，以及相关的值。</p><h3 id="Swift的KVO与KVC"><a href="#Swift的KVO与KVC" class="headerlink" title="Swift的KVO与KVC"></a>Swift的KVO与KVC</h3><p>Swift版本的的就看这篇文章吧，内容很详细。<br><a href="http://swiftcafe.io/2016/01/03/kvc/" target="_blank" rel="noopener">漫谈 KVC 与 KVO</a></p><blockquote><p>Reference<br><a href="http://www.cnblogs.com/kenshincui/p/3871178.html" target="_blank" rel="noopener">iOS开发系列—Objective-C之KVC、KVO</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Syntax </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Objective-C </tag>
            
            <tag> KVO </tag>
            
            <tag> KVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[iOS] 小问题记录</title>
      <link href="/2016/04/18/%5BiOS%5DCollections-of-issues/"/>
      <url>/2016/04/18/%5BiOS%5DCollections-of-issues/</url>
      
        <content type="html"><![CDATA[<h3 id="iOS-system"><a href="#iOS-system" class="headerlink" title="iOS system"></a>iOS system</h3><h4 id="iOS-version检测"><a href="#iOS-version检测" class="headerlink" title="iOS version检测"></a>iOS version检测</h4><p><a href="http://stackoverflow.com/a/5337804/4522227" target="_blank" rel="noopener">reference</a></p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">#define SYSTEM_VERSION_EQUAL_TO(v)                  ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] == NSOrderedSame)#define SYSTEM_VERSION_GREATER_THAN(v)              ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] == NSOrderedDescending)#define SYSTEM_VERSION_GREATER_THAN_OR_EQUAL_TO(v)  ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] != NSOrderedAscending)#define SYSTEM_VERSION_LESS_THAN(v)                 ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] == NSOrderedAscending)#define SYSTEM_VERSION_LESS_THAN_OR_EQUAL_TO(v)     ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] != NSOrderedDescending)if (SYSTEM_VERSION_LESS_THAN(@"8.0")) {   ...}</code></pre><h4 id="文件保存数据库的问题"><a href="#文件保存数据库的问题" class="headerlink" title="文件保存数据库的问题"></a>文件保存数据库的问题</h4><p>iOS 往数据库里写保存文件路径的时候，不要写全路径，因为软件更新或者重新安装沙盒路径会变</p><blockquote><p>更新的流程是这样的：更新时，先在新的路径里安装新程序，然后把旧程序文件夹里的配置文件之类的文件拷贝到新的路径里去，然后删除旧程序</p></blockquote><p>所以，如果数据库里保存的是绝对路径，那么软件会找不到文件。所以要保存相对路径。比如/var/mobile/Applications/ECDD1B2D-E53D-4914-BDDB-F0578BADAA38/Documents/A/B/C/9A4613EA-232A-480C-9492-B34A00BE3CB6.txt<br>只写/A/B/C/9A4613EA-232A-480C-9492-B34A00BE3CB6.txt就好，前半部分用系统方法获取。</p><h4 id="保存图片至iPhone图库"><a href="#保存图片至iPhone图库" class="headerlink" title="保存图片至iPhone图库"></a>保存图片至iPhone图库</h4><p><a href="http://stackoverflow.com/a/179066/4522227" target="_blank" rel="noopener">reference</a></p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">UIImageWriteToSavedPhotosAlbum(UIImage *image,                                id completionTarget,                                SEL completionSelector,                                void *contextInfo);</code></pre><hr><h3 id="NSString"><a href="#NSString" class="headerlink" title="NSString"></a>NSString</h3><h4 id="NSString-和-std-string-相互转换"><a href="#NSString-和-std-string-相互转换" class="headerlink" title="NSString 和 std::string 相互转换"></a>NSString 和 std::string 相互转换</h4><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">//NSString to stringNSString *strA = @"NSString";std::string *strB = new std::string([strA UTF8String]);//orstd::string strB([strA UTF8String]);//string to NSStringNSString *str = [NSString stringWithCString:string.c_str()                                    encoding:[NSString defaultCStringEncoding]];NSString *str = [NSString stringWithCString:string.c_str()                                    encoding:NSUTF8StringEncoding]; // for chinesestd::string param; // <-- inputNSString* result = [NSString stringWithUTF8String:param.c_str()];NSString* alternative = [[NSString alloc] initWithUTF8String:param.c_str()];//chinese[NSString stringWithCString:m_AnswerSheet.GetName().c_str() encoding:NSUTF8StringEncoding]</code></pre><h4 id="NSString实现trimRight方法"><a href="#NSString实现trimRight方法" class="headerlink" title="NSString实现trimRight方法"></a>NSString实现trimRight方法</h4><p>参考这里：<a href="http://stackoverflow.com/questions/5689288/how-to-remove-whitespace-from-right-end-of-nsstring" target="_blank" rel="noopener">link</a><br><a href="http://stackoverflow.com/a/20521689/4522227" target="_blank" rel="noopener">reference</a></p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">//该方法会删除string两端的空格NSString *newString = [oldString stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];//若要只删除string结尾的空格  写一个NSString拓展类 添加如下方法- (NSString *)stringByTrimmingTrailingCharactersInSet:(NSCharacterSet *)characterSet {    NSUInteger location = 0;    NSUInteger length = [self length];    unichar charBuffer[length];        [self getCharacters:charBuffer];    for (length; length > 0; length--) {        if (![characterSet characterIsMember:charBuffer[length - 1]]) {            break;        }    }    return [self substringWithRange:NSMakeRange(location, length - location)];}//然后调用NSString *trimmedString = [yourString stringByTrimmingTrailingCharactersInSet:[NSCharacterset whitespaceAndNewlineCharacterSet]];</code></pre><h4 id="NSString后连接字符串"><a href="#NSString后连接字符串" class="headerlink" title="NSString后连接字符串"></a>NSString后连接字符串</h4><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">string = [NSString initWithFormat:@"%@,%@", string1, string2 ];string = [string1 stringByAppendingString:string2];string = [string stringByAppendingFormat:@"%@,%@",string1, string2];</code></pre><h4 id="NSString-Char-ASCII转换"><a href="#NSString-Char-ASCII转换" class="headerlink" title="NSString,Char,ASCII转换"></a>NSString,Char,ASCII转换</h4><ul><li><a href="http://stackoverflow.com/questions/7940283/convert-char-to-nsstring" target="_blank" rel="noopener">linkA</a></li><li><a href="http://stackoverflow.com/questions/2832729/how-to-convert-ascii-value-to-a-character-in-objective-c" target="_blank" rel="noopener">linkB</a></li></ul><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">//char to int ASCII-codechar c = 'a';int ascii_code = (int)c;//int to charint i = 65; // Ac = (char)i;// NSString to ASCIINSString *string = @"A";int asciiCode = [string characterAtIndex:0]; // 65// ASCII to NSStringint asciiCode = 65;NSString *string = [NSString stringWithFormat:@"%c", asciiCode]; // Achar myChar = 'r';NSString* string = [NSString stringWithFormat:@"%c" , myChar];</code></pre><h4 id="NSString文字高度"><a href="#NSString文字高度" class="headerlink" title="NSString文字高度"></a>NSString文字高度</h4><p><a href="http://stackoverflow.com/a/22014311/4522227" target="_blank" rel="noopener">reference</a></p><h4 id="cocoa获取UUID"><a href="#cocoa获取UUID" class="headerlink" title="cocoa获取UUID"></a>cocoa获取UUID</h4><p>参考：<a href="http://linfan.info/blog/2012/04/20/uuid/" target="_blank" rel="noopener">各种OS中生成UUID的方法</a></p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">NSString CHelpFunction::stringWithUuid() {    CFUUIDRef uuidObj = CFUUIDCreate(nil);    NSString *uuidString = (NSString *)CFBridgingRelease(CFUUIDCreateString(nil, uuidObj));    CFRelease(uuidObj);    return uuidString;}</code></pre><hr><h3 id="UIView"><a href="#UIView" class="headerlink" title="UIView"></a>UIView</h3><h4 id="UIView贴背景图"><a href="#UIView贴背景图" class="headerlink" title="UIView贴背景图"></a>UIView贴背景图</h4><p>UIView只有<code>setBackgroundColor</code>，就用它来设置</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">UIColor *color = [UIColor colorWithPatternImage:[UIImage imageNamed:@"bg.png"]];[myLabel setBackgroundColor:color];</code></pre><h4 id="UIView添加点击事件"><a href="#UIView添加点击事件" class="headerlink" title="UIView添加点击事件"></a>UIView添加点击事件</h4><p> 参考：<a href="http://stackoverflow.com/questions/17120476/click-event-on-uiimageview-programmatically-in-ios" target="_blank" rel="noopener">reference</a></p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">UITapGestureRecognizer *singleTap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tapDetected)];singleTap.numberOfTapsRequired = 1;[preArrowImage setUserInteractionEnabled:YES];[preArrowImage addGestureRecognizer:singleTap];-(void)tapDetected{    NSLog(@"single Tap on imageview");  }</code></pre><h4 id="获取UIView触摸点"><a href="#获取UIView触摸点" class="headerlink" title="获取UIView触摸点"></a>获取UIView触摸点</h4><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event {    UITouch *touch = [touches anyObject];    CGPoint point = [touch locationInView:self];    NSLog(@"x:%f,   y:%f", point.x, point.y);    if (!CGRectContainsPoint(centerView.frame, point)) {        [self removeFromSuperview];    }}</code></pre><h4 id="layoutSubviews调用时机"><a href="#layoutSubviews调用时机" class="headerlink" title="layoutSubviews调用时机"></a>layoutSubviews调用时机</h4><p><a href="http://stackoverflow.com/questions/728372/when-is-layoutsubviews-called" target="_blank" rel="noopener">reference</a></p><ul><li><code>init</code>：不会调用<code>layoutSubviews</code></li><li><code>addSubview:</code>：被添加的view1、调用这个方法的view2、view2的所有子view都会调用<code>layoutSubviews</code></li><li><code>setFrame</code>：只有在view设置frame且尺寸参数有不同的情况下调用</li><li>滑动<code>UIScrollView</code>时，scrollView和其父view会调用</li><li>旋转屏幕会在viewController的根view调用</li><li>重新改变view的大小，其父view会调用</li></ul><h4 id="drawInRect-withAttributes-的参数怎么写"><a href="#drawInRect-withAttributes-的参数怎么写" class="headerlink" title="drawInRect: withAttributes:的参数怎么写"></a>drawInRect: withAttributes:的参数怎么写</h4><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">UIFont *textFont = [UIFont fontWithName: @"Helvetica" size: 60];UIColor *textColor = [UIColor blackColor];NSMutableParagraphStyle *textStyle = [[NSMutableParagraphStyle defaultParagraphStyle] mutableCopy];textStyle.lineBreakMode = NSLineBreakByWordWrapping;textStyle.alignment = NSTextAlignmentCenter;[textContent drawInRect:textRect withAttributes:@{NSFontAttributeName:textFont, NSForegroundColorAttributeName:textColor, NSParagraphStyleAttributeName:textStyle}];</code></pre><h4 id="设置粗体文字"><a href="#设置粗体文字" class="headerlink" title="设置粗体文字"></a>设置粗体文字</h4><blockquote><p>首先可以上这个网站：<a href="http://iosfonts.com/" target="_blank" rel="noopener">http://iosfonts.com/</a>查看自己要用的字体是否支持粗体，然后使用下面方法</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">-(void)boldFontForLabel:(UILabel *)label{    UIFont *currentFont = label.font;    UIFont *newFont = [UIFont fontWithName:[NSString stringWithFormat:@"%@-Bold",currentFont.fontName] size:currentFont.pointSize];    label.font = newFont;}</code></pre></blockquote><h4 id="UIView一些尺寸属性"><a href="#UIView一些尺寸属性" class="headerlink" title="UIView一些尺寸属性"></a>UIView一些尺寸属性</h4><ul><li>frame：origin是相对于屏幕的点的坐标，size就是其尺寸</li><li>bound:  origin永远是(0,0)，size也是尺寸</li><li>center: 是View的中心点，但坐标是相对于屏幕的。如果需要相对自己的中心点，则需要用bound.origin来计算</li></ul><h4 id="UIView加外边框"><a href="#UIView加外边框" class="headerlink" title="UIView加外边框"></a>UIView加外边框</h4><p><a href="http://stackoverflow.com/a/15184257/4522227" target="_blank" rel="noopener">reference</a></p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">CGFloat borderWidth = 2.0f;self.frame = CGRectInset(self.frame, -borderWidth, -borderWidth);self.layer.borderColor = [UIColor yellowColor].CGColor;self.layer.borderWidth = borderWidth;</code></pre><h4 id="UIView切换动画"><a href="#UIView切换动画" class="headerlink" title="UIView切换动画"></a>UIView切换动画</h4><p>只要提供View的初识状态和结束状态，然后交给showAnimation来做即可</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">-(void)showAnimation {    [self.view addSubview:geopointView]    geopointView.frame = // somewhere offscreen, in the direction you want it to appear from    [UIView animateWithDuration:10.0                      animations:^{                         geopointView.frame = // its final location                     }];}</code></pre><h4 id="UIView滑入动画"><a href="#UIView滑入动画" class="headerlink" title="UIView滑入动画"></a>UIView滑入动画</h4><p><a href="http://stackoverflow.com/a/18133127/4522227" target="_blank" rel="noopener">reference</a></p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">[UIView transitionFromView:viewToReplace                    toView:replacementView                  duration:1                   options:UIViewAnimationOptionTransitionFlipFromBottom                completion:nil];</code></pre><h4 id="判断一个点在UIView里"><a href="#判断一个点在UIView里" class="headerlink" title="判断一个点在UIView里"></a>判断一个点在UIView里</h4><p><a href="http://stackoverflow.com/a/6501123/4522227" target="_blank" rel="noopener">reference</a></p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">CGPoint locationInView = [imageView convertPoint:point fromView:imageView.window];if ( CGRectContainsPoint(imageView.bounds, locationInView) ) {    // Point lies inside the bounds.}</code></pre><h4 id="UIView调用presentViewController"><a href="#UIView调用presentViewController" class="headerlink" title="UIView调用presentViewController"></a>UIView调用presentViewController</h4><p><a href="http://stackoverflow.com/a/15623730/4522227" target="_blank" rel="noopener">reference</a></p><h4 id="自动布局下获取View的尺寸"><a href="#自动布局下获取View的尺寸" class="headerlink" title="自动布局下获取View的尺寸"></a>自动布局下获取View的尺寸</h4><p><a href="http://stackoverflow.com/a/13542580/4522227" target="_blank" rel="noopener">reference</a></p><h4 id="把touch事件传递给子View"><a href="#把touch事件传递给子View" class="headerlink" title="把touch事件传递给子View"></a>把touch事件传递给子View</h4><p>涉及到事件传递部分内容，另外再开博客记录<br><a href="http://stackoverflow.com/a/7719901/4522227" target="_blank" rel="noopener">reference</a></p><hr><h3 id="UILabel"><a href="#UILabel" class="headerlink" title="UILabel"></a>UILabel</h3><h4 id="UILabel设置行间距"><a href="#UILabel设置行间距" class="headerlink" title="UILabel设置行间距"></a>UILabel设置行间距</h4><p><a href="http://stackoverflow.com/questions/5494498/how-to-control-the-line-spacing-in-uilabel" target="_blank" rel="noopener">reference</a></p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">NSMutableAttributedString *attributedString = [[NSMutableAttributedString alloc] init];NSMutableParagraphStyle *paragraphStyle = [[NSMutableParagraphStyle alloc] init];paragraphStyle.lineSpacing = spacing;[attributedString addAttribute:NSParagraphStyleAttributeName value:paragraphStyle range:NSMakeRange(0, label.text.length)];label.attributedText = attributedString;</code></pre><h4 id="UILabel下划线"><a href="#UILabel下划线" class="headerlink" title="UILabel下划线"></a>UILabel下划线</h4><p><a href="http://stackoverflow.com/a/2711587/4522227" target="_blank" rel="noopener">reference</a></p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">NSDictionary *underlineAttribute = @{NSUnderlineStyleAttributeName: @(NSUnderlineStyleSingle)};myLabel.attributedText = [[NSAttributedString alloc] initWithString:@"Test string"                                                          attributes:underlineAttribute];</code></pre><hr><h3 id="UIButton"><a href="#UIButton" class="headerlink" title="UIButton"></a>UIButton</h3><h4 id="模拟按钮点击事件"><a href="#模拟按钮点击事件" class="headerlink" title="模拟按钮点击事件"></a>模拟按钮点击事件</h4><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">[buttonObj sendActionsForControlEvents: UIControlEventTouchUpInside];</code></pre><hr><h3 id="UIImage-amp-UIImageView"><a href="#UIImage-amp-UIImageView" class="headerlink" title="UIImage &amp; UIImageView"></a>UIImage &amp; UIImageView</h3><h4 id="用纯色生成一个UIImage"><a href="#用纯色生成一个UIImage" class="headerlink" title="用纯色生成一个UIImage"></a>用纯色生成一个UIImage</h4><p><a href="http://stackoverflow.com/questions/6496441/creating-a-uiimage-from-a-uicolor-to-use-as-a-background-image-for-uibutton" target="_blank" rel="noopener">reference</a></p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">@implementation  UIButton (ButtonMagic)- (void)setBackgroundColor:(UIColor *)backgroundColor forState:(UIControlState)state {    [self setBackgroundImage:[UIButton imageFromColor:backgroundColor] forState:state];}+ (UIImage *)imageFromColor:(UIColor *)color {    CGRect rect = CGRectMake(0, 0, 1, 1);    UIGraphicsBeginImageContext(rect.size);    CGContextRef context = UIGraphicsGetCurrentContext();    CGContextSetFillColorWithColor(context, [color CGColor]);    CGContextFillRect(context, rect);    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();    UIGraphicsEndImageContext();    return image;}</code></pre><h4 id="UIImage占内存大小"><a href="#UIImage占内存大小" class="headerlink" title="UIImage占内存大小"></a>UIImage占内存大小</h4><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">NSUInteger size  = CGImageGetHeight(thumbImage.CGImage) * CGImageGetBytesPerRow(thumbImage.CGImage);</code></pre><h4 id="UIImage加边框"><a href="#UIImage加边框" class="headerlink" title="UIImage加边框"></a>UIImage加边框</h4><p><a href="http://stackoverflow.com/questions/27395497/add-white-border-to-uiimage" target="_blank" rel="noopener">reference</a></p><h4 id="把UIView生成UIImage"><a href="#把UIView生成UIImage" class="headerlink" title="把UIView生成UIImage"></a>把UIView生成UIImage</h4><p><a href="http://stackoverflow.com/a/6079336/4522227" target="_blank" rel="noopener">reference</a><br><a href="http://stackoverflow.com/a/22494886/4522227" target="_blank" rel="noopener">reference2</a></p><hr><h3 id="UIColor"><a href="#UIColor" class="headerlink" title="UIColor"></a>UIColor</h3><h4 id="给ClearColor添加alpha"><a href="#给ClearColor添加alpha" class="headerlink" title="给ClearColor添加alpha"></a>给ClearColor添加alpha</h4><p><a href="http://stackoverflow.com/a/11440737/4522227" target="_blank" rel="noopener">reference</a></p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">- (void)setBackgroundColor:(UIColor *)color {    self.backgroundColor = [color colorWithAlphaComponent:0.3f];}</code></pre><hr><h3 id="NSNotification"><a href="#NSNotification" class="headerlink" title="NSNotification"></a>NSNotification</h3><h4 id="NSNotification流程"><a href="#NSNotification流程" class="headerlink" title="NSNotification流程"></a>NSNotification流程</h4><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">//sendNSNotificationCenter *nc = [NSNotificationCenter defaultCenter];NSDictionary *d = [NSDictionary dictionaryWithObject:[NSNumber numberWithInt:m_index] forKey:@"index"];[nc postNotificationName:@"viewClicked" object:self userInfo:d];//regist observer[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(viewClickAt:) name:@"quesViewClicked" object:nil];//do function- (void)quesViewClickAt:(NSNotification *)noti {    int index = [[[noti userInfo] objectForKey:@"index"] intValue];}//dealloc- (void)dealloc {    [[NSNotificationCenter defaultCenter] removeObserver:self];}</code></pre><hr><h3 id="UITextView-amp-UITextField"><a href="#UITextView-amp-UITextField" class="headerlink" title="UITextView &amp; UITextField"></a>UITextView &amp; UITextField</h3><h4 id="keyboard强行关闭"><a href="#keyboard强行关闭" class="headerlink" title="keyboard强行关闭"></a>keyboard强行关闭</h4><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">[view endEditing:YES];</code></pre><h4 id="UITextView限制输入字符"><a href="#UITextView限制输入字符" class="headerlink" title="UITextView限制输入字符"></a>UITextView限制输入字符</h4><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">- (BOOL)textView:(nonnull UITextView *)textView shouldChangeTextInRange:(NSRange)range replacementText:(nonnull NSString *)text {    // Prevent crashing undo bug     if(range.length + range.location > textView.text.length)    {        return NO;    }    NSUInteger newLength = [textView.text length] + [text length] - range.length;    return newLength <= 1024;}</code></pre><h4 id="UITextView添加默认文字"><a href="#UITextView添加默认文字" class="headerlink" title="UITextView添加默认文字"></a>UITextView添加默认文字</h4><p>UITextField是有placeholder(?)这个属性的，但是UITextView没有，大家表示也是醉了。<br><a href="http://stackoverflow.com/a/10201671/4522227" target="_blank" rel="noopener">reference</a></p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">- (void)textViewDidBeginEditing:(UITextView *)textView{    if ([textView.text isEqualToString:@"placeholder text here..."]) {         textView.text = @"";         textView.textColor = [UIColor blackColor]; //optional    }    [textView becomeFirstResponder];}- (void)textViewDidEndEditing:(UITextView *)textView{    if ([textView.text isEqualToString:@""]) {        textView.text = @"placeholder text here...";        textView.textColor = [UIColor lightGrayColor]; //optional    }    [textView resignFirstResponder];}</code></pre><h4 id="UITextField光标距离左边间隔太小"><a href="#UITextField光标距离左边间隔太小" class="headerlink" title="UITextField光标距离左边间隔太小"></a>UITextField光标距离左边间隔太小</h4><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">UITextField *content = ......;//设置输入左边距CGRect frame = content.frame;frame.size.width = 5;UIView *leftView = [[UIView alloc] initWithFrame:frame];content.leftViewMode = UITextFieldViewModeAlways;content.leftView = leftView;</code></pre><h4 id="UITextField下划线"><a href="#UITextField下划线" class="headerlink" title="UITextField下划线"></a>UITextField下划线</h4><p><a href="http://stackoverflow.com/a/26801251/4522227" target="_blank" rel="noopener">reference</a></p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec"> CALayer *border = [CALayer layer];    CGFloat borderWidth = 2;    border.borderColor = [UIColor darkGrayColor].CGColor;    border.frame = CGRectMake(0, textField.frame.size.height - borderWidth, textField.frame.size.width, textField.frame.size.height);    border.borderWidth = borderWidth;    [textField.layer addSublayer:border];    textField.layer.masksToBounds = YES;</code></pre><h4 id="UITextField内容改变事件"><a href="#UITextField内容改变事件" class="headerlink" title="UITextField内容改变事件"></a>UITextField内容改变事件</h4><p>UITextView有对应的回调，UITextField就没有。<br><a href="http://stackoverflow.com/questions/4006137/uitextfield-value-changed-event" target="_blank" rel="noopener">reference</a><br><a href="http://stackoverflow.com/a/15489967/4522227" target="_blank" rel="noopener">reference2</a></p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">[myTextField addTarget:self                 action:@selector(textFieldDidChange:)       forControlEvents:UIControlEventEditingChanged];</code></pre><h4 id="多个UITextField，键盘return改为next-gt-next-gt-done-（iOS9又有新的类型）"><a href="#多个UITextField，键盘return改为next-gt-next-gt-done-（iOS9又有新的类型）" class="headerlink" title="多个UITextField，键盘return改为next-&gt;next-&gt;done （iOS9又有新的类型）"></a>多个UITextField，键盘return改为next-&gt;next-&gt;done （iOS9又有新的类型）</h4><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">//set keyboardif (i == count - 1)    [contentText setReturnKeyType:UIReturnKeyDone];else   [contentText setReturnKeyType:UIReturnKeyNext];#pragma mark - TextFieldDelegate- (BOOL)textFieldShouldReturn:(nonnull UITextField *)textField {    NSInteger nextTag = textField.tag + 1;    // Try to find next responder    UIResponder* nextResponder = [textField.superview viewWithTag:nextTag];    if (nextResponder) {        // Found next responder, so set it.        [nextResponder becomeFirstResponder];    } else {        // Not found, so remove keyboard.        [textField resignFirstResponder];    }    return NO; // We do not want UITextField to insert line-breaks.}</code></pre><hr><h3 id="UIScrollView-amp-UITableView-amp-UICollectionView"><a href="#UIScrollView-amp-UITableView-amp-UICollectionView" class="headerlink" title="UIScrollView &amp; UITableView &amp; UICollectionView"></a>UIScrollView &amp; UITableView &amp; UICollectionView</h3><h4 id="UIScrollView滚动到顶端"><a href="#UIScrollView滚动到顶端" class="headerlink" title="UIScrollView滚动到顶端"></a>UIScrollView滚动到顶端</h4><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">//UPDATE FOR iOS 7[self.scrollView setContentOffset:    CGPointMake(0, -self.scrollView.contentInset.top) animated:YES];//ORIGINAL[self.scrollView setContentOffset:CGPointZero animated:YES];//or if you want to preserve the horizontal scroll position and just reset the vertical position:[self.scrollView setContentOffset:CGPointMake(self.scrollView.contentOffset.x, 0) animated:YES];</code></pre><h4 id="UITableView屏蔽自动滚动效果"><a href="#UITableView屏蔽自动滚动效果" class="headerlink" title="UITableView屏蔽自动滚动效果"></a>UITableView屏蔽自动滚动效果</h4><p><a href="http://stackoverflow.com/questions/9637089/disabling-automatic-scrolling-of-uitableview-when-editing-uitextfield-inside-uit" target="_blank" rel="noopener">reference</a><br>继承UITableViewController重写</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">- (void)viewWillAppear:(BOOL)animated { //不调用super方法  屏蔽自动滚动    //[super ...];}</code></pre><h4 id="判断UITableViewCell是否可见"><a href="#判断UITableViewCell是否可见" class="headerlink" title="判断UITableViewCell是否可见"></a>判断UITableViewCell是否可见</h4><p><a href="http://stackoverflow.com/a/3326891/4522227" target="_blank" rel="noopener">reference</a></p><pre class=" language-lang-onjectivec"><code class="language-lang-onjectivec">-(BOOL)isRowZeroVisible {  NSArray *indexes = [tableView indexPathsForVisibleRows];  for (NSIndexPath *index in indexes) {    if (index.row == 0) {      return YES;    }  }  return NO;}</code></pre><h4 id="UICollectionViewCell构造"><a href="#UICollectionViewCell构造" class="headerlink" title="UICollectionViewCell构造"></a>UICollectionViewCell构造</h4><p>UICollectionViewCell 不能用<code>-(id)init{}</code>，要用<code>-(id)initWithFrame:(CGRect)frame</code>或者<code>initWithCoder()</code></p><hr><h3 id="NSArray-amp-NSDictionary"><a href="#NSArray-amp-NSDictionary" class="headerlink" title="NSArray &amp; NSDictionary"></a>NSArray &amp; NSDictionary</h3><h4 id="NSArray和std-vector转换"><a href="#NSArray和std-vector转换" class="headerlink" title="NSArray和std::vector转换"></a>NSArray和std::vector<std::string>转换</std::string></h4><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">std::vector<std::string> strVec;for (int i = 0; i < [NSMutableArrayObject count]; i++) {   NSString *NS_Ans = (NSString *)[NSMutableArrayObject objectAtIndex:i];   std::string Str_Ans = *new std::string([NS_Ans UTF8String]);   strVec.push_back(Str_Ans);}return strVec;//std::vector<std::string> ansArray = getOneVector();           NSMutableArray *nsArray = [NSMutableArray array];for (int j = 0; j < ansArray.size(); j++) {   NSString *item = [NSString stringWithCString:ansArray[j].c_str() encoding:[NSString defaultCStringEncoding]];            [nsArray addObject:item];}return ansArray;</code></pre><h4 id="NSArray添加CGPoint对象"><a href="#NSArray添加CGPoint对象" class="headerlink" title="NSArray添加CGPoint对象"></a>NSArray添加CGPoint对象</h4><p>一般使用NSValue <a href="http://stackoverflow.com/a/899653/4522227" target="_blank" rel="noopener">reference</a></p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">NSArray *points = [NSArray arrayWithObjects:                     [NSValue valueWithCGPoint:CGPointMake(5.5, 6.6)],                     [NSValue valueWithCGPoint:CGPointMake(7.7, 8.8)],                     nil];NSValue *val = [points objectAtIndex:0];CGPoint p = [val CGPointValue];</code></pre><h4 id="NSMutableArray-NSMutableDictionary插入空值"><a href="#NSMutableArray-NSMutableDictionary插入空值" class="headerlink" title="NSMutableArray/NSMutableDictionary插入空值"></a>NSMutableArray/NSMutableDictionary插入空值</h4><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">if ((NSNull *)[mPages objectAtIndex:showPos] == [NSNull null]) {        [mPages removeObjectAtIndex:showPos];}[mPages insertObject:mPage atIndex:showPos];[mPages removeObjectAtIndex:hidePos];[mPages insertObject:[NSNull null] atIndex:hidePos];</code></pre><h4 id="NSDictionary保存int类型"><a href="#NSDictionary保存int类型" class="headerlink" title="NSDictionary保存int类型"></a>NSDictionary保存<code>int</code>类型</h4><p>NSDictionary保存的都是对象，所以<code>int</code>要转成<code>NSNumber</code></p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">//save[NSDictionary dictionaryWithObject:[NSNumber numberWithInt:m_quesIndex] forKey:@"index"];//geti = [[dic objectForKey:@"index"] intValue];</code></pre><hr><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="Cocoapods-pod-install-太慢"><a href="#Cocoapods-pod-install-太慢" class="headerlink" title="Cocoapods pod install 太慢"></a>Cocoapods pod install 太慢</h4><p><a href="http://stackoverflow.com/a/36821144/4522227" target="_blank" rel="noopener">reference</a></p><pre class=" language-lang-bash"><code class="language-lang-bash">pod install --verbose --no-repo-update</code></pre><h4 id="标注代码段"><a href="#标注代码段" class="headerlink" title="标注代码段"></a>标注代码段</h4><p><a href="http://stackoverflow.com/a/24037870/4522227" target="_blank" rel="noopener">reference</a><br>在OC里经常用</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">#pragma mark - xxxx</code></pre><p>来分隔代码<br>Swift里用的是</p><pre class=" language-lang-Swift"><code class="language-lang-Swift">// MARK: - xxx</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Swift] Swift笔记</title>
      <link href="/2016/04/16/%5BSwift%5DNotes-of-Swift/"/>
      <url>/2016/04/16/%5BSwift%5DNotes-of-Swift/</url>
      
        <content type="html"><![CDATA[<p>开始整理<code>Swift</code>笔记了。打算直接用<code>Playground</code>去写，里面自带的<code>Markup</code>语法和<code>Markdown</code>差不多，显示的效果也不差于博客。而且用<code>Xcode</code>看代码也方便。所以这部分内容不再在博客里记录了，直接上传<code>Github</code>。<br>地址：<a href="https://github.com/wossoneri/swift_basics" target="_blank" rel="noopener">https://github.com/wossoneri/swift_basics</a><br>需要看的直接<code>Fork</code>，我不定时提交，你也可以提交更新。</p>]]></content>
      
      
      <categories>
          
          <category> Syntax </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[iOS] 列表滑动展开隐藏头部HeaderView</title>
      <link href="/2016/02/22/%5BiOS%5DScroll-to-hide-show-HeaderView/"/>
      <url>/2016/02/22/%5BiOS%5DScroll-to-hide-show-HeaderView/</url>
      
        <content type="html"><![CDATA[<h2 id="先看一下效果图"><a href="#先看一下效果图" class="headerlink" title="先看一下效果图"></a>先看一下效果图</h2><p>首先看一下BiliBili客户端的视频浏览界面。默认界面<code>Header</code>完全展开，并且<code>Header</code>显示AV号（别乱想，就是视频编号了）以及播放按钮。滑动之后<code>Header</code>被压缩，按钮移到AV号左边。</p><p><img src="https://github.com/wossoneri/iOS-ScrollHeader/blob/master/gifs/ios_header.gif?raw=true" alt="bilibiliTop"></p><p>我就照着界面简单实现了主要功能，比较简陋。对于按钮移动的动画就没有去花时间还原了，毕竟这里主要是为了实现滚动压缩、展开<code>Header</code>，动画不讨论。</p><p><img src="https://github.com/wossoneri/iOS-ScrollHeader/blob/master/gifs/myScroll.gif?raw=true" alt="myScroll"></p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>如图所示：<br><img src="https://github.com/wossoneri/iOS-ScrollHeader/blob/master/gifs/scrollHeader.png?raw=true" alt></p><p>首先在要将该界面分成两部分：一个<code>ScrollHeader</code>，一个<code>UITableView</code>。</p><ul><li><em>ScrollHeader</em>占据屏幕上方，高度为展开后的高度</li><li><em>UITableView</em>占据整个屏幕，这样可以完全滚动。为了让内容不被<code>ScrollHeader</code>遮盖，设置<code>contentOffset</code>属性即可</li></ul><blockquote><p>我这里用的<code>ScrollHeader</code>是作为独立的控件使用，与<code>UITableView</code>的<code>HeaderView</code>并无关系</p></blockquote><p>之后将<code>ScrollHeader</code>分成两部分：<code>topView</code>和<code>bottomView</code>。</p><ul><li><em>topView</em> 即为压缩后的布局</li><li><em>bottomView</em> 即为展开后的布局<br>我这里采取将<em>topView</em>固定在<code>ScrollHeader</code>的顶部，覆盖在<code>bottomView</code>上方，根据滑动对其淡入淡出。</li></ul><blockquote><p>另一种效果是把<code>topView</code>与<code>bottomView</code>上下连接在一起，也就是没有覆盖关系，然后当<code>bottomView</code>向上滑时<code>topView</code>从屏幕外滑入屏幕内。这个读者可以尝试着实现一下。</p></blockquote><h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><p>首先按照前面的设计将界面布局好，之后的重点是为<code>ScrollHeader</code>增加滑动效果。<br>由于我的<code>ScrollHeader</code>继承的是<code>UIView</code>，所以为了处理滑动，为其设置一个<code>UIScrollView</code></p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">@property (nonatomic, strong) UIScrollView *headerScrollView;</code></pre><p>这个属性的作用就是获得<code>UITableView</code>对应的<code>scrollView</code>，因为<code>UITableView</code>本身是继承<code>UIScrollView</code>的，所以在初始化<code>ScrollHeader</code>的时候可以这么写：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">MyScrollHeader header = [[MyScrollHeader alloc] init];header.headerScrollView = _tableView;</code></pre><p>这样，在<code>ScrollHeader</code>中就可以通过<code>headerScrollView</code>来判断滑动状态了。</p><p>剩下的工作就是捕捉滑动状态，并且对滑动距离进行计算，移动<code>topView</code>和<code>bottomView</code>了。对于计算也不做过多说明了，因为没有几张草图也说不清。直接贴上代码，跟着代码算一下就知道怎么回事了。</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">#pragma mark - scroll state-(void)willMoveToSuperview:(UIView *)newSuperview{    [self.headerScrollView addObserver:self forKeyPath:@"contentOffset" options:(NSKeyValueObservingOptionNew) context:Nil];    self.headerScrollView.contentInset = UIEdgeInsetsMake(_bottomHeight, 0, 0, 0); // tableview 偏移}-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context{ //监视滑动    CGPoint newOffset = [change[@"new"] CGPointValue];     [self updateSubViewsWithScrollOffset:newOffset];}-(void)updateSubViewsWithScrollOffset:(CGPoint)newOffset {    //    NSLog(@"scrollview inset top:%f", self.headerScrollView.contentInset.top);    //    NSLog(@"new offset before:%f", newOffset.y);    //    NSLog(@"newOffset : %f", newOffset.y);    float startChangeOffset = - self.headerScrollView.contentInset.top;    newOffset = CGPointMake(newOffset.x, newOffset.y < startChangeOffset ? startChangeOffset : (newOffset.y > _destinaOffset ? _destinaOffset : newOffset.y));    //    NSLog(@"new offset after:%f", newOffset.y);    float newY = - newOffset.y - _bottomHeight;    float d = _destinaOffset - startChangeOffset;    float alpha = 1 - (newOffset.y - startChangeOffset) / d;    self.frame = CGRectMake(0, newY, self.frame.size.width, self.frame.size.height);    topView.frame = CGRectMake(0, -newY, self.frame.size.width, self.frame.size.height);    topView.alpha = 1 - alpha;    bottomView.alpha = alpha;    _currentOffset = newOffset.y;    NSLog(@"current offset: %f", _currentOffset);}</code></pre><h2 id="最后放上源码"><a href="#最后放上源码" class="headerlink" title="最后放上源码"></a>最后放上源码</h2><p><a href="https://github.com/wossoneri/iOS-ScrollHeader" target="_blank" rel="noopener">github</a></p><p>粗略写的，代码是用自动布局写的。往后抽空会优化一下代码，把<code>ScrollHeader</code>封装成控件方便使用。</p>]]></content>
      
      
      <categories>
          
          <category> iOS入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> ScrollHeaderView </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Objective-C] Block实现回调和简单的学习思考</title>
      <link href="/2016/02/20/%5BObjective-C%5DCallback-with-block/"/>
      <url>/2016/02/20/%5BObjective-C%5DCallback-with-block/</url>
      
        <content type="html"><![CDATA[<p>关于Objective-C的回调，最常见的应该是用<code>delegate</code>代理实现。不过代理的实现比起<code>Block</code>要更基础，就不介绍了，下面总结一下<code>Block</code>回调的实现。</p><p>就拿我昨天才写的博客为例：<a href="http://www.wossoneri.com/2016/02/18/[iOS]%20%E8%BE%93%E5%85%A5%E6%A1%86%E9%AB%98%E5%BA%A6%E9%9A%8F%E8%BE%93%E5%85%A5%E5%86%85%E5%AE%B9%E5%8F%98%E5%8C%96/" target="_blank" rel="noopener">[iOS] 输入框高度随输入内容变化</a></p><p>在昨天的例子中，我的组件封装控件后，是通过代理实现返回行数的变化的。这次改用<code>Block</code>来实现。</p><ol><li>定义一个<code>Block</code>类型，用来代替原来的<code>@Protocol</code></li></ol><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">typedef void(^getTextViewRows)(NSInteger lines);</code></pre><ol><li>在<code>interface</code>中声明参数为<code>Block</code>的实例方法</li></ol><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">- (void)textViewRowsChangeTo:(getTextViewRows)block;</code></pre><ol><li>实现<code>textViewRowsChangeTo:</code>的方法</li></ol><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">- (void)textViewRowsChangeTo:(getTextViewRows)block {    block(lines);}</code></pre><p>唉，等等，我应该返回的行数是在<code>textViewDidChange:</code>运行时获得后才返回的啊，这样写还回调个什么鬼。。</p><p>所以我们需要声明一个<code>Block</code>变量，保存从外部传进来的<code>Block</code>的地址，然后当我们获取到改变的行数后，再从这个地址把正确的内容返回。</p><p>在第2步添加声明<code>Block</code>变量</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">@property (nonatomic, strong) getTextViewRows b_getRowsBlock;- (void)textViewRowsChangeTo:(getTextViewRows)block;</code></pre><p>修改第3步</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">- (void)textViewRowsChangeTo:(getTextViewRows)block {    _b_getRowsBlock = block;}</code></pre><p>然后在需要返回行数的时候，把行数作为参数传给<code>Block</code></p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">- (void)textViewDidChange:(UITextView *)textView {    NSInteger numLines = textView.contentSize.height / textView.font.lineHeight;    if (numLines != rows) {        rows = numLines;        //发生换行        _b_getRowsBlock(rows);    }    ......}</code></pre><p>最后，在外部调用前面的实例方法即可</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">B *b = [B new];[b textViewRowsChangeTo:^(NSInteger lines) {    rowCount = lines;    [self remakeConstraint];}];</code></pre><blockquote><p>最后，这又是一篇How to do的文章。说起来价值不算大。</p><p>但我觉得，想快速学一个新东西并且上手用起来，是需要从不断模仿别人写的代码做起的。</p><p>就像我第一次看代理，虽然了解大概实现过程，但用起来还是经常会出现忘写<code>XX.delegate = self</code>这看似微不足道的代码的，导致的结果就是调试程序的时候发现代理不起作用，然后排查业务逻辑，看手势事件有没有捕捉到…到最后才会想到排查语法错误。一个小错误导致我效率低下。（这种错误其实是对代理实现原理理解的不够造成的，但对于新手，理解需要时间，而要快速上项目就需要熟记这个实现流程，然后通过大量编码的过程去参悟原理。）</p><p>我想说的是，一般调试逻辑bug的时候很少会去想到语法错误，这就要求了我们平时写代码的时候要注意编程的细节，在学习的时候打好基础。有时候为了追求快速实现功能，可以不去深究，知道实现步骤就可以，比如说这个<code>Block</code>回调，这篇文章就可以作为一个模板，每次用的时候都按照这个步骤去做可以保证不出错，可以快速出效果。照着这个写多了，熟练了就自然不会犯低级的语法错误，这对提升效率很有帮助。这也是为什么我坚持记录How to do的文章的原因。</p><p>不过另外说起来，How to do的文章还有一个意义，那就是How to do都是有一个步骤顺序的，先干什么，再干什么。这个顺序就很有意义，它能提供一套解决问题的思路，也就是能看出这套语法的设计者是怎么去思考的。从设计者的思路去看语法就为我们后期深入学习理解相关知识提供了一条路子。当然了，具体能看到什么，学到什么还是看个人对编程的理解，也就是我所认为的编程心法。</p><p>好了，扯的有点偏，关于<code>Block</code>回调快速上手的方法就是这样了，熟记这个步骤（千万别死记，编码是灵活的），多去敲代码，慢慢就会产生诸如”为什么要写_b_getRowsBlock = block;”的疑问，当产生疑问时，那就说明你熟悉并开始思考语法了。一定要思考，不然注定是当一辈子的码农，而不是程序员。</p><p>关于<code>Block</code>的内容还有很多。由于平时<code>Block</code>用的的确少，所以关于这部分的资料我还需要一些时间去消化。后面我会尽量多写<code>Block</code>，感受不同场景下的使用。</p><p>最最后，我还记得几个月前我盯着代码发呆然后突然感叹一声：“原来这TM就是面向对象啊”的喜悦呢。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Syntax </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Objective-C </tag>
            
            <tag> block </tag>
            
            <tag> 思考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Objective-C] 从NSInteger说开去</title>
      <link href="/2016/02/18/%5BObjective-C%5DTalk-about-NSInteger/"/>
      <url>/2016/02/18/%5BObjective-C%5DTalk-about-NSInteger/</url>
      
        <content type="html"><![CDATA[<h2 id="坏习惯的开端"><a href="#坏习惯的开端" class="headerlink" title="坏习惯的开端"></a>坏习惯的开端</h2><p>初写iOS时，我做的是把原项目从<code>Android</code>端移植到<code>iOS</code>端。因为涉及到不同语言，又因为不熟悉<code>iOS</code>，加上还要与用<code>C</code>写的网络库进行纠缠，我小心翼翼的用了基本数据类型完成大多数编码。能用<code>int</code>就坚决不用<code>NSInteger</code>，能用<code>float</code>就坚决不用<code>CGFloat</code>。你可能会问，虽然这个过程用到的语言很杂，写<code>Objective-C</code>的时候就大胆的用<code>Foundation</code>的数据类型呗。想法很好，只是当时我看不懂我们网络库实现原因不敢乱改代码，怕伤着哪个地方的逻辑，最后代码移着移着，我的<code>.m</code>文件就变成了<code>.mm</code>文件——对，变成<code>Objective-C</code>和<code>C++</code>混编代码了。当时就索性一股脑的用<code>C</code>语言的基本数据类型去做了。现在想想我入门<code>iOS</code>的过程真是坎坷呢，留下了一堆烂毛病。</p><p>不过好在我现在开始拼命的多看资料，一点点把走的弯路走回来。</p><h2 id="一次突然的疑问"><a href="#一次突然的疑问" class="headerlink" title="一次突然的疑问"></a>一次突然的疑问</h2><p>平时也会看<code>Github</code>上面的一些代码，发现代码里用到<code>int</code>的比较少，用<code>NSInteger</code>的比较多，于是就考虑了一下这个问题：这两种类型有啥区别？</p><blockquote><p>这里不得不吐槽一下<objectice-c程序设计>这本书，当初就是看这本书了解O-C语法的，可书上的介绍与代码全是<code>int</code>的，完全没见<code>NSInteger</code>的影子。可见学习这事不能只靠一本书，毕竟书的内容覆盖面有限。</objectice-c程序设计></p></blockquote><h2 id="关于NSInteger和int的优劣"><a href="#关于NSInteger和int的优劣" class="headerlink" title="关于NSInteger和int的优劣"></a>关于NSInteger和int的优劣</h2><p>从查看头文件可以看到其实这样定义的：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">#if __LP64__ || (TARGET_OS_EMBEDDED && !TARGET_OS_IPHONE) || TARGET_OS_WIN32 || NS_BUILD_32_LIKE_64typedef long NSInteger;typedef unsigned long NSUInteger;#elsetypedef int NSInteger;typedef unsigned int NSUInteger;#endif</code></pre><p>这段定义是说如果程序是在64位系统下运行的，<code>NSInteger</code>就代表<code>long</code>，如果是32位的就代表<code>int</code>。<br>也就是说，如果你不知道程序将要在什么系统环境下运行时，最好使用<code>NSInteger</code>，这样可以保证数据很大时不出现问题。简而言之，就是如果你并不考虑位数对程序的影响或者说你觉得并不能游刃有余的操作<code>int</code>和<code>long</code>，那么<code>NSInteger</code>是一个很安全的选择。</p><p>那么是不是说有了<code>NSInteger</code>就可以不用<code>int</code>了呢？</p><p>当然不，以上的前提都是基于一个很大范围数字变量所要考虑的。当你的变量值的范围在一个你可控的范围内，使用<code>int</code>反而更合适，比如说，你要保存一张手机照片的尺寸，那么几千的值是绝对够了的，于是用<code>int</code>也不会产生任何问题，而用<code>NSInteger</code>反而增加代码阅读难度。毕竟<code>int</code>作为通用的基本类型很直观，相反的是<code>NSInteger</code>的代码往其他地方移植也会对别人产生困扰（是不是想太多了: D），而且，从效率上来讲，直接用<code>int</code>的效率还是略微要高一些的。</p><h2 id="什么时候用NSInteger"><a href="#什么时候用NSInteger" class="headerlink" title="什么时候用NSInteger"></a>什么时候用NSInteger</h2><p>其实在Apple的文档或者示例代码里，<code>int</code>和<code>NSInteger</code>都会存在，大多数出现<code>NSInteger</code>是在函数的返回值上。因为函数的返回值是根据参数而不断变化的，范围是不可控的，所以就会使用<code>NSInteger</code>作为返回值。</p><p>所以，简单说来，凡是API用到了<code>NSInteger</code>，那就别用<code>int</code>了。一般情况代码计数不会出现很大的值，毕竟32位的<code>int</code>范围可达到-2147483648～2147483647。</p><h2 id="然后说开去，说什么"><a href="#然后说开去，说什么" class="headerlink" title="然后说开去，说什么"></a>然后说开去，说什么</h2><p>与<code>NSInteger</code>类似，<code>Foundation</code>数据类型里也有类似于与<code>float</code>对应的<code>CGFloat</code></p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">/* Definition of `CGFLOAT_TYPE', `CGFLOAT_IS_DOUBLE', `CGFLOAT_MIN', and   `CGFLOAT_MAX'. */#if defined(__LP64__) && __LP64__# define CGFLOAT_TYPE double# define CGFLOAT_IS_DOUBLE 1# define CGFLOAT_MIN DBL_MIN# define CGFLOAT_MAX DBL_MAX#else# define CGFLOAT_TYPE float# define CGFLOAT_IS_DOUBLE 0# define CGFLOAT_MIN FLT_MIN# define CGFLOAT_MAX FLT_MAX#endif/* Definition of the `CGFloat' type and `CGFLOAT_DEFINED'. */typedef CGFLOAT_TYPE CGFloat;#define CGFLOAT_DEFINED 1</code></pre><p>看完定义就明白，<code>CGFloat</code>也是对于不同位的系统的容错。<br>最后至于<code>NSString</code>和<code>std::string</code>那区别就没那么简单了。<br>对于常用的数据类型，就这些了。</p><p>对于这些数据类型的格式化，可以参考这部分文档：<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Strings/Articles/formatSpecifiers.html#//apple_ref/doc/uid/TP40004265-SW5" target="_blank" rel="noopener">formatSpecifiers</a></p><h2 id="你觉得我这就说完了"><a href="#你觉得我这就说完了" class="headerlink" title="你觉得我这就说完了"></a>你觉得我这就说完了</h2><p>起初遇到这个问题时，我就简单的上网查了一下，感觉没什么区别。不过最近看博客，发现有个大神这样讲</p><blockquote><p>应避免使用基本类型，建议使用 Foundation 数据类型</p></blockquote><p>当时我就一惊，我的代码用的都是<code>int</code>，压根就没打算用<code>NSInteger</code>，我突然觉得自己养成了一个很差的编码习惯，而且我的代码可能会对我以后求职有影响。</p><p>惊诈之余我就上网找起资料，认真阅读不同人的不同说法，然后得到一个我自己的结论：写<code>int</code>并无大碍，而且用基本数据类型并没什么明显缺陷，毕竟我也是知道什么时候用<code>int</code>啊，<code>long</code>啊，’float’啊这些的。虚惊一场。</p><p>但这事还是有教训的，那就是了解一个新东西一定要多了解一些，像我当初就对这个问题不以为意，突然提起来了心就虚了。<br>另外有一个收获就是多看别人写的博客多关注一些细微的知识点总是能学到新东西的。像今天这个问题一样，对我已经写好的代码影响虽然不大，但我再写这块代码时的确是更安心了对吧。</p><blockquote><p>reference<br><a href="http://stackoverflow.com/questions/4445173/when-to-use-nsinteger-vs-int" target="_blank" rel="noopener">When to use NSInteger vs. int</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Syntax </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Objective-C </tag>
            
            <tag> 数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[iOS] 输入框高度随输入内容变化</title>
      <link href="/2016/02/18/%5BiOS%5DInput-height-changed-by-content/"/>
      <url>/2016/02/18/%5BiOS%5DInput-height-changed-by-content/</url>
      
        <content type="html"><![CDATA[<p>实现这个效果的关键点只有两点：</p><ol><li>获取正在输入内容在<code>UITextView</code>占用了多少行</li><li>让<code>UITextView</code>动态改变大小</li></ol><blockquote><p>一开始，为了解决第一个问题，我一直在考虑怎么获取换行事件，发现只用捕捉<code>\n</code>输入即可，但这样又有一个麻烦，就是删除行怎么办？所以感觉这个思路太麻烦</p></blockquote><p>对于第一点，有一个方便的计算方法，就是获取<code>UITextView</code>内容的高度比上<code>UITextView</code>的字体的高度，即可得到当前的行数。</p><p>这里有一个技巧，那就是不要用<code>UITextView</code>的<code>bound.size.height</code>获取其高度，因为这个获取的高度跟你输入的文字总高度并没有任何关系。</p><p>要知道，<code>UITextView</code>是继承<code>UIScrollView</code>的。</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">NS_CLASS_AVAILABLE_IOS(2_0) @interface UITextView : UIScrollView <UITextInput></code></pre><p>这一点你可以不知道，但根据平时的操作经验，一个<code>UITextView</code>输入文字过多时是可以用手上下拖动浏览内容的，所以可以猜想是和<code>UIScrollView</code>有关系。</p><blockquote><p>另一个类似的输入框<code>UITextField</code>不支持换行哦，设置什么<code>lineBreakMode</code>啊，<code>lineNumber</code>（好像没这个属性）啊都不可以换行！我以前在这上面栽过跟头。<code>UITextField</code>输入满了会把文字顶到前面看不见的地方，但还不支持左右拖动！这一点比<code>Android</code>体验要差！</p></blockquote><p>好了，知道其集成<code>UIScrollView</code>就好办了，因为<code>UITextView</code>只有在输入内容超过其显示范围才可以拖动，那就知道输入文字的<code>bound</code>就是<code>UIScrollView</code>的<code>contentSize</code>。这样就知道输入内容的总大小了。</p><p>那每一行的高度呢？</p><blockquote><p>按我以前的经验，行高差不多是字体大小的 4/3 倍.这样设值显示效果一般都挺好。所以可以设值一个宏定义来处理与字体相关的高度。</p></blockquote><p>当然，我的经验是因为过去没有这方面经验的笨办法，正确的办法是使用<code>Font</code>的<code>lineHeight</code>属性：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">// The height of text lines (measured in points). (read-only)@property(nonatomic,readonly)        CGFloat   lineHeight NS_AVAILABLE_IOS(4_0);</code></pre><p>OK，知道每行的高度，就可以计算当前有多少行文字了，在</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">- (void)textViewDidChange:(UITextView *)textView</code></pre><p>代理方法中计算高度即可。</p><p>对于第二点，根据计算出的高度重绘界面布局即可。这里我用的是自动布局，每次高度改变就刷新布局关系就行。下面放部分代码：</p><p>我把输入框和一些其他组件封装为一个控件，在类中声明代理：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">@protocol EssayEditDelegate <NSObject>@optional- (void) onTextViewLineCountChangeTo:(NSInteger)lines;@end</code></pre><p>在每次输入内容的时候计算行数，声明一个变量保存上一次的行数，两次行数不一致即为发生换行</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">- (void)textViewDidChange:(UITextView *)textView {    NSInteger numLines = textView.contentSize.height / textView.font.lineHeight;    if (numLines != rows) {        rows = numLines;        //发生换行        if (_delegate && [_delegate respondsToSelector:@selector(onTextViewLineCountChangeTo:)]) {            [_delegate onTextViewLineCountChangeTo:rows];        }    }    ......}</code></pre><p>在外部实现代理方法，更新界面</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">#pragma mark - Essay delegate- (void)onTextViewLineCountChangeTo:(NSInteger)lines {    rowCount = lines;    [self remakeConstraint];}- (void)remakeConstraint {    NSInteger toobarHeight;    NSInteger rows = rowCount > DEFAULT_ROW_COUNT ? rowCount : DEFAULT_ROW_COUNT;    toobarHeight = (ESSAY_EDIT_FONT_SIZE / 2 * 3) * rows + MARGIN_BUTTON * 2;    [toolBarView mas_remakeConstraints:^(MASConstraintMaker *make) {        make.left.bottom.right.equalTo(self);        make.top.equalTo(quesImageView.mas_bottom);        make.height.mas_equalTo(toobarHeight);    }];}</code></pre><blockquote><p>reference<br><a href="http://stackoverflow.com/questions/3585470/how-to-read-number-of-lines-in-uitextview" target="_blank" rel="noopener">How to Read Number of lines in UITextView</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> iOS入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> UITextView </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[iOS] UICollectionView初始化滚动到中间</title>
      <link href="/2016/01/21/%5BiOS%5DInit-UICollectionView-to-Center/"/>
      <url>/2016/01/21/%5BiOS%5DInit-UICollectionView-to-Center/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>首先看一下我之前写的demo：<a href="http://www.wossoneri.com/2016/01/09/[iOS]%20UICollectionView%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E6%B0%B4%E5%B9%B3%E6%BB%9A%E5%8A%A8/" target="_blank" rel="noopener">link</a></p><p>demo是封装了一个控件，直接在<code>MainViewController</code>的<code>viewWillAppear</code>里初始化，并且调用一个初始化滚动到中间的方法，方法主要是调用了</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">- (void)scrollToItemAtIndexPath:(NSIndexPath *)indexPath atScrollPosition:(UICollectionViewScrollPosition)scrollPosition animated:(BOOL)animated;</code></pre><p>方法，在初始化后将其滚动到中间的区域。不过，当我在项目里使用的时候，遇到了调用该方法却无法滚动到中间的情况。<br>我的使用步骤是：在我界面的<code>UIView</code>中，创建该控件对象并且调用滚动到中间的方法。</p><h2 id="scrollToItemAtIndexPath使用"><a href="#scrollToItemAtIndexPath使用" class="headerlink" title="scrollToItemAtIndexPath使用"></a>scrollToItemAtIndexPath使用</h2><p>发现效果无法实现，我第一时间检查了函数有没有调用，然后发现是调用的了，但没有出现该出现的效果。所以简单看一下该方法的官方注释。xcode提示的描述是：<br><code>Scrolls the collection view contents until the specified item is visible.</code>只是方法的作用，并没有说使用条件。为了快速解决问题，google了一下<code>scrolltoitematindexpath not working</code>，在这里：<a href="http://stackoverflow.com/questions/14977896/xcode-collectionviewcontroller-scrolltoitematindexpath-not-working" target="_blank" rel="noopener">link</a>找到了答案：</p><blockquote><p>不知道这是一个bug还是一个特性，每当在<code>UICollectionView</code>显示它的<code>subview</code>之前调用<code>scrollToItemAtIndexPath:atScrollPosition:Animated</code>方法，UIKit就会报错。<br>所以要解决它，就应该在<code>viewController</code>中，在你能确认<code>CollectionView</code>完全计算出其<code>subview</code>布局的地方去调用这个方法。比如在<code>viewDidLayoutSubviews</code>里调用就没有问题。</p></blockquote><p>方法的意思已经明确，就是找到一个能计算出<code>collectionview</code>的所有布局地方调用滚动方法。但我的界面使用的是自动布局，只在模块外有一个<code>viewController</code>，其余的都是在<code>UIView</code>中创建添加，所以在我使用这个控件对象的地方，我无法复写<code>viewController</code>的方法。所以想了几个办法。</p><h2 id="layoutsubviews"><a href="#layoutsubviews" class="headerlink" title="-layoutsubviews"></a>-layoutsubviews</h2><p>既然情况发生在<code>UIView</code>中，那首先想到的是重写该方法。重写之前，看一下文档说明：</p><blockquote><p>Lays out subviews.</p><p>Discussion<br>The default implementation of this method does nothing on iOS 5.1 and earlier. Otherwise, the default implementation uses any constraints you have set to determine the size and position of any subviews.</p></blockquote><p>Subclasses can override this method as needed to perform more precise layout of their subviews. You should override this method only if the autoresizing and constraint-based behaviors of the subviews do not offer the behavior you want. You can use your implementation to set the frame rectangles of your subviews directly.</p><p>You should not call this method directly. If you want to force a layout update, call the setNeedsLayout method instead to do so prior to the next drawing update. If you want to update the layout of your views immediately, call the layoutIfNeeded method.</p><p>该方法为子view布局。<br>子类可以复写该方法为子view实现更精确的布局。但你只应该在用自动布局时无法实现效果时用它。而且你不应该直接调用该方法，如果需要强制刷新布局，调用<code>setNeedLayout</code>，会在下一次绘制刷新前更新布局。调用<code>layoutIfNeed</code>可以立即刷新布局。</p><p>看起来这个方法有用，我便试了一下。</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">[self setNeedLayout];[self layoutIfNeed];[myPicker scrollToCenter];</code></pre><p>然而还是没有效果。</p><h2 id="view-window"><a href="#view-window" class="headerlink" title="view.window"></a>view.window</h2><p>前面的方法没效果，我又想了一下<code>scrolltoitematindexpath</code>的实现条件，是在<code>UICollectionView</code>显示之后调用才有效，所以我需要在<code>UIView</code>中获得它显示的状态再去滚动。幸好，我的控件也是继承<code>UIView</code>的，其中有这么一个属性:</p><blockquote><p>Property: window<br>This property is nil if the view has not yet been added to a window.</p></blockquote><p>也就是说这个属性值代表着这个<code>view</code>有没有放在窗口中显示，那么我就需要在当前<code>UIView</code>的生命周期中检查<code>myPicker</code>对象的这个属性就好了。所以最后的解决方法是，起一个子线程，对<code>myPicker</code>的状态进行检查，当状态为显示的时候调用滚动方法：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">NSThread *checkShownThread;checkShownThread = [[NSThread alloc] initWithTarget:self selector:@selector(checkIfViewIsShowing) object:nil];[checkShownThread start];- (void)checkIfViewIsShowing {    while (1) {        if (hPicker.window != nil) {            break;        }    }    dispatch_async(dispatch_get_main_queue(), ^{        [hPicker scrollToCenter];    });    [checkShownThread cancel];    checkShownThread = nil;}</code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这个bug只是一个很小的bug，我记录它的原因，一方面是解决过程中学习到了一些不了解的方法，另一方面是记录一下解决问题的思路，希望可以对以后的学习有帮助。也希望将来回头看这一段的时候可以对问题有更好的解决思路。</p>]]></content>
      
      
      <categories>
          
          <category> iOS入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> UICollectionView </tag>
            
            <tag> scrollToItemAtIndexPath </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[iOS] UICollectionView实现图片水平滚动</title>
      <link href="/2016/01/09/%5BiOS%5DHorizon-Scroll-UICollectionView/"/>
      <url>/2016/01/09/%5BiOS%5DHorizon-Scroll-UICollectionView/</url>
      
        <content type="html"><![CDATA[<p><strong>最新更新: 简单封装了一下代码，参考新文章：<a href="http://www.wossoneri.com/2016/05/05/[iOS]WSHorizontalPickerView" target="_blank" rel="noopener">UICollectionView实现图片水平滚动</a></strong></p><p>先简单看一下效果：<br><img src="https://raw.githubusercontent.com/wossoneri/iosdemos/master/HorizontalPickerView2/gifs/7.gif" alt="result"></p><h2 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h2><p>首先先加入一些资源文件：</p><p>先建立一个<code>xcassets</code>文件，放入图片：</p><p><img src="https://github.com/wossoneri/iosdemos/blob/master/HorizontalPickerView2/gifs/hpicker2.png?raw=true" alt="xcassets"></p><p>再建立一个plist文件，写入与图片对应的内容：</p><p><img src="https://github.com/wossoneri/iosdemos/blob/master/HorizontalPickerView2/gifs/hpicker1.png?raw=true" alt="plist"></p><p>在ViewController中读取<code>plist</code>到词典中：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">@property (nonatomic, strong) NSArray *itemTitles;NSString *path = [[NSBundle mainBundle] pathForResource:@"titles" ofType:@"plist"];NSDictionary *rootDictionary = [[NSDictionary alloc] initWithContentsOfFile:path];self.itemTitles = [rootDictionary objectForKey:@"heros"];</code></pre><p>可以打<code>log</code>输出，可以看到<code>plist</code>的内容已经读取出来，后面就可以用<code>_itemTitle</code>作为数据源了。</p><h2 id="添加UICollectionView初步显示图片"><a href="#添加UICollectionView初步显示图片" class="headerlink" title="添加UICollectionView初步显示图片"></a>添加UICollectionView初步显示图片</h2><p>每个<code>CollectionView</code>都有一个对应的布局<code>layout</code>，对于默认的的<code>UICollectionViewFlowLayout</code>，效果是类似Android的<code>GridView</code>的布局。如果要自定义<code>CollectionView</code>的样式，就要对这个<code>layout</code>进行修改。</p><p>建立自己的<code>HorizontalFlowLayout</code>，继承自<code>UICollectionViewFlowLayout</code>，然后在初始化方法里将滚动方向设置为水平：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">- (instancetype) init {    if (self = [super init]) {        self.scrollDirection = UICollectionViewScrollDirectionHorizontal;    }    return self;}</code></pre><p>接下来定制我们的<code>cell</code>的显示样式，建立<code>DotaCell</code>，继承自<code>UICollectionViewCell</code>。由于我们要实现的是图片和文字的上下布局，所以增加两个属性：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">@interface DotaCell : UICollectionViewCell@property (nonatomic, strong) UIImageView *image;@property (nonatomic, strong) UILabel *name;@end</code></pre><p>然后设置图片与文字上下对齐布局，这里我使用<code>pod</code>导入<code>Masonry</code>库来写自动布局：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">- (instancetype)initWithFrame:(CGRect)frame {    self = [super initWithFrame:frame];    if (self) {        [self initialize];    }    return self;}- (void)initialize {    self.layer.doubleSided = NO;    self.image = [[UIImageView alloc] init];    self.image.backgroundColor = [UIColor clearColor];    self.image.contentMode = UIViewContentModeCenter;    self.image.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;    self.name = [[UILabel alloc] init];    self.name.font = [UIFont fontWithName:@"Helvetica Neue" size:20];    self.name.textAlignment = NSTextAlignmentCenter;    [self.contentView addSubview:self.image];    [self.contentView addSubview:self.name];    [_image mas_makeConstraints:^(MASConstraintMaker *make) {        make.left.right.equalTo(self.contentView);        make.top.equalTo(self.contentView).offset(30);        make.bottom.equalTo(_name.mas_top).offset(-10);    }];    [_name mas_makeConstraints:^(MASConstraintMaker *make) {        make.left.right.equalTo(self.contentView);        make.top.equalTo(_image.mas_bottom).offset(10);        make.bottom.equalTo(self.contentView).offset(-20);    }];}</code></pre><p>写好<code>layout</code>和<code>cell</code>后就可以用这两个类来初始化我们的<code>collectionView</code>了:</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">//add in view did load    self.layout = [[HorizontalFlowLayout alloc] init];    CGRect rct = self.view.bounds;    rct.size.height = 150;    rct.origin.y = [[UIScreen mainScreen] bounds].size.height / 2.0 - rct.size.height;    self.collectionView = [[UICollectionView alloc] initWithFrame:rct collectionViewLayout:_layout];    self.collectionView.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;    self.collectionView.showsHorizontalScrollIndicator = NO;    self.collectionView.decelerationRate = UIScrollViewDecelerationRateNormal;    [self.collectionView registerClass:[DotaCell class] forCellWithReuseIdentifier:NSStringFromClass([DotaCell class])];    [self.collectionView setBackgroundColor:[UIColor clearColor]];    [self.collectionView setDelegate:self];    [self.collectionView setDataSource:self];    [self.view addSubview:_collectionView];</code></pre><p>添加<code>UICollectionViewDataSource</code>的代理方法，使其显示数据。</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">- (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section {    return [self.itemTitles count];}- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath {    DotaCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:NSStringFromClass([DotaCell class]) forIndexPath:indexPath];    cell.image.image = [UIImage imageNamed:[self.itemTitles objectAtIndex:indexPath.row]];    cell.name.text = [self.itemTitles objectAtIndex:indexPath.row];    return cell;}</code></pre><p>这样程序就有了我们想要的初步效果：<br><img src="https://github.com/wossoneri/iosdemos/blob/master/HorizontalPickerView2/gifs/1.gif?raw=true" alt="gif1"></p><h2 id="图片水平排放"><a href="#图片水平排放" class="headerlink" title="图片水平排放"></a>图片水平排放</h2><p>但…效果的确很差！<br>下面要做的就是逐步完善效果，首先我们要让两排图像变成一排去展示。那要怎么去做？首先，我们在初始化<code>collectionView</code>的地方设置了高度为150，所以图片就挤在这个150的高度里尽可能的压缩显示。由于<code>collectionView</code>的尺寸已经设定，那么就剩<code>cell</code>的尺寸可以控制了。实现<code>CollectionViewFlowLayoutDelegate</code>的代理方法<code>sizeForItemAtIndexPath</code>：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">- (CGSize)collectionView:(nonnull UICollectionView *)collectionView layout:(nonnull UICollectionViewLayout *)collectionViewLayout sizeForItemAtIndexPath:(nonnull NSIndexPath *)indexPath {    return CGSizeMake(64, collectionView.bounds.size.height); }</code></pre><blockquote><p>这里宽度64是图片的尺寸，高度设置填满<code>collectionView</code>的高度是为了防止上图中两行图片挤压的情况，所以直接让一个<code>cell</code>的高度占满整个容器。</p></blockquote><p>这时候的效果好了很多，已经有点样子了：<br><img src="https://github.com/wossoneri/iosdemos/blob/master/HorizontalPickerView2/gifs/2.gif?raw=true" alt="gif2"></p><h2 id="顶端图片滑到中间"><a href="#顶端图片滑到中间" class="headerlink" title="顶端图片滑到中间"></a>顶端图片滑到中间</h2><p>但这离我们最终的效果还差很远，接下来我需要实现让第一张图片和最后一张图片都能滑到屏幕中点的位置，这应该是很常见的效果，实现起来也很简单。首先我们的一排<code>cell</code>都默认为顶端与<code>collectionView</code>的两端对齐的，<code>collectionView</code>的左右两端与<code>viewController.view</code>也是对齐的，所以显示的效果是，两端的图片都与屏幕对齐。知道这个关系就好办了，直接设置<code>collectionView</code>与其父<code>view</code>的内间距即可。<br>依旧是实现<code>flowLayout</code>的代理方法：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">//Asks the delegate for the margins to apply to content in the specified section.安排初始位置//使前后项都能居中显示- (UIEdgeInsets)collectionView:(nonnull UICollectionView *)collectionView layout:(nonnull UICollectionViewLayout *)collectionViewLayout insetForSectionAtIndex:(NSInteger)section {    NSInteger itemCount = [self collectionView:collectionView numberOfItemsInSection:section];    NSIndexPath *firstIndexPath = [NSIndexPath indexPathForItem:0 inSection:section];    CGSize firstSize = [self collectionView:collectionView layout:collectionViewLayout sizeForItemAtIndexPath:firstIndexPath];    NSIndexPath *lastIndexPath = [NSIndexPath indexPathForItem:itemCount - 1 inSection:section];    CGSize lastSize = [self collectionView:collectionView layout:collectionViewLayout sizeForItemAtIndexPath:lastIndexPath];    return UIEdgeInsetsMake(0, (collectionView.bounds.size.width - firstSize.width) / 2,                            0, (collectionView.bounds.size.width - lastSize.width) / 2);}</code></pre><p>效果如图：<br><img src="https://github.com/wossoneri/iosdemos/blob/master/HorizontalPickerView2/gifs/3.gif?raw=true" alt="gif3"></p><h2 id="居中图片放大显示"><a href="#居中图片放大显示" class="headerlink" title="居中图片放大显示"></a>居中图片放大显示</h2><p>接下来添加一个我们需要的特效，就是中间的图片放大显示，其余的缩小并且增加一层半透明效果。<br>在<code>FlowLayout</code>中有一个名为<code>layoutAttributesForElementsInRect</code>的方法，功能如其名，就是设置范围内元素的<code>layout</code>属性。对于这个效果，首先需要设置放大的比例，其次要根据图片大小和间距来设定一个合适的触发放大的区域宽度，当图滑入这个区域就进行缩放。</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">static CGFloat const ActiveDistance = 80;static CGFloat const ScaleFactor = 0.2;//这里设置放大范围- (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect{    NSArray *array = [super layoutAttributesForElementsInRect:rect];    CGRect visibleRect = (CGRect){self.collectionView.contentOffset, self.collectionView.bounds.size};    for (UICollectionViewLayoutAttributes *attributes in array) {        //如果cell在屏幕上则进行缩放        if (CGRectIntersectsRect(attributes.frame, rect)) {            attributes.alpha = 0.5;            CGFloat distance = CGRectGetMidX(visibleRect) - attributes.center.x;//距离中点的距离            CGFloat normalizedDistance = distance / ActiveDistance;            if (ABS(distance) < ActiveDistance) {                CGFloat zoom = 1 + ScaleFactor * (1 - ABS(normalizedDistance)); //放大渐变                attributes.transform3D = CATransform3DMakeScale(zoom, zoom, 1.0);                attributes.zIndex = 1;                attributes.alpha = 1.0;            }        }    }    return array;}</code></pre><p>效果如下：<br><img src="https://github.com/wossoneri/iosdemos/blob/master/HorizontalPickerView2/gifs/4.gif?raw=true" alt="gif4"></p><h2 id="滑动校正"><a href="#滑动校正" class="headerlink" title="滑动校正"></a>滑动校正</h2><p>这时候几乎完成了，但还差点东西，就是让其在滚动停止的时候，离屏幕中间最近的<code>cell</code>自动矫正位置到中间。还是在<code>FlowLayout</code>添加该方法，具体说明我都写到注释里了：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">//scroll 停止对中间位置进行偏移量校正- (CGPoint)targetContentOffsetForProposedContentOffset:(CGPoint)proposedContentOffset withScrollingVelocity:(CGPoint)velocity {    CGFloat offsetAdjustment = MAXFLOAT;    ////  |-------[-------]-------|    ////  |滑动偏移|可视区域 |剩余区域|    //是整个collectionView在滑动偏移后的当前可见区域的中点    CGFloat centerX = proposedContentOffset.x + (CGRectGetWidth(self.collectionView.bounds) / 2.0);    //    CGFloat centerX = self.collectionView.center.x; //这个中点始终是屏幕中点    //所以这里对collectionView的具体尺寸不太理解，输出的是屏幕大小，但实际上宽度肯定超出屏幕的    CGRect targetRect = CGRectMake(proposedContentOffset.x, 0.0, self.collectionView.bounds.size.width, self.collectionView.bounds.size.height);    NSArray *array = [super layoutAttributesForElementsInRect:targetRect];    for (UICollectionViewLayoutAttributes *layoutAttr in array) {        CGFloat itemCenterX = layoutAttr.center.x;        if (ABS(itemCenterX - centerX) < ABS(offsetAdjustment)) { // 找出最小的offset 也就是最中间的item 偏移量            offsetAdjustment = itemCenterX - centerX;        }    }    return CGPointMake(proposedContentOffset.x + offsetAdjustment, proposedContentOffset.y);}</code></pre><p><img src="https://github.com/wossoneri/iosdemos/blob/master/HorizontalPickerView2/gifs/5.gif?raw=true" alt="gif5"></p><h2 id="增加图片点击效果"><a href="#增加图片点击效果" class="headerlink" title="增加图片点击效果"></a>增加图片点击效果</h2><p>最后 添加一个点击cell 将其滚动到中间<br>在<code>viewcontroller</code>添加<code>CollectionViewDelegate</code>的代理方法</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">- (void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath {    [self.collectionView selectItemAtIndexPath:indexPath animated:YES scrollPosition:UICollectionViewScrollPositionNone];    //滚动到中间    [self.collectionView scrollToItemAtIndexPath:indexPath atScrollPosition:UICollectionViewScrollPositionCenteredHorizontally animated:YES];}</code></pre><p><img src="https://github.com/wossoneri/iosdemos/blob/master/HorizontalPickerView2/gifs/6.gif?raw=true" alt="gif6"></p><h2 id="封装成控件"><a href="#封装成控件" class="headerlink" title="封装成控件"></a>封装成控件</h2><p>当我们把效果实现之后，就可以考虑将代码优化一下，合到一个类里，减少书写常量，增加接口，封装成一个控件去使用。比如可以设定文字的显示与隐藏接口，再比如增加适应各种尺寸的图片等等。这个代码就不放了，毕竟不难，有问题给我留言好了。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>有网友照着我的代码写demo，发现居中放大的效果不起作用，那是因为需要在<code>flowLayout</code>里增加以下方法：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">- (BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds {    return YES;}</code></pre><p>用来刷新布局。这样在滑动的时候就会改变<code>cell</code>的大小了。</p>]]></content>
      
      
      <categories>
          
          <category> iOS入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> UICollectionView </tag>
            
            <tag> 图片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Objective-C] id类型和instancetype类型</title>
      <link href="/2015/12/29/%5BObjective-C%5DType-of-id-and-instancetype/"/>
      <url>/2015/12/29/%5BObjective-C%5DType-of-id-and-instancetype/</url>
      
        <content type="html"><![CDATA[<h2 id="id类型"><a href="#id类型" class="headerlink" title="id类型"></a>id类型</h2><p><code>id</code>数据类型可以存储任何类型的对象。可以说，它是一般对象类型。<br>例如可以声明一个为<code>id</code>类型的变量：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">id graphicObject</code></pre><p>也可声明方法使其具有id类型的返回值：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">- (id)newObject:(int)type;</code></pre><p><code>id</code>类型是Objective-C中十分重要的特性，它是多态和动态绑定的基础。</p><hr><h2 id="instancetype类型"><a href="#instancetype类型" class="headerlink" title="instancetype类型"></a>instancetype类型</h2><p><code>instancetype</code>是clang3.5开始提供的一个关键字，表示一个未知的Objective-C对象，类似于<code>id</code></p><p>按照Cocoa的惯例，Objective-C里所有使用<code>init</code>，<code>alloc</code>等名称的方法都会返回一个接受类类型的实例。这些方法被称为“有一个关联的返回类型”的方法，也就是说发给这些方法中的任意一个的消息都会返回一个以相同的静态类型代替接收类类型的一个实例，例如：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">@interface NSObject+ (id)alloc;- (id)init;@end@interface NSArray : NSObject@end</code></pre><p>和下面的通用初始化代码：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">NSArray *array = [[NSArray alloc] init];</code></pre><p>该表达式<code>[NSArray alloc]</code>是<code>NSArray *</code>类型，因为<code>alloc</code>拥有一个隐式的关联的返回类型。类似的，表达式<code>[[NSArray alloc] init]</code>也是<code>NSArray *</code>类型，因为<code>init</code>的返回类型也是一个关联的返回类型，同时也知道它的接收器有一个<code>NSArray *</code>的类型。如果<code>alloc</code>和<code>init</code>都没有一个关联的返回类型，表达式就会返回一个<code>id</code>类型，如同方法签名里声明的一样。</p><blockquote><p>iOS 8 里很多以前返回<code>id</code>的方法现在都改为了<code>instancetype</code>，甚至<code>init</code>和<code>alloc</code>。另外考虑兼容swift，还是用<code>instancetype</code>好</p></blockquote><p>可以通过声明<code>instancetype</code>类型作为一个拥有关联类型的方法的返回类型。<code>instancetype</code>这个上下文关键字<strong>只允许</strong>用在Objective-C<strong>方法</strong>的返回类型中。例如：</p><blockquote><p>注意只能用在Objective-C的方法中，变量不行的哦。常见于构造方法。<br>```objectivec<br>@implementation oneObject</p><ul><li>(instancetype)initOneObject {<br>  oneObject *obj = [oneObject new];<br>  return oneObject;<br>}<br>@end</li></ul></blockquote><pre><code>一个关联返回类型也可以通过一些方法推断出来。要确定一个方法是否有一个可以被推断出的关联的返回类型，首先要参考驼峰命名法命名的`selector`中的第一个单词（如`initWithObjects`中的`init`），其次要看其返回类型与自己的类的类型是否兼容，并且：* 第一个单词是`alloc`或`new`，并且方法是一个类方法(`+`开头)* 第一个单词是`autorelease`，`init`，`retain`或者`self`，且方法是一个实例方法(`-`开头)如果一个拥有关联返回类型的方法被子类方法复写了，那么子类方法必须返回一个与子类类型兼容的类型。比如：```objectivec@interface NSString : NSObject- (NSUnrelated *)init; // incorrect usage: NSUnrelated is not NSString or a superclass of NSString@end</code></pre><p>关联的返回类型只会影响发送的消息的类型或者通过指定方法访问属性的类型。在其他方面，拥有关联返回类型的方法与返回<code>id</code>类型的方法是一致的。</p><hr><h2 id="用instancetype代替id有什么好处？"><a href="#用instancetype代替id有什么好处？" class="headerlink" title="用instancetype代替id有什么好处？"></a>用instancetype代替id有什么好处？</h2><p>用<code>instancetype</code>可以给自定义方法一个类似<code>alloc/init</code>的行为，这个主要方便于构造函数</p><p>当使用<code>id</code>时，本质上不会有任何类型检查。使用<code>instancetype</code>，编译器和IDE知道返回的是什么类型的东西，并且更好地检查你的代码和自动补全代码。举个例子：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">//Class A@interface ClassA : NSObject- (id)methodA;- (instancetype)methodB;@end//Class B@interface ClassB : NSObject- (id)methodX;@end//Main.mint main(int argc, const char * argv[]) {    @autoreleasepool {        //这一行编译器不会产生报错，因为methodA方法返回的是id。但在运行时会出现异常        [[[[ClassA alloc] init] methodA] methodX];        //这一行不会通过编译器的检查，错误为"No visible @interface ClassA declares selector methodX"，因为methodB返回instancetype，即接收器的类型。        [[[[ClassA alloc] init] methodB] methodX];    }    return 0;}</code></pre><p>也可以说，在所有可以使用<code>instancetype</code>的情形中都有其好处。在详细解释之前，先声明：在一个类返回一个与自己类型一致的实例时，就适合使用<code>instancetype</code>。<br>实际上，Apple对于这个主题是这么解释的：</p><blockquote><p>在你的代码中，在合适的地方用返回类型<code>instancetype</code>代替<code>id</code>类型。这通常出现在<code>init</code>方法和类的工厂方法。即使编译器会自动的把以<code>init</code>，<code>alloc</code>和<code>new</code>开头和返回类型为<code>id</code>的方法转换成返回<code>instancetype</code>类型，除此之外它并不会转换其他方法。<strong>Objectice-C 明确约定对所有方法都写<code>instancetype</code></strong>。来源<a href="https://developer.apple.com/library/ios/releasenotes/ObjectiveC/ModernizationObjC/AdoptingModernObjective-C/AdoptingModernObjective-C.html#//apple_ref/doc/uid/TP40014150-CH1-SW11" target="_blank" rel="noopener">Adopting Modern Objective-C</a></p></blockquote><p>下面继续，首先看几个定义：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">@interface Foo:NSObject- (id)initWithBar:(NSInteger)bar; //initializer+ (id)fooWithBar:(NSInteger)bar;  //class factory@end</code></pre><p>对于一个类工厂方法，你应该<strong>总是</strong>使用<code>instancetype</code>类型。编译器不会自动将<code>id</code>转换为<code>instancetype</code>。这个<code>id</code>是一个通用对象。不过你一旦将其改为<code>instancetype</code>，编译器就知道这个方法返回的是一个什么类型的对象。</p><p>这并不是一个学术问题。举例来说，以前在Mac OS下<code>[[NSFileHandle fileHandleWithStandardOutput] writeData:formattedData]</code>会产生如下错误：<strong>Multiple methods named ‘writeData:’ found with mismatched result, parameter type or attributes</strong>。原因就在于<code>NSFileHandle</code>和<code>NSURLHandle</code>都提供一个<code>writeData:</code>方法。由于<code>[NSFileHandle fileHandleWithStandardOutput]</code>返回的是<code>id</code>，编译器就不确定<code>writeData:</code>是哪个类调用的。<br>解决这个问题就需要做下列方法中的一个：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">[(NSFileHandle *)[NSFileHandle fileHandleWithStandardOutput] writeData:formattedData];</code></pre><p>或者</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">NSFileHandle *fileHandle = [NSFileHandle fileHandleWithStandardOutput];[fileHandle writeData:formattedData];</code></pre><p>当然，更好的方法就是声明<code>fileHandleWithStandardOutput</code>的返回类型为<code>instancetype</code>。这样，就不需要声明类型或赋值了。</p><blockquote><p>现在版本的O-C源码里对上述例子有了修改：<code>+ (NSFileHandle *)fileHandleWithStandardOutput;</code>，所以不会有报错。不过，还是有其他例子存在，比如<code>length</code>方法，在<code>UILayoutSupport</code>中返回<code>CGFloat</code>，在<code>NSString</code>里返回<code>NSUInteger</code></p></blockquote><p>对于初始化器，这个就更加复杂了。当你写出如下代码：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">- (id)initWithBar:(NSInteger)bar</code></pre><p>编译器就会假设你输入的是这样的代码</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">- (instancetype)initWithBar:(NSInteger)bar</code></pre><p>这对于ARC来说很重要。见前面instancetype的定义。<br>这也就是为什么很多人会说使用<code>instancetype</code>不是必须的。当然我认为你还是应该去这么写。下面会解释为什么：</p><p>这有三个好处：</p><ol><li><strong>明确性</strong>。你的代码的行为如同你写的那样，而不是其他行为。</li><li><strong>模式化</strong>。你为此养成了一个好的代码习惯，这有时的确很重要。</li><li><strong>一致性</strong>。你写的代码前后会保持一致，增加其可读性。</li></ol><p><strong>明确性</strong>：<br>不得不承认，一个初始化方法<code>init</code>返回<code>instancetype</code>并不会带来明显的技术优势。但是这只是因为编译器会自动地将<code>id</code>转换为<code>instancetype</code>。你若让<code>init</code>    方法返回<code>id</code>类型，编译器还要再解释这个方法好像是要返回<code>instancetype</code>，这样总会显得很奇怪。<br>下面两句代码<strong>对于编译器</strong>来说是等价的：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">- (id)initWithBar:(NSInteger)bar;- (instancetype)initWithBar:(NSInteger)bar;</code></pre><p>而对你来说，看这两行代码应该并不一样。在最好的情况下而言，你会学会忽略这两行的差别。<strong>但这并不是你应该学会忽略的，对你来说这两句应该是不一样的</strong></p><p><strong>模式化</strong>：<br>当然<code>init</code>方法和其他方法没有区别，但一旦你定义一个类工厂，那就有差别了。<br>下面两行代码并不等价：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">+ (id)fooWithBar:(NSInteger)bar;+ (instancetype)fooWithBar:(NSInteger)bar;</code></pre><p>你需要第二个代码样式。如果你习惯去写<code>instancetype</code>作为返回类型的话，你每次都会得到正确的类型。</p><p><strong>一致性</strong>：<br>最后，想象你把这些东西都放在一起：你想要一个<code>init</code>方法和一个类工厂。<br>如果你习惯于对<code>init</code>使用<code>id</code>类型，你的代码看起来是这样：</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">- (id)initWithBar:(NSInteger)bar;+ (instancetype)fooWithBar:(NSInteger)bar;</code></pre><p>但是，如果你使用<code>instancetype</code>，你的代码就好看的多</p><pre class=" language-lang-objectivec"><code class="language-lang-objectivec">- (instancetype)initWithBar:(NSInteger)bar;+ (instancetype)fooWithBar:(NSInteger)bar;</code></pre><p>这样更明确也更可读。而且更清楚的看到他们返回同样的东西。</p><p>结论：<br>除非你是故意为旧的编译器写代码，否则在合适的地方你应该用<code>instancetype</code>。<br>以后当你写<code>id</code>之前应该三思：这个方法返回的是否是这个类的实例，如果是，就用<code>instancetype</code>。<br>当然，还是会有很多需要写<code>id</code>类型的情形，但你可能用<code>instancetype</code>会更多一些。</p><hr><blockquote><p>参考<br><a href="http://clang.llvm.org/docs/LanguageExtensions.html#related-result-types" target="_blank" rel="noopener">http://clang.llvm.org/docs/LanguageExtensions.html#related-result-types</a><br><a href="http://stackoverflow.com/questions/8972221/would-it-be-beneficial-to-begin-using-instancetype-instead-of-id" target="_blank" rel="noopener">http://stackoverflow.com/questions/8972221/would-it-be-beneficial-to-begin-using-instancetype-instead-of-id</a><br><a href="http://nshipster.com/instancetype/" target="_blank" rel="noopener">http://nshipster.com/instancetype/</a></p><p>Written with <a href="https://stackedit.io/" target="_blank" rel="noopener">StackEdit</a>.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Syntax </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Objective-C </tag>
            
            <tag> id </tag>
            
            <tag> instancetype </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Mac] OS X El Captain 配置 Apache-php-mysql</title>
      <link href="/2015/12/23/%5BMacOS%5D%20Mac-OS-X-El-Captain-Apache-php-mysql/"/>
      <url>/2015/12/23/%5BMacOS%5D%20Mac-OS-X-El-Captain-Apache-php-mysql/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="http://huangbingbing.com/2015/05/01/mac%E4%B8%8B%E9%85%8D%E7%BD%AEphp%E7%8E%AF%E5%A2%83/" target="_blank" rel="noopener">原文链接</a>:<a href="http://huangbingbing.com/2015/05/01/mac%E4%B8%8B%E9%85%8D%E7%BD%AEphp%E7%8E%AF%E5%A2%83/" target="_blank" rel="noopener">Mac-Yosemite10.10配置Apache-php-mysql</a><br>因为我是10.11.2的系统，验证操作可用，故转载过来</p></blockquote><h2 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h2><p>Mac OS X Yosemite 10.10 是預裝了apache和php的。</p><p>所以直接打開apache</p><pre class=" language-lang-Bash"><code class="language-lang-Bash">sudo apachectl start</code></pre><p>查看apache版本</p><pre class=" language-lang-Bash"><code class="language-lang-Bash">httpd -v</code></pre><p>在我的系統下返回一下結果</p><pre class=" language-lang-Bash"><code class="language-lang-Bash">Server version: Apache/2.4.16 (Unix)Server built:   Jul 31 2015 15:53:26</code></pre><p>重新启用PHP，避免脚本直接显示在页面上</p><pre class=" language-lang-Bash"><code class="language-lang-Bash">sudo vim /etc/apache2/httpd.conf</code></pre><p>ctrl + w 搜索下面這句，將其註釋(#)去掉</p><pre class=" language-lang-Bash"><code class="language-lang-Bash">LoadModule php5_module libexec/apache2/libphp5.so</code></pre><p>设置允许访问用户目录</p><ul><li>在用戶目錄下，創建Sites 文件夾<pre class=" language-lang-Bash"><code class="language-lang-Bash">sudo mkdir ~/Sites</code></pre>他就是預設被隱藏的個人根目錄資料夾，建立資料夾後他會自動有一個自己的圖案</li><li>修改httpd.conf 設置<pre class=" language-lang-Bash"><code class="language-lang-Bash">sudo vim /etc/apache2/httpd.conf</code></pre>ctrl + w 搜索下面內容，將其註釋(#)去掉<br>```Bash<br>LoadModule authz_core_module libexec/apache2/mod_authz_core.so</li></ul><p>LoadModule authz_host_module libexec/apache2/mod_authz_host.so</p><p>LoadModule userdir_module libexec/apache2/mod_userdir.so</p><p>LoadModule php5_module libexec/apache2/libphp5.so</p><p>Include /private/etc/apache2/extra/httpd-vhosts.conf</p><p>Include /private/etc/apache2/extra/httpd-userdir.conf</p><pre><code>* 修改httpd-userdir.conf設置```Bashsudo vim /etc/apache2/extra/httpd-userdir.conf</code></pre><p>ctrl + w 搜索下面內容，將其註釋(#)去掉</p><pre class=" language-lang-Bash"><code class="language-lang-Bash">Include /private/etc/apache2/users/*.conf</code></pre><ul><li>修改yourUserName.conf配置<pre class=" language-lang-Bash"><code class="language-lang-Bash">sudo vim /etc/apache2/users/username.conf</code></pre><blockquote><p><strong>ps</strong>: username.conf 裡的 username 是指你的mac的用戶名，如果沒有這個文件，上面的這條命令就會新建一個。</p></blockquote></li></ul><p>裡面添加(或修改)內容</p><pre class=" language-lang-xml"><code class="language-lang-xml"><Directory "/Users/你的用戶名/Sites/">    Options Indexes MultiViews    AllowOverride None    Require all granted</Directory></code></pre><ul><li>給以該文件權限(注意修改命令的username)<pre class=" language-lang-Bash"><code class="language-lang-Bash">sudo chmod 777 /etc/apache2/users/username.conf</code></pre></li><li>重啟apache<pre class=" language-lang-Bash"><code class="language-lang-Bash">sudo apachectl restart</code></pre></li><li>訪問<br>將php文件放入 Sites 中<pre class=" language-lang-Bash"><code class="language-lang-Bash">http://localhost/~username/</code></pre></li></ul><hr><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><blockquote><p><a href="http://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">下載</a><br>參考此文章：<a href="http://blog.csdn.net/colourless/article/details/41647199" target="_blank" rel="noopener">Mac osx 10.10系统下MySQL的安装（安装失败解决方法）</a></p></blockquote><p>開啟mysql</p><pre class=" language-lang-Bash"><code class="language-lang-Bash">sudo /usr/local/mysql/support-files/mysql.server start</code></pre><p>自行新增環境變量</p><pre class=" language-lang-Bash"><code class="language-lang-Bash">cd ; nano .bash_profileexport PATH="/usr/local/mysql/bin:$PATH"</code></pre><p>重新載入shell</p><pre class=" language-lang-Bash"><code class="language-lang-Bash">source ~/.bash_profile</code></pre><p>設定MySQL的帳號密碼</p><pre class=" language-lang-Bash"><code class="language-lang-Bash">/usr/local/mysql/bin/mysqladmin -u root password 'yourpasswordhere'sudo mkdir /var/mysqlsudo ln -s /tmp/mysql.sock /var/mysql/mysql.sock</code></pre><p>自動執行MySQL</p><pre class=" language-lang-Bash"><code class="language-lang-Bash">sudo nano /Library/LaunchDaemons/com.mysql.mysql.plist</code></pre><p>增加下面這段</p><pre class=" language-lang-xml"><code class="language-lang-xml"><plist version="1.0">  <dict>    <key>KeepAlive</key>    <true />    <key>Label</key>    <string>com.mysql.mysqld</string>    <key>ProgramArguments</key>    <array>      <string>/usr/local/mysql/bin/mysqld_safe</string>      <string>--user=mysql</string>    </array>          </dict></plist></code></pre><p>保存後執行</p><pre class=" language-lang-Bash"><code class="language-lang-Bash">sudo chown root:wheel /Library/LaunchDaemons/com.mysql.mysql.plistsudo chmod 644 /Library/LaunchDaemons/com.mysql.mysql.plistsudo launchctl load -w /Library/LaunchDaemons/com.mysql.mysql.plist</code></pre><hr><h2 id="phpMyAdmin"><a href="#phpMyAdmin" class="headerlink" title="phpMyAdmin"></a>phpMyAdmin</h2><blockquote><p><a href="http://www.phpmyadmin.net/home_page/downloads.php" target="_blank" rel="noopener">下載</a></p></blockquote><p>將下載的phpMyAdmin文件名改成phpMyAdmin，放入Stites文件夾裡，</p><p>創建配置文件</p><pre class=" language-lang-Bash"><code class="language-lang-Bash">mkdir ~/Sites/phpMyAdmin/config</code></pre><p>配置</p><pre class=" language-lang-Bash"><code class="language-lang-Bash">http://localhost/~username/phpmyadmin/setup/</code></pre><ul><li>點擊新建服務器</li><li>認證</li><li>在 config 认证方式的密码 欄 輸入設置的數據庫用戶名和密碼</li><li>應用，保存。<br>登錄phpMyAdmin<pre><code>http://localhost/~username/phpmyadmin/</code></pre></li></ul><blockquote><p>Written with <a href="https://stackedit.io/" target="_blank" rel="noopener">StackEdit</a>.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac OS </tag>
            
            <tag> PHP </tag>
            
            <tag> MySQL </tag>
            
            <tag> Apache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[iOS] 圆形进度条及计时功能</title>
      <link href="/2015/10/11/%5BiOS%5DCircle-Progress-Bar/"/>
      <url>/2015/10/11/%5BiOS%5DCircle-Progress-Bar/</url>
      
        <content type="html"><![CDATA[<blockquote><p>完整代码可以看:<a href="https://github.com/wossoneri/CircularProgressBar" target="_blank" rel="noopener">Github</a>。<br>其实没什么难度，下面记录几个要点</p></blockquote><p>放个预览图<br><img src="https://github.com/wossoneri/CircularProgressBar/raw/master/ExampleImage/Screen%20Shot%202015-10-10%20at%2011.10.22%20AM.png?raw=true" alt></p><p><img src="https://github.com/wossoneri/CircularProgressBar/raw/master/ExampleImage/Screen%20Shot%202015-10-10%20at%2011.10.35%20AM.png?raw=true" alt></p><hr><h2 id="画圆"><a href="#画圆" class="headerlink" title="画圆"></a>画圆</h2><p>用的贝塞尔曲线UIBezierPath来画，这个类支持画很多种形状，可以单独去尝试。</p><pre class=" language-lang-c"><code class="language-lang-c">UIBezierPath *progress = [UIBezierPath bezierPath];[progress addArcWithCenter:CGPointMake(rect.size.width / 2, rect.size.height / 2)                      radius:RADIUS                  startAngle:startAngle                    endAngle:endAngle                   clockwise:YES];progress.lineWidth = PROGRESS_WIDTH;[[UIColor redColor] set];[progress stroke];</code></pre><p>参数分别为圆心点、半径、绘制起始角度、绘制结束角度、顺时针方向。如果画一个整圆，角度设为0，2pi即可。这里0度对应3点钟方向，我希望绘制从12点方向开始，设置起始角度为-0.5pi即可。结束角度就根据经过的时间和总的时间的比例进行角度计算。有了以上参数也可以算出在当前角度下的圆周上点的坐标，即可以画出那个圆点。</p><hr><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>这里为了绘制看起来更连贯，我选择0.05秒刷新一次界面，而没有参考系统定时器的1秒刷新一次，这样看起来会更舒服。但在显示数字上会遇到1秒的误差，所以我在格式化字符串的时候对剩余时间做了向上去整<code>ceil()</code>的操作，具体差别可以通过改代码来尝试。</p><pre class=" language-lang-c"><code class="language-lang-c">m_timer = [NSTimer scheduledTimerWithTimeInterval:TIMER_INTERVAL target:self selector:@selector(setProgress) userInfo:nil repeats:YES];</code></pre><hr><h2 id="UIPickerView循环显示"><a href="#UIPickerView循环显示" class="headerlink" title="UIPickerView循环显示"></a>UIPickerView循环显示</h2><p>我一直以为iOS的滚轮是支持内容循环显示的，然而并没有看到相关接口，所以有点迷茫。查过资料后发现原来是用了一个技巧，<strong>即循环设置非常多的滚轮内容，然后默认选择居中的item，</strong>比如设置10000个项，内容是：0，1，2, …, 97, 98, 99, 0, 1, 2, …, 97, 98, 99, …,然后默认显示第5000个条目，这样用户划起来就好像是循环的。因为总的内容很多，用户不会划很多次，所以用户一般不会遇到划到头的情况。于是，我在系统计时器里试了一下，的确是这样的，当我往一个方向划动非常多次后，滚轮还是会到头的。所以这是可行的方法。</p><pre class=" language-lang-c"><code class="language-lang-c">//这里可以直接用MAX_ROWS / 2，但下面的计算适合各种情况:取中间位置，取整，再取余根据余数校正起始位置为要显示内容的第一项（即选中居中的 0 的位置）- (void)init {[m_pickerView selectRow:(((NSInteger)((MAX_ROWS / 2) / [m_arrayData count])) * [m_arrayData count]) + (selectedRow % [m_arrayData count]) inComponent:0 animated:NO];}-(NSInteger)pickerView:(UIPickerView *)pickerView numberOfRowsInComponent:(NSInteger)component{    return MAX_ROWS;}</code></pre><hr><h2 id="固定“分钟”单位"><a href="#固定“分钟”单位" class="headerlink" title="固定“分钟”单位"></a>固定“分钟”单位</h2><p>系统定时器在选择数字的时候，右边会有一个固定的单位。我依然没有在UIPickerView中找到设置固定单位的接口。如果在<code>-(NSString *)pickerView:(UIPickerView *)pickerView titleForRow:(NSInteger)row forComponent:(NSInteger)componet</code>方法里加上单位，则效果是每一项都会有这个单位。为了解决这个问题，我先尝试了第一种方法，即返回两列滑轮，第二列只有一行：“分钟”，这样显示效果没问题，但第二列是可以拖动的，即有边界弹性效果，而且系统也没有提供关闭弹性效果的接口（btw:UIScrollView里有）。因为这个效果和系统定时器的不一样，所以弃用，不过代码里依然遗留。第二个方案就是直接贴一个<code>Label</code>到适当的位置。简单粗暴，就是位置坐标需要调整到完美显示。不过把它封装成一套控件，往后就可以随意使用了。</p><blockquote><p>参考资料因为chrome没设置同步历史记录，所以这台电脑上没有，改天抽空补上<br>完整代码可以看:<a href="https://github.com/wossoneri/CircularProgressBar" target="_blank" rel="noopener">Github</a><br>自定义AlertView用的是开源的项目:<a href="https://github.com/wimagguc/ios-custom-alertview" target="_blank" rel="noopener">Github</a></p><p>Written with <a href="https://stackedit.io/" target="_blank" rel="noopener">StackEdit</a>.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> iOS入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> UIPickerView </tag>
            
            <tag> 圆形进度条 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Java] 多线程编程</title>
      <link href="/2015/09/29/%5BJava%5DMulti-Thread/"/>
      <url>/2015/09/29/%5BJava%5DMulti-Thread/</url>
      
        <content type="html"><![CDATA[<h2 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h2><p>和其他多数计算机语言不同，Java内置支持<code>多线程编程（multithreaded programming）</code>。</p><p>多线程程序包含两条或两条以上并发运行的部分。程序中每个这样的部分都叫一个<code>线程（thread）</code>，每个线程都有独立的执行路径。因此，多线程是多任务处理的一种特殊形式。</p><p>你一定知道多任务处理，因为它实际上被所有的现代操作系统所支持。然而，多任务处理有两种截然不同的类型：基于<strong>进程</strong>的和基于<strong>线程</strong>的。认识两者的不同是十分重要的。</p><p><code>进程(process)</code>本质上是一个执行的程序。因此，<strong><code>基于进程(process-based)</code>的多任务处理的特点是允许你的计算机同时运行两个或更多的程序</strong>。举例来说，基于进程的多任务处理使你在运用文本编辑器的时候可以同时运行Java编译器。在基于进程的多任务处理中，程序是调度程序所分派的最小代码单位。</p><p>在<code>基于线程(thread-based)</code> 的多任务处理环境中，线程是最小的执行单位。这意味着<strong>一个程序可以同时执行两个或者多个任务的功能</strong>。例如，一个文本编辑器可以在打印的同时格式化文本。</p><p>所以，多进程程序处理“大图片”，而多线程程序处理细节问题。</p><p><strong>多线程程序比多进程程序需要更少的管理费用</strong>。进程是重量级的任务，需要分配它们自己独立的地址空间。进程间通信是昂贵和受限的。进程间的转换也是很需要花费的。另一方面，线程是轻量级的选手。它们共享相同的地址空间并且共同分享同一个进程。线程间通信是便宜的，线程间的转换也是低成本的。当Java程序使用多进程任务处理环境时，多进程程序不受Java的控制，而多线程则受Java控制。</p><p>多线程帮助你写出CPU最大利用率的高效程序，因为空闲时间保持最低。这对Java运行的交互式的网络互连环境是至关重要的，因为空闲时间是公共的。举个例子来说，网络的数据传输速率远低于计算机处理能力，本地文件系统资源的读写速度远低于CPU的处理能力，当然，用户输入也比计算机慢很多。在传统的单线程环境中，你的程序必须等待每一个这样的任务完成以后才能执行下一步——尽管CPU有很多空闲时间。多线程使你能够获得并充分利用这些空闲时间。</p><hr><h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><p>Java运行系统在很多方面依赖于线程，所有的类库设计都考虑到多线程。实际上，Java使用线程来使整个环境异步。这有利于通过防止CPU循环的浪费来减少无效部分。</p><p>为更好的理解多线程环境的优势可以将它与它的对照物相比较。单线程系统的处理途径是使用一种叫作轮询的事件循环方法。在该模型中，单线程控制在一无限循环中运行，轮询一个事件序列来决定下一步做什么。一旦轮询装置返回信号表明，已准备好读取网络文件，事件循环调度控制管理到适当的事件处理程序。直到事件处理程序返回，系统中没有其他事件发生。这就浪费了CPU时间。这导致了程序的一部分独占了系统，阻止了其他事件的执行。总的来说，单线程环境，当一个线程因为等待资源时阻塞（block，挂起执行），整个程序停止运行。</p><p>Java多线程的优点在于取消了主循环/轮询机制。一个线程可以暂停而不影响程序的其他部分。例如，当一个线程从网络读取数据或等待用户输入时产生的空闲时间可以被利用到其他地方。多线程允许活的循环在每一帧间隙中沉睡一秒而不暂停整个系统。在Java程序中出现线程阻塞，仅有一个线程暂停，其他线程继续运行。</p><p>线程存在于好几种状态。线程可以正在运行（running）。只要获得CPU时间它就可以运行。运行的线程可以被挂起（suspend），并临时中断它的执行。一个挂起的线程可以被恢复（resume），允许它从停止的地方继续运行。一个线程可以在等待资源时被阻塞（block）。<strong><font color="brown">在任何时候，线程可以终止（terminate），这立即中断了它的运行。一旦终止，线程不能被恢复。</font></strong></p><h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>Java给每个线程安排优先级以决定与其他线程比较时该如何对待该线程。线程优先级是详细说明线程间优先关系的整数。作为绝对值，优先级是毫无意义的；当只有一个线程时，优先级高的线程并不比优先权低的线程运行的快。相反，线程的优先级是用来决定何时从一个运行的线程切换到另一个。这叫“上下文转换”(context switch)。决定上下文转换发生的规则很简单：</p><ul><li>线程可以自动放弃控制。在I/O未决定的情况下，睡眠或阻塞由明确的让步来完成。在这种假定下，所有其他的线程被检测，准备运行的最高优先级线程被授予CPU。</li><li>线程可以被高优先级的线程抢占。在这种情况下，低优先级线程不主动放弃，处理器只是被先占——无论它正在干什么——处理器被高优先级的线程占据。基本上，一旦高优先级线程要运行，它就执行。这叫做有优先权的多任务处理。</li></ul><blockquote><p>当两个相同优先级的线程竞争CPU周期时，情形有一点复杂。具体与操作系统有关。</p><p>不同的操作系统下等优先级线程的上下文转换可能会产生错误。</p></blockquote><h3 id="同步性"><a href="#同步性" class="headerlink" title="同步性"></a>同步性</h3><p>因为多线程在你的程序中引入了一个异步行为，所以在你需要的时候必须有加强同步性的方法。举例来说，如果你希望两个线程相互通信并共享一个复杂的数据结构，例如链表序列，你需要某些方法来确保它们没有相互冲突。也就是说，你必须防止一个线程写入数据而另一个线程正在读取链表中的数据。为此目的，Java在进程间同步性的老模式基础上实行了另一种方法：<code>管程（monitor）</code>。管程是一种由C.A.R.Hoare首先定义的控制机制。</p><p>你可以把管程想象成一个仅控制一个线程的小盒子。一旦线程进入管程，所有线程必须等待直到该线程退出了管程。用这种方法，管程可以用来防止共享的资源被多个线程操纵。</p><p>很多多线程系统把管程作为程序必须明确的引用和操作的对象。Java提供一个清晰的解决方案。没有“Monitor”类；相反，每个对象都拥有自己的隐式管程，当对象的同步方法被调用时管程自动载入。一旦一个线程包含在一个同步方法中，没有其他线程可以调用相同对象的同步方法。这就使你可以编写非常清晰和简洁的多线程代码，因为同步支持是语言内置的。</p><h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><p>在你把程序分成若干线程后，你就要定义各线程之间的联系。用大多数其他语言规划时，你必须依赖于操作系统来确立线程间通信。这样当然增加花费。然而，Java提供了多线程间谈话清洁的、低成本的途径——通过调用所有对象都有的预先确定的方法。Java的消息传递系统允许一个线程进入一个对象的一个同步方法，然后在那里等待，直到其他线程明确通知它出来。</p><h3 id="Thread-类和Runnable-接口"><a href="#Thread-类和Runnable-接口" class="headerlink" title="Thread 类和Runnable 接口"></a>Thread 类和Runnable 接口</h3><p>Java的多线程系统建立于Thread类，它的方法，它的共伴接口Runnable基础上。Thread类封装了线程的执行。既然你不能直接引用运行着的线程的状态，你要通过它的代理处理它，于是Thread 实例产生了。为创建一个新的线程，你的程序必须扩展Thread 或实现Runnable接口。</p><p>Thread类定义了好几种方法来帮助管理线程。本章用到的方法如下表所示：</p><p></p><p align="center">管理线程的方法</p><br>| 方法    |意义     |<br>| ———- | ———-  |<br>| getName   | 获得线程名称                 |<br>| getPriority | 获得线程优先级                 |<br>| isAlive       | 判定线程是否仍在运行             |<br>| join           | 等待一个线程终止                 |<br>| run           | 线程的入口点             |<br>| sleep         | 在一段时间内挂起线程             |<br>| start       | 通过调用运行方法来启动线程 |<br>（博客园markdown不支持表格显示？）<p></p><hr><h2 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h2><p>当Java程序启动时，一个线程立刻运行，该线程通常叫做程序的<code>主线程（main thread）</code>，因为它是程序开始时就执行的。主线程的重要性体现在两方面：</p><ul><li>它是产生其他子线程的线程</li><li>通常它必须最后完成执行，因为它执行各种关闭动作</li></ul><p>尽管主线程在程序启动时自动创建，但它可以由一个Thread对象控制。为此，你必须调用方法currentThread()获得它的一个引用，currentThread()是Thread类的公有的静态方法。它的通常形式如下：</p><pre class=" language-lang-java"><code class="language-lang-java">static Thread currentThread( )</code></pre><p>该方法返回一个调用它的线程的引用。一旦你获得主线程的引用，你就可以像控制其他线程那样控制主线程。</p><p>让我们从复习下面例题开始：</p><pre class=" language-lang-java"><code class="language-lang-java">public class CurrentThreadDemo {    public static void main(String args[]) {        Thread t = Thread.currentThread();        System.out.println("Current thread: " + t);        // change the name of the thread        t.setName("My Thread");        System.out.println("After name change: " + t);        try {            for (int n = 5; n > 0; n--) {                System.out.println(n);                Thread.sleep(1000);            }        } catch (InterruptedException e) {            System.out.println("Main thread interrupted");        }    }}</code></pre><p>在本程序中，当前线程（自然是主线程）的引用通过调用currentThread()获得，该引用保存在局部变量t中。然后，程序显示了线程的信息。接着程序调用setName()改变线程的内部名称。线程信息又被显示。然后，一个循环数从5开始递减，每数一次暂停一秒。暂停是由sleep()方法来完成的。Sleep()语句明确规定延迟时间是1毫秒。注意循环外的try/catch块。</p><p>Thread类的sleep()方法可能引发一个InterruptedException异常。这种情形会在其他线程想要打搅沉睡线程时发生。本例只是打印了它是否被打断的消息。在实际的程序中，你必须灵活处理此类问题。下面是本程序的输出：</p><blockquote><p>Current thread: Thread[main,5,main]<br>After name change: Thread[My Thread,5,main]<br>5<br>4<br>3<br>2<br>1</p></blockquote><p>注意<code>t</code>作为语句println()中参数运用时输出的产生。该显示顺序：线程名称，优先级以及组的名称。默认情况下，主线程的名称是main。它的优先级是5，这也是默认值，main也是所属线程组的名称。一个<code>线程组（thread group）</code>是一种将线程作为一个整体集合的状态控制的数据结构。这个过程由专有的运行时环境来处理，在此就不赘述了。线程名改变后，t又被输出。这次，显示了新的线程名。</p><p>让我们更仔细的研究程序中Thread类定义的方法。sleep()方法按照毫秒级的时间指示使线程从被调用到挂起。它的通常形式如下：</p><pre class=" language-lang-java"><code class="language-lang-java"> static void sleep(long milliseconds) throws InterruptedException</code></pre><p>挂起的时间被明确定义为毫秒。该方法可能引发InterruptedException异常。</p><p>sleep()方法还有第二种形式，显示如下，该方法允许你指定时间是以毫秒还是以纳秒为周期。</p><pre class=" language-lang-java"><code class="language-lang-java">static void sleep(long milliseconds, int nanoseconds) throws InterruptedException</code></pre><p>第二种形式仅当允许以纳秒为时间周期时可用。如上述程序所示，你可以用setName()设置线程名称，用getName()来获得线程名称（该过程在程序中没有体现）。这些方法都是Thread 类的成员，声明如下：</p><pre class=" language-lang-java"><code class="language-lang-java">final void setName(String threadName)final String getName( )</code></pre><p>这里，threadName 特指线程名称。</p><hr><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>大多数情况，通过实例化一个Thread对象来创建一个线程。Java定义了两种方式：</p><ul><li>实现Runnable 接口</li><li>可以继承Thread类</li></ul><h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><p><font color="brown"><strong>创建线程的最简单的方法就是创建一个实现Runnable 接口的类。</strong></font>Runnable抽象了一个执行代码单元。你可以通过实现Runnable接口的方法创建每一个对象的线程。为实现Runnable 接口，一个类仅需实现一个run()的简单方法，该方法声明如下：</p><pre class=" language-lang-java"><code class="language-lang-java">public void run( )</code></pre><p>在run()中可以定义代码来构建新的线程。理解下面内容是至关重要的：run()方法能够像主线程那样调用其他方法，引用其他类，声明变量。仅有的不同是run()在程序中确立另一个并发的线程执行入口。当run()返回时，该线程结束。</p><p>在你已经创建了实现Runnable接口的类以后，你要在类内部实例化一个Thread类的对象。Thread 类定义了好几种构造函数。我们会用到的如下：</p><pre class=" language-lang-java"><code class="language-lang-java">Thread(Runnable threadOb, String threadName)</code></pre><p>该构造函数中，threadOb是一个实现Runnable接口类的实例。这定义了线程执行的起点。新线程的名称由threadName定义。</p><p>建立新的线程后，它并不运行直到调用了它的start()方法，该方法在Thread 类中定义。本质上，start() 执行的是一个对run()的调用。Start()方法声明如下：</p><pre class=" language-lang-java"><code class="language-lang-java">void start( )</code></pre><p>下面的例子是创建一个新的线程并启动它运行：</p><pre class=" language-lang-java"><code class="language-lang-java">// Create a second thread.class NewThread implements Runnable {    Thread t;    NewThread() {        // Create a new, second thread        t = new Thread(this, "Demo Thread");        System.out.println("Child thread: " + t);        t.start(); // Start the thread    }    // This is the entry point for the second thread.    public void run() {        try {            for (int i = 5; i > 0; i--) {                System.out.println("Child Thread: " + i);                Thread.sleep(500);            }        } catch (InterruptedException e) {            System.out.println("Child interrupted.");        }        System.out.println("Exiting child thread.");    }}public class Demo {    public static void main(String args[]) {        new NewThread(); // create a new thread        try {            for (int i = 5; i > 0; i--) {                System.out.println("Main Thread: " + i);                Thread.sleep(1000);            }        } catch (InterruptedException e) {            System.out.println("Main thread interrupted.");        }        System.out.println("Main thread exiting.");    }}</code></pre><p>在NewThread 构造函数中，新的Thread对象由下面的语句创建：:</p><pre class=" language-lang-java"><code class="language-lang-java">t = new Thread(this, "Demo Thread");</code></pre><p>通过前面的语句this 表明在this对象中你想要新的线程调用run()方法。然后，start() 被调用，以run()方法为开始启动了线程的执行。这使子线程for 循环开始执行。调用start()之后，NewThread 的构造函数返回到main()。当主线程被恢复，它到达for 循环。两个线程继续运行，共享CPU，直到它们的循环结束。该程序的输出如下：</p><blockquote><p>Child thread: Thread[Demo Thread,5,main]<br>Main Thread: 5<br>Child Thread: 5<br>Child Thread: 4<br>Main Thread: 4<br>Child Thread: 3<br>Child Thread: 2<br>Main Thread: 3<br>Child Thread: 1<br>Exiting child thread.<br>Main Thread: 2<br>Main Thread: 1<br>Main thread exiting.</p></blockquote><p>如前面提到的，在多线程程序中，通常主线程必须是结束运行的最后一个线程。实际上，一些老的JVM，如果主线程先于子线程结束，Java的运行时间系统就可能“挂起”。前述程序保证了主线程最后结束，因为主线程沉睡周期1000毫秒，而子线程仅为500毫秒。这就使子线程在主线程结束之前先结束。简而言之，你将看到等待线程结束的更好途径。</p><h3 id="扩展Thread"><a href="#扩展Thread" class="headerlink" title="扩展Thread"></a>扩展Thread</h3><p><font color="brown"><strong>创建线程的另一个途径是创建一个新类来扩展Thread类，然后创建该类的实例。</strong></font>当一个类继承Thread时，它必须重载run()方法，这个run()方法是新线程的入口。它也必须调用start()方法去启动新线程执行。下面用扩展thread类重写前面的程序：</p><pre class=" language-lang-java"><code class="language-lang-java">// Create a second thread by extending Threadclass NewThread extends Thread {    NewThread() {        // Create a new, second thread        super("Demo Thread");        System.out.println("Child thread: " + this);        start(); // Start the thread    }    // This is the entry point for the second thread.    public void run() {        try {            for (int i = 5; i > 0; i--) {                System.out.println("Child Thread: " + i);                Thread.sleep(500);            }        } catch (InterruptedException e) {            System.out.println("Child interrupted.");        }        System.out.println("Exiting child thread.");    }}public class Demo {    public static void main(String args[]) {        new NewThread(); // create a new thread        try {            for (int i = 5; i > 0; i--) {                System.out.println("Main Thread: " + i);                Thread.sleep(1000);            }        } catch (InterruptedException e) {            System.out.println("Main thread interrupted.");        }        System.out.println("Main thread exiting.");    }}</code></pre><p>该程序生成和前述版本相同的输出。子线程是由实例化NewThread对象生成的，该对象从Thread类派生。注意NewThread 中super()的调用。该方法调用了下列形式的Thread构造函数：</p><pre class=" language-lang-java"><code class="language-lang-java">public Thread(String threadName)</code></pre><p>这里，threadName指定线程名称。</p><blockquote><p>Thread类定义了多种方法可以被派生类复写。对于所有的方法，惟一的必须被复写的是run()方法。这当然是实现Runnable接口所需的同样的方法。很多Java程序员认为类仅在它们被加强或修改时应该被扩展。因此，如果你不复写Thread的其他方法时，最好只实现Runnable 接口。这当然由你决定。然而，在本章的其他部分，我们应用实现runnable接口的类来创建线程。</p></blockquote><hr><h2 id="创建多线程"><a href="#创建多线程" class="headerlink" title="创建多线程"></a>创建多线程</h2><p>到目前为止，我们仅用到两个线程：主线程和一个子线程。然而，你的程序可以创建所需的更多线程。例如，下面的程序创建了三个子线程：<br>到目前为止，我们仅用到两个线程：主线程和一个子线程。然而，你的程序可以创建所需的更多线程。例如，下面的程序创建了三个子线程：</p><pre class=" language-lang-java"><code class="language-lang-java">// Create multiple threads.class NewThread implements Runnable {    String name; // name of thread    Thread t;    NewThread(String threadname) {        name = threadname;        t = new Thread(this, name);        System.out.println("New thread: " + t);        t.start(); // Start the thread    }    // This is the entry point for thread.    public void run() {        try {            for (int i = 5; i > 0; i--) {                System.out.println(name + ": " + i);                Thread.sleep(1000);            }        } catch (InterruptedException e) {            System.out.println(name + "Interrupted");        }        System.out.println(name + " exiting.");    }}public class Demo {    public static void main(String args[]) {        new NewThread("One"); // start threads        new NewThread("Two");        new NewThread("Three");        try {            // wait for other threads to end            Thread.sleep(10000);        } catch (InterruptedException e) {            System.out.println("Main thread Interrupted");        }        System.out.println("Main thread exiting.");    }}</code></pre><p>程序输出：</p><blockquote><p>New thread: Thread[One,5,main]<br>New thread: Thread[Two,5,main]<br>One: 5<br>New thread: Thread[Three,5,main]<br>Two: 5<br>Three: 5<br>One: 4<br>Three: 4<br>Two: 4<br>Two: 3<br>Three: 3<br>One: 3<br>Two: 2<br>One: 2<br>Three: 2<br>Two: 1<br>Three: 1<br>One: 1<br>One exiting.<br>Two exiting.<br>Three exiting.<br>Main thread exiting.</p></blockquote><p>如你所见，一旦启动，所有三个子线程共享CPU。注意main()中对sleep(10000)的调用。这使主线程沉睡十秒确保它最后结束。</p><hr><h2 id="使用-isAlive-和-join"><a href="#使用-isAlive-和-join" class="headerlink" title="使用 isAlive() 和 join()"></a>使用 isAlive() 和 join()</h2><p>如前所述，通常你希望主线程最后结束。在前面的例子中，这点是通过在main()中调用sleep()来实现的，经过足够长时间的延迟以确保所有子线程都先于主线程结束。然而，这不是一个令人满意的解决方法，它也带来一个大问题：一个线程如何知道另一线程已经结束？幸运的是，Thread类提供了回答此问题的方法。</p><p>有两种方法可以判定一个线程是否结束。第一，可以在线程中调用isAlive()。这种方法由Thread定义，它的通常形式如下：</p><pre class=" language-lang-java"><code class="language-lang-java">final boolean isAlive( )</code></pre><p>如果所调用线程仍在运行，isAlive()方法返回true，如果不是则返回false。但isAlive（）很少用到，等待线程结束的更常用的方法是调用join()，描述如下：</p><pre class=" language-lang-java"><code class="language-lang-java">final void join( ) throws InterruptedException</code></pre><p>该方法等待所调用线程结束。该名字来自于要求线程等待直到指定线程参与的概念。join()的附加形式允许给等待指定线程结束定义一个最大时间。下面是前面例子的改进版本。运用join()以确保主线程最后结束。同样，它也演示了isAlive()方法。</p><pre class=" language-lang-java"><code class="language-lang-java">// Using join() to wait for threads to finish.class NewThread implements Runnable {    String name; // name of thread    Thread t;    NewThread(String threadname) {        name = threadname;        t = new Thread(this, name);        System.out.println("New thread: " + t);        t.start(); // Start the thread    }    // This is the entry point for thread.    public void run() {        try {            for (int i = 5; i > 0; i--) {                System.out.println(name + ": " + i);                Thread.sleep(1000);            }        } catch (InterruptedException e) {            System.out.println(name + " interrupted.");        }        System.out.println(name + " exiting.");    }}class DemoJoin {    public static void main(String args[]) {        NewThread ob1 = new NewThread("One");        NewThread ob2 = new NewThread("Two");        NewThread ob3 = new NewThread("Three");        System.out.println("Thread One is alive: " + ob1.t.isAlive());        System.out.println("Thread Two is alive: " + ob2.t.isAlive());        System.out.println("Thread Three is alive: " + ob3.t.isAlive());        // wait for threads to finish        try {            System.out.println("Waiting for threads to finish.");            ob1.t.join();            ob2.t.join();            ob3.t.join();        } catch (InterruptedException e) {            System.out.println("Main thread Interrupted");        }        System.out.println("Thread One is alive: " + ob1.t.isAlive());        System.out.println("Thread Two is alive: " + ob2.t.isAlive());        System.out.println("Thread Three is alive: " + ob3.t.isAlive());        System.out.println("Main thread exiting.");    }}</code></pre><p>运行结果：</p><blockquote><p>New thread: Thread[One,5,main]<br>New thread: Thread[Two,5,main]<br>One: 5<br>New thread: Thread[Three,5,main]<br>Two: 5<br>Thread One is alive: true<br>Thread Two is alive: true<br>Three: 5<br>Thread Three is alive: true<br>Waiting for threads to finish.<br>Two: 4<br>Three: 4<br>One: 4<br>One: 3<br>Two: 3<br>Three: 3<br>Two: 2<br>Three: 2<br>One: 2<br>Two: 1<br>One: 1<br>Three: 1<br>Three exiting.<br>Two exiting.<br>One exiting.<br>Thread One is alive: false<br>Thread Two is alive: false<br>Thread Three is alive: false<br>Main thread exiting.</p></blockquote><p>如你所见，调用join()后返回，线程终止执行。</p><hr><h2 id="线程优先级-1"><a href="#线程优先级-1" class="headerlink" title="线程优先级"></a>线程优先级</h2><p>线程优先级<strong>被线程调度</strong>用来<strong>判定何时每个线程允许运行</strong>。理论上，优先级高的线程比优先级低的线程获得更多的CPU时间。实际上，线程获得的CPU时间通常由包括优先级在内的多个因素决定（例如，一个实行多任务处理的操作系统如何更有效的利用CPU时间）。一个优先级高的线程自然比优先级低的线程优先。举例来说，当低优先级线程正在运行，而一个高优先级的线程被恢复（例如从沉睡中或等待I/O中），它将抢占低优先级线程所使用的CPU。</p><p>理论上，等优先级线程有同等的权利使用CPU。但你必须小心了。记住，Java是被设计成能在很多环境下工作的。一些环境下实现多任务处理从本质上与其他环境不同。为安全起见，等优先级线程偶尔也受控制。这保证了所有线程在无优先级的操作系统下都有机会运行。实际上，在无优先级的环境下，多数线程仍然有机会运行，因为很多线程不可避免的会遭遇阻塞，例如等待输入输出。遇到这种情形，阻塞的线程挂起，其他线程运行。但是如果你希望多线程执行的顺利的话，最好不要采用这种方法。同样，有些类型的任务是占CPU的。对于这些支配CPU类型的线程，有时你希望能够支配它们，以便使其他线程可以运行。</p><p>设置线程的优先级，用setPriority()方法，该方法也是Tread 的成员。它的通常形式为：</p><pre class=" language-lang-java"><code class="language-lang-java">final void setPriority(int level)</code></pre><p>这 里 ， level 指 定了对所调用的线程的新的优先权的设置。Level的值必须在MIN_PRIORITY到MAX_PRIORITY范围内。通常，它们的值分别是1和10。要返回一个线程为默认的优先级，指定NORM_PRIORITY，通常值为5。这些优先级在Thread中都被定义为final型变量。</p><p>你可以通过调用Thread的getPriority()方法来获得当前的优先级设置。该方法如下：</p><pre class=" language-lang-java"><code class="language-lang-java">final int getPriority( )</code></pre><p>当涉及调度时，Java的执行可以有本质上不同的行为。Windows 95/98/NT/2000 的工作或多或少如你所愿。但其他版本可能工作的完全不同。大多数矛盾发生在你使用有优先级行为的线程，而不是协同的腾出CPU时间。最安全的办法是获得可预先性的优先权，Java获得跨平台的线程行为的方法是自动放弃对CPU的控制。</p><p>下面的例子阐述了两个不同优先级的线程，运行于具有优先权的平台，这与运行于无优先级的平台不同。一个线程通过Thread.NORM_PRIORITY设置了高于普通优先级两级的级数，另一线程设置的优先级则低于普通级两级。两线程被启动并允许运行10秒。每个线程执行一个循环，记录反复的次数。10秒后，主线程终止了两线程。每个线程经过循环的次数被显示。</p><pre class=" language-lang-java"><code class="language-lang-java">// Demonstrate thread priorities.class clicker implements Runnable {     int click = 0;    Thread t;    private volatile boolean running = true;    public clicker(int p) {        t = new Thread(this);        t.setPriority(p);    }    public void run() {        while (running) {            click++;        }    }    public void stop() {        running = false;    }    public void start() {        t.start();    }}class Demo {    public static void main(String args[]) {        Thread.currentThread().setPriority(Thread.MAX_PRIORITY);        clicker hi = new clicker(Thread.NORM_PRIORITY + 2);        clicker lo = new clicker(Thread.NORM_PRIORITY - 2);        lo.start();        hi.start();        try {            Thread.sleep(10000);        } catch (InterruptedException e) {            System.out.println("Main thread interrupted.");        }        lo.stop();        hi.stop();        // Wait for child threads to terminate.        try {            hi.t.join();            lo.t.join();        } catch (InterruptedException e) {            System.out.println("InterruptedException caught");        }        System.out.println("Low-priority thread: " + lo.click);        System.out.println("High-priority thread: " + hi.click);    }}</code></pre><p>我在Mac上运行结果是：</p><blockquote><p>Low-priority thread: 158021835<br>High-priority thread: 111098732</p></blockquote><p>原文情况比较早，如下：<br>该程序在Windows 98下运行的输出，表明线程确实上下转换，甚至既不屈从于CPU，也不被输入输出阻塞。优先级高的线程获得大约90%的CPU时间。</p><blockquote><p>Low-priority thread: 4408112<br>High-priority thread: 589626904</p></blockquote><p>当然，该程序的精确的输出结果依赖于你的CPU的速度和运行的其他任务的数量。当同样的程序运行于无优先级的系统，将会有不同的结果。</p><p>上述程序还有个值得注意的地方。注意running前的关键字volatile。尽管volatile 在下章会被很仔细的讨论，用在此处以确保running的值在下面的循环中每次都得到验证。</p><pre class=" language-lang-java"><code class="language-lang-java">while (running) {    click++;}</code></pre><p>如果不用volatile，Java可以自由的优化循环：running的值被存在CPU的一个寄存器中，每次重复不一定需要复检。volatile的运用阻止了该优化，告知Java running可以改变，改变方式并不以直接代码形式显示。</p><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>当两个或两个以上的线程需要共享资源，它们需要某种方法来确定资源在某一刻仅被一个线程占用。达到此目的的过程叫做<code>同步(synchronization）</code>。像你所看到的，Java为此提供了独特的，语言水平上的支持。</p><p>同步的关键是管程（也叫<code>信号量semaphore</code>）的概念。管程是一个互斥独占锁定的对象，或称<code>互斥体（mutex）</code>。在给定的时间，仅有一个线程可以获得管程。当一个线程需要锁定，它必须进入管程。所有其他的试图进入已经锁定的管程的线程必须挂起直到第一个线程退出管程。这些其他的线程被称为等待管程。一个拥有管程的线程如果愿意的话可以再次进入相同的管程。</p><p>如果你用其他语言例如C或C++时用到过同步，你会知道它用起来有一点诡异。这是因为很多语言它们自己不支持同步。相反，对同步线程，程序必须利用操作系统源语。幸运的是Java通过语言元素实现同步，大多数的与同步相关的复杂性都被消除。</p><p>你可以用两种方法同步化代码。两者都包括synchronized关键字的运用，下面分别说明这两种方法。</p><h3 id="使用同步方法"><a href="#使用同步方法" class="headerlink" title="使用同步方法"></a>使用同步方法</h3><p>Java中同步是简单的，因为所有对象都有它们与之对应的隐式管程。进入某一对象的管程，就是调用被synchronized关键字修饰的方法。当一个线程在一个同步方法内部，所有试图调用该方法（或其他同步方法）的同实例的其他线程必须等待。为了退出管程，并放弃对对象的控制权给其他等待的线程，拥有管程的线程仅需从同步方法中返回。</p><p>为理解同步的必要性，让我们从一个应该使用同步却没有用的简单例子开始。下面的程序有三个简单类。首先是Callme，它有一个简单的方法call( )。call( )方法有一个名为msg的String参数。该方法试图在方括号内打印msg 字符串。有趣的事是在调用call( ) 打印左括号和msg字符串后，调用Thread.sleep(1000)，该方法使当前线程暂停1秒。</p><p>下一个类的构造函数Caller，引用了Callme的一个实例以及一个String，它们被分别存在target 和 msg 中。构造函数也创建了一个调用该对象的run( )方法的新线程。该线程立即启动。Caller类的run( )方法通过参数msg字符串调用Callme实例target的call( ) 方法。最后，Synch类由创建Callme的一个简单实例和Caller的三个具有不同消息字符串的实例开始。Callme的同一实例传给每个Caller实例。</p><pre class=" language-lang-java"><code class="language-lang-java">// This program is not synchronized.class Callme {    void call(String msg) {        System.out.print("[" + msg);        try {            Thread.sleep(1000);        } catch (InterruptedException e) {            System.out.println("Interrupted");        }        System.out.println("]");    }}class Caller implements Runnable {    String msg;    Callme target;    Thread t;    public Caller(Callme targ, String s) {        target = targ;        msg = s;        t = new Thread(this);        t.start();    }    public void run() {        target.call(msg);    }}class Synch {    public static void main(String args[]) {        Callme target = new Callme();        Caller ob1 = new Caller(target, "Hello");        Caller ob2 = new Caller(target, "Synchronized");        Caller ob3 = new Caller(target, "World");        // wait for threads to end        try {            ob1.t.join();            ob2.t.join();            ob3.t.join();        } catch (InterruptedException e) {            System.out.println("Interrupted");        }    }}</code></pre><p>该程序的输出如下：</p><blockquote><p>[Hello[World[Synchronized]<br>]<br>]</p></blockquote><p>在本例中，通过调用sleep( )，call( )方法允许执行转换到另一个线程。该结果是三个消息字符串的混合输出。该程序中，没有阻止三个线程同时调用同一对象的同一方法的方法存在。这是一种竞争，因为三个线程争着完成方法。例题用sleep( )使该影响重复和明显。在大多数情况，竞争是更为复杂和不可预知的，因为你不能确定何时上下文转换会发生。这使程序时而运行正常时而出错。</p><p>为达到上例所想达到的目的，必须有权连续的使用call( )。也就是说，在某一时刻，必须限制只有一个线程可以支配它。为此，你只需在call( ) 定义前加上关键字synchronized，如下：</p><pre class=" language-lang-java"><code class="language-lang-java">class Callme {    synchronized void call(String msg) {        ...    }}</code></pre><p>这防止了在一个线程使用call( )时其他线程进入call( )。在synchronized加到call( )前面以后，程序输出如下：</p><blockquote><p>[Hello]<br>[World]<br>[Synchronized]</p></blockquote><p>任何时候在多线程情况下，你有一个方法或多个方法操纵对象的内部状态，都必须用synchronized 关键字来防止状态出现竞争。记住，一旦线程进入实例的同步方法，没有其他线程可以进入相同实例的同步方法。然而，该实例的其他不同步方法却仍然可以被调用。</p><h3 id="同步语句"><a href="#同步语句" class="headerlink" title="同步语句"></a>同步语句</h3><p>尽管在创建的类的内部创建同步方法是获得同步的简单和有效的方法，但它并非在任何时候都有效。这其中的原因，请跟着思考。假设你想获得不为多线程访问设计的类对象的同步访问，也就是，该类没有用到synchronized方法。而且，该类不是你自己，而是第三方创建的，你不能获得它的源代码。这样，你不能在相关方法前加synchronized修饰符。怎样才能使该类的一个对象同步化呢？很幸运，解决方法很简单：你只需将对这个类定义的方法的调用放入一个synchronized块内就可以了。</p><p>下面是synchronized语句的普通形式：</p><pre class=" language-lang-java"><code class="language-lang-java">synchronized(object) {    // statements to be synchronized}</code></pre><p>其中，object是被同步对象的引用。如果你想要同步的只是一个语句，那么不需要花括号。一个同步块确保对object成员方法的调用仅在当前线程成功进入object管程后发生。<br>下面是前面程序的修改版本，在run( )方法内用了同步块：</p><pre class=" language-lang-java"><code class="language-lang-java">// synchronize calls to call()    public void run() {        synchronized (target) { // synchronized block            target.call(msg);        }    }</code></pre><p>这里，call( )方法没有被synchronized修饰。而synchronized是在Caller类的run( )方法中声明的。这可以得到上例中同样正确的结果，因为每个线程运行前都等待先前的一个线程结束。</p><hr><h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><p>上述例题无条件的阻塞了其他线程异步访问某个方法。Java对象中隐式管程的应用是很强大的，但是你可以通过线程间通信达到更微妙的境界。这在Java中是尤为简单的。</p><p>像前面所讨论过的，多线程通过把任务分成离散的和合乎逻辑的单元代替了事件循环程序。线程还有第二优点：它远离了轮询。轮询通常由重复监测条件的循环实现。一旦条件成立，就要采取适当的行动。这浪费了CPU时间。举例来说，考虑经典的序列问题，当一个线程正在产生数据而另一个程序正在消费它。为使问题变得更有趣，假设数据产生器必须等待消费者完成工作才能产生新的数据。在轮询系统，消费者在等待生产者产生数据时会浪费很多CPU周期。一旦生产者完成工作，它将启动轮询，浪费更多的CPU时间等待消费者的工作结束，如此下去。很明显，这种情形不受欢迎。</p><p>为避免轮询，Java包含了通过wait( )，notify( )和notifyAll( )方法实现的一个进程间通信机制。这些方法在对象中是用final方法实现的，所以所有的类都含有它们。这三个方法仅在synchronized方法中才能被调用。尽管这些方法从计算机科学远景方向上来说具有概念的高度先进性，实际中用起来是很简单的：</p><ul><li>wait( ) 告知被调用的线程放弃管程进入睡眠直到其他线程进入相同管程并且调用notify( )。</li><li>notify( ) 恢复相同对象中第一个调用 wait( ) 的线程。</li><li>notifyAll( ) 恢复相同对象中所有调用 wait( ) 的线程。具有最高优先级的线程最先运行。</li></ul><p>这些方法在Object中被声明，如下所示：</p><pre class=" language-lang-java"><code class="language-lang-java">final void wait( ) throws InterruptedExceptionfinal void notify( )final void notifyAll( )</code></pre><p>wait( )存在的另外的形式允许你定义等待时间。</p><p>下面的例子程序错误的实行了一个简单生产者/消费者的问题。它由四个类组成：Q，设法获得同步的序列；Producer，产生排队的线程对象；Consumer，消费序列的线程对象；以及PC，创建单个Q，Producer，和Consumer的小类。</p><pre class=" language-lang-java"><code class="language-lang-java">// An incorrect implementation of a producer and consumer.class Q {    int n;    synchronized int get() {        System.out.println("Got: " + n);        return n;    }    synchronized void put(int n) {        this.n = n;        System.out.println("Put: " + n);    }}class Producer implements Runnable {    Q q;    Producer(Q q) {        this.q = q;        new Thread(this, "Producer").start();    }    public void run() {        int i = 0;        while (true) {            q.put(i++);        }    }}class Consumer implements Runnable {    Q q;    Consumer(Q q) {        this.q = q;        new Thread(this, "Consumer").start();    }    public void run() {        while (true) {            q.get();        }    }}class PC {    public static void main(String args[]) {        Q q = new Q();        new Producer(q);        new Consumer(q);        try {            Thread.sleep(1);        } catch (InterruptedException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }        System.exit(0);    }}</code></pre><p>尽管Q类中的put( )和get( )方法是同步的，没有东西阻止生产者超越消费者，也没有东西阻止消费者消费同样的序列两次。这样，你就得到下面的错误输出（输出将随处理器速度和装载的任务而改变，每次也会不同）：</p><blockquote><p>Put: 0<br>Put: 1<br>Got: 1<br>Got: 1<br>Got: 1<br>Got: 1<br>Got: 1<br>Put: 2<br>Put: 3<br>Put: 4<br>Put: 5<br>Put: 6<br>Put: 7<br>Got: 7</p></blockquote><p>生产者生成1后，消费者依次获得同样的1五次。生产者在继续生成2到7，消费者没有机会获得它们。</p><p>用Java正确的编写该程序是用wait( )和notify( )来对两个方向进行标志，如下所示：</p><pre class=" language-lang-java"><code class="language-lang-java">// A correct implementation of a producer and consumer.class Q {    int n;    boolean valueSet = false;    synchronized int get() {        if (!valueSet)            try {                wait();            } catch (InterruptedException e) {                System.out.println("InterruptedException caught");            }        System.out.println("Got: " + n);        valueSet = false;        notify();        return n;    }    synchronized void put(int n) {        if (valueSet)            try {                wait();            } catch (InterruptedException e) {                System.out.println("InterruptedException caught");            }        this.n = n;        valueSet = true;        System.out.println("Put: " + n);        notify();    }}</code></pre><p>内部get( ), wait( )被调用。这使执行挂起直到Producer 告知数据已经预备好。这时，内部get( ) 被恢复执行。获取数据后，get( )调用notify( )。这告诉Producer可以向序列中输入更多数据。在put( )内，wait( )挂起执行直到Consumer取走了序列中的项目。当执行再继续，下一个数据项目被放入序列，notify( )被调用，这通知Consumer它应该移走该数据。</p><p>下面是该程序的输出，它清楚的显示了同步行为：</p><blockquote><p>Put: 0<br>Got: 0<br>Put: 1<br>Got: 1<br>Put: 2<br>Got: 2<br>Put: 3<br>Got: 3</p></blockquote><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>需要避免的与多任务处理有关的特殊错误类型是<code>死锁（deadlock）</code>。死锁发生在当两个线程对一对同步对象有循环依赖关系时。例如，假定一个线程进入了对象X的管程而另一个线程进入了对象Y的管程。如果X的线程试图调用Y的同步方法，它将像预料的一样被锁定。而Y的线程同样希望调用X的一些同步方法，线程永远等待，因为为到达X，必须释放自己的Y的锁定以使第一个线程可以完成。死锁是很难调试的错误，因为：</p><ul><li>通常，它极少发生，只有到两线程的时间段刚好符合时才能发生。</li><li>它可能包含多于两个的线程和同步对象（也就是说，死锁在比刚讲述的例子有更多复杂的事件序列的时候可以发生）。</li></ul><p>为充分理解死锁，观察它的行为是很有用的。下面的例子生成了两个类，A和B，分别有foo( )和bar( )方法。这两种方法在调用其他类的方法前有一个短暂的停顿。主类，名为Deadlock，创建了A和B的实例，然后启动第二个线程去设置死锁环境。foo( )和bar( )方法使用sleep( )强迫死锁现象发生。</p><pre class=" language-lang-java"><code class="language-lang-java">// An example of deadlock.class A {    synchronized void foo(B b) {        String name = Thread.currentThread().getName();        System.out.println(name + " entered A.foo");        try {            Thread.sleep(1000);        } catch (Exception e) {            System.out.println("A Interrupted");        }        System.out.println(name + " trying to call B.last()");        b.last();    }    synchronized void last() {        System.out.println("Inside A.last");    }}class B {    synchronized void bar(A a) {        String name = Thread.currentThread().getName();        System.out.println(name + " entered B.bar");        try {            Thread.sleep(1000);        } catch (Exception e) {            System.out.println("B Interrupted");        }        System.out.println(name + " trying to call A.last()");        a.last();    }    synchronized void last() {        System.out.println("Inside A.last");    }}class Deadlock implements Runnable {    A a = new A();    B b = new B();    Deadlock() {        Thread.currentThread().setName("MainThread");        Thread t = new Thread(this, "RacingThread");        t.start();        a.foo(b); // get lock on a in this thread.        System.out.println("Back in main thread");    }    public void run() {        b.bar(a); // get lock on b in other thread.        System.out.println("Back in other thread");    }    public static void main(String args[]) {        new Deadlock();    }}</code></pre><p>运行程序后，输出如下：</p><blockquote><p>MainThread entered A.foo<br>RacingThread entered B.bar<br>MainThread trying to call B.last()<br>RacingThread trying to call A.last()</p></blockquote><p>因为程序死锁，RacingThread在等待管程a时占用管程b，同时，MainThread占用a等待b。该程序永远都不会结束。像该例阐明的，你的多线程程序经常被锁定，死锁是你首先应检查的问题。</p><hr><h2 id="挂起、恢复和终止线程"><a href="#挂起、恢复和终止线程" class="headerlink" title="挂起、恢复和终止线程"></a>挂起、恢复和终止线程</h2><p>有时，线程的挂起是很有用的。例如，一个独立的线程可以用来显示当日的时间。如果用户不希望用时钟，线程被挂起。在任何情形下，挂起线程是很简单的，一旦挂起，重新启动线程也是一件简单的事。</p><p>挂起，终止和恢复线程机制在Java 2和早期版本中有所不同。尽管你运用Java 2的途径编写代码，你仍需了解这些操作在早期Java环境下是如何完成的。例如，你也许需要更新或维护老的代码。你也需要了解为什么Java 2会有这样的变化。因为这些原因，下面内容描述了执行线程控制的原始方法，接着是Java 2的方法。</p><h3 id="Java-1-1或更早版本的线程的挂起、恢复和终止"><a href="#Java-1-1或更早版本的线程的挂起、恢复和终止" class="headerlink" title="Java 1.1或更早版本的线程的挂起、恢复和终止"></a>Java 1.1或更早版本的线程的挂起、恢复和终止</h3><p>先于Java2的版本，程序用Thread 定义的suspend() 和 resume() 来暂停和再启动线程。它们的形式如下：</p><pre class=" language-lang-java"><code class="language-lang-java">final void suspend( )final void resume( )</code></pre><p>下面的程序描述了这些方法：</p><pre class=" language-lang-java"><code class="language-lang-java">// Using suspend() and resume().class NewThread implements Runnable {    String name; // name of thread    Thread t;    NewThread(String threadname) {        name = threadname;        t = new Thread(this, name);        System.out.println("New thread: " + t);        t.start(); // Start the thread    }    // This is the entry point for thread.    public void run() {        try {            for (int i = 15; i > 0; i--) {                System.out.println(name + ": " + i);                Thread.sleep(200);            }        } catch (InterruptedException e) {            System.out.println(name + " interrupted.");        }        System.out.println(name + " exiting.");    }}class SuspendResume {    public static void main(String args[]) {        NewThread ob1 = new NewThread("One");        NewThread ob2 = new NewThread("Two");        try {            Thread.sleep(1000);            ob1.t.suspend();            System.out.println("Suspending thread One");            Thread.sleep(1000);            ob1.t.resume();            System.out.println("Resuming thread One");            ob2.t.suspend();            System.out.println("Suspending thread Two");            Thread.sleep(1000);            ob2.t.resume();            System.out.println("Resuming thread Two");        } catch (InterruptedException e) {            System.out.println("Main thread Interrupted");        }        // wait for threads to finish        try {            System.out.println("Waiting for threads to finish.");            ob1.t.join();            ob2.t.join();        } catch (InterruptedException e) {            System.out.println("Main thread Interrupted");        }        System.out.println("Main thread exiting.");    }}</code></pre><p>程序输出如下：</p><blockquote><p>New thread: Thread[One,5,main]<br>New thread: Thread[Two,5,main]<br>One: 15<br>Two: 15<br>Two: 14<br>One: 14<br>Two: 13<br>One: 13<br>Two: 12<br>One: 12<br>Two: 11<br>One: 11<br>Suspending thread One<br>Two: 10<br>Two: 9<br>Two: 8<br>Two: 7<br>Two: 6<br>Resuming thread One<br>Suspending thread Two<br>One: 10<br>One: 9<br>One: 8<br>One: 7<br>One: 6<br>Resuming thread Two<br>Waiting for threads to finish.<br>Two: 5<br>One: 5<br>Two: 4<br>One: 4<br>Two: 3<br>One: 3<br>Two: 2<br>One: 2<br>Two: 1<br>One: 1<br>Two exiting.<br>One exiting.<br>Main thread exiting.</p></blockquote><p>Thread类同样定义了stop() 来终止线程。它的形式如下：</p><pre class=" language-lang-java"><code class="language-lang-java">void stop( )</code></pre><p>一旦线程被终止，它不能被resume() 恢复继续运行。</p><h3 id="Java-2中挂起、恢复和终止线程"><a href="#Java-2中挂起、恢复和终止线程" class="headerlink" title="Java 2中挂起、恢复和终止线程"></a>Java 2中挂起、恢复和终止线程</h3><p>Thread定义的suspend()，resume()和stop()方法看起来是管理线程的完美的和方便的方法，它们不能用于新Java版本的程序。下面是其中的原因。Thread类的suspend()方法在Java2中不被赞成，因为suspend()有时会造成严重的系统故障。假定对关键的数据结构的一个线程被锁定的情况，如果该线程在那里挂起，这些锁定的线程并没有放弃对资源的控制。其他的等待这些资源的线程可能死锁。</p><p>Resume()方法同样不被赞同。它不引起问题，但不能离开suspend()方法而独立使用。Thread类的stop()方法同样在Java 2中受到反对。这是因为该方法可能导致严重的系统故障。设想一个线程正在写一个精密的重要的数据结构且仅完成一个零头。如果该线程在此刻终止，则数据结构可能会停留在崩溃状态。</p><p>因为在Java 2中不能使用suspend()，resume()和stop() 方法来控制线程，你也许会想那就没有办法来停止，恢复和结束线程。其实不然。相反，线程必须被设计以使run() 方法定期检查以来判定线程是否应该被挂起，恢复或终止它自己的执行。有代表性的，这由建立一个指示线程状态的标志变量来完成。只要该标志设为“running”，run()方法必须继续让线程执行。如果标志为“suspend”，线程必须暂停。若设为“stop”，线程必须终止。</p><p>当然，编写这样的代码有很多方法，但中心主题对所有的程序应该是相同的。</p><p>下面的例题阐述了从Object继承的wait()和notify()方法怎样控制线程的执行。该例与前面讲过的程序很像。然而，不被赞同的方法都没有用到。让我们思考程序的执行。</p><p>NewTread 类包含了用来控制线程执行的布尔型的实例变量suspendFlag。它被构造函数初始化为false。Run()方法包含一个监测suspendFlag 的同步声明的块。如果变量是true，wait()方法被调用以挂起线程。Mysuspend()方法设置suspendFlag为true。Myresume()方法设置suspendFlag为false并且调用notify()方法来唤起线程。最后，main()方法被修改以调用mysuspend()和myresume()方法。</p><pre class=" language-lang-java"><code class="language-lang-java">// Suspending and resuming a thread for Java2class NewThread implements Runnable {    String name; // name of thread    Thread t;    boolean suspendFlag;    NewThread(String threadname) {        name = threadname;        t = new Thread(this, name);        System.out.println("New thread: " + t);        suspendFlag = false;        t.start(); // Start the thread    }    // This is the entry point for thread.    public void run() {        try {            for (int i = 15; i > 0; i--) {                System.out.println(name + ": " + i);                Thread.sleep(200);                synchronized (this) {                    while (suspendFlag) {                        wait();                    }                }            }        } catch (InterruptedException e) {            System.out.println(name + " interrupted.");        }        System.out.println(name + " exiting.");    }    void mysuspend() {        suspendFlag = true;    }    synchronized void myresume() {        suspendFlag = false;        notify();    }}class SuspendResume {    public static void main(String args[]) {        NewThread ob1 = new NewThread("One");        NewThread ob2 = new NewThread("Two");        try {            Thread.sleep(1000);            ob1.mysuspend();            System.out.println("Suspending thread One");            Thread.sleep(1000);            ob1.myresume();            System.out.println("Resuming thread One");            ob2.mysuspend();            System.out.println("Suspending thread Two");            Thread.sleep(1000);            ob2.myresume();            System.out.println("Resuming thread Two");        } catch (InterruptedException e) {            System.out.println("Main thread Interrupted");        }        // wait for threads to finish        try {            System.out.println("Waiting for threads to finish.");            ob1.t.join();            ob2.t.join();        } catch (InterruptedException e) {            System.out.println("Main thread Interrupted");        }        System.out.println("Main thread exiting.");    }}</code></pre><p>该程序的输出与前面的程序相同。尽管Java 2控制线程机制不像老方法那样“干净”，然而，它是确保运行时不发生错误的方法。它是所有新的代码必须采用的方法。</p><hr><h2 id="使用多线程机制"><a href="#使用多线程机制" class="headerlink" title="使用多线程机制"></a>使用多线程机制</h2><p>如果你和大多数程序员一样，那么在语言中加入多线程支持对你来说是很新鲜的事物。有效运用这种支持的关键是并发思考而不是连续思考。例如，当你的程序有两个可以并行执行的子系统，创建他们各自的线程。仔细的运用多线程，你能编写出非常有效的程序。然而要注意：如果你创建太多的线程，你可能会减弱而不是加强程序的性能。记住，上下文转换是需要开销的。如果你创建了太多的线程，更多的CPU时间会用于上下文转换而不是用来执行程序。</p><blockquote><p>Written with <a href="https://stackedit.io/" target="_blank" rel="noopener">StackEdit</a>.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Syntax </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Multithread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[iOS] Win8下在Vmware11中安装使用苹果系统OS X 10.10</title>
      <link href="/2015/06/22/%5BiOS%5DInstall-OSX-in-Vmware-under-Win8/"/>
      <url>/2015/06/22/%5BiOS%5DInstall-OSX-in-Vmware-under-Win8/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;近来因为需要做 iOS 的项目，所以需要多花一些时间看看敲敲代码。因为自己手头上并没有 Mac（过年为了闲的时候能玩玩游戏买了联想，唉），想想不能只靠每天在公司的时间练 demo 吧，那样学的太慢了，所以就想着在 Win8 下装个 Mac 试试。装 Mac 有两个选择，一个是双系统，这个我查了查，发现我的型号的笔记本驱动问题太多，再加上我已经装了 Ubuntu 双系统，怕自己搞出大问题来，所以放弃。如果你想装双系统的话，就别看下去了，赶快去找双系统的攻略吧。另一个选择就是装虚拟机里，我在网上找了找方法， 发现的确可以用，装完 Xcode 在模拟器里跑程序一点不卡，就是虚拟机的 Mac 显卡驱动有点老了，界面上稍微有一点的不流畅，当然完全不影响操作的！下面我就把安装配置过程记录下来。虽然网上这类文章虽然很多，但比较乱，有些还是旧版本的，我记录的是从安装到结束的整个过程以及遇到的一些问题和解决方法，如果按照这个步骤来肯定没问题的，下面进入正题。</p><hr><p>补充一下：<br>因为有人说装好了还是卡，这里补充一下我的笔记本的配置，仅仅对你做个参考，不同机子跑起来效果可能会不一样，具体要不要安装还是你来决定。</p><ul><li>显卡GTX860M 4G</li><li>内存8G</li><li>i5 4200H</li></ul><p>还有人要我传装好的虚拟机，我看了一下22G，压缩保守估计也要10G多点，压缩再上传要点时间，我还要找不用电脑的空闲时间干这事儿，所以不急的话就多等等吧。但我比较建议自己弄一遍，可以熟悉熟悉Vmware的一些功能。</p><hr><p>首先上一张我用 OS X 调代码的图吧，一般来说，只开Xcode的话是完全不卡的。像我开双显示器，一边虚拟机调代码，另一边 Win8 查资料很方便。</p><p><img src="http://images.cnblogs.com/cnblogs_com/rossoneri/682731/o_mac.png" alt="原图链接http://images.cnblogs.com/cnblogs_com/rossoneri/682731/o_mac.png" title="右击图片，在新标签页打开图片"></p><hr><h2 id="首先你需要下载"><a href="#首先你需要下载" class="headerlink" title="首先你需要下载"></a>首先你需要下载</h2><ol><li>Vmware，这个好搞，从官方下载，再找个注册机就好了。我觉得博客园的读者应该都装的有吧~</li><li>OS X 10.10 系统，<a href="http://pan.baidu.com/s/1sj4ri5R" target="_blank" rel="noopener">点击这里下载</a>，提取码：y86w</li><li>unlocker203，用来让 Vmware 识别 Mac 系统的，<a href="http://pan.baidu.com/s/1o6iI9tg" target="_blank" rel="noopener">点击这里下载</a>，提取码：km1c</li><li>Vmware Tools for Mac 和 Vmsvga2_1.2.5_OS_10.9.pkg，虚拟机里面的显卡驱动，不装会很卡，<a href="http://files.cnblogs.com/files/rossoneri/%E5%88%86%E8%BE%A8%E7%8E%87.zip" target="_blank" rel="noopener">点我下载</a></li><li>虚拟机下 Mac 的声卡驱动，我没下，用不上。但你要觉得使用的时候里面的提示音怪怪的让你很难受也可以去找来装上。</li></ol><hr><h2 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h2><ul><li><p>先打开下载好的 unlocker203 文件夹，找到<code>win-install.cmd</code>，右击管理员运行，<font color="red">注意该路径和 Vmware 的路径都不要有中文</font>，否则会失败。如果路径没中文还不行的话，Google 一下 error 代码。这里一个建议，因为这个文件是用来修改 Vmware 的服务的，我的电脑是这个情况：每次重启电脑后，Vmware 的服务就会重新开启，所以必须再执行这个文件一次才可以正常打开  Mac 虚拟机，所以建议把这个文件在桌面放一个快捷方式，玩 Mac 之前运行一次就好。</p></li><li><p>打开 Vmware ，新建虚拟机，选择典型安装，下一步。<br><img src="http://images.cnblogs.com/cnblogs_com/rossoneri/682731/o_Mac1.png" alt="选择典型安装"><br>然后选择镜像路径，选择的时候注意文件格式，搜索的默认格式是iso，而这个系统是cdr，所以文件夹里面看不见，改一下就行。然后下一步。<br><img src="http://images.cnblogs.com/cnblogs_com/rossoneri/682731/o_Mac2.png" alt="选择镜像文件"><br>这时，如果第一步成功的话，这里可以在系统列表中看到<code>Apple Mac OS X</code>的选项了，下面版本选择 <code>OS X 10.10</code>，下一步。<br><img src="http://images.cnblogs.com/cnblogs_com/rossoneri/682731/o_Mac3.png" alt="系统版本选择"><br>后面的步骤就一路下一步了，唯一需要设置的就是虚拟机参数，我把我的参数放出来供参考吧。我的电脑8G内存，分了4G给虚拟机。至少我这样不卡，你们酌情配置。<br><img src="http://images.cnblogs.com/cnblogs_com/rossoneri/682731/o_Mac4.png" alt="虚拟机配置"></p></li><li><p>这时候点击启动虚拟机，你可能会弹出一个错误，关于这个，在<code>unlocker203</code>文件夹内的<code>readme.txt</code>已经说明，解决方案就是打开保存 OS X 虚拟机的路径，找到<code>.vmx</code>后缀的文件，用记事本打开，搜索<code>smc.present = &quot;TRUE&quot;</code>这一句，在它下面添加一行：<code>smc.version = &quot;0&quot;</code>，之后顺利启动，进入安装界面。</p></li><li><p>安装中会出现一次磁盘空间不够的提示，那是因为它识别到的磁盘是镜像盘，不是你装虚拟机分的空盘。而你找不到分出来的盘是因为格式不识别，需要格式化。点击 Mac 顶部工具栏-&gt;实用工具-&gt;磁盘工具，然后可以看到左边有几十个G的磁盘，选中，右边有抹掉，也就是格式化，选择格式，下面改个磁盘名，点击抹掉。之后就简单了，等它自己装好就行。</p></li></ul><hr><h2 id="显示与分辨率"><a href="#显示与分辨率" class="headerlink" title="显示与分辨率"></a>显示与分辨率</h2><p>&emsp;&emsp;花了十几分钟，装好了 OS X，进系统看到那漂亮的界面，心里暗爽，不禁要操作操作，然而刚挥动起鼠标，我擦，怎么全是残影！再一看系统，32M显存什么鬼，虽然我知道苹果机显存和内存共用，而且这又是虚拟机，但这个32M肯定有问题，而且分辨率也很怪。然后网上一查，原来也要装显卡驱动。解压我前面提供下载的驱动，找到 darwin.iso 文件，在虚拟机设置里选择CD/DVD，选择使用镜像，打开darwin.iso。</p><p><img src="http://images.cnblogs.com/cnblogs_com/rossoneri/682731/o_Mac5.png" alt="设置"></p><p>&emsp;&emsp;然后在 Vmware 右下角的状态栏找到光盘图标，单击选择连接，就可以在 OS X 的桌面右上角看到加载的磁盘了。没看到的话，按照下图设置一下，还不行再重启系统。打开磁盘，安装 Vmware Tools 。安装结束重启系统。现再进入系统发现没有那么卡了。</p><p><img src="http://images.cnblogs.com/cnblogs_com/rossoneri/682731/o_Mac6.png" alt="OS X 设置"></p><p>&emsp;&emsp;之后安装显卡驱动<code>VMsvga2_v1.2.5_OS_10.9.pkg</code>。在前面下载的目录里找到该文件，然后把文件拖到虚拟机中，然后…嗯？以前都这么玩的，这次发现竟然拖不了！解决方案就是回到虚拟机设置界面，在选项中打开共享文件夹，共享的路径尽量英文吧。具体如图：</p><p><img src="http://images.cnblogs.com/cnblogs_com/rossoneri/682731/o_Mac7.png" alt="共享文件夹"></p><p>&emsp;&emsp;按照图片设置结束后，把要拷进去的文件放在这里，然后重启 OS X 系统，即可看到这个文件夹。打开文件夹，双击<code>VMsvga2_v1.2.5_OS_10.9.pkg</code>安装驱动。结束后还是要重启一次，这时再查看系统，会发现显存变成了128M，而且操作也流畅了非常的多。然后在系统设置里找到显示选项，看有没有适合你的分辨率，如果没有的话，打开 Vmware 设置，在硬件里选择显示器，手动输入你想要的分辨率，点确定，再启动OS X系统，打开设置显示，菜单里出现了你需要的分辨率，选择它，然后尽情地玩吧。</p><p><img src="http://images.cnblogs.com/cnblogs_com/rossoneri/682731/o_Mac8.png" alt="分辨率"></p><hr><h2 id="怎么联网"><a href="#怎么联网" class="headerlink" title="怎么联网"></a>怎么联网</h2><p>&emsp;&emsp;系统装好了，然后就要写代码了，OS X下写代码当然要用强大的 Xcode 。你可以从网上下载好安装包放到共享文件夹里，然后用OS X安装，当然也可以直接上App Store下载最新的稳定版本。那么怎么联网？<br>打开Windows的网络，选择当前上网的网络属性，选择共享标签，选择允许其他链接此网络，如图：</p><p><img src="http://images.cnblogs.com/cnblogs_com/rossoneri/682731/o_Mac9.png" alt="网络共享"></p><p>然后回到虚拟机设置，网络适配器选择：仅主机模式</p><p><img src="http://images.cnblogs.com/cnblogs_com/rossoneri/682731/o_Mac10.png" alt="主机模式"></p><p>接着打开OS X，打开网络设置，左边选择以太网，右边选择使用DHCP，点应用，然后大功告成。<br>用App Store下载Xcode，之后就开始编程学习吧。说实话，这两天发现Xcode用起来蛮爽的！</p><p>当然，这样搞只是权宜之计，如果你真想投入iOS开发，还是买个Mac好。如果你钱不是很多的话，买个便宜的Mac Mini做开发也行的。<br>如果你只是想先体验体验，这样折腾折腾自己也是必要的。</p><p>最后，又截图又贴图真的好麻烦啊！</p>]]></content>
      
      
      <categories>
          
          <category> Configuration </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac OS </tag>
            
            <tag> 虚拟机 </tag>
            
            <tag> VMware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Android] 仿照 Last App Switcher 写的小程序</title>
      <link href="/2015/06/08/%5BAndroid%5DA-Demo-Of-Last-App-Switcher/"/>
      <url>/2015/06/08/%5BAndroid%5DA-Demo-Of-Last-App-Switcher/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;在Android众多工具类app中，<code>Last App Switcher</code>绝对算是一个让人用过就不会卸载的工具。<code>LAS</code>这个应用，它的功能很简单，就是通过一个浮动按钮实现在两个应用之间一键切换，但是非常实用，尤其是在边玩边聊天需要频繁切换应用的时候。所以可以看出，想开发一款受欢迎的应用，一定要注重用户体验，只要用户用的爽，功能再再再简单，它也会受欢迎。那么这功能到底有多简单呢？跟我来实现一下就好了。</p><p><a href="https://github.com/wossoneri/LAS_Demo" target="_blank" rel="noopener">项目代码地址</a>:<a href="https://github.com/wossoneri/LAS_Demo" target="_blank" rel="noopener">https://github.com/wossoneri/LAS_Demo</a></p><p>&emsp;&emsp;我就不截图了，下面用官方的截图来说明。这里真心推荐读者下载用一下。谷歌商店的下载地址：<a href="https://play.google.com/store/apps/details?id=com.abhi.lastappswitcher" title="Last App Switcher" target="_blank" rel="noopener">Last App Switcher</a> 搞开发的应该都会翻墙吧</p><p>看下原始程序界面：<br><img src="http://images.cnblogs.com/cnblogs_com/rossoneri/682731/o_unnamed.png" alt="LAS Main View"></p><p>&emsp;&emsp;可以看到主界面就是一系列开关选项，同时程序右边有一个浮动的圆形窗口。下面我会按照步骤一步步增加功能。</p><h2 id="仿iOS按钮"><a href="#仿iOS按钮" class="headerlink" title="仿iOS按钮"></a>仿iOS按钮</h2><p>&emsp;&emsp;写demo不需要多好的界面，但也不能太丑，手里有看起来不错的控件就直接拖进来用了。下面是效果图，这一套按钮有好几种，都是仿iOS的，想要的可以点原作者的<a href="http://blog.csdn.net/vipzjyno1/article/details/23707149#comments" title="SwitchButton 开关按钮 的多种实现方式 （附源码DEMO）" target="_blank" rel="noopener">这篇博客</a>，源码<a href="https://github.com/ikew0ng/SwitchButton" target="_blank" rel="noopener">Github地址</a>。</p><p>先添加一个开关主功能的按钮：<br><img src="http://images.cnblogs.com/cnblogs_com/rossoneri/682731/o_1.png" alt="初始界面"></p><h2 id="浮动按钮"><a href="#浮动按钮" class="headerlink" title="浮动按钮"></a>浮动按钮</h2><p>&emsp;&emsp;可以看到，这个应用的主要功能就在于那个红色的浮动按钮上面。根据程序功能可以知道，这个浮动按钮是由程序开启的服务中创建的。又因为程序的Activity在离开onStart()状态后就会销毁(这样做的原因后面说)，之后按钮仍保持其可用状态。所以可以知道是通过startService()启动的服务。下面我们就需要先写一个服务出来，再在服务中绘一个浮动按钮。具体有关服务的细节参考我上一篇博客：<a href="http://www.cnblogs.com/rossoneri/p/4530216.html" title="[Android] Service服务详解以及如何使service服务不被杀死" target="_blank" rel="noopener">博客传送门</a>。</p><p>写一个服务<code>FloatButtonService</code>，在AndroidManifest.xml文件添加服务</p><pre class=" language-lang-xml"><code class="language-lang-xml"><service android:name=".FloatButtonService" ></service></code></pre><p>服务中添加绘制浮动按钮方法，相关说明见注释</p><pre class=" language-lang-java"><code class="language-lang-java">private void createFloatView() {}</code></pre><p>方法添加完毕在服务相应的调用位置创建和销毁浮动按钮</p><pre class=" language-lang-java"><code class="language-lang-java">@Overridepublic void onCreate() {    // TODO Auto-generated method stub    super.onCreate();    createFloatView();}@Overridepublic void onDestroy() {    // TODO Auto-generated method stub    super.onDestroy();    if (mFloatLayout != null) {        mWindowManager.removeView(mFloatLayout);    }}</code></pre><p>使用浮动按钮还需要增加权限：</p><pre class=" language-lang-xml"><code class="language-lang-xml"><uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW" /></code></pre><p>这样，我们在MainActivity中就可以为按钮增加响应事件，进行开启和关闭服务了。</p><h2 id="将程序从最近任务-last-recent-tasks-中移除"><a href="#将程序从最近任务-last-recent-tasks-中移除" class="headerlink" title="将程序从最近任务(last recent tasks)中移除"></a>将程序从最近任务(last recent tasks)中移除</h2><p>&emsp;&emsp;按下系统导航栏第三个按钮我们就可以看到最近使用过的任务列表，当然，LAS切换程序也是在这里选择最后使用的两个应用程序切换的。所以在切换的时候，把自己的Activity从最近的任务中删掉是很必要的。<br>前面提到过，就是在Activity的onPause()状态或者onStop()状态中执行finishAndRemoveTask()方法删除任务。但这个方法在API 21也就是Android 5.0才引入。不过，我们还有一个更方便的方法，就是在配置文件的<code>&lt;activity&gt;</code>标签中增加</p><pre class=" language-lang-xml"><code class="language-lang-xml">android:excludeFromRecents="true"</code></pre><p>这样不论你是按下back键还是home键，程序都会从最近使用过的任务列表中删除</p><h2 id="获取系统任务列表，进行任务间的切换"><a href="#获取系统任务列表，进行任务间的切换" class="headerlink" title="获取系统任务列表，进行任务间的切换"></a>获取系统任务列表，进行任务间的切换</h2><p>&emsp;&emsp;将自身Activity从最近任务列表中删除后，我们就可以考虑获取最后两次的任务，然后互相一键切换了。<br>在浮动按钮的单击事件中添加<br>首先需要获得ActivityManager的对象</p><pre class=" language-lang-java"><code class="language-lang-java">ActivityManager mActivityManager = (ActivityManager) this.getSystemService(Context.ACTIVITY_SERVICE);</code></pre><p>要获取任务还需要对应权限</p><pre class=" language-lang-xml"><code class="language-lang-xml"><uses-permission android:name="android.permission.GET_TASKS"/></code></pre><p>有了权限，就可以获取到任务列表了</p><pre class=" language-lang-java"><code class="language-lang-java">List<ActivityManager.RecentTaskInfo> mAppList = new ArrayList<ActivityManager.RecentTaskInfo>();mAppList = mActivityManager.getRecentTasks(3, ActivityManager.RECENT_IGNORE_UNAVAILABLE);</code></pre><p>建立一个装有<code>RecentTaskInfo</code>的列表，通过<code>getRecentTasks</code>方法获取系统的最近使用过的应用列表。</p><p>关于<code>getRecentTasks</code>方法，第一个参数是一个整型值，是你需要返回的应用数量，但实际上得到的数量可能会比这个值要小。比如<br>我要得到3个，但后台只开了1个，那么只返回1个。第二个参数是要返回的应用的状态，我选择的是忽略不可用的应用，应该是完全关闭，不在后台的应用。</p><p>再说一点，这个方法在Android5.0因为安全问题屏蔽掉了，也就是android5.0以上的版本不能用这个方法。所以我前一阵子在App Store上看到评论都是Android5.0用这个没有效果。现在行不行我倒不知道，闲了再研究吧。（每次我说闲了再做基本都是个坑- -|）</p><p>前面的参数我之所以要选择3，是因为我只需要获得最近使用的2个应用，因为每次开新应用，这个应用信息都会存在列表的最上面，所以获取前3个即可。</p><p>但为什么是3而不是2呢，因为Android的Home界面也是一个Activity（应该是），我可以选择是否要在切换的时候忽略掉Home界面。所以考虑到Home，就要用3。<br>Home的包名为<code>com.android.launcher</code>，以此为根据进行判断即可。</p><pre class=" language-lang-java"><code class="language-lang-java">private void getAndStartIntent(int i){    ActivityManager.RecentTaskInfo info = mAppList.get(i);    if (null == info)        Toast.makeText(FloatButtonService.this, "No other apps", Toast.LENGTH_SHORT).show();    else if(sp.getBoolean(StringKey.ExcludeHome, false)){ // if set true, do follow func        if(info.baseIntent.getComponent().getPackageName().equals(HOME_PACKAGE))    //exclude HOME            getAndStartIntent(2);    }else        startActivityWithoutAnimation(info);}</code></pre><p>启动一个应用的过程默认是有一个切换动画的，我们的程序就是用来切换程序的，所以取消启动动画是一个比较好的选择。<br>只用给要启动的intent加一个flag即可（有些情况下不会生效）</p><pre class=" language-lang-java"><code class="language-lang-java">intent.addFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION);</code></pre><h2 id="开机启动"><a href="#开机启动" class="headerlink" title="开机启动"></a>开机启动</h2><p>&emsp;&emsp;Android开机启动结束会发送一个BOOT_COMPLETED的广播，我们在程序中建立一个广播接收器来接收这个广播，接收成功就直接启动服务来显示浮动按钮即可。<br>先建立一个广播接收器 BootReceiver</p><pre class=" language-lang-java"><code class="language-lang-java">public class BootReceiver extends BroadcastReceiver {    @Override    public void onReceive(Context context, Intent intent) {        // TODO Auto-generated method stub        if (intent.getAction().equals("android.intent.action.BOOT_COMPLETED")) {// on boot            Intent a = new Intent(context, FloatButtonService.class);            context.startService(a);        }    }}</code></pre><p>在配置文件中，<code>&lt;application&gt;</code>标签下注册广播接收器</p><pre class=" language-lang-xml"><code class="language-lang-xml"><receiver android:name=".BootReceiver" >    <intent-filter>        <action android:name="android.intent.action.BOOT_COMPLETED" />        <category android:name="android.intent.category.LAUNCHER" />    </intent-filter></receiver></code></pre><p>然后增加权限</p><pre class=" language-lang-xml"><code class="language-lang-xml"><uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" /></code></pre><p>开机启动就完成了。但怎么用开关来控制其是否开机启动呢？</p><h2 id="SharedPreferences"><a href="#SharedPreferences" class="headerlink" title="SharedPreferences"></a>SharedPreferences</h2><p>&emsp;&emsp;用开关控制功能的开启状态，这个状态不能保存在程序中，因为程序是要被关闭的。那么就是要用一些方法保存开关的状态到系统中，然后服务从文件读取状态，控制自己的程序行为。Android中最适合保存配置状态的就是用SharedPreferences了。当我查看LAS应用的数据文件的时候，发现输出的结果的确是这样的。</p><pre class=" language-lang-bash"><code class="language-lang-bash">cat /data/data/com.abhi.lastappswitcher/shared_prefs/com.inpen.lastAppSwitcher.APPLICATION_PREFS.xml</code></pre><pre class=" language-lang-xml"><code class="language-lang-xml"><?xml version='1.0' encoding='utf-8' standalone='yes' ?><map><boolean name="com.inpen.lastAppSwitcher.PREF_SNAP_TO_EDGE" value="true" /><int name="com.inpen.lastAppSwitcher.PREF_LAND_HEIGHT" value="800" /><int name="com.inpen.lastAppSwitcher.PREF_LAND_FLOATER_Y" value="485" /><int name="com.inpen.lastAppSwitcher.PREF_LAND_WIDTH" value="1280" /><int name="com.inpen.lastAppSwitcher.PREF_PORT_FLOATER_Y" value="776" /><int name="com.inpen.lastAppSwitcher.PREF_PORT_WIDTH" value="800" /><boolean name="com.inpen.lastAppSwitcher.PREF_ERROR_MSG" value="true" /><boolean name="com.inpen.lastAppSwitcher.PREF_STATUS_BAR_OVERLAY" value="false" /><int name="com.inpen.lastAppSwitcher.PREF_FLOATER_SIZE" value="55" /><int name="com.inpen.lastAppSwitcher.PREF_PORT_FLOATER_X" value="765" /><int name="com.inpen.lastAppSwitcher.PREF_PORT_HEIGHT" value="1280" /><int name="com.inpen.lastAppSwitcher.PREF_FLOATER_TRANSPARENCY" value="75" /><int name="currentQuote" value="6" /><int name="com.inpen.lastAppSwitcher.PREF_SWITCHING_METHOD" value="1" /><boolean name="com.inpen.lastAppSwitcher.PREF_FLOATER_MOVABLE" value="true" /><boolean name="com.inpen.lastAppSwitcher.PREF_HAPTIC_FEEDBACK" value="false" /><int name="com.inpen.lastAppSwitcher.PREF_FLOATER_COLOR" value="0" /></map></code></pre><p>那么，我们就可以根据自己的需求来写sharedPreferences文件了<br>先获得 SharedPreferences 的实例</p><pre class=" language-lang-java"><code class="language-lang-java">SharedPreferences sp = getSharedPreferences("las_demo", Context.MODE_PRIVATE);</code></pre><p>参数1是不带后缀的文件名，根据文件名获取实例，同一个名字的SharedPreferences对象只获得同一个实例；<br>参数2是模式操作模式：</p><ul><li><font color="green">Context.MODE_PRIVATE:</font><br>  为默认操作模式，代表该文件是私有数据，只能被应用本身访问，在该模式下，写入的内容会覆盖原文件的内容。</li><li><font color="green">Context.MODE_APPEND:</font><br>  创建的文件是私有数据，该模式会检查文件是否存在，存在就往文件追加内容，否则就创建新文件。</li><li><font color="green">MODE_WORLD_READABLE:</font><br>  表示当前文件可以被其他应用读取。</li><li><font color="green">MODE_WORLD_WRITEABLE:</font><br>  表示当前文件可以被其他应用写入。</li></ul><p>获得实例之后要进行初始化，写入一些设定值。这里因为初始化只需要一次，但我没找到判断sharedPreferences文件是否存在的方法(没想用File去查，这个文件存在系统路径，有权限问题，估计不行，有知道的可以告诉我)，有一个<code>public abstract boolean contains (String key)</code>方法，但用了感觉没效果，所以我又加了一个key，来保存第一次创建的状态，然后写入其他键-值，保存。</p><pre class=" language-lang-java"><code class="language-lang-java">if(!sp.getBoolean(StringKey.FirstCreate, true)){    Editor editor = sp.edit();    editor.putBoolean(StringKey.FirstCreate, true);    editor.putBoolean(StringKey.RunAtStart, false);    editor.putBoolean(StringKey.SnapToEdge, true);    editor.putBoolean(StringKey.StatusBarOverlay, false);    editor.putBoolean(StringKey.ExcludeHome, true);    editor.commit();}</code></pre><p>设置好键-值后就可以根据这些值设置界面里按钮的开关状态和设置程序的一些行为。</p><pre class=" language-lang-java"><code class="language-lang-java">if (sp.getBoolean(StringKey.RunAtStart, false))    mBtnRunAtStartup.setChecked(true);else    mBtnRunAtStartup.setChecked(false);</code></pre><p>当然，在手动改变按钮状态的时候也要为某个key重新写入新的value</p><pre class=" language-lang-java"><code class="language-lang-java">mBtnRunAtStartup.setOnCheckedChangeListener(new OnCheckedChangeListener() {    @Override    public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {        // TODO Auto-generated method stub        if (isChecked)            editBoolKey(StringKey.RunAtStart, true);        else            editBoolKey(StringKey.RunAtStart, false);    }});private void editBoolKey(String str, boolean b) {    Editor editor = sp.edit();    editor.putBoolean(str, b);    editor.apply();}</code></pre><p>改SharedPreferences的key-value的时候需要获得editor对象实例，设置完成用apply()方法或者commit()方法提交修改。如果有两个editor实例在同时修改，则以最后一次的提交为准。如果不关心返回值，且在应用的主线程里使用，用apply()要比commit()好。<br>至此，需要开关功能就在功能实现的地方加一层读取SP键值的过程，根据读到的结果决定功能。是否可用。</p><h2 id="悬浮按钮显示在status-bar上方"><a href="#悬浮按钮显示在status-bar上方" class="headerlink" title="悬浮按钮显示在status bar上方"></a>悬浮按钮显示在status bar上方</h2><p>&emsp;&emsp;按照下面设置windowManager的属性就好，没什么好解释的，放上文档看吧。</p><pre class=" language-lang-java"><code class="language-lang-java">wmParams.flags = LayoutParams.FLAG_NOT_TOUCH_MODAL               | LayoutParams.FLAG_NOT_FOCUSABLE               | LayoutParams.FLAG_LAYOUT_IN_SCREEN;</code></pre><ul><li><font color="green">int android.view.WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL = 32 [0x20]</font><br>  Window flag: Even when this window is focusable (its is not set), allow any pointer events outside of the window to be sent to the windows behind it. Otherwise it will consume all pointer events itself, regardless of whether they are inside of the window.</li><li><p><font color="green">int android.view.WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE = 8 [0x8]</font><br>  Window flag: this window won’t ever get key input focus, so the user can not send key or other button events to it. Those will instead go to whatever focusable window is behind it. This flag will also enable FLAG_NOT_TOUCH_MODAL whether or not that is explicitly set.</p><p>  Setting this flag also implies that the window will not need to interact with a soft input method, so it will be Z-ordered and positioned independently of any active input method (typically this means it gets Z-ordered on top of the input method, so it can use the full screen for its content and cover the input method if needed. You can use FLAG_ALT_FOCUSABLE_IM to modify this behavior.</p></li><li><font color="green">int android.view.WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN = 256 [0x100]</font><br>  Window flag: place the window within the entire screen, ignoring decorations around the border (a.k.a. the status bar). The window must correctly position its contents to take the screen decoration into account. This flag is normally set for you by Window as described in Window.setFlags.</li></ul><h2 id="按钮边缘吸附效果"><a href="#按钮边缘吸附效果" class="headerlink" title="按钮边缘吸附效果"></a>按钮边缘吸附效果</h2><p>&emsp;&emsp;这个应该是最简单的了，在按钮的touch事件中，当移动结束，手指抬起行为ACTION_UP中对位置进行判断，如果按钮的x坐标在屏幕左半边，x设为0，即贴着屏幕左边缘显示，反之一个道理。</p><p>功能就粗略地实现了这么多，原应用中还有很多小功能就不一一实现了，代码我传到github了，地址点<a href="https://github.com/wossoneri/LAS_Demo" target="_blank" rel="noopener">这里</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> sharedPreference </tag>
            
            <tag> 浮动按钮 </tag>
            
            <tag> 获取任务列表 </tag>
            
            <tag> 开机启动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Android] Service服务详解以及如何使service服务不被杀死</title>
      <link href="/2015/05/26/%5BAndroid%5DDetail-of-Service/"/>
      <url>/2015/05/26/%5BAndroid%5DDetail-of-Service/</url>
      
        <content type="html"><![CDATA[<h2 id="Services"><a href="#Services" class="headerlink" title="Services"></a>Services</h2><p>&emsp;&emsp;服务是一个应用程序组件,可以在后台执行长时间运行的操作,不提供用户界面。一个应用程序组件可以启动一个服务,它将继续在后台运行,即使用户切换到另一个应用程序。此外,一个组件可以绑定到一个服务与它交互,甚至执行进程间通信(IPC)。例如,一个服务可能处理网络通信,播放音乐,执行文件I/O,或与一个内容提供者交互,都在后台执行。</p><p>一个服务本质上讲有两种形式：</p><p>Started 启动的</p><blockquote><p><code>started</code>形式的服务是指当一个应用组件(比如<code>activity</code>)通过startService()方法开启的服务。一旦开启，该服务就可以<font color="red"><b>无限期</b></font>地在后台运行，哪怕开启它的组件被销毁掉。<br>通常,开启的服务执行一个单独的操作且并不向调用者返回一个结果。<br>比如，可能从网络进行下载或者上传一个文件。当任务完成，服务就该自我停止。</p></blockquote><p>Bound 绑定的</p><blockquote><p><code>bound</code>形式的服务是指一个应用组件通过调用 bindService() 方法与服务绑定。一个绑定的服务提供一个客户-服务端接口，以允许组件与服务交互，发送请求，获得结果，甚至执行进程间通信。一个绑定的服务只和与其绑定的组件同时运行。多个组件可以同时绑定到一个服务，但当全部接触绑定后，服务就被销毁。</p></blockquote><p>&emsp;&emsp;虽然分这两类，但是一个服务可以同时使用这两种方式——可以用<code>started</code>无限期的运行，同时允许绑定。只需要在服务中实现两个回调方法：<i>onStartCommand()</i>允许组件开启服务，<i>onBind()</i>允许绑定。</p><p>&emsp;&emsp;不论应用程序是怎么起服务的，<font color="red"><b>任何</b></font>应用程序都可以用这个服务。同样的，任何组件可以使用一个<code>Activity</code>通过传递<code>Intent</code>开启服务。你也可以在配置文件设置服务为私有来防止其他应用访问该服务。</p><blockquote><p><font color="red"><b>注意：</b></font>一个服务在进程中的主线程运行——一个服务<b>不会</b>创建自己的线程，也<b>不会</b>在另外的进程运行(除非另外指定)。这意味着，如果服务需要做一些频繁占用CPU的工作或者会发生阻塞的操作，你需要在服务中另开线程执行任务。这可以降低产生ANR的风险，提高用户体验。</p></blockquote><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>&emsp;&emsp;创建一个服务需要建立一个<code>Service</code>相关的子类，然后需要实现一些回调方法，好在不同的生命周期内做对应处理和绑定服务，比较重要的方法如下：</p><ul><li><i>onStartCommand()</i><br>  当其他组件，如 activity 请求服务启动时，系统会调用这个方法。一旦这个方法执行，服务就开始并且无限期的执行。如果实现这个方法，当这个服务完成任务后，需要你来调用 stopSelf() 或者 stopService() 停掉服务。如果只想提供绑定，不需要自己实现这个方法。</li><li><i>onBind()</i><br>  当有其他组件想通过 bindService() 方法绑定这个服务时系统就会调用此方法。在实现的方法里面，必须添加一个供客户端使用的接口通过返回一个<code>IBinder</code>来与服务通信，这个方法必须实现。当然不想允许绑定的话，返回<code>null</code>即可。</li><li><i>onCreate()</i><br>  服务第一次建立的时候会调用这个方法，执行一次性设置程序，在上面2个方法执行前调用。如果服务已存在，则不执行该方法。</li><li><i>onDestroy()</i><br>  服务不再使用则使用该方法。服务应该实现这个方法来清理诸如线程，注册的监听器等资源。这是最后调用的方法。</li></ul><p>&emsp;&emsp;安卓系统只会在内存占用很高，必须恢复系统资源供当前运行程序的情况下强制停掉一个运行中的服务。如果服务绑定在当前运行的程序中，就几乎不会被杀掉，如果服务声明了在前台运行（其实在后台，只是给系统一个错的信息来提高优先级），就几乎不会被杀掉。另外，如果一个服务正在运行，且运行了很久，系统就会根据运行时间把其排在后台任务列表的后面，则这个服务很容易被杀掉。根据<i>onStartCommand()</i> 的返回值设置，服务被杀掉后仍可以在资源充足的条件下立即重启。</p><blockquote><p><b>是用一个服务好还是开一个线程好</b><br>一个服务就是一个可以忽略交互，在后台独立运行的组件，如果你需要这样就用服务<br>如果你需要在用户与程序交互时在主线程外执行任务，那就开个线程吧。<br>比如想播放音乐，但只在程序运行时播放，你可能在 onCreate() 开一个线程，在 onStart() 中开启它，在 onStop() 停止它。也可以考虑使用<code>AsyncTask</code>或者<code>HandlerThread</code>取代一般的线程。<br>记住，如果使用一个服务，它还是默认在主线程中运行，如果会发生阻塞，还是要在服务中另开线程的。</p></blockquote><h3 id="在-manifest-文件声明服务"><a href="#在-manifest-文件声明服务" class="headerlink" title="在 manifest 文件声明服务"></a>在 manifest 文件声明服务</h3><p>要使用服务就必须在 <code>manifest</code> 文件声明要用的所有服务，只用在<code>&lt;application&gt;</code>标签内添加子标签<code>&lt;service&gt;</code>即可。</p><pre class=" language-lang-xml"><code class="language-lang-xml">    <manifest ...>        ...        <application ...>            <service android:name=".ExampleService"                android:enabled=["true" | "false"]                 android:exported=["true" | "false"]                 android:isolatedProcess=["true" | "false"]                 android:label="string resource"                 android:icon="drawable resource"                 android:permission="string"                 android:process="string" >                ...            </service>        </application>    </manifest></code></pre><p>下面对<code>service</code>标签属性做说明</p><ul><li><font color="green">android:name</font><br>  你所编写的服务类的类名，可填写完整名称，包名+类名，如<code>com.example.test.ServiceA</code>，也可以忽略包名，用<code>.</code>开头，如<code>.ServiceA</code>，因为在<code>manifest</code>文件开头会定义包名，它会自己引用。</li></ul><blockquote><p>一旦你发布应用，你就不能改这个名字(除非设置<code>android:exported=&quot;false&quot;</code>)，另外<code>name</code>没有默认值，必须定义。</p><ul><li><font color="green">android:enabled</font><br>  是否可以被系统实例化，默认为<code>true</code></li></ul></blockquote><pre><code>因为父标签`&lt;application&gt;`也有`enable`属性，所以必须两个都为默认值`true`的情况下服务才会被激活，否则不会激活。</code></pre><ul><li><p><font color="green">android:exported</font><br>  其他应用能否访问该服务，如果不能，则只有本应用或有相同用户ID的应用能访问。当然除了该属性也可以在下面<code>permission</code>中限制其他应用访问本服务。</p><p>  这个默认值与服务是否包含意图过滤器<code>intent filters</code>有关。如果一个也没有则为<code>false</code></p></li><li><font color="green">android:isolatedProcess</font><br>  设置<code>true</code>意味着，服务会在一个特殊的进程下运行，这个进程与系统其他进程分开且没有自己的权限。与其通信的唯一途径是通过服务的API(binding and starting)。</li><li><font color="green">android:label</font><br>  可以显示给用户的服务名称。如果没设置，就用<code>&lt;application&gt;</code>的<code>lable</code>。不管怎样，这个值是所有服务的意图过滤器的默认<code>lable</code>。定义尽量用对字符串资源的引用。</li><li><font color="green">android:icon</font><br>  类似<code>label</code>，是图标，尽量用<code>drawable</code>资源的引用定义。</li><li><p><font color="green">android:permission</font><br>  是一个实体必须要运行或绑定一个服务的权限。如果没有权限，<code>startService()</code>，<code>bindService()</code>或<code>stopService()</code>方法将不执行，<code>Intent</code>也不会传递到服务。</p><p>  如果属性未设置，会由<code>&lt;application&gt;</code>权限设置情况应用到服务。如果两者都未设置，服务就不受权限保护。</p></li><li><p><font color="green">android:process</font><br>  服务运行所在的进程名。通常为默认为应用程序所在的进程，与包名同名。<code>&lt;application&gt;</code>元素的属性<code>process</code>可以设置不同的进程名，当然组件也可设置自己的进程覆盖应用的设置。</p><p>  如果名称设置为冒号<code>：</code>开头，一个对应用程序私有的新进程会在需要时和运行到这个进程时建立。如果名称为小写字母开头，服务会在一个相同名字的全局进程运行，如果有权限这样的话。这允许不同应用程序的组件可以分享一个进程，减少了资源的使用。</p></li></ul><h2 id="创建“启动的”服务"><a href="#创建“启动的”服务" class="headerlink" title="创建“启动的”服务"></a>创建“启动的”服务</h2><p>&emsp;&emsp;启动的(started)服务由<i>startService(Intent)</i>方法启动，在服务中的<i>onStartCommand()</i>方法里获得<code>Intent</code>信息。关闭则由服务自己的方法<i>stopSelf()</i>或者由启动服务的地方调用<i>stopService(Intent)</i>方法来关闭。并不会因为启动服务的应用程序销毁而关闭。</p><p>&emsp;&emsp;示例，一个应用需要保存数据到远程数据库，这时启动一个服务，通过创建启动的服务给服务传递数据，由服务执行保存行为，行为结束再自我销毁。因为服务跟启动它的应用在一个进程的主线程中，所以对于耗时的操作要起一个新的线程去做。</p><pre class=" language-lang-java"><code class="language-lang-java">//activity中Intent intent = new Intent(MainActivity.this, ServiceA.class);intent.putExtra("name", strName);startService(intent);//service中@Overridepublic int onStartCommand(Intent intent, int flags, int startId) {    // TODO Auto-generated method stub    // 获取数据    String strName = intent.getStringExtra("name");    // ... 数据库操作    new Thread(new Runnable() {            @Override            public void run() {                // TODO Auto-generated method stub                耗时的操作            }        }).run();    return Service.START_STICKY;}</code></pre><p>写服务有2种，继承<code>service</code>或者<code>IntentService</code>。后者是前者的子类。前者包含上面介绍的各种方法，用于普通的服务。后者可以自己开一个工作线程一个接一个处理多个请求。</p><h3 id="继承IntentService"><a href="#继承IntentService" class="headerlink" title="继承IntentService"></a>继承IntentService</h3><p>大多数服务不需要同时处理多个请求，继承<code>IntentService</code>是最好的选择</p><p>IntentService处理流程</p><ul><li>创建默认的一个<code>worker</code>线程处理传递给<i>onStartCommand()</i>的所有<code>intent</code>，不占据应用的主线程</li><li>创建一个工作队列一次传递一个<code>intent</code>到你实现的<i>onHandleIntent()</i>方法，避免了多线程</li><li>在所以启动请求被处理后自动关闭服务，不需要调用<i>stopSelf()</i></li><li>默认提供<i>onBind()</i>的实现，并返回<code>null</code></li><li>默认提供<i>onStartCommand()</i>的实现，实现发送<code>intent</code>到工作队列再到你的<i>onHandleIntent()</i>方法实现。</li></ul><p>这些都加入到<code>IntentService</code>中了，你需要做的就是实现构造方法和<i>onHandleIntent()</i>，如下：</p><pre class=" language-lang-java"><code class="language-lang-java">public class HelloIntentService extends IntentService {  /**   * A constructor is required, and must call the super IntentService(String)   * constructor with a name for the worker thread.   */  public HelloIntentService() {      super("HelloIntentService");  }  /**   * The IntentService calls this method from the default worker thread with   * the intent that started the service. When this method returns, IntentService   * stops the service, as appropriate.   */  @Override  protected void onHandleIntent(Intent intent) {      // Normally we would do some work here, like download a file.      // For our sample, we just sleep for 5 seconds.      long endTime = System.currentTimeMillis() + 5*1000;      while (System.currentTimeMillis() < endTime) {          synchronized (this) {              try {                  wait(endTime - System.currentTimeMillis());              } catch (Exception e) {              }          }      }  }}</code></pre><p>如果需要重写其他回调方法，如<i>onCreate()</i>,<i>onStartCommand()</i>等，一定要调用<i>super()</i>方法，保证<code>IntentService</code>正确处理<code>worker</code>线程，只有<i>onHandleIntent()</i>和<i>onBind()</i>不需要这样。如：</p><pre class=" language-lang-java"><code class="language-lang-java">@Overridepublic int onStartCommand(Intent intent, int flags, int startId) {    Toast.makeText(this, "service starting", Toast.LENGTH_SHORT).show();    return super.onStartCommand(intent,flags,startId);}</code></pre><h4 id="继承Service"><a href="#继承Service" class="headerlink" title="继承Service"></a>继承Service</h4><p>继承<code>Service</code>就可以实现对请求多线程的处理，前面介绍了<code>service</code>的生命周期，可以按照生命周期实现方法。就不放示例了。</p><p><b><i>onStartCommand()</i>的返回值</b><br>返回一个整型值，用来描述系统在杀掉服务后是否要继续启动服务，返回值有三种：</p><ul><li><font color="#0099cc">START_NOT_STICKY</font><br>  系统不重新创建服务，除非有将要传递来的<code>intent</code>。这是最安全的选项，可以避免在不必要的时候运行服务。</li><li><font color="#0099cc">START_STICKY</font><br>  系统重新创建服务并且调用<i>onStartCommand()</i>方法，但并不会传递最后一次传递的<code>intent</code>，只是传递一个空的<code>intent</code>。除非存在将要传递来的<code>intent</code>，那么就会传递这些<code>intent</code>。这个适合播放器一类的服务，不需要执行命令，只需要独自运行，等待任务。</li><li><font color="#0099cc">START_REDELIVER_INTENT</font><br>  系统重新创建服务并且调用<i>onStartCommand()</i>方法，传递最后一次传递的<code>intent</code>。其余存在的需要传递的intent会按顺序传递进来。这适合像下载一样的服务，立即恢复，积极执行。</li></ul><p>如果想从服务获得结果，可以用广播来处理</p><h2 id="创建“绑定的”服务"><a href="#创建“绑定的”服务" class="headerlink" title="创建“绑定的”服务"></a>创建“绑定的”服务</h2><ul><li>用<i>bindService()</i>方法将应用组件绑定到服务，建立一个长时间保持的联系。</li><li>如果需要在<code>activity</code>或其他组件和服务交互或者通过进程间通信给其他应用程序提供本应用的功能，就需要绑定的服务。</li><li>建立一个绑定的服务需要实现<i>onBind()</i>方法返回一个定义了与服务通信接口的<code>IBinder</code>对象。其他应用程序组件可以调用<i>bindService()</i>方法获取接口并且调用服务上的方法。</li><li>创建一个绑定的服务，第一件事就是定义一个说明客户端与服务通信方式的接口。这个接口必须是<code>IBinder</code>的实现，并且必须要从<i>onBind()</i>方法返回。一旦客户端接收到了<code>IBinder</code>，就可以通过这个接口进行交互。</li><li>多个客户端可以绑定到一个服务，可以用<i>unbindService()</i>方法解除绑定，当没有组件绑定在服务上，这个服务就会被销毁。</li></ul><pre class=" language-lang-java"><code class="language-lang-java">//activity中private ServiceConnection connB = new ServiceConnection() {    @Override    public void onServiceDisconnected(ComponentName name) {        // TODO Auto-generated method stub        Log.v(tag, "Service B disconnected");    }    @Override    public void onServiceConnected(ComponentName name, IBinder service) {        // TODO Auto-generated method stub        Log.v(tag, "Service B connected");        MyBinderB binder = (MyBinderB) service;        ServiceB SB = binder.getService();        SB.showLog();    }};@Overrideprotected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_main);    findViewById(R.id.button1).setOnClickListener(new OnClickListener() {        @Override        public void onClick(View v) {            // TODO Auto-generated method stub            Intent a = new Intent(MainActivity.this, ServiceB.class);            bindService(a, connB, BIND_AUTO_CREATE);    }}//ServiceBpublic class ServiceB extends Service {    public void showLog() {        Log.i(tag, "serviceB-->showLog()");    }    public class MyBinderB extends Binder {        public ServiceB getService() {            return ServiceB.this;        }    }    private MyBinderB myBinderB = new MyBinderB();    @Override    public IBinder onBind(Intent intent) {        // TODO Auto-generated method stub        return myBinderB;    }}</code></pre><h4 id="启动前台服务"><a href="#启动前台服务" class="headerlink" title="启动前台服务"></a>启动前台服务</h4><p>&emsp;&emsp;前台服务是被认为是用户已知的正在运行的服务，当系统需要释放内存时不会优先杀掉该进程。前台进程必须发一个<code>notification</code>在状态栏中显示，直到进程被杀死。因为前台服务会一直消耗一部分资源，但不像一般服务那样会在需要的时候被杀掉，所以为了能节约资源，保护电池寿命，一定要在建前台服务的时候发<code>notification</code>，提示用户。当然，系统提供的方法就是必须有<code>notification</code>参数的，所以不要想着怎么把<code>notification</code>隐藏掉。</p><pre class=" language-lang-java"><code class="language-lang-java">@Overridepublic int onStartCommand(Intent intent, int flags, int startId) {    // TODO Auto-generated method stub    Intent notificationIntent = new Intent(this, MainActivity.class);    PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, notificationIntent, 0);    Notification noti = new Notification.Builder(this)                .setContentTitle("Title")                .setContentText("Message")                .setSmallIcon(R.drawable.ic_launcher)                .setContentIntent(pendingIntent)                .build();    startForeground(12346, noti);    return Service.START_STICKY;}</code></pre><p><i>startForeground()</i>方法就是将服务设为前台服务。参数12346就是这个通知唯一的id，只要不为0即可。</p><h3 id="服务的生命周期"><a href="#服务的生命周期" class="headerlink" title="服务的生命周期"></a>服务的生命周期</h3><p><img src="http://images.cnblogs.com/cnblogs_com/rossoneri/682731/o_service_lifecycle.png" alt="生命周期图"></p><ul><li>启动的服务：<br>  startService()-&gt;onCreate()-&gt;onStartCommand()-&gt;running-&gt;stopService()/stopSelf()-&gt;onDestroy()-&gt;stopped<br>  其中，服务未运行时会调用一次onCreate()，运行时不调用。</li><li>绑定的服务：<br>  bindService()-&gt;onCreate()-&gt;onBind()-&gt;running-&gt;onUnbind()-&gt;onDestroy()-&gt;stopped</li></ul><p>服务起始于<i>onCreate()</i>，终止于<i>onDestory()</i><br>服务的开关过程，只有<i>onStartCommand()</i>可多次调用，其他在一个生命周期只调用一次。</p><p>这两个过程并不完全独立，也可以绑定一个由<i>startService()</i>启动过的服务</p><h2 id="关于怎样让服务不被杀死"><a href="#关于怎样让服务不被杀死" class="headerlink" title="关于怎样让服务不被杀死"></a>关于怎样让服务不被杀死</h2><p>&emsp;&emsp;这个倒是有点流氓软件的意思，但有些特定情况还是需要服务能保持开启不被杀死，当然这样做我还是在程序里添加了关闭服务的按钮，也就是开启了就杀不死，除非在软件里关闭。</p><p>服务不被杀死分3种来讨论<br>1.系统根据资源分配情况杀死服务<br>2.用户通过<code>settings</code>-&gt;<code>Apps</code>-&gt;<code>Running</code>-&gt;<code>Stop</code>方式杀死服务<br>3.用户通过<code>settings</code>-&gt;<code>Apps</code>-&gt;<code>Downloaded</code>-&gt;<code>Force Stop</code>方式杀死服务</p><p><b>第一种情况：</b><br>&emsp;&emsp;用户不干预，完全靠系统来控制，办法有很多。比如<i>onStartCommand()</i>方法的返回值设为<code>START_STICKY</code>，服务就会在资源紧张的时候被杀掉，然后在资源足够的时候再恢复。当然也可设置为前台服务，使其有高的优先级，在资源紧张的时候也不会被杀掉。</p><p><b>第二种情况：</b><br>&emsp;&emsp;用户干预，主动杀掉运行中的服务。这个过程杀死服务会通过服务的生命周期，也就是会调用<i>onDestory()</i>方法，这时候一个方案就是在<i>onDestory()</i>中发送广播开启自己。这样杀死服务后会立即启动。如下：</p><pre class=" language-lang-java"><code class="language-lang-java">@Overridepublic void onCreate() {    // TODO Auto-generated method stub    super.onCreate();    mBR = new BroadcastReceiver() {        @Override        public void onReceive(Context context, Intent intent) {            // TODO Auto-generated method stub            Intent a = new Intent(ServiceA.this, ServiceA.class);            startService(a);        }    };    mIF = new IntentFilter();    mIF.addAction("listener");    registerReceiver(mBR, mIF);}@Overridepublic void onDestroy() {    // TODO Auto-generated method stub    super.onDestroy();    Intent intent = new Intent();    intent.setAction("listener");    sendBroadcast(intent);    unregisterReceiver(mBR);}</code></pre><p>&emsp;&emsp;当然，从理论上来讲这个方案是可行的，实验一下也可以。但有些情况下，发送的广播在消息队列中排的靠后，就有可能服务还没接收到广播就销毁了(这是我对实验结果的猜想，具体执行步骤暂时还不了解)。所以为了能让这个机制完美运行，可以开启两个服务，相互监听，相互启动。服务A监听B的广播来启动B，服务B监听A的广播来启动A。经过实验，这个方案可行，并且用360杀掉后几秒后服务也还是能自启的。到这里再说一句，如果不是某些功能需要的服务，不建议这么做，会降低用户体验。</p><p><b>第三种情况：</b><br>&emsp;&emsp;强制关闭就没有办法。这个好像是从包的level去关的，并不走完整的生命周期。所以在服务里加代码是无法被调用的。处理这个情况的唯一方法是屏蔽掉<code>force stop</code>和<code>uninstall</code>按钮，让其不可用。方法自己去找吧。当然有些手机自带的清理功能就是从这个地方清理的，比如华为的清理。所以第三种情况我也没有什么更好的办法了。</p><p>&emsp;&emsp;最后再说一句，别在这上面太折腾，弄成流氓软件就不好了。我就是讨厌一些软件乱发通知，起服务才转而用iPhone的。不过下一代Android好像可以支持用户选择是否开启软件设置的权限了，倒是可以期待一下。<br>推荐一篇文章：<a href="http://www.androidguys.com/2009/09/09/diamonds-are-forever-services-are-not/" title="Diamonds Are Forever. Services Are Not." target="_blank" rel="noopener">Diamonds Are Forever. Services Are Not.</a></p><p>补充：检测服务是否在运行的方法，就是获取所有正在运行的服务，一一与相应的服务名称做比较：</p><pre class=" language-lang-java"><code class="language-lang-java">public static boolean isServiceRunning(String serviceClassName){         final ActivityManager activityManager = (ActivityManager)Application.getContext().getSystemService(Context.ACTIVITY_SERVICE);         final List<RunningServiceInfo> services = activityManager.getRunningServices(Integer.MAX_VALUE); //这个value取任意大于1的值，但返回的列表大小可能比这个值小。        for (RunningServiceInfo runningServiceInfo : services) {             if (runningServiceInfo.service.getClassName().equals(serviceClassName)){                 return true;             }         }         return false;      }</code></pre>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Service </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[MarkDown] MarkDown语法小结</title>
      <link href="/2015/04/24/%5BMarkDown%5DSyntax-of-markdown/"/>
      <url>/2015/04/24/%5BMarkDown%5DSyntax-of-markdown/</url>
      
        <content type="html"><![CDATA[<h2 id="特殊字符自动转换"><a href="#特殊字符自动转换" class="headerlink" title="特殊字符自动转换"></a>特殊字符自动转换</h2><p>HTML中，&copy; 可以写成<code>&amp;copy;</code>也可以直接输 ©</p><p>HTML中 &lt; 和 &amp; 都要转码  但markdown不必，输入<code>&amp;</code> 和 <code>&amp;amp;</code> 都显示 <code>&amp;</code>，<code>&lt;</code> 也一样</p><p>4 &lt; 5  输<code>&lt;</code>后面最好加个空格，否则会当起始标签使用<br>4&lt;5 输字符码<code>&amp;lt;</code>不用考虑这个问题</p><hr><h2 id="段落和换行"><a href="#段落和换行" class="headerlink" title="段落和换行"></a>段落和换行</h2><p>一个 Markdown 段落的前后要有一个以上的空行。普通段落不该用空格或制表符来缩进。如果想在段前加缩进 <code>&amp;emsp;</code>是一个中文字符 <code>&amp;ensp;</code>是半个中文字符 <code>&amp;nbsp;</code>是1/4中文字符</p><p>标题有两种形式<br>1.用=或者-表示两阶标题，符号数量建议3个以上，紧挨着显示的标题下一行输入</p><pre><code>第一阶标题=======第二阶标题显示效果有下划线---</code></pre><p>效果：</p><h1 id="第一阶标题"><a href="#第一阶标题" class="headerlink" title="第一阶标题"></a>第一阶标题</h1><h2 id="第二阶标题显示效果有下划线"><a href="#第二阶标题显示效果有下划线" class="headerlink" title="第二阶标题显示效果有下划线"></a>第二阶标题显示效果有下划线</h2><p>2.开头用#的数量表示1-6阶的标题，结尾可以以任意数量#结尾（包括0个）</p><h1 id="H1"><a href="#H1" class="headerlink" title="H1"></a>H1</h1><h2 id="H2有下划线"><a href="#H2有下划线" class="headerlink" title="H2有下划线"></a>H2有下划线</h2><h3 id="H3"><a href="#H3" class="headerlink" title="H3"></a>H3</h3><h4 id="H4"><a href="#H4" class="headerlink" title="H4"></a>H4</h4><h5 id="H5"><a href="#H5" class="headerlink" title="H5"></a>H5</h5><h6 id="H6"><a href="#H6" class="headerlink" title="H6"></a>H6</h6><h6 id="H7-超过6个-就是这个样子"><a href="#H7-超过6个-就是这个样子" class="headerlink" title="#H7 超过6个#就是这个样子"></a>#H7 超过6个#就是这个样子</h6><hr><h2 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h2><p>在每行前面使用&gt; 或者只在段落中第一行前加&gt;</p><blockquote><p>This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,<br>consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.<br>Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</p><p>Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse<br> id sem consectetuer libero luctus adipiscing.</p></blockquote><p>区块引用也可以嵌套，在嵌套的地方加多个&gt;&gt;就好<br>这里空行可以不加 &gt; 只要前后段落没有其他不加&gt;的段落就不影响效果，自己可以试试</p><blockquote><p>数据结构</p><blockquote><p>树</p><blockquote><p>二叉树</p><blockquote><p>平衡二叉树</p><blockquote><p>满二叉树</p></blockquote></blockquote></blockquote></blockquote></blockquote><p>引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：</p><blockquote><h2 id="这是一个标题。"><a href="#这是一个标题。" class="headerlink" title="这是一个标题。"></a>这是一个标题。</h2><ol><li>这是第一行列表项。</li><li>这是第二行列表项。</li></ol><p>给出一些例子代码：</p><pre><code>return shell_exec(&quot;echo $input | $markdown_script&quot;);</code></pre></blockquote><hr><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>支持有序列表和无序列表，就是列表项前面是数字还是点<br>无序可用 * + - 显示都是点<br>比如输入</p><pre><code>* Red+ Green- Blue</code></pre><p>显示为</p><ul><li>Red</li></ul><ul><li>Green</li></ul><ul><li>Blue</li></ul><p>有序用数字加英文. 数字是几无所谓的 生成的html代码是一样的</p><p>建议第一个项目最好还是从 1. 开始，因为 Markdown 未来可能会支持有序列表的 start 属性。</p><ol><li>Red</li><li>Green</li><li>Blue</li></ol><p>&lt;/br&gt;<br>列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。每一项换行后前面不对齐也没关系，产生的效果还是好的</p><ul><li>Lorem ipsum dolor sit amet, consectetuer adipiscing elit.<br>   Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,<br>viverra nec, fringilla in, laoreet vitae, risus.</li><li>Donec sit amet nisl. Aliquam semper ipsum sit amet velit.<br>Suspendisse id sem consectetuer libero luctus adipiscing.</li></ul><p>如果列表项之间用空格隔开，输出html会给每一项加<code>&lt;p&gt;</code>标签</p><p>一个列表项也可以包含多个段落  每一项下的段落都必须缩进4个空格或者一个制表符</p><ol><li><p>This is a list item with two paragraphs. Lorem ipsum dolor<br>sit amet, consectetuer adipiscing elit. Aliquam hendrerit<br>mi posuere lectus.</p><p>Vestibulum enim wisi, viverra nec, fringilla in, laoreet<br>vitae, risus. Donec sit amet nisl. Aliquam semper ipsum<br>sit amet velit.</p></li><li><p>Suspendisse id sem consectetuer libero luctus adipiscing.</p></li></ol><p>如果列表项内的引用需要缩进，在<code>&gt;</code>前面加上缩进，引用就在列表项内显示</p><ul><li><p>A list item with a blockquote:</p><blockquote><p>This is a blockquote<br>inside a list item</p></blockquote></li></ul><p>如果要在list中放代码，该区块需要缩进2次 即8个空格或2个tab</p><ul><li><p>a list item with a codeblock</p><pre><code>  private void fun(int x){  }</code></pre></li></ul><hr><h2 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h2><p>开头加4个空格或一个tab即可，markdown会在生成的html代码包上 pre code 标签</p><pre><code>这是代码区块</code></pre><p>一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。</p><pre><code>&lt;div class=&quot;footer&quot;&gt;    &amp;copy; 2004 Foo Corporation&lt;/div&gt;</code></pre><p>代码区块中的 <code>&amp;</code> 和 <code>&lt;</code> <code>&gt;</code> 符号会自动转成html应该显示的代码,输 <code>&amp;</code> 就会转换成 <code>&amp;amp;</code>，显示为 <code>&amp;</code> ,也就是输什么显示什么。</p><p>代码区块中 markdown 语法不会转换，比如</p><pre><code>* Red+ Green- Blue</code></pre><hr><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>可以在一行用3个以上的 <code>*</code>,<code>-</code>,<code>_</code>来建立一条分割线，行内除了空格不能有其他东西，当然三条线效果是不同的，按顺序是很明显，不明显，一般。第二种不仔细看真看不到有线，我是换了暗色主题才看清。</p><hr><hr><hr><hr><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>链接文字都是用 [方括号] 来标记。分为两种方式：（我直接用<a></a>如何呢）</p><ol><li><p>行内式</p><p>只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，如：</p><p>This is <a href="http://www.cnblogs.com/rossoneri/" title="我的博客园" target="_blank" rel="noopener">an example</a> inline link with title.<br><a href="http://www.cnblogs.com/rossoneri/" target="_blank" rel="noopener">This link</a> has no title.</p></li><li><p>参考式</p><p>是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记，两个括号间可以最多加上一个空格：</p><p>This is <a href="http://www.cnblogs.com/rossoneri/" title="我的博客园" target="_blank" rel="noopener">an example</a> reference-style link.</p><p>接着，在文件的任意处，你可以把这个标记的链接内容定义出来：<br><code>[id]: http://www.cnblogs.com/rossoneri/ &quot;我的博客园&quot;</code><br>链接内容定义的形式为：</p><ul><li>方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字</li><li>接着一个冒号</li><li>接着一个以上的空格或制表符</li><li>接着链接的网址</li><li>选择性地接着 title 内容，可以用单引号、双引号或是括弧包着</li></ul><p>下面这三种链接的定义都是相同的：</p></li></ol><pre><code>    [foo]: http://example.com/  &quot;Optional Title Here&quot;    [foo]: http://example.com/  &#39;Optional Title Here&#39;    [foo]: http://example.com/  (Optional Title Here)</code></pre><p>   请注意：有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。</p><p>链接网址也可以用尖括号包起来，其中title属性可以换行：</p><pre><code>[id]: &lt;http://example.com/&gt;  &quot;Optional Title Here&quot;</code></pre><p>隐式链接标记功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号.<br>如果你要让 “Google” 链接到 google.com，你可以简化成：<code>[Google co.][]</code><br>然后定义链接内容：<code>[Google co.]: http://google.com/</code></p><p>效果如下：<br><a href="http://google.com/" target="_blank" rel="noopener">Google co.</a></p><p>下面列出三种写法，推荐参考式，链接放在段落最后写起来会比较清晰。</p><pre><code>参考式1I get 10 times more traffic from [Google] [1] than from [Yahoo] [2] or [MSN] [3].[1]: http://google.com/        &quot;Google&quot;[2]: http://search.yahoo.com/  &quot;Yahoo Search&quot;[3]: http://search.msn.com/    &quot;MSN Search&quot;</code></pre><hr><pre><code>参考式2 get 10 times more traffic from [Google][] than from [Yahoo][] or [MSN][]. [google]: http://google.com/        &quot;Google&quot; [yahoo]:  http://search.yahoo.com/  &quot;Yahoo Search&quot; [msn]:    http://search.msn.com/    &quot;MSN Search&quot;</code></pre><hr><pre><code>行内式I get 10 times more traffic from [Google (http://google.com/ &quot;Google&quot;) than from [Yahoo](http://search.yahoo.com/ &quot;Yahoo Search&quot;) or [MSN](http://search.msn.com/ &quot;MSN Search&quot;).</code></pre><p>效果：<br>I get 10 times more traffic from <a href="https://github.com/guodongxiaren/README/blob/master/emoji.md" target="_blank" rel="noopener">Google</a> than from <a href="http://search.yahoo.com/" title="Yahoo Search" target="_blank" rel="noopener">Yahoo</a> or <a href="http://search.msn.com/" title="MSN Search" target="_blank" rel="noopener">MSN</a>.</p><hr><h2 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h2><p>两端<font color="red">各</font>用<font color="red">一个</font> <code>*</code>或者 <code>_</code>包起来是斜体，<font color="red">各</font>用<font color="red">两个</font>包起来是粗体：<br><em>single asterisks</em><br>_single underscores_<br><strong>double asterisks</strong><br><strong>double underscores</strong></p><p>如果符号两边都是空白，没有紧贴着文字，将会当普通符号。<br>如果就是要输出符号则要反斜杠<code>\*</code> 或者 <code>\_</code></p><hr><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p>文本两端加上两个<code>~~</code>即可<br><del>删除我</del></p><hr><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>要标记一小段行内代码，用反引号包起来 <code>` </code><br>Use the <code>printf()</code> function.</p><p>如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段<br>像这样输入 <code>``There is a literal backtick (`) here.`` </code><br>效果为 <code>There is a literal backtick (`) here.</code></p><p>代码区段起始前和结束后都可以放一个空格，方便代码段隔开<br>比如可以输入 <code>`` `foo` `` </code><br>就显示为 <code>`foo` </code></p><p>代码内可以直接放入 <code>&lt;</code> <code>&gt;</code> <code>&amp;</code> 符号</p><p>另外还可以设置代码高亮，根据代码类型来选择，输入格式为：</p><pre><code>```java (type)    code here```</code></pre><p>几种代码效果如下：</p><pre class=" language-lang-Java"><code class="language-lang-Java">public static void main(String[]args){} //Java</code></pre><pre class=" language-lang-c"><code class="language-lang-c">int main(int argc, char *argv[]) //C</code></pre><pre class=" language-lang-Bash"><code class="language-lang-Bash">echo "hello GitHub"#Bash</code></pre><pre class=" language-lang-javascript"><code class="language-lang-javascript">document.getElementById("myH1").innerHTML="Welcome to my Homepage"; //javascipt</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">string &operator+(const string& A,const string& B) //cpp</code></pre><hr><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>也分为行内式和链接式</p><ul><li>行内式格式：! + [替代图片的文字，可空] + (路径 title)</li><li>链接式格式：! + [替代图片的文字，可空] + [id]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    [id]: 路径 title</li></ul><hr><h2 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠"></a>反斜杠</h2><p>反斜杠可以输出显示一些符号，支持的有</p><pre><code>\   反斜线`   反引号*   星号_   底线{}  花括号[]  方括号()  括弧#   井字号+   加号-   减号.   英文句点!   惊叹号</code></pre><hr><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><pre><code>表头1  | 表头2------------- | -------------Content Cell  | Content CellContent Cell  | Content Cell| 表头1  | 表头2|| ------------- | ------------- || Content Cell  | Content Cell  || Content Cell  | Content Cell  || 名字 | 描述          || ------------- | ----------- || Help      | Display the help window.|| Close     | Closes a window     |表格中也可以使用普通文本的删除线，斜体等效果| 名字 | 描述          || ------------- | ----------- || Help      | ~~Display the~~ help window.|| Close     | _Closes_ a window     |表格可以指定对齐方式| 左对齐 | 居中  | 右对齐 || :------------ |:---------------:| -----:|| col 3 is      | some wordy text | $1600 || col 2 is      | centered        |   $12 || zebra stripes | are neat        |    $1 |</code></pre><p>效果：<br><img src="http://images.cnblogs.com/cnblogs_com/rossoneri/682731/o_222.png" alt="表格效果" title="表格效果"></p><hr><h2 id="github-特有的特性"><a href="#github-特有的特性" class="headerlink" title="github 特有的特性"></a>github 特有的特性</h2><h3 id="复选框列表"><a href="#复选框列表" class="headerlink" title="复选框列表"></a>复选框列表</h3><p>在列表符号后面加上<code>[]</code>或者<code>[x]</code>代表选中或者未选中情况</p><ul><li>[x] C</li><li>[x] C++</li><li>[x] Java</li><li>[x] Qt</li><li>[x] Android</li><li>[ ] C#</li><li>[ ] .NET</li></ul><p>效果如图：<br><img src="http://images.cnblogs.com/cnblogs_com/rossoneri/682731/o_aaa.png" alt="复选框列表" title="复选框效果"></p><h3 id="emoji表情"><a href="#emoji表情" class="headerlink" title="emoji表情"></a>emoji表情</h3><p>Github的Markdown语法支持添加emoji表情，输入不同的符号码（两个冒号包围的字符）可以显示出不同的表情。</p><p>比如<code>:blush:</code>，可以显示<img src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f60a.png" alt="blush" title="blush">。</p><p>更多表情符号可以从<a href="https://github.com/guodongxiaren/README/blob/master/emoji.md" target="_blank" rel="noopener">这里</a>找。</p><h3 id="有待补充"><a href="#有待补充" class="headerlink" title="有待补充"></a>有待补充</h3><p>其实在haroopad左侧有一个 Quick Markdown 的选项，里面还有不少没用过的命令，看名字大概能猜出意思，这个往后慢慢研究再补充吧。<br><img src="http://images.cnblogs.com/cnblogs_com/rossoneri/682731/o_md%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8.png" alt="待补充" title="待补充"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://wowubuntu.com/markdown/" title="markdown语法说明" target="_blank" rel="noopener">Markdown 语法说明</a><br><a href="https://github.com/guodongxiaren/README" target="_blank" rel="noopener">某人的Github</a></p>]]></content>
      
      
      <categories>
          
          <category> Syntax </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Android] 关于系统工具栏和全屏沉浸模式</title>
      <link href="/2015/04/12/%5BAndroid%5DSystemBar-And-ImmersiveMode/"/>
      <url>/2015/04/12/%5BAndroid%5DSystemBar-And-ImmersiveMode/</url>
      
        <content type="html"><![CDATA[<p>关于System Bars，之前写过几篇相关的文章：(链接等我把博客迁移好之后补上)</p><ul><li><a href>[Android]获取系统顶部状态栏(Status Bar)与底部导航栏(Navigation Bar)的高度</a></li><li><a href>[Android]状态栏的一些认识</a></li><li><a href>[Android]锁定屏幕</a></li></ul><p>这三篇是按顺序写的，本来只是项目上的应用，其实并不需要深究的，查到方法并能用起来就好。随着应用程序的一些深入设计，大家总想要更好的界面和体验，所以有些东西并不能只是知道方法就结束了，是得要去深入研究研究的。通过这个过程我觉得，从应用层面来讲，想实现一个功能很简单，但若想实现的好，就要去了解设计者的设计思路以及提供的方法。而了解设计者想法最直接的途径就是查看文档。当然，了解文档以后还可以再进一步，看看 Android 的源码是怎么实现的，也就是从 Application 层进入到 Framework 层。熟悉 Framework 后就可以配合着 Linux 内核的知识了解 Android 底层的实现了。好了，先把注意放在应用层，毕竟这是最简单的。</p><p>System Bars 包括三条 bar：</p><ul><li>status bar，也就是顶部的一条显示时间、电量、通知等信息的 bar</li><li>Navigation Bar，底部包含 back 键、home 键以及 recent 键的 bar</li><li>action bar，程序内顶部的可以添加诸如 search、menu 的 bar</li></ul><p>　　对 System Bar 的 操作也就是获取高度、状态以及设置显示/隐藏状态，前两者之前写过了，这次就把隐藏这些 bar 写详细点。</p><hr><h2 id="淡化系统工具栏"><a href="#淡化系统工具栏" class="headerlink" title="淡化系统工具栏"></a>淡化系统工具栏</h2><p>　　淡化(dim—不知道这么译合适不)工具栏的效果就是 status bar 和 navigation bar 上的图标都变成一个淡灰色的圆点。这么做的意义就是可以让用户目光的焦点集中在程序要显示的内容上面，避免了屏幕上过多的东西分散用户注意力。</p><p>　　可能这么说起来感觉这么做没有太大的意义，但实际上用户体验就是各方面一点点的细节积累起来的。有些时候用户在比较几款 APP 的时候都会有很明显的喜欢哪个不喜欢哪个，但让他具体列出来差距在哪里他却列不出来。这其中的原因大多就在这些小细节上，说不出但能感觉的到。而且既然有这个功能，它便有存在的意义，那么就来了解了解它怎么实现的。</p><p>　　注意这个方法只在4.0版本及以上适用。使用时，应用内容显示的尺寸不会变化，只会把两条 bar 上的图标变淡，一旦触摸 bar 的区域，所有图标就会显现出来，不再消失。</p><p>　　方法很简单，设置 system flag 为 SYSTEM_UI_FLAG_LOW_PROFILE 即可</p><pre class=" language-lang-java"><code class="language-lang-java">getActivity().getWindow().getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LOW_PROFILE);</code></pre><p>　　注意一旦触摸 bar 的位置，这个 flag 就会被清空，所以触摸结束后图标也不会淡化了。如果需要继续实现淡化效果，可以用 View.OnSystemUiVisibilityChangeListener 来监听状态变化再做处理。</p><p>　　如果想通过代码在某些情况下主动清除当前 system ui flag ，可以用：</p><pre class=" language-lang-java"><code class="language-lang-java">getActivity().getWindow().getDecorView().setSystemUiVisibility(0);</code></pre><p>　　看过我之前文章的可以知道，0 代表默认状态，也就是 bar 都正常显示的 flag，即：</p><pre class=" language-lang-java"><code class="language-lang-java">public static final int SYSTEM_UI_FLAG_VISIBLE = 0;</code></pre><hr><h2 id="隐藏-Status-Bar"><a href="#隐藏-Status-Bar" class="headerlink" title="隐藏 Status Bar"></a>隐藏 Status Bar</h2><p>　　其实淡化用的不是很多，而隐藏 Status Bar 倒是比较多。因为可以释放更多的显示空间，可以提供更好的用户体验。</p><p>　　下面两张图可以看到隐藏 status bar 让程序更直观简洁，看起来更舒服。<br><img src="http://images.cnitblog.com/blog2015/663710/201504/120109592111835.png" alt="显示ActionBar和Status Bar"><img src="http://images.cnitblog.com/blog2015/663710/201504/120110436655187.png" alt="全屏"><br>　　注意，左边的图带有 action bar，如果你不显示 status bar 的时候也要把 action bar 隐藏掉，这是设计界面的建议。<br>设置方法：</p><p>4.0及以下版本：<br>: 1. 在 manifest 中设置：</p><pre class=" language-lang-xml"><code class="language-lang-xml"><application    ... android:theme="@android:style/Theme.Holo.NoActionBar.Fullscreen" >    ...</application></code></pre><p>这样设置比较简单而且不易出错，因为系统在实例化 mainActivity 前已经拥有要渲染的界面，所以UI转换会比较平滑<br>: 2. 在代码中用 WindowManager flags 设置</p><pre class=" language-lang-java"><code class="language-lang-java">public class MainActivity extends Activity {    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        // If the Android version is lower than Jellybean, use this call to hide the status bar.        if (Build.VERSION.SDK_INT < 16) {            getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,                    WindowManager.LayoutParams.FLAG_FULLSCREEN);        }        setContentView(R.layout.activity_main);    }    ...}</code></pre><p>设置完 WindowManager flags 后这个 flag 会一直保留直到用代码清理掉他们。如果已经设定 FLAG_FULLSCREEN，就可以用 FLAG_LAYOUT_IN_SCREEN 设置 activity layout 使用当前可用的屏幕区域，这个 flag 可以防止显示/隐藏 status bar 时界面尺寸变化。</p><p>4.1及以上版本：<br>: 可以用前面提到的 setSystemUiVisibility() 在单独 view 层级上设置 UI 的标志，这些标志在窗口上生效。</p><pre class=" language-lang-java"><code class="language-lang-java">View decorView = getWindow().getDecorView();// Hide the status bar.int uiOptions = View.SYSTEM_UI_FLAG_FULLSCREEN;decorView.setSystemUiVisibility(uiOptions);// Remember that you should never show the action bar if the// status bar is hidden, so hide that too if necessary.ActionBar actionBar = getActionBar();actionBar.hide();</code></pre><blockquote><p><strong>注意：</strong></p></blockquote><ol><li>设置的 flag 一旦清空，应用程序需要重新设置 flag 才能隐藏 bar 。添加 listener 做处理即可</li><li>设置 flag 的代码写在不同的地方有不同的效果。比如你在 activity 的 onCreate() 方法里设置隐藏的标志，用户按下 Home 键， status bar 会再度显示，之后再打开应用程序，status bar 会保持显示的状态。如果需要其隐藏掉，需要在 onResume() 或者 onWindowFocusChanged() 方法里设置。 </li><li>setSystemUiVisibility() 方法只在可见的 view 中设置才有效，比如设置 View.gone 就没有效果</li><li>切换 view 会把当前 view 设置的 flag 清空</li></ol><blockquote><p>将程序内容显示在 Status Bar 的后面<br>之前的文章遇到过这个问题，还困扰了我半天，后来才发现程序是可以显示在 status bar 的后面的，这样的好处是程序的内容尺寸不会随着 status bar 的显示和隐藏而改变。<br>实现这个效果只用设置 SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN ，同时用 SYSTEM_UI_FLAG_LAYOUT_STABLE 来保证尺寸不变即可</p><p>When you use this approach, it becomes your responsibility to ensure that critical parts of your app’s UI (for example, the built-in controls in a Maps application) don’t end up getting covered by system bars. This could make your app unusable. In most cases you can handle this by adding the android:fitsSystemWindows attribute to your XML layout file, set to true. This adjusts the padding of the parent ViewGroup to leave space for the system windows. This is sufficient for most applications.</p><p>In some cases, however, you may need to modify the default padding to get the desired layout for your app. To directly manipulate how your content lays out relative to the system bars (which occupy a space known as the window’s “content insets”), override fitSystemWindows(Rect insets). The fitSystemWindows() method is called by the view hierarchy when the content insets for a window have changed, to allow the window to adjust its content accordingly. By overriding this method you can handle the insets (and hence your app’s layout) however you want.</p></blockquote><hr><h2 id="隐藏-Navigation-Bar"><a href="#隐藏-Navigation-Bar" class="headerlink" title="隐藏 Navigation Bar"></a>隐藏 Navigation Bar</h2><p>　　作为设计上的建议，在隐藏掉导航栏的同时，也要把状态栏隐藏掉(当然状态栏隐藏了也要把动作栏也隐藏掉)，当然隐藏掉还是保持随时可唤出的，这样可以利用整个屏幕空间，给用户更棒的体验。<br>　　在4.0及以上版本使用 SYSTEM_UI_FLAG_HIDE_NAVIGATION 设置同时隐藏 status bar 和 navigation bar。　　</p><pre class=" language-lang-java"><code class="language-lang-java">View decorView = getWindow().getDecorView();// Hide both the navigation bar and the status bar.// SYSTEM_UI_FLAG_FULLSCREEN is only available on Android 4.1 and higher, but as a general rule, you should design your app to hide the status bar whenever you hide the navigation bar.int uiOptions = View.SYSTEM_UI_FLAG_HIDE_NAVIGATION              | View.SYSTEM_UI_FLAG_FULLSCREEN;decorView.setSystemUiVisibility(uiOptions);</code></pre><p>注意事项参考隐藏 status bar 的注意。</p><blockquote><p>当然，既然可以让程序内容显示在 status bar 的后面，那么相同效果也可以在 Navigation bar 上设置。使用 SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION 和 SYSTEM_UI_FLAG_LAYOUT_STABLE 即可。</p></blockquote><hr><h2 id="使用全屏沉浸模式"><a href="#使用全屏沉浸模式" class="headerlink" title="使用全屏沉浸模式"></a>使用全屏沉浸模式</h2><p>　　这是4.4版本新加的模式，设置标志为 SYSTEM_UI_FLAG_IMMERSIVE 和 SYSTEM_UI_FLAG_IMMERSIVE_STICKY两种。经常配合着 SYSTEM_UI_FLAG_HIDE_NAVIGATION 和 SYSTEM_UI_FLAG_FULLSCREEN 使用。</p><p>(补充：FLAG_IMMERSIVE 要和 FLAG_HIDE_NAVIGATION and FLAG_FULLSCREEN 两者其一一起使用才有效，与前者用为隐藏下方的 bar，与后者用为隐藏上方的 bar)</p><p>　　这个模式的效果为隐藏掉上下两条 bar，同时你在 bar 的范围内点击事件也不会将其唤出，这为程序的操作提供了很大的便利。你会问，既然点击事件不会唤出 bar，那我要是想用 bar 上的功能怎么办？这个也很简单，手指放在 bar 的区域，如果是 status bar 的区域则手指向下滑动，反之则向上滑动，这样就可以把两条 bar 唤出了。这个操作实际上是把 SYSTEM_UI_FLAG_HIDE_NAVIGATION 和 SYSTEM_UI_FLAG_FULLSCREEN 清掉了，所以才会可见，同时会触发对应的 Listener 。</p><p>　　前面说了有两种 IMMERSIVE 和 IMMERSIVE_STICKY ，前者是将 bar 唤出后不再消失，后者是将 bar 唤出后几秒就消失，后者不触发 Listener。</p><p>　　还有一点，设置 FULLSCREEN 会让 status bar 显示的时候背景为半透明，正常状态下 status bar 的背景是黑色的。见下图：<br>　　<br><img src="http://images.cnitblog.com/blog2015/663710/201504/121855096967988.png" alt="example img"></p><p>图1：正常状态。图2：第一次进入 immersive full-screen mode 时会有提示。</p><p>关于 IMMERSIVE 和 IMMERSIVE_STICKY 的选择：</p><ul><li>如果是做一个看书、杂志软件或者看新闻软件，建议使用 IMMERSIVE 标志，配合 SYSTEM_UI_FLAG_FULLSCREEN 和 SYSTEM_UI_FLAG_HIDE_NAVIGATION 。因为用户可能会频繁需要用到 UI 按钮，同时在浏览内容的时候不希望被打扰。</li><li>如果希望用户体验沉浸模式，那就用 STICKY 标志</li><li>如果像视频播放器那样用户交互就很少，就不要用 IMMERSIVE 了，之前写的内容就可以满足需求</li></ul><p>　　使用 IMMERSIVE 标志时，隐藏的 bar 会一直显示，那么就需要设置一些标志保持软件内容尺寸不变，如SYSTEM_UI_FLAG_HIDE_NAVIGATION 和 SYSTEM_UI_FLAG_LAYOUT_STABLE，同时也要注意 action bar 的隐藏。</p><pre class=" language-lang-java"><code class="language-lang-java">// This snippet hides the system bars.private void hideSystemUI() {    // Set the IMMERSIVE flag.    // Set the content to appear under the system bars so that the content    // doesn't resize when the system bars hide and show.    mDecorView.setSystemUiVisibility(            View.SYSTEM_UI_FLAG_LAYOUT_STABLE            | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION            | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN            | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION // hide nav bar            | View.SYSTEM_UI_FLAG_FULLSCREEN // hide status bar            | View.SYSTEM_UI_FLAG_IMMERSIVE);}// This snippet shows the system bars. It does this by removing all the flags// except for the ones that make the content appear under the system bars.private void showSystemUI() {    mDecorView.setSystemUiVisibility(            View.SYSTEM_UI_FLAG_LAYOUT_STABLE            | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION            | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN);}</code></pre><p>　　下面是程序窗口收到焦点时设置 IMMERSIVE_STICKY 如下，其实结合前面提到的一些方法，自己组合可以实现很好的效果。</p><pre class=" language-lang-java"><code class="language-lang-java">@Overridepublic void onWindowFocusChanged(boolean hasFocus) {        super.onWindowFocusChanged(hasFocus);    if (hasFocus) {        decorView.setSystemUiVisibility(                View.SYSTEM_UI_FLAG_LAYOUT_STABLE                | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION                | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN                | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION                | View.SYSTEM_UI_FLAG_FULLSCREEN                | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY);}}</code></pre><hr><h2 id="对系统工具栏显示变化的响应"><a href="#对系统工具栏显示变化的响应" class="headerlink" title="对系统工具栏显示变化的响应"></a>对系统工具栏显示变化的响应</h2><p>　　注册一个 View.OnSystemUiVisibilityChangeListener 来使界面同步变化，可以在 onCreate() 方法中添加以下代码：</p><pre class=" language-lang-java"><code class="language-lang-java">View decorView = getWindow().getDecorView();decorView.setOnSystemUiVisibilityChangeListener        (new View.OnSystemUiVisibilityChangeListener() {    @Override    public void onSystemUiVisibilityChange(int visibility) {        // Note that system bars will only be "visible" if none of the        // LOW_PROFILE, HIDE_NAVIGATION, or FULLSCREEN flags are set.        if ((visibility & View.SYSTEM_UI_FLAG_FULLSCREEN) == 0) {            // TODO: The system bars are visible. Make any desired            // adjustments to your UI, such as showing the action bar or            // other navigational controls.        } else {            // TODO: The system bars are NOT visible. Make any desired            // adjustments to your UI, such as hiding the action bar or            // other navigational controls.        }    }});</code></pre><p>以上可能有理解上误差或者我测试中的没发现的错误，如果您看过后发现有哪些问题请留下反馈，谢谢。</p><blockquote><p>Written with <a href="https://stackedit.io/" target="_blank" rel="noopener">StackEdit</a>.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Status Bar </tag>
            
            <tag> Navigation Bar </tag>
            
            <tag> Immersive Mode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Android] 针对生成的图片文件在系统Gallery不显示的处理</title>
      <link href="/2015/04/01/%5BAndroid%5DNew-Image-not-show-in-Gallery/"/>
      <url>/2015/04/01/%5BAndroid%5DNew-Image-not-show-in-Gallery/</url>
      
        <content type="html"><![CDATA[<p>　　之前遇到过一个问题，就是发现我在程序中生成一个新的 Bitmap 之后，当我打开系统的 Gallery 查看时，并没有看到新生成的图像。然而打开文件浏览器，找到保存 Bitmap 所在的文件夹下，还能看到程序生成的 Bitmap 文件。也就是说，文件其实存在，但 Gallery 似乎并没有刷新。之后，又一个新的行为证实了我的观点，即，每次重启设备之后， Gallery 中就会显示新生成的 Bitmap 了。也就是说，重启设备之后，系统对某个保存有图片信息的文件进行了重新读写（当时得出的是这么个结论，具体原理后面会专门写博客讨论）。</p><p>　　好了，原理能猜出个大概，那么就猜一猜方法：也许可以通知系统来对保存有图片信息的那个文件进行刷新，做一次对文件夹的扫描。但到底有没有这个方法呢？带着疑问，我在网上找了找资料，发现原理的确是这么回事，方法也是有的。</p><p>　　现在有两个方法可以解决这个问题：</p><p>Solution 1: 发送广播，通知系统刷新。</p><p>sendBroadcast(new Intent(Intent.ACTION_MEDIA_MOUNTED, Uri.parse(“file://“+ Environment.getExternalStorageDirectory())));<br>　　不过用这个方法需要给程序添加权限：</p><p><uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"></uses-permission></p><p><uses-permission android:name="android.permission.RESTART_PACKAGES"><br>　　这个方法我没有测试，但看介绍应该是可以的。</uses-permission></p><p>Solution 2: 使用 MediaScannerConnection ：</p><p>　　首先对要使用该方法的类继承 MediaScannerConnectionClient ：</p><p>public class YourView  implements MediaScannerConnectionClient {</p><p>}<br>　　继承该类需要重写两个方法：</p><p>@Override<br>public void onMediaScannerConnected() {<br>    // TODO Auto-generated method stub<br>    try {<br>        msc.scanFile(bitmapPath, “image/jpg”);<br>    } catch (Exception e) {<br>        e.printStackTrace();<br>    }<br>}</p><p>@Override<br>public void onScanCompleted(String path, Uri uri) {<br>    // TODO Auto-generated method stub<br>    msc.disconnect();<br>}<br>　　方法看其名称就能猜到，前者是连接上 MediaScanner 后，进行查找文件。 bitmapPath 是文件的绝对路径，”image/jpg” 是文件格式， jpg 可改为 png 甚至 * 。后者方法是查找结束后断开连接。</p><p>　　最后，创建 MediaScannerConnection 对象，在生成图片后调用其方法：</p><p>MediaScannerConnection msc;</p><p>…..</p><p>if (msc != null) {<br>    msc.disconnect();<br>}<br>msc = new MediaScannerConnection(mActivity, thisClass.this);<br>msc.connect();<br>　　这样，下次再生成新的图片后，就可以在 Gallery 中看到新生成的图片了！</p><p>　　恩，问题解决了。然后我又发现了一个问题：如果我在程序中删除了某个图片，结果发现 Gallery 中还有这个图片的路径，能看到有这个图片，但打开图片是一片灰色。说简单点，就是我用代码删除图片文件了，系统的保存信息还是有这个文件的路径存在，只有重启才会删掉这些无效路径。好了，问题来了，怎么改？</p><p>　　能不能像之前的步骤再来一次？前面的步骤好像是刷新了系统的某个配置文件，再做一次也许会行。尝试之后发现（第一种方法没试。。），然而并不行。</p><p>　　既然这样不行，那也许是我对系统的某些原理还没有搞懂，应该还有其他的方法。经过一番探索，我还是找到了解决方法，并且对 Android 系统扫描存储这些信息的原理有了进一步的了解。下一篇文章，就简单讨论讨论这个原理和解决办法。今天先到这里。</p><p>参考资料：</p><p>[Android实例] 把bitmap保存后无法在图库看到,但文件是存在的</p><p>Image, saved to sdcard, doesn’t appear in Android’s Gallery app</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Gallery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Sublime-Text] Linux下用Sublime-Text3编译输出Java文件</title>
      <link href="/2015/03/30/%5BSublime-Text%5DUse-Sublime-Text3-compile-Java/"/>
      <url>/2015/03/30/%5BSublime-Text%5DUse-Sublime-Text3-compile-Java/</url>
      
        <content type="html"><![CDATA[<p>因为现在在借着经典的书籍巩固一些基础知识，所以会经常跑一些简单的程序，可又不想开庞大的IDE。所以就想试着用Sublime-Text来编译程序，哦，当然如果习惯的话，用 terminal 也可以。其实Sublime-Text里有编译功能，ctrl+B 即可，但编译后只是生成了 .class 文件，并没有执行，也就看不到结果。针对这一情况，需要一些配置文件的修改。我在网上查了一些方法，发现没有能用的，自己大概摸索了一下，找到了一个解决方法。当然，这个方法是以对付 JAVA 来做的，当然稍做修改也可以用来对付其他的语言。下面讲讲我理解的原理。</p><p>在 Sublime-Text 的文件夹下有一个 Packages 文件夹，里面有很多针对各种语言的工具包。对付 JAVA 就需要打开 Java.sublime-package 。不用解压，直接打开文件 JavaC.sublime-build 。ctrl + B 编译就是通过这个文件执行的，可以看到内容是：</p><pre class=" language-lang-Bash"><code class="language-lang-Bash">{    "shell_cmd": "javac \"$file\"",    "file_regex": "^(...*?):([0-9]*):?([0-9]*)",    "selector": "source.java"}</code></pre><p>难怪，编译的时候只执行了 javac ，所以只是生成 .class 文件。那我们现在需要执行文件得到结果，就需要从这一行命令入手。</p><p>打开 jdk 目录下的 /bin 。对，就是 javac 所在的目录，在里面我们新建一个脚本 runJava.sh ：</p><pre class=" language-lang-Bash"><code class="language-lang-Bash"> #!/bin/bash[ -f "$1.class" ] && rm $1.classfor file in $1do  echo "-Compiling $file.java ..."  javac $file.javadoneif [ -f "$1.class" ]then  echo "------Output------"  java $1else  echo " "fi</code></pre><p>记得 chmod 777 ( 自己的环境权限设成 777 无所谓，不行就 755 ，反正必须可执行)</p><p>脚本的意思是 有一个文件 test.java ，获取其文件名 test 做参数， test.class 存在就将其删掉重新编译，编译成功就执行。(注意不要乱删空格)</p><p>然后注销计算机，重新登录，在终端输入 runJava.sh 命令是否存在( 其实只要系统能找到这个文件放哪都行，放 jdk 只是因为 jdk 安装后都会配置其环境，比较省事儿)</p><p>之后就修改 JavaC.sublime-build 文件，将第一行改成：</p><pre class=" language-lang-Bash"><code class="language-lang-Bash">"shell_cmd": "runJava.sh \"$file_base_name\"",</code></pre><p>把 javac 换成新加的命令，后面文件名， $file 代表 test.java，$file_base_name 代表 test，明显，我们的命令需要后者为输入。</p><p>修改后保存，重启 Sublime-Text ，让其重新加载修改后的工具包。打开文件， ctrl + B 即可看到输出。</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sublime Text </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
