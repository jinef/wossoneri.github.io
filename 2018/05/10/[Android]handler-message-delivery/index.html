<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    <meta name="keywords" content="[Android] Handler消息传递机制, wOw的博客">
    <meta name="description" content="今天看文章的时候看到一个对Android消息传递机制的描述，回想了一下这块的知识点，感觉有必要再细致地整理一番">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>[Android] Handler消息传递机制 | wOw的博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    
    <script src="/libs/jquery/jquery.min.js"></script>
    
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>


<body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper head-container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">wOw的博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">wOw的博客</div>
        <div class="logo-desc">
            
            就怕你一生碌碌无为，还安慰自己平凡可贵
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/wossoneri" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/wossoneri" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/0.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">[Android] Handler消息传递机制</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Android/">
                                <span class="chip bg-color">Android</span>
                            </a>
                        
                            <a href="/tags/Handler/">
                                <span class="chip bg-color">Handler</span>
                            </a>
                        
                            <a href="/tags/Looper/">
                                <span class="chip bg-color">Looper</span>
                            </a>
                        
                            <a href="/tags/Message/">
                                <span class="chip bg-color">Message</span>
                            </a>
                        
                            <a href="/tags/MessageQueue/">
                                <span class="chip bg-color">MessageQueue</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Android/" class="post-category">
                                Android
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2018-05-10
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    4,775
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    20 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>

        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>今天看文章的时候看到这么一句话：</p>
<blockquote>
<p>UI线程是从ActivityThread运行的，在该类的main()方法中已经使用了Looper.prepareMainLooper()为该线程添加了Looper对象，已经为该线程创建了消息队列，是自带秘书光环的。因此，我们才可以在Activity中去定义Handler对象，因为创建Handler对象时其线程必须已经创建了消息队列，装卸工得配运输带要不然没法干活。而普通的Thread则没有默认创建消息队列，所以不能直接在Thread中直接定义Handler，这个就是我们不懂程序运行原理导致的困惑。</p>
</blockquote>
<p>其实这块知识我都看过，但是读完这段话有些地方还是让我回想了一小会儿。想完就觉着既然回想了一遍，不如整理一篇博客出来好了。</p>
<h2 id="经验之谈"><a href="#经验之谈" class="headerlink" title="经验之谈"></a>经验之谈</h2><p>在Android中经常会创建线程做一些耗时的事情，结束后会更新UI线程。一般代码这样写：</p>
<pre class=" language-lang-java"><code class="language-lang-java">    private Handler uiHandler = new Handler() {
        @Override
        public void handleMessage(Message msg) {
            switch (msg.what) {
                case 1:
                    break;
            }
        }
    };

        new Thread(new Runnable() {
            @Override
            public void run() {
                Message msg = uiHandler.obtainMessage();
                msg.what = 1;
                uiHandler.sendMessage(msg);
            }
        }).start();
</code></pre>
<p>即在主线程中创建Handler接收处理消息，在子线程用handler发送消息。</p>
<p>上面的Handler是在主线程中创建的，当我们在子线程创建一个Handler时，运行程序会报错：</p>
<pre class=" language-lang-java"><code class="language-lang-java">java.lang.RuntimeException: Can't create handler inside thread that has not called Looper.prepare()
  at android.os.Handler.<init>(Handler.java:203)
    at android.os.Handler.<init>(Handler.java:117)
</code></pre>
<p>这是因为主线程是自带Looper的，而子线程需要我们自己添加Looper。</p>
<pre class=" language-lang-java"><code class="language-lang-java">class LooperThread extends Thread {
    public Handler mHandler;

    public void run() {
          Looper.prepare();

        mHandler = new Handler() {
            public void handleMessage(Message msg) {
            // process incoming messages here
            }
        };

        Looper.loop();
          // loop就进入死循环，loop之后的代码不会执行，除非loop结束。
    }
}
</code></pre>
<p>看到这里，虽然说代码会写，功能会实现，但是很多问题却无法准确回答。</p>
<p>所以后面就跟着源码，把这些关系理清楚。</p>
<h2 id="android-os-Message"><a href="#android-os-Message" class="headerlink" title="android.os.Message"></a>android.os.Message</h2><p>一个包含描述信息和任意数据的可以发送给Handler的消息对象。它包含两个int域和一个object域供直接使用（省去alloc操作）。</p>
<p>它虽然有构造函数，但还是推荐使用Message.obtain()获得Message实例，或者使用Handler.obtainMessage()方法从消息回收池获取消息对象。</p>
<pre class=" language-lang-java"><code class="language-lang-java">public final Message obtainMessage()
{
        return Message.obtain(this);
}
</code></pre>
<p>Handler调用的方法就是Message自己的obtain。Message源码如下：</p>
<pre class=" language-lang-java"><code class="language-lang-java">public final class Message implements Parcelable {
    // 标识一个message。因为每个Handler都有自己的命名空间，故不必担心这个值和其他handler冲突
    public int what;

   // 如果只要存储int数据，用arg1和arg2即可，不需要构建Bundle对象做setData
    public int arg1;
    public int arg2;

    // 任意的一个对象。当用Messenger在进程间发消息时，如果它包含一个framework类的Parcelable对象，则它是非空的。对于其他数据使用Bundle.SetData即可。
    public Object obj;

    // 负责回复消息的Messenger，可选。使用取决于发送者和接收者
    public Messenger replyTo;

    // 消息uid标识，只在被Messenger传递消息时使用，平时是-1
    public int sendingUid = -1;

    // 表示message正被使用。
    // 该标志在消息入队完成后设置，并在传送后包括到回收之后都保持设置状态。 只有在创建或获取新消息时才会清除该标志，因为这是允许应用程序修改消息内容的唯一时间。所以在in use状态下不可以对一个message进行enqueue和recycle操作
    /*package*/ static final int FLAG_IN_USE = 1 << 0;

    // 标识消息是否是异步的
    /*package*/ static final int FLAG_ASYNCHRONOUS = 1 << 1;

    // 需要在CopyFrom方法清除的标识，默认是FLAG_IN_USE
    /*package*/ static final int FLAGS_TO_CLEAR_ON_COPY_FROM = FLAG_IN_USE;

    /*package*/ int flags;
    /*package*/ long when;

    // 关键数据
    /*package*/ Bundle data;

      // 发送和处理消息关联的Handler
    /*package*/ Handler target;

    /*package*/ Runnable callback;

    // 有时会用链表关联下一个message
    /*package*/ Message next;

      // 同步锁使用的对象
    private static final Object sPoolSync = new Object();
    private static Message sPool;
    private static int sPoolSize = 0; //obtain时-1，recycleUnchecked后+1

    private static final int MAX_POOL_SIZE = 50;
    private static boolean gCheckRecycle = true; // 只在recycle使用


    // 从消息回收池返回一个新的message对象
    public static Message obtain() {
        synchronized (sPoolSync) {
            if (sPool != null) {
                Message m = sPool;
                sPool = m.next;
                m.next = null;
                m.flags = 0; // clear in-use flag
                sPoolSize--;
                return m;
            }
        }
        return new Message();
    }

    // 先obtain一个message，然后从参数message拷贝一份数据
    public static Message obtain(Message orig) {
        Message m = obtain(); 
        m.what = orig.what;
        m.arg1 = orig.arg1;
        m.arg2 = orig.arg2;
        m.obj = orig.obj;
        m.replyTo = orig.replyTo;
        m.sendingUid = orig.sendingUid;
        if (orig.data != null) {
            m.data = new Bundle(orig.data);
        }
        m.target = orig.target;
        m.callback = orig.callback;
        return m;
    }

    // 先obtain一个message，然后设置要传递的handler
    public static Message obtain(Handler h) {
        Message m = obtain();
        m.target = h;
        return m;
    }
    // 下面的不用介绍了，和上面类似。
    public static Message obtain(Handler h, Runnable callback) {}
    public static Message obtain(Handler h, int what) {}
    public static Message obtain(Handler h, int what, Object obj) {}
    public static Message obtain(Handler h, int what, int arg1, int arg2) {}
    public static Message obtain(Handler h, int what,
            int arg1, int arg2, Object obj) {}

    /** @hide */
    public static void updateCheckRecycle(int targetSdkVersion) {
        if (targetSdkVersion < Build.VERSION_CODES.LOLLIPOP) {
            gCheckRecycle = false; // 只有版本低于lollipop的在recycle时不会抛出异常信息
        }
    }

    // 返回一个message实例到global pool
    // 调用这个方法后就不能再访问该消息了，因为它已经被有效释放。
      // 对于正在enqueued或者被delivered到Handler的message是不能调用recycle的。
    public void recycle() {
        if (isInUse()) {
            if (gCheckRecycle) {
                throw new IllegalStateException("This message cannot be recycled because it is still in use.");
            }
            return;
        }
        recycleUnchecked();
    }

    // 回收可能正在in-use状态的消息。 在处理队列消息时由MessageQueue和Looper在内部使用。
    void recycleUnchecked() {
        // 当其保持在recycled object pool时将message标记为in use，并清除其他信息
        flags = FLAG_IN_USE;
        what = 0;
        arg1 = 0;
        arg2 = 0;
        obj = null;
        replyTo = null;
        sendingUid = -1;
        when = 0;
        target = null;
        callback = null;
        data = null;

        synchronized (sPoolSync) {
            if (sPoolSize < MAX_POOL_SIZE) {
                next = sPool;
                sPool = this;
                sPoolSize++;
            }
        }
    }

    // 浅拷贝
    public void copyFrom(Message o) {
        this.flags = o.flags & ~FLAGS_TO_CLEAR_ON_COPY_FROM;
        // ...省略...
    }

    // 返回消息目标delivery时间  毫秒
    public long getWhen() { return when; }
    public void setTarget(Handler target) { this.target = target; }
    public Handler getTarget() { return target; }
    public Runnable getCallback() { return callback; }

    // data为空会创建新的Bundle
    public Bundle getData() {
        if (data == null) {
            data = new Bundle();
        }

        return data;
    }
    // data为空就返回空
    public Bundle peekData() { return data; }
    public void setData(Bundle data) { this.data = data; }

    // 把自己发送给目标Handler
    public void sendToTarget() { target.sendMessage(this); }

    // true则为异步的。意味着他不是Looper synchronization barriers
    public boolean isAsynchronous() {
        return (flags & FLAG_ASYNCHRONOUS) != 0;
    }

    // 某些操作（如视图无效）可能会在Looper的消息队列中引入同步障碍，以防止后续消息被传递，直到满足某些条件。
    // 在视图无效的情况下，在调用View.invalidate之后发布的消息将通过同步屏障挂起，直到下一帧准备好绘制为止。
    // 同步屏障确保在恢复之前完全处理失效请求。
    public void setAsynchronous(boolean async) {
        if (async) {
            flags |= FLAG_ASYNCHRONOUS;
        } else {
            flags &= ~FLAG_ASYNCHRONOUS;
        }
    }

    /*package*/ boolean isInUse() { return ((flags & FLAG_IN_USE) == FLAG_IN_USE); }
    /*package*/ void markInUse() { flags |= FLAG_IN_USE; }

  // 剩下的省略
</code></pre>
<blockquote>
<p> 代码中提到的同步障碍（synchronization barriers）可以参考 <a href="http://wossoneri.github.io/2018/05/08/[Java]CountDownLatch-and-CyclicBarrier/">[Java] CountDownLatch 与 CyclicBarrier</a> 了解一下Barrier。</p>
</blockquote>
<p>源码的注释应该很详细了，关键点再整理如下：</p>
<ul>
<li>FLAG_IN_USE 标志在消息入队完成后设置，并在消息传送后包括到回收之后都保持设置状态。 </li>
<li>只有在创建或获取新消息时才会清除FLAG_IN_USE标志，因为这是允许应用程序修改消息内容的唯一时间。</li>
<li>in use状态下不可以对一个message进行enqueue和recycle操作。</li>
<li>调用recycle后就不能再访问该消息了，因为它已经被有效释放。</li>
<li>对于正在enqueued或者被delivered到Handler的message是不能调用recycle的。</li>
</ul>
<p>剩下我认为比较重要的是</p>
<pre class=" language-lang-java"><code class="language-lang-java">    private static int sPoolSize = 0; //obtain时-1，recycleUnchecked后+1
</code></pre>
<p>如同介绍，调用obtain时计数-1，调用recycleUnchecked后计数+1。除此之外，没有其他地方为其赋值。</p>
<p>所以这两个方法的调用在整个消息机制里起很大的作用。<code>obtain</code> 方法就不说了，获取Message对象用的，<code>recycleUnchecked</code> 方法的调用都在什么地方呢？</p>
<p>首先在Message自身的<code>recycle</code> 方法内会执行一次。</p>
<p>然后在源码搜索，找到两个调用的类：MessageQueue和Looper。</p>
<p>Looper的调用很简单：</p>
<pre class=" language-lang-java"><code class="language-lang-java">    public static void loop() {
        final Looper me = myLooper();
        ...
        for (;;) {
            Message msg = queue.next(); // might block
            if (msg == null) {
                // No message indicates that the message queue is quitting.
                return;
            }
          ...
            msg.recycleUnchecked();
        }
    }
</code></pre>
<p>就是在loop循环的时候，从消息队列一个个取出Message，处理完的最后调用 msg.recycleUnchecked()。</p>
<p>所以一个消息在被 Looper 处理时或者移出队列时会被标识为 FLAG_IN_USE，然后会被加入回收的消息链表，这样我们调用 Message.obtain() 方法时就可以从回收的消息池中获取一个旧的消息，从而节约成本。</p>
<p>MessageQueue的调用可以找到9处，分别在：</p>
<pre class=" language-lang-java"><code class="language-lang-java">public void removeSyncBarrier(int token){ ... }
void removeMessages(Handler h, int what, Object object) { ... }
void removeMessages(Handler h, Runnable r, Object object) { ... }
void removeCallbacksAndMessages(Handler h, Object object) { ... }
private void removeAllMessagesLocked() { ... }
private void removeAllFutureMessagesLocked() { ... }
</code></pre>
<p>通过函数名就知道，所有remove消息的操作都会把remove掉的消息recycle。</p>
<h2 id="android-os-MessageQueue"><a href="#android-os-MessageQueue" class="headerlink" title="android.os.MessageQueue"></a>android.os.MessageQueue</h2><p>MessageQueue是一个低级别的类，它持有一个将由Looper派发的Message列表。Message不是直接添加到MessageQueue的，而是通过与Looper关联的Handler对象的。</p>
<p>整理下语言就是，MessageQueue存放Message列表，Handler往队列里塞Message，Looper从队列取出Message往外发送。</p>
<pre class=" language-lang-java"><code class="language-lang-java">public final class MessageQueue {

    // 队列是否可以退出
    private final boolean mQuitAllowed;

    @SuppressWarnings("unused")
    private long mPtr; // Native层使用

    Message mMessages;
    private final ArrayList<IdleHandler> mIdleHandlers = new ArrayList<IdleHandler>();
    private SparseArray<FileDescriptorRecord> mFileDescriptorRecords;
    private IdleHandler[] mPendingIdleHandlers;
    private boolean mQuitting;

    // next()阻塞提示
    private boolean mBlocked;

    // 下一个屏障的token.
    // 屏障由具有空目标的消息指定，其arg1字段携带该token。
    private int mNextBarrierToken;
</code></pre>
<p>当前线程的MessageQueue对象是通过Looper.myQueue()获取的（这个线程必须启动Looper，才有MessageQueue）：</p>
<pre class=" language-lang-java"><code class="language-lang-java">    public static @NonNull MessageQueue myQueue() {
        return myLooper().mQueue;
    }

    private Looper(boolean quitAllowed) {
        mQueue = new MessageQueue(quitAllowed);
        mThread = Thread.currentThread();
    }

   public static void prepare() {
        prepare(true);
    }

    private static void prepare(boolean quitAllowed) {
        if (sThreadLocal.get() != null) {
            throw new RuntimeException("Only one Looper may be created per thread");
        }
        sThreadLocal.set(new Looper(quitAllowed));
    }
</code></pre>
<pre class=" language-lang-java"><code class="language-lang-java">    MessageQueue(boolean quitAllowed) {
        mQuitAllowed = quitAllowed;
        mPtr = nativeInit();
    }
</code></pre>
<p>以上是MessageQueue的构造过程。在Looper一开始的prepare阶段创建new Looper（true），然后拿到new MessageQueue（true）。</p>
<p>队列的功能是按顺序排列消息，实行FIFO原则。所以看一下这个In和Out。</p>
<p>入队方法：</p>
<pre class=" language-lang-java"><code class="language-lang-java">boolean enqueueMessage(Message msg, long when) {
          // 如开头介绍，消息是通过Handler塞进消息队列的，所以先判断消息的Handler是否为空
        if (msg.target == null) { 
            throw new IllegalArgumentException("Message must have a target.");
        }
          // 回去再看Message的FLAG_IN_USE注释，明确说明inUse状态下不可以入队
        if (msg.isInUse()) {
            throw new IllegalStateException(msg + " This message is already in use.");
        }

        synchronized (this) { // 加锁
            if (mQuitting) { // 队列已退出
                IllegalStateException e = new IllegalStateException(
                        msg.target + " sending message to a Handler on a dead thread");
                Log.w(TAG, e.getMessage(), e);
                msg.recycle();
                return false;
            }

            msg.markInUse(); // 前面异常判断完，可以入队了，标记消息为in use
            msg.when = when;
            Message p = mMessages;
            boolean needWake;
            if (p == null || when == 0 || when < p.when) {
                // 原来空的链表阻塞消息读取，新消息进入唤醒
                msg.next = p;
                mMessages = msg;
                needWake = mBlocked;
            } else {
                // 消息插入到队列。通常只有在队列头有屏障且这个消息是异步消息时需要唤醒队列
                needWake = mBlocked && p.target == null && msg.isAsynchronous();
                Message prev;
                for (;;) {
                    prev = p;
                    p = p.next;
                    if (p == null || when < p.when) {
                        break;
                    }
                    if (needWake && p.isAsynchronous()) {
                        needWake = false;
                    }
                }
                msg.next = p; // invariant: p == prev.next
                prev.next = msg;
            }

            // We can assume mPtr != 0 because mQuitting is false.
            if (needWake) {
                nativeWake(mPtr);
            }
        }
        return true;
    }
</code></pre>
<p>可以看到，MessageQueue 虽然叫“消息队列”，持有的其实是一个消息链表的节点。插入消息也是以链表插入。</p>
<p>下面是出队</p>
<pre class=" language-lang-java"><code class="language-lang-java">    Message next() {
        // 如果Message loop退出，直接return
        final long ptr = mPtr;
        if (ptr == 0) {
            return null;
        }

        int pendingIdleHandlerCount = -1; // -1 only during first iteration
        int nextPollTimeoutMillis = 0;
        for (;;) {
            // 如果有需要过段时间再处理的消息，先调用 Binder 的方法
            if (nextPollTimeoutMillis != 0) {
                Binder.flushPendingCommands();
            }

            nativePollOnce(ptr, nextPollTimeoutMillis);

            synchronized (this) {
                // 找下一个消息  找到就return 消息
                final long now = SystemClock.uptimeMillis();
                Message prevMsg = null;
                Message msg = mMessages; // 链表头
                if (msg != null && msg.target == null) {
                    // 如果消息没有 target，那它就是一个屏障，需要一直往后遍历找到第一个异步的消息
                    do {
                        prevMsg = msg;
                        msg = msg.next;
                    } while (msg != null && !msg.isAsynchronous());
                }
                if (msg != null) {
                    if (now < msg.when) {
                        // 如果这个消息还没到处理时间，就设置个时间过段时间再处理
                        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
                    } else {
                        // 拿到消息
                        mBlocked = false;
                        if (prevMsg != null) {
                            prevMsg.next = msg.next;
                        } else {
                            mMessages = msg.next;
                        }
                        msg.next = null;
                        if (DEBUG) Log.v(TAG, "Returning message: " + msg);
                        msg.markInUse(); // 标记使用
                        return msg;
                    }
                } else {
                    // 队列没有消息了
                    nextPollTimeoutMillis = -1;
                }

                // 所有等待的消息都处理完了，处理退出消息
                if (mQuitting) {
                    dispose();
                    return null;
                }

                // 如果第一次idle, 获取要运行idlers的数量.
                // Idle handles仅在队列为空时或队列中的第一条消息（可能是屏障）将在未来处理时才运行。
                if (pendingIdleHandlerCount < 0
                        && (mMessages == null || now < mMessages.when)) {
                    pendingIdleHandlerCount = mIdleHandlers.size();
                }
                if (pendingIdleHandlerCount <= 0) {
                    // No idle handlers to run.  Loop and wait some more.
                    mBlocked = true;
                    continue;
                }

                if (mPendingIdleHandlers == null) {
                    mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];
                }
                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);
            }

            // Run the idle handlers.
            // We only ever reach this code block during the first iteration.
            for (int i = 0; i < pendingIdleHandlerCount; i++) {
                final IdleHandler idler = mPendingIdleHandlers[i];
                mPendingIdleHandlers[i] = null; // release the reference to the handler

                boolean keep = false;
                try {
                    keep = idler.queueIdle();
                } catch (Throwable t) {
                    Log.wtf(TAG, "IdleHandler threw exception", t);
                }

                if (!keep) {
                    synchronized (this) {
                        mIdleHandlers.remove(idler);
                    }
                }
            }

            // Reset the idle handler count to 0 so we do not run them again.
            pendingIdleHandlerCount = 0;

            // While calling an idle handler, a new message could have been delivered
            // so go back and look again for a pending message without waiting.
            nextPollTimeoutMillis = 0;
        }
    }
</code></pre>
<p>代码中出现很多IdleHandler，其定义如下：</p>
<pre class=" language-lang-java"><code class="language-lang-java">    // 当线程block等待更多消息时，获得新消息的回调接口
    public static interface IdleHandler {
        // 在消息队列没有消息并且等待更多消息时调用。
        // 返回true表示保持idle handler活跃，false表示将其移除
          // 如果队列有消息等待在未来某时间点执行也会调用这个方法。
        boolean queueIdle();
    }
</code></pre>
<p>当消息队列阻塞时，就会回调到这里。</p>
<p>这里大概知道MessageQueue是什么就够了。</p>
<p>前面介绍Message时，提到Looper在Loop时处理完消息会将消息recycle掉，在prepare的时候会创建MessageQueue。而且必须是在线程中加入Looper这个线程才可以拥有MessageQueue。那么下面就看一下Looper。</p>
<h2 id="android-os-Looper"><a href="#android-os-Looper" class="headerlink" title="android.os.Looper"></a>android.os.Looper</h2><p>Looper是对一个线程运行消息循环的类。一个线程默认是没有消息循环的，如果要创建一个，需要在线程先调用Looper.prepare，然后调用Looper.loop使其处理消息，知道循环结束。</p>
<p>基本上是和Handler交互处理消息循环。</p>
<pre class=" language-lang-java"><code class="language-lang-java">public final class Looper {

    // 必须调用先prepare()，否则sThreadLocal.get()返回空
    static final ThreadLocal<Looper> sThreadLocal = new ThreadLocal<Looper>();
    private static Looper sMainLooper;  // guarded by Looper.class

    final MessageQueue mQueue;
    final Thread mThread;

    private Printer mLogging;
    private long mTraceTag;

    /* If set, the looper will show a warning log if a message dispatch takes longer than time. */
    private long mSlowDispatchThresholdMs;
</code></pre>
<p>Looper声明了其管理的消息队列，以及与之绑定的线程。</p>
<p>在线程里使用Looper的第一步是Looper.prepare()，看一下源码：</p>
<pre class=" language-lang-java"><code class="language-lang-java">    public static void prepare() {
        prepare(true);
    }

    private static void prepare(boolean quitAllowed) {
        if (sThreadLocal.get() != null) {
            throw new RuntimeException("Only one Looper may be created per thread");
        }
        sThreadLocal.set(new Looper(quitAllowed));
    }
</code></pre>
<p>这里就解释了必须调用先prepare()，否则sThreadLocal.get()返回空的原因。在prepare的时候会从sThreadLocal判断这个线程是否有Looper，如果没有则创建。</p>
<blockquote>
<p>ThreadLocal用于提供线程内部的局部变量，这些变量与它们的正常对象不同，每个线程访问一个单独属于自己的，独立的变量的初始副本。</p>
</blockquote>
<p>通过ThreadLocal控制一个线程只有一个Looper。</p>
<p>Looper里还有一个和prepare相关的方法：</p>
<pre class=" language-lang-java"><code class="language-lang-java">    // 初始化当前线程为一个Looper，并标记它为一个应用程序的主Looper。应用程序的主Looper是在Android环境中构建的，所以不要自己去调用这个方法
    public static void prepareMainLooper() {
        prepare(false);
        synchronized (Looper.class) {
            if (sMainLooper != null) {
                throw new IllegalStateException("The main Looper has already been prepared.");
            }
            sMainLooper = myLooper();
        }
    }

    // 返回应用程序主线程中的主Looper
    public static Looper getMainLooper() {
        synchronized (Looper.class) {
            return sMainLooper;
        }
    }
</code></pre>
<p>这个就是主线程创建的Looper，一开始的例子说过，在UI线程创建Handler不需要自己加Looper，因为UI线程已经做过这个工作了。具体的创建在后面介绍。</p>
<p>Looper在prepare之后，就只剩下一个重要功能，loop：</p>
<pre class=" language-lang-java"><code class="language-lang-java">    // 在当前线程中运行message queue。确保在结束时调用quit结束loop
    public static void loop() {
        final Looper me = myLooper();
        if (me == null) { // 确保Looper.prepare调用过
            throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");
        }
        final MessageQueue queue = me.mQueue;
        // 底层对IPC标识处理
        Binder.clearCallingIdentity();
        final long ident = Binder.clearCallingIdentity();

        for (;;) { // 无限循环
            Message msg = queue.next(); // 读Message，可能会阻塞
            if (msg == null) {
                // 没有消息意味着消息队列正在退出
                return;
            }

            // 打印一些Log Trace
            final Printer logging = me.mLogging;
            if (logging != null) {
                logging.println(">>>>> Dispatching to " + msg.target + " " +
                        msg.callback + ": " + msg.what);
            }

            final long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;

            final long traceTag = me.mTraceTag;
            if (traceTag != 0 && Trace.isTagEnabled(traceTag)) {
                Trace.traceBegin(traceTag, msg.target.getTraceName(msg));
            }
            final long start = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();
            final long end;
            try {
                msg.target.dispatchMessage(msg); // 调用Handler派发消息
                end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();
            } finally {
                if (traceTag != 0) {
                    Trace.traceEnd(traceTag);
                }
            }
            if (slowDispatchThresholdMs > 0) {
                final long time = end - start;
                if (time > slowDispatchThresholdMs) {
                    Slog.w(TAG, "Dispatch took " + time + "ms on "
                            + Thread.currentThread().getName() + ", h=" +
                            msg.target + " cb=" + msg.callback + " msg=" + msg.what);
                }
            }

            if (logging != null) {
                logging.println("<<<<< Finished to " + msg.target + " " + msg.callback);
            }

            // 确保在调度过程中线程的identity没有被破坏。
            final long newIdent = Binder.clearCallingIdentity();
            if (ident != newIdent) {
                Log.wtf(TAG, "Thread identity changed from 0x"
                        + Long.toHexString(ident) + " to 0x"
                        + Long.toHexString(newIdent) + " while dispatching to "
                        + msg.target.getClass().getName() + " "
                        + msg.callback + " what=" + msg.what);
            }

            msg.recycleUnchecked(); // 在Message提到过
        }
    }
</code></pre>
<p>Looper.loop就是从MessageQueue取出消息，如果没有消息就阻塞，知道来消息或者MessageQueue退出。拿到消息后，有消息内部绑定的Handler进行处理。</p>
<p>回想一下，MessageQueue的消息是Handler塞进去的，Looper循环拿消息出来最后还是由Handler处理。</p>
<p>最后确保在结束时调用quit结束loop即可。</p>
<p>再往回看一遍，MessageQueue，Looper都有自己明确的辅助工作。而真正完成消息传递的，全靠Handler。</p>
<h2 id="android-os-Handler"><a href="#android-os-Handler" class="headerlink" title="android.os.Handler"></a>android.os.Handler</h2><p>Handler允许你发送和处理Message和与线程的MessageQueue关联的Runnable对象。</p>
<p><strong>每个</strong>Handler实例都与<strong>一个</strong>线程和这个线程的<strong>MessageQueue</strong>相关联。当你创建一个新的Handler，它直接与创建它的所在的线程和MessageQueue绑定。这一点上，它会传递消息和runnable到那个MessageQueue，并且在消息从队列取出时执行消息。</p>
<p>Handler的两个主要用途：</p>
<ol>
<li>规划（Scheduling）message和runnable在未来某个时间点执行</li>
<li>将一个要在其他线程执行的操作入队</li>
</ol>
<p>Scheduling Message是由以下方法完成：</p>
<pre class=" language-lang-java"><code class="language-lang-java">public final boolean post(Runnable r)
public final boolean postAtTime(Runnable r, long uptimeMillis)
public final boolean postDelayed(Runnable r, long delayMillis)
public final boolean sendEmptyMessage(int what)
public final boolean sendMessage(Message msg)
public boolean sendMessageAtTime(Message msg, long uptimeMillis)
public final boolean sendMessageDelayed(Message msg, long delayMillis)
</code></pre>
<p>post方法传递runnable参数，由message queue调用。send方法都是Message参数，由Handler的handleMessage处理。</p>
<p>回到最开始的例子，Handler的使用步骤如下：</p>
<ol>
<li>在线程A内创建Handler，重载handleMessage方法处理消息</li>
<li>在线程B使用Handler.sendMessage等发送消息</li>
<li>消息从线程B发到线程A，handleMessage接收到消息并处理</li>
</ol>
<p>下面以这三步来跟一下源码。</p>
<p>Handler最重要的就是线程间消息传递，下面跟源码了解中间发生了什么</p>
<pre class=" language-lang-java"><code class="language-lang-java">public class Handler {
    // 将此标志设置为true以检测扩展此Handler类并且不是静态的匿名，本地或成员类。 这些类可能会造成泄漏。
      // 关于Handler内存泄露的隐患，以后在研究。
    private static final boolean FIND_POTENTIAL_LEAKS = false;
    private static final String TAG = "Handler";
    private static Handler MAIN_THREAD_HANDLER = null;

    final Looper mLooper;
    final MessageQueue mQueue;
    final Callback mCallback;
    final boolean mAsynchronous;
    IMessenger mMessenger;
</code></pre>
<p>Handler的属性并不多，关于Callback：</p>
<pre class=" language-lang-java"><code class="language-lang-java">    public interface Callback {
        public boolean handleMessage(Message msg);
    }
</code></pre>
<p>这个接口增加一个handleMessage的回调，根据注释：</p>
<blockquote>
<p>Callback interface you can use when instantiating a Handler to avoid having to implement your own subclass of Handler.</p>
</blockquote>
<p>说明可以在构造Handler的时候实现这个接口方法，这样就不用重载handleMessage方法了。实现如下：</p>
<pre class=" language-lang-java"><code class="language-lang-java">Handler mHandler = new Handler(new Handler.Callback() {
    @Override
    public boolean handleMessage(Message msg) {
        return false;
    }
});
</code></pre>
<blockquote>
<p><strong>需要注意，这里创建了匿名内部类，还是会持有外部引用，导致内存泄漏</strong>。</p>
</blockquote>
<p>通过源码，可以了解到这么做的原理：</p>
<pre class=" language-lang-java"><code class="language-lang-java">    public void dispatchMessage(Message msg) {
        if (msg.callback != null) {
            handleCallback(msg);
        } else {
            if (mCallback != null) {
                if (mCallback.handleMessage(msg)) {
                    return;
                }
            }
            handleMessage(msg);
        }
    }
    private static void handleCallback(Message message) {
        message.callback.run();
    }

    /**
     * Subclasses must implement this to receive messages.
     */
    public void handleMessage(Message msg) {
    }
</code></pre>
<p>源码在调用dispatchMessage的时候（记不记得从MessageQueue读取到Message后就是调用这个方法？），如果有callback，就调用callback的接口并返回，否则就调用自己的handleMessage，进而调用到我们重载的方法。</p>
<p>前面提到，Handler发送消息有postXXX和sendXXX。</p>
<p>其实看完postXXX方法后，发现post也是调用sendXXX方法进行下一步处理，就是把runnable存入message的callback中，然后send message。所以选择一个send方法了解过程。</p>
<pre class=" language-lang-java"><code class="language-lang-java">public final boolean sendMessage(Message msg)
{
    return sendMessageDelayed(msg, 0);
}

public final boolean sendMessageDelayed(Message msg, long delayMillis)
{
    if (delayMillis < 0) {
        delayMillis = 0;
    }
    return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);
}

public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
    MessageQueue queue = mQueue;
    if (queue == null) {
        RuntimeException e = new RuntimeException(
            this + " sendMessageAtTime() called with no mQueue");
        Log.w("Looper", e.getMessage(), e);
        return false;
    }
    return enqueueMessage(queue, msg, uptimeMillis);
}

private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
    msg.target = this;
    if (mAsynchronous) {
        msg.setAsynchronous(true);
    }
    return queue.enqueueMessage(msg, uptimeMillis);
}
</code></pre>
<p>Handler 发送消息最后调用到了消息队列的 <code>enqueueMessage()</code> 方法。然后从队列取出message也讲过了，最终是调用Handler.dispatchMessage()派发消息出去。这段代码在上面callback处已经贴出，然后send到调用便结束了。</p>
<p>另外提一点，如果移除消息，调用的也是消息队列的remove方法。</p>
<h2 id="几个问题"><a href="#几个问题" class="headerlink" title="几个问题"></a>几个问题</h2><h3 id="这几个概念间的关系"><a href="#这几个概念间的关系" class="headerlink" title="这几个概念间的关系"></a>这几个概念间的关系</h3><p><img src="https://github.com/wossoneri/wossoneri.github.io/blob/master/articleImage/handler.png?raw=true" alt></p>
<ul>
<li>一个Thread只有一个Looper</li>
<li>Looper内有一个MessageQueue</li>
<li>一个Thread可以有多个Handler</li>
<li>Handler内持有一个Looper和MessageQueue的引用</li>
<li>Handler内的Looper就是当前Thread（sThreadLocal）的Looper，MQ就是这个Looper的MQ</li>
</ul>
<p>Handler构造方法：</p>
<pre class=" language-lang-java"><code class="language-lang-java">    public Handler(Callback callback, boolean async) {
        if (FIND_POTENTIAL_LEAKS) {
            final Class<? extends Handler> klass = getClass();
            if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &&
                    (klass.getModifiers() & Modifier.STATIC) == 0) {
                Log.w(TAG, "The following Handler class should be static or leaks might occur: " +
                    klass.getCanonicalName());
            }
        }

        mLooper = Looper.myLooper();
        if (mLooper == null) {
            throw new RuntimeException(
                "Can't create handler inside thread that has not called Looper.prepare()");
        }
        mQueue = mLooper.mQueue;
        mCallback = callback;
        mAsynchronous = async;
    }
</code></pre>
<h3 id="跨线程通信"><a href="#跨线程通信" class="headerlink" title="跨线程通信"></a>跨线程通信</h3><p>核心就是，Handler可以在任意线程发送消息。</p>
<p>回到开头那段代码：</p>
<pre class=" language-lang-java"><code class="language-lang-java">private Handler uiHandler = new Handler() {
    @Override
    public void handleMessage(Message msg) {
        switch (msg.what) {
            case 1:
                break;
        }
    }
};

    new Thread(new Runnable() {
        @Override
        public void run() {
            Message msg = uiHandler.obtainMessage();
            msg.what = 1;
            uiHandler.sendMessage(msg);
        }
    }).start();
</code></pre>
<p>在UI线程创建uiHandler，此时这个Handler属于UIThread，其内部Looper也是UIThread创建的，MQ也在UIThread（Looper内持有）。</p>
<p>做到跨线程通信，就是在新的Thread内使用uiHandler的引用，用它给MQ发送一个message，这样消息就从Thread发送到了UIThread。</p>
<h3 id="getMainLooper-amp-prepareMainLooper"><a href="#getMainLooper-amp-prepareMainLooper" class="headerlink" title="getMainLooper&amp;prepareMainLooper"></a>getMainLooper&amp;prepareMainLooper</h3><p>前面的例子，在UIThread创建Handler是不用指定Looper的，因为相关Looper已经创建。</p>
<p>如果在子线程中想更新UI线程，除了在UI线程创建Handler外，也可以在子线程创建Handler，不过需要给这个Handler指定主线程的Looper：</p>
<pre class=" language-lang-java"><code class="language-lang-java">    Handler mainHandler = new Handler(Looper.getMainLooper());
    mainHandler.post(new Runnable() {
        @Override
        public void run() {
            //已在主线程中，可以更新UI
        }
    });
</code></pre>
<p>通过上面的信息，了解到这两个方法和主线程息息相关，所以先看看这两个方法的源码：</p>
<pre class=" language-lang-java"><code class="language-lang-java">    // 将当前线程初始化为一个Looper，并标记其为应用的主looper。这个Looper是由Android环境创建的，所以你不应该主动调用这个方法。
    public static void prepareMainLooper() {
        prepare(false);
        synchronized (Looper.class) {
            if (sMainLooper != null) {
                throw new IllegalStateException("The main Looper has already been prepared.");
            }
            sMainLooper = myLooper();
        }
    }

    // 返回应用程序的主looper，其存在于应用的主线程
    public static Looper getMainLooper() {
        synchronized (Looper.class) {
            return sMainLooper;
        }
    }
</code></pre>
<p>所以要想知道系统的主线程是何时创建Main Looper的，就要跟踪<code>prepareMainLooper</code> 方法。</p>
<p>搜索AOSP，找到两处调用该方法的地方：</p>
<ol>
<li>frameworks/base/services/java/com/android/server/SystemServer.java 的 run 方法</li>
<li>frameworks/base/core/java/android/app/ActivityThread.java 的 main 方法</li>
</ol>
<p>这边直接说结论，ActivityThread就是所谓的主线程，其中的main方法就是主线程的入口：</p>
<pre class=" language-lang-java"><code class="language-lang-java">public static void main(String[] args) {
        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "ActivityThreadMain");
        SamplingProfilerIntegration.start();

        // CloseGuard defaults to true and can be quite spammy.  We
        // disable it here, but selectively enable it later (via
        // StrictMode) on debug builds, but using DropBox, not logs.
        CloseGuard.setEnabled(false);

        Environment.initForCurrentUser();

        // Set the reporter for event logging in libcore
        EventLogger.setReporter(new EventLoggingReporter());

        // Make sure TrustedCertificateStore looks in the right place for CA certificates
        final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());
        TrustedCertificateStore.setDefaultUserDirectory(configDir);

        Process.setArgV0("<pre-initialized>");

          // 这里sMainLooper赋值
        Looper.prepareMainLooper();

        ActivityThread thread = new ActivityThread();
        thread.attach(false);

        if (sMainThreadHandler == null) {
            sMainThreadHandler = thread.getHandler();
        }

        if (false) {
            Looper.myLooper().setMessageLogging(new
                    LogPrinter(Log.DEBUG, "ActivityThread"));
        }

        // End of event ActivityThreadMain.
        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
        Looper.loop();    // Looper进入循环

        throw new RuntimeException("Main thread loop unexpectedly exited");
    }
</code></pre>
<p>主线程的Handler从thread.getHandler();拿到的：</p>
<pre class=" language-lang-java"><code class="language-lang-java">final H mH = new H();    
final Handler getHandler() {
    return mH;
}
</code></pre>
<p>H这个Handler基本处理了所有与应用有关的操作。具体的自己可以看看源码：<a href="http://androidxref.com/8.0.0_r4/xref/frameworks/base/core/java/android/app/ActivityThread.java#1462" target="_blank" rel="noopener">H源码</a> </p>
<p>至此，Android的Handler消息传递机制大概总结完了。不过又引出一个新的问题，ActivityThread的启动流程以及Application的启动过程和Activity的启动过程。这几天会抽时间整理一下。</p>

            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://wossoneri.github.io" rel="external nofollow noreferrer">Wossoneri</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://wossoneri.github.io/2018/05/10/[Android]handler-message-delivery/">http://wossoneri.github.io/2018/05/10/[Android]handler-message-delivery/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by-nc/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY-NC 4.0</a>
                    许可协议。转载请注明来源
                    <a href="http://wossoneri.github.io" target="_blank">Wossoneri</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Android/">
                                    <span class="chip bg-color">Android</span>
                                </a>
                            
                                <a href="/tags/Handler/">
                                    <span class="chip bg-color">Handler</span>
                                </a>
                            
                                <a href="/tags/Looper/">
                                    <span class="chip bg-color">Looper</span>
                                </a>
                            
                                <a href="/tags/Message/">
                                    <span class="chip bg-color">Message</span>
                                </a>
                            
                                <a href="/tags/MessageQueue/">
                                    <span class="chip bg-color">MessageQueue</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.png" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            
        </div>
    </div>

    

    
        <link rel="stylesheet" href="/libs/gitment/gitment-default.css">
<link rel="stylesheet" href="/css/gitment.css">

<div class="gitment-card card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="gitment-content" class="card-content"></div>
</div>

<script src="/libs/gitment/gitment.js"></script>
<script>
var gitment = new Gitment({
    id: 'Thu May 10 2018 23:12:22 GMT+0800',
    owner: 'wossoneri',
    repo: 'wossoneri.github.io',
    oauth: {
        client_id: '40b6c719a11e3fca29e8',
        client_secret: '9d7241035e9211e280e753883f5b8f5a1a49bf77'
    }
});

gitment.render('gitment-content');
</script>
    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2018/05/17/[Android][Framework]ActivityThread/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/14.jpg" class="responsive-img" alt="[Android][Framework]ActivityThread">
                        
                        <span class="card-title">[Android][Framework]ActivityThread</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Android ActivityThread介绍
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2018-05-17
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Android/" class="post-category">
                                    Android
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Android/">
                        <span class="chip bg-color">Android</span>
                    </a>
                    
                    <a href="/tags/ActivityThread/">
                        <span class="chip bg-color">ActivityThread</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2018/05/08/[Java]CountDownLatch-and-CyclicBarrier/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/23.jpg" class="responsive-img" alt="[Java] CountDownLatch 与 CyclicBarrier">
                        
                        <span class="card-title">[Java] CountDownLatch 与 CyclicBarrier</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            看代码看到CountDownLatch，就顺便了解了一下，然后引出CyclicBarrier，于是把相关知识整理下来。
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2018-05-08
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Syntax/" class="post-category">
                                    Syntax
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/java/">
                        <span class="chip bg-color">java</span>
                    </a>
                    
                    <a href="/tags/Multithread/">
                        <span class="chip bg-color">Multithread</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: wOw的博客<br />'
            + '文章作者: Wossoneri<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h1, h2, h3, h4, h5'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4, h5').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>



    <footer class="page-footer bg-color">
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2014</span>
            <a href="http://wossoneri.github.io" target="_blank">Wossoneri</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2014";
                    var startMonth = "1";
                    var startDate = "1";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/wossoneri" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:wossoneri@163.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=478251276" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 478251276" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-70716047-2"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', 'UA-70716047-2');
</script>


    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    

    

    
    
    
    <script src="/libs/instantpage/instantpage.js" type="module"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
    

</body>

</html>
